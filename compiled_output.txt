=== src\Activity.h ===

#pragma once
#include "gui/interface/Window.h"

class Activity
{
public:
	virtual void Exit() {}
	virtual void Show() {}
	virtual void Hide() {}
	virtual ~Activity() {}
};

class WindowActivity: public ui::Window, public Activity
{
public:
	WindowActivity(ui::Point position, ui::Point size) :
		ui::Window(position, size)
	{
		Show();
	}
	void Exit() override
	{
		Hide();
		SelfDestruct();
	}
	void Show() override
	{
		MakeActiveWindow();
	}
	void Hide() override
	{
		CloseActiveWindow();
	}
	virtual ~WindowActivity() {}
};


=== src\Config.template.h ===

#pragma once
#include "VcsTag.h"
#include "common/Version.h"

constexpr bool SET_WINDOW_ICON          = @SET_WINDOW_ICON@;
constexpr bool DEBUG                    = @DEBUG@;
constexpr bool X86                      = @X86@;
constexpr bool BETA                     = @BETA@;
constexpr bool SNAPSHOT                 = @SNAPSHOT@;
constexpr bool MOD                      = @MOD@;
constexpr bool NOHTTP                   = @NOHTTP@;
constexpr bool LUACONSOLE               = @LUACONSOLE@;
constexpr bool ALLOW_FAKE_NEWER_VERSION = @ALLOW_FAKE_NEWER_VERSION@;
constexpr bool USE_UPDATESERVER         = @USE_UPDATESERVER@;
constexpr bool CAN_INSTALL              = @CAN_INSTALL@;
constexpr bool SHARED_DATA_FOLDER       = @SHARED_DATA_FOLDER@;
constexpr bool USE_BLUESCREEN           = @USE_BLUESCREEN@;
constexpr bool INSTALL_CHECK            = @INSTALL_CHECK@;
constexpr bool IGNORE_UPDATES           = @IGNORE_UPDATES@;
constexpr bool ENFORCE_HTTPS            = @ENFORCE_HTTPS@;
constexpr bool SECURE_CIPHERS_ONLY      = @SECURE_CIPHERS_ONLY@;
constexpr bool PLATFORM_CLIPBOARD       = @PLATFORM_CLIPBOARD@;
constexpr bool USE_SYSTEM_CERT_PROVIDER = @USE_SYSTEM_CERT_PROVIDER@;
constexpr bool FFTW_PLAN_MEASURE        = @FFTW_PLAN_MEASURE@;
constexpr bool ALLOW_QUIT               = @ALLOW_QUIT@;
constexpr bool DEFAULT_TOUCH_UI         = @DEFAULT_TOUCH_UI@;
constexpr bool ALLOW_DATA_FOLDER        = @ALLOW_DATA_FOLDER@;
constexpr char PATH_SEP_CHAR            = '@PATH_SEP_CHAR@';

enum ForceWindowFrameOps
{
	forceWindowFrameOpsNone, // usual behaviour
	forceWindowFrameOpsEmbedded, // e.g. into a webpage; this sweeps a few emscripten limitations under the rug
	forceWindowFrameOpsHandheld, // e.g. the system doesn't support windowed mode; includes odd setups like chromebooks
};
constexpr ForceWindowFrameOps FORCE_WINDOW_FRAME_OPS = @FORCE_WINDOW_FRAME_OPS@;

constexpr char SERVER[]         = "@SERVER@";
constexpr char STATICSERVER[]   = "@STATICSERVER@";
constexpr char UPDATESERVER[]   = "@UPDATESERVER@";
constexpr char IDENT_PLATFORM[] = "@IDENT_PLATFORM@";
constexpr char IDENT[]          = "@IDENT@";
constexpr char APPNAME[]        = "@APPNAME@";
constexpr char APPCOMMENT[]     = "@APPCOMMENT@";
constexpr char APPEXE[]         = "@APPEXE@";
constexpr char APPID[]          = "@APPID@";
constexpr char APPDATA[]        = "@APPDATA@";
constexpr char APPVENDOR[]      = "@APPVENDOR@";
constexpr char PACKAGE_MODE[]   = "@PACKAGE_MODE@";

constexpr int MOD_ID               = @MOD_ID@;

struct DisplayVersionWithBuild
{
	Version<2> displayVersion;
	size_t build;
};
constexpr DisplayVersionWithBuild APP_VERSION = { { @DISPLAY_VERSION_MAJOR@, @DISPLAY_VERSION_MINOR@ }, @BUILD_NUM@ };
constexpr DisplayVersionWithBuild UPSTREAM_VERSION = { { @UPSTREAM_VERSION_MAJOR@, @UPSTREAM_VERSION_MINOR@ }, @UPSTREAM_BUILD_NUM@ };

constexpr auto DISPLAY_VERSION = APP_VERSION.displayVersion;

constexpr char IDENT_RELTYPE    = SNAPSHOT ? 'S' : (BETA ? 'B' : 'R');

constexpr char LOCAL_SAVE_DIR[] = "Saves";
constexpr char STAMPS_DIR[]     = "stamps";
constexpr char BRUSH_DIR[]      = "Brushes";

constexpr int httpMaxConcurrentStreams = 50;
constexpr int httpConnectTimeoutS      = 15;


=== src\Controller.h ===

#pragma once
class Controller
{
private:
	virtual void Exit();
	virtual void Show();
	virtual void Hide();
	virtual ~Controller() = default;
};


=== src\Format.cpp ===

#include <cstdint>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <iostream>
#include <iterator>
#include <optional>
#include <stdexcept>
#include <png.h>
#include "Format.h"
#include "graphics/VideoBuffer.h"

ByteString format::UnixtimeToDate(time_t unixtime, ByteString dateFormat, bool local)
{
	struct tm * timeData;
	char buffer[128];

	if (local)
	{
		timeData = localtime(&unixtime);
	}
	else
	{
		timeData = gmtime(&unixtime);
	}

	strftime(buffer, 128, dateFormat.c_str(), timeData);
	return ByteString(buffer);
}

ByteString format::UnixtimeToDateMini(time_t unixtime)
{
	time_t currentTime = time(nullptr);
	struct tm currentTimeData = *gmtime(&currentTime);
	struct tm timeData = *gmtime(&unixtime);

	if(currentTimeData.tm_year != timeData.tm_year)
	{
		return UnixtimeToDate(unixtime, "%d %b %Y");
	}
	else if(currentTimeData.tm_mon != timeData.tm_mon || currentTimeData.tm_mday != timeData.tm_mday)
	{
		return UnixtimeToDate(unixtime, "%d %B");
	}
	else
	{
		return UnixtimeToDate(unixtime, "%H:%M:%S");
	}
}

String format::CleanString(String dirtyString, bool ascii, bool color, bool newlines, bool numeric)
{
	for (size_t i = 0; i < dirtyString.size(); i++)
	{
		switch(dirtyString[i])
		{
		case '\b':
			if (color)
			{
				dirtyString.erase(i, 2);
				i--;
			}
			else
				i++;
			break;
		case '\x0E':
			if (color)
			{
				dirtyString.erase(i, 1);
				i--;
			}
			break;
		case '\x0F':
			if (color)
			{
				dirtyString.erase(i, 4);
				i--;
			}
			else
				i += 3;
			break;
		case '\r':
		case '\n':
			if (newlines)
				dirtyString[i] = ' ';
			break;
		default:
			if (numeric && (dirtyString[i] < '0' || dirtyString[i] > '9'))
			{
				dirtyString.erase(i, 1);
				i--;
			}
			// if less than ascii 20 or greater than ascii 126, delete
			else if (ascii && (dirtyString[i] < ' ' || dirtyString[i] > '~'))
			{
				dirtyString.erase(i, 1);
				i--;
			}
			break;
		}
	}
	return dirtyString;
}

std::vector<char> format::PixelsToPPM(PlaneAdapter<std::vector<pixel>> const &input)
{
	std::vector<char> data;
	char buffer[256];
	sprintf(buffer, "P6\n%d %d\n255\n", input.Size().X, input.Size().Y);
	data.insert(data.end(), buffer, buffer + strlen(buffer));

	data.reserve(data.size() + input.Size().X * input.Size().Y * 3);

	for (int i = 0; i < input.Size().X * input.Size().Y; i++)
	{
		auto colour = RGB::Unpack(input.data()[i]);
		data.push_back(colour.Red);
		data.push_back(colour.Green);
		data.push_back(colour.Blue);
	}

	return data;
}

static std::unique_ptr<PlaneAdapter<std::vector<uint32_t>>> readPNG(
	std::span<const char> data,
	// If omitted,
	//   RGB data is returned with A=0xFF
	//   RGBA data is returned as itself
	// If specified
	//   RGB data is returned with A=0x00
	//   RGBA data is blended against the background and returned with A=0x00
	std::optional<RGB> background
)
{
	png_infop info = nullptr;
	auto deleter = [&info](png_struct *png) {
		png_destroy_read_struct(&png, &info, nullptr);
	};
	auto png = std::unique_ptr<png_struct, decltype(deleter)>(
		png_create_read_struct(PNG_LIBPNG_VER_STRING, nullptr,
			[](png_structp png, png_const_charp msg) {
				fprintf(stderr, "PNG error: %s\n", msg);
			},
			[](png_structp png, png_const_charp msg) {
				fprintf(stderr, "PNG warning: %s\n", msg);
			}
		), deleter
	);
	if (!png)
		return nullptr;

	// libpng might longjmp() here in case of error
	// Every time we create an object with a non-trivial destructor we must call setjmp again
	if (setjmp(png_jmpbuf(png.get())))
		return nullptr;

	info = png_create_info_struct(png.get());
	if (!info)
		return nullptr;

	auto it = data.begin();
	auto const end = data.end();
	auto readFn = [&it, end](png_structp png, png_bytep data, size_t length) {
		if (size_t(end - it) < length)
			png_error(png, "Tried to read beyond the buffer");
		std::copy_n(it, length, data);
		it += length;
	};

	// See above
	if (setjmp(png_jmpbuf(png.get())))
		return nullptr;

	png_set_read_fn(png.get(), static_cast<void *>(&readFn), [](png_structp png, png_bytep data, size_t length) {
		(*static_cast<decltype(readFn) *>(png_get_io_ptr(png)))(png, data, length);
	});
	png_set_user_limits(png.get(), RES.X, RES.Y); // Refuse to parse larger images
	png_read_info(png.get(), info);

	auto output = std::make_unique<PlaneAdapter<std::vector<uint32_t>>>(
		Vec2<int>(png_get_image_width(png.get(), info), png_get_image_height(png.get(), info))
	);

	std::vector<png_bytep> rowPointers(output->Size().Y);
	for (int y = 0; y < output->Size().Y; y++)
		rowPointers[y] = reinterpret_cast<png_bytep>(&*output->RowIterator(Vec2(0, y)));

	// See above
	if (setjmp(png_jmpbuf(png.get())))
		return nullptr;

	png_set_filler(png.get(), background ? 0x00 : 0xFF, PNG_FILLER_AFTER);
	png_set_bgr(png.get());

	auto bitDepth = png_get_bit_depth(png.get(), info);
	auto colorType = png_get_color_type(png.get(), info);
	if (colorType == PNG_COLOR_TYPE_PALETTE)
		png_set_palette_to_rgb(png.get());
	if (colorType == PNG_COLOR_TYPE_GRAY && bitDepth < 8)
		png_set_expand_gray_1_2_4_to_8(png.get());
	if (bitDepth == 16)
		png_set_scale_16(png.get());
	if (png_get_valid(png.get(), info, PNG_INFO_tRNS))
		png_set_tRNS_to_alpha(png.get());
	if (colorType == PNG_COLOR_TYPE_GRAY || colorType == PNG_COLOR_TYPE_GRAY_ALPHA)
		png_set_gray_to_rgb(png.get());
	if (background)
	{
		png_color_16 colour;
		colour.red = background->Red;
		colour.green = background->Green;
		colour.blue = background->Blue;
		png_set_background(png.get(), &colour, PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
	}

	png_read_image(png.get(), rowPointers.data());
	return output;
}

std::unique_ptr<PlaneAdapter<std::vector<pixel_rgba>>> format::PixelsFromPNG(std::span<const char> data)
{
	return readPNG(data, std::nullopt);
}

std::unique_ptr<PlaneAdapter<std::vector<pixel>>> format::PixelsFromPNG(std::span<const char> data, RGB background)
{
	return readPNG(data, background);
}

std::unique_ptr<std::vector<char>> format::PixelsToPNG(PlaneAdapter<std::vector<pixel>> const &input)
{
	png_infop info = nullptr;
	auto deleter = [&info](png_struct *png) {
		png_destroy_write_struct(&png, &info);
	};
	auto png = std::unique_ptr<png_struct, decltype(deleter)>(
		png_create_write_struct(PNG_LIBPNG_VER_STRING, nullptr,
			[](png_structp png, png_const_charp msg) {
				fprintf(stderr, "PNG error: %s\n", msg);
			},
			[](png_structp png, png_const_charp msg) {
				fprintf(stderr, "PNG warning: %s\n", msg);
			}
		), deleter
	);
	if (!png)
		return nullptr;

	// libpng might longjmp() here in case of error
	// Every time we create an object with a non-trivial destructor we must call setjmp again
	if (setjmp(png_jmpbuf(png.get())))
		return nullptr;


	info = png_create_info_struct(png.get());
	if (!info)
		return nullptr;

	std::vector<char> output;
	auto writeFn = [&output](png_structp png, png_bytep data, size_t length) {
		output.insert(output.end(), data, data + length);
	};

	std::vector<png_const_bytep> rowPointers(input.Size().Y);
	for (int y = 0; y < input.Size().Y; y++)
		rowPointers[y] = reinterpret_cast<png_const_bytep>(&*input.RowIterator(Vec2(0, y)));

	// See above
	if (setjmp(png_jmpbuf(png.get())))
		return nullptr;

	png_set_write_fn(png.get(), static_cast<void *>(&writeFn), [](png_structp png, png_bytep data, size_t length) {
		(*static_cast<decltype(writeFn) *>(png_get_io_ptr(png)))(png, data, length);
	}, nullptr);
	png_set_IHDR(png.get(), info, input.Size().X, input.Size().Y, 8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
	png_write_info(png.get(), info);
	png_set_filler(png.get(), 0x00, PNG_FILLER_AFTER);
	png_set_bgr(png.get());
	png_write_image(png.get(), const_cast<png_bytepp>(rowPointers.data()));
	png_write_end(png.get(), nullptr);

	return std::make_unique<std::vector<char>>(std::move(output));
}

const static char hex[] = "0123456789ABCDEF";

ByteString format::URLEncode(ByteString source)
{
	ByteString result;
	for (auto it = source.begin(); it < source.end(); ++it)
	{
		if (!((*it >= 'a' && *it <= 'z') ||
		      (*it >= 'A' && *it <= 'Z') ||
		      (*it >= '0' && *it <= '9')))
		{
			auto byte = uint8_t(*it);
			result.append(1, '%');
			result.append(1, hex[(byte >> 4) & 0xF]);
			result.append(1, hex[ byte       & 0xF]);
		}
		else
		{
			result.append(1, *it);
		}
	}
	return result;
}

ByteString format::URLDecode(ByteString source)
{
	ByteString result;
	for (auto it = source.begin(); it < source.end(); ++it)
	{
		if (*it == '%' && it < source.end() + 2)
		{
			auto byte = uint8_t(0);
			for (auto i = 0; i < 2; ++i)
			{
				it += 1;
				auto *off = strchr(hex, tolower(*it));
				if (!off)
				{
					return {};
				}
				byte = (byte << 4) | (off - hex);
			}
			result.append(1, byte);
		}
		else if (*it == '+')
		{
			result.append(1, ' ');
		}
		else
		{
			result.append(1, *it);
		}
	}
	return result;
}

void format::RenderTemperature(StringBuilder &sb, float temp, int scale)
{
	switch (scale)
	{
	case 1:
		sb << (temp - 273.15f) << "C";
		break;
	case 2:
		sb << (temp - 273.15f) * 1.8f + 32.0f << "F";
		break;
	default:
		sb << temp << "K";
		break;
	}
}

float format::StringToTemperature(String str, int defaultScale)
{
	auto scale = defaultScale;
	if (str.size())
	{
		if (str.EndsWith("K"))
		{
			scale = 0;
			str = str.SubstrFromEnd(1);
		}
		else if (str.EndsWith("C"))
		{
			scale = 1;
			str = str.SubstrFromEnd(1);
		}
		else if (str.EndsWith("F"))
		{
			scale = 2;
			str = str.SubstrFromEnd(1);
		}
	}
	if (!str.size())
	{
		throw std::out_of_range("empty string");
	}
	auto out = str.ToNumber<float>();
	switch (scale)
	{
	case 1:
		out = out + 273.15;
		break;
	case 2:
		out = (out - 32.0f) / 1.8f + 273.15f;
		break;
	}
	return out;
}


=== src\Format.h ===

#pragma once
#include <memory>
#include <span>
#include <vector>
#include "common/String.h"
#include "common/Plane.h"
#include "graphics/Pixel.h"

class VideoBuffer;

namespace format
{
	ByteString URLEncode(ByteString value);
	ByteString URLDecode(ByteString value);
	ByteString UnixtimeToDate(time_t unixtime, ByteString dateFomat = ByteString("%d %b %Y"), bool local = true);
	ByteString UnixtimeToDateMini(time_t unixtime);
	String CleanString(String dirtyString, bool ascii, bool color, bool newlines, bool numeric = false);
	std::vector<char> PixelsToPPM(PlaneAdapter<std::vector<pixel>> const &);
	std::unique_ptr<std::vector<char>> PixelsToPNG(PlaneAdapter<std::vector<pixel>> const &);
	std::unique_ptr<PlaneAdapter<std::vector<pixel_rgba>>> PixelsFromPNG(std::span<const char> data);
	std::unique_ptr<PlaneAdapter<std::vector<pixel>>> PixelsFromPNG(std::span<const char> data, RGB background);
	void RenderTemperature(StringBuilder &sb, float temp, int scale);
	float StringToTemperature(String str, int defaultScale);
}


=== src\FpsLimit.h ===

#pragma once
#include <variant>

struct FpsLimitNone
{
};
struct FpsLimitExplicit
{
	float value;
};
using SimFpsLimit = std::variant<FpsLimitNone, FpsLimitExplicit>;
struct FpsLimitFollowDraw
{
};
using FpsLimit = std::variant<FpsLimitNone, FpsLimitExplicit, FpsLimitFollowDraw>;

struct DrawLimitDisplay
{
};
struct DrawLimitNone
{
};
struct DrawLimitExplicit
{
	int value;
};
// TODO: DrawLimitVsync
using DrawLimit = std::variant<DrawLimitDisplay, DrawLimitNone, DrawLimitExplicit>;


=== src\FrameSchedule.h ===

#pragma once
#include <cstdint>
#include <algorithm>

class FrameSchedule
{
	uint64_t startNs = 0;
	uint64_t oldStartNs = 0;

public:
	void SetNow(uint64_t nowNs)
	{
		oldStartNs = startNs;
		startNs = nowNs;
	}

	uint64_t GetNow() const
	{
		return startNs;
	}

	uint64_t GetFrameTime() const
	{
		return startNs - oldStartNs;
	}

	uint64_t Arm(float fps)
	{
		auto oldNowNs = startNs;
		auto timeBlockDurationNs = uint64_t(std::clamp(1e9f / fps, 1.f, 1e9f));
		auto oldStartTimeBlock = oldStartNs / timeBlockDurationNs;
		auto startTimeBlock = oldStartTimeBlock + 1U;
		startNs = std::max(startNs, startTimeBlock * timeBlockDurationNs);
		return startNs - oldNowNs;
	}

	bool HasElapsed(uint64_t nowNs) const
	{
		return nowNs >= startNs;
	}
};


=== src\meson.build ===

conf_data = configuration_data()

upstream_version = meson.project_version()
upstream_version_components = upstream_version.split('-')
if upstream_version_components.length() > 1
	upstream_version = upstream_version_components[upstream_version_components.length() - 1]
endif
display_version = upstream_version
override_display_version = get_option('override_display_version')
if override_display_version != ''
	display_version = override_display_version
endif
display_version = display_version.split('.')
upstream_version = upstream_version.split('.')

app_id = get_option('app_id')
mod_id = get_option('mod_id')
is_snapshot = get_option('snapshot')
is_beta = get_option('beta')
is_mod = mod_id > 0
conf_data.set('X86', is_x86.to_string())
conf_data.set('BETA', is_beta.to_string())
conf_data.set('MOD_ID', mod_id)
conf_data.set('DEBUG', is_debug.to_string())
conf_data.set('MOD', is_mod.to_string())
conf_data.set('SNAPSHOT', is_snapshot.to_string())
conf_data.set('DISPLAY_VERSION_MAJOR', display_version[0].to_int())
conf_data.set('DISPLAY_VERSION_MINOR', display_version[1].to_int())
conf_data.set('BUILD_NUM', display_version[2].to_int())
conf_data.set('UPSTREAM_VERSION_MAJOR', upstream_version[0].to_int())
conf_data.set('UPSTREAM_VERSION_MINOR', upstream_version[1].to_int())
conf_data.set('UPSTREAM_BUILD_NUM', upstream_version[2].to_int())
conf_data.set('MANIFEST_COPYRIGHT', get_option('manifest_copyright'))
conf_data.set('MANIFEST_MACOS_MIN_VER', get_option('manifest_macos_min_ver'))
conf_data.set('MANIFEST_DATE', get_option('manifest_date'))
conf_data.set('ALLOW_FAKE_NEWER_VERSION', (is_snapshot or is_beta or is_debug or is_mod).to_string())
conf_data.set('IDENT_PLATFORM', ident_platform)
conf_data.set('IDENT', '@0@-@1@-@2@'.format(host_arch, host_platform, host_libc).to_upper())

enforce_https = get_option('enforce_https')
server = get_option('server')
static_server = get_option('static_server')
update_server = get_option('update_server')

if not (server.startswith('http://') or server.startswith('https://'))
	server = 'https://' + server
endif
if server.startswith('http://') and enforce_https
	error('enforce_https is true but server is a http:// URL base')
endif
if not (static_server.startswith('http://') or static_server.startswith('https://'))
	static_server = 'https://' + static_server
endif
if static_server.startswith('http://') and enforce_https
	error('enforce_https is true but static_server is a http:// URL base')
endif

use_update_server = false
if update_server != ''
	use_update_server = true
	if not (update_server.startswith('http://') or update_server.startswith('https://'))
		update_server = 'https://' + update_server
	endif
	if update_server.startswith('http://') and enforce_https
		error('enforce_https is true but update_server is a http:// URL base')
	endif
endif
conf_data.set('USE_UPDATESERVER', use_update_server.to_string())
conf_data.set('UPDATESERVER', update_server)

platform_clipboard = get_option('platform_clipboard')
allow_quit = true
force_window_frame_ops = 'forceWindowFrameOpsNone'
allow_data_folder = true
if host_platform == 'emscripten'
	allow_quit = false
	force_window_frame_ops = 'forceWindowFrameOpsEmbedded'
	allow_data_folder = false
endif
default_touch_ui = false
if host_platform == 'android'
	default_touch_ui = true # TODO: some more sophisticated heuristic at runtime instead
	force_window_frame_ops = 'forceWindowFrameOpsHandheld'
endif
secure_ciphers_only = get_option('secure_ciphers_only')
if not is_debug and not enforce_https
	error('refusing to build a release binary without enforcing HTTPS, configure with -Denforce_https=true to fix this error')
endif
conf_data.set('ALLOW_QUIT', allow_quit.to_string())
conf_data.set('FORCE_WINDOW_FRAME_OPS', force_window_frame_ops)
conf_data.set('DEFAULT_TOUCH_UI', default_touch_ui.to_string())
conf_data.set('ALLOW_DATA_FOLDER', allow_data_folder.to_string())
conf_data.set('ENFORCE_HTTPS', enforce_https.to_string())
conf_data.set('SECURE_CIPHERS_ONLY', secure_ciphers_only.to_string())
conf_data.set('PLATFORM_CLIPBOARD', platform_clipboard.to_string())

conf_data.set('IGNORE_UPDATES', get_option('ignore_updates').to_string())
conf_data.set('SERVER', server)
conf_data.set('STATICSERVER', static_server)
conf_data.set('APPNAME', get_option('app_name'))
conf_data.set('APPCOMMENT', get_option('app_comment'))
conf_data.set('APPEXE', app_exe)
conf_data.set('APPID', app_id)
conf_data.set('APPDATA', get_option('app_data'))
conf_data.set('APPVENDOR', get_option('app_vendor'))
conf_data.set('PACKAGE_MODE', get_option('package_mode'))

if host_platform == 'android'
	android_permissions = [
		'<uses-permission android:name="android.permission.VIBRATE" />',
	]
	if enable_http
		android_permissions += [
			'<uses-permission android:name="android.permission.INTERNET" />',
		]
	endif
	android_properties = []
	if is_debug
		android_properties += [ 'android:debuggable="true"' ]
	endif
	conf_data.set('ANDROID_PERMISSIONS', '\n'.join(android_permissions))
	conf_data.set('ANDROID_PROPERTIES', '\n'.join(android_properties))
endif

powder_files = files(
	'SDLCompat.cpp',
	'PowderToySDL.cpp',
	'PowderToy.cpp',
	'lua/CommandInterface.cpp',
	'lua/TPTSTypes.cpp',
)
powder_external_files = []

if host_platform == 'emscripten'
	powder_files += files(
		'PowderToySDLEmscripten.cpp',
	)
else
	powder_files += files(
		'PowderToySDLCommon.cpp',
	)
endif
if is_x86
	powder_files += files('X86KillDenormals.cpp')
endif

render_files = files(
	'PowderToyRenderer.cpp',
)

font_files = files(
	'PowderToyFontEditor.cpp',
	'PowderToySDL.cpp',
	'PowderToySDLCommon.cpp',
)

common_files = files(
	'Format.cpp',
	'Misc.cpp',
	'Probability.cpp',
)

resolve_vcs_tag = get_option('resolve_vcs_tag')
if resolve_vcs_tag == 'yes' or (resolve_vcs_tag == 'static_release_only' and not is_debug and is_static)
	common_files += vcs_tag(
		input: 'VcsTag.template.h',
		output: 'VcsTag.h',
		fallback: 'unknown',
	)
else
	vcs_tag_conf_data = configuration_data()
	vcs_tag_conf_data.set('VCS_TAG', '')
	configure_file(
		input: 'VcsTag.template.h',
		output: 'VcsTag.h',
		configuration: vcs_tag_conf_data
	)
endif

if host_platform == 'linux'
	powder_files += files('WindowIcon.cpp')
	font_files += files('WindowIcon.cpp')
endif

subdir('bson')
subdir('bzip2')
subdir('client')
subdir('common')
subdir('debug')
subdir('graphics')
subdir('gui')
if lua_variant != 'none'
	subdir('lua')
	conf_data.set('LUACONSOLE', 'true')
else
	powder_files += files(
		'lua/PlainCommandInterface.cpp',
	)
	conf_data.set('LUACONSOLE', 'false')
endif
subdir('prefs')
subdir('resampler')
subdir('simulation')
subdir('tasks')

simulation_elem_defs = []
foreach elem_name_id : simulation_elem_ids
	simulation_elem_defs += 'ELEMENT_DEFINE(' + elem_name_id[0] + ', ' + elem_name_id[1].to_string() + ');'
endforeach
elements_conf_data = configuration_data()
elements_conf_data.set('element_defs', '\n'.join(simulation_elem_defs))
configure_file(
	input: 'simulation/ElementNumbers.template.h',
	output: 'ElementNumbers.h',
	configuration: elements_conf_data
)

if platform_clipboard
	clipboard_impl_defs = []
	foreach impl_subsys_factory : clipboard_impl_factories
		clipboard_impl_defs += 'IMPL_DEFINE(' + impl_subsys_factory[0] + ', ' + impl_subsys_factory[1] + ')'
	endforeach
	clipboard_impls_data = configuration_data()
	clipboard_impls_data.set('impl_defs', '\n'.join(clipboard_impl_defs))
	configure_file(
		input: 'common/clipboard/ClipboardImpls.template.h',
		output: 'ClipboardImpls.h',
		configuration: clipboard_impls_data
	)
endif

simulation_tool_defs = []
foreach tool_name_id : simulation_tool_ids
	simulation_tool_defs += 'TOOL_DEFINE(' + tool_name_id[0] + ', ' + tool_name_id[1].to_string() + ');'
endforeach
tools_conf_data = configuration_data()
tools_conf_data.set('tool_defs', '\n'.join(simulation_tool_defs))
configure_file(
	input: 'simulation/ToolNumbers.template.h',
	output: 'ToolNumbers.h',
	configuration: tools_conf_data
)

configure_file(
	input: 'Config.template.h',
	output: 'Config.h',
	configuration: conf_data
)


=== src\Misc.cpp ===

#include "Misc.h"
#include "common/String.h"
#include <cstring>
#include <sys/types.h>
#include <cmath>
#include <algorithm>

void HSV_to_RGB(int h,int s,int v,int *r,int *g,int *b)//convert 0-255(0-360 for H) HSV values to 0-255 RGB
{
	float hh, ss, vv, c, x;
	int m;
	hh = h/60.0f;//normalize values
	ss = s/255.0f;
	vv = v/255.0f;
	c = vv * ss;
	x = c * ( 1 - fabs(fmod(hh,2.0f) -1) );
	if(hh<1){
		*r = (int)(c*255.0);
		*g = (int)(x*255.0);
		*b = 0;
	}
	else if(hh<2){
		*r = (int)(x*255.0);
		*g = (int)(c*255.0);
		*b = 0;
	}
	else if(hh<3){
		*r = 0;
		*g = (int)(c*255.0);
		*b = (int)(x*255.0);
	}
	else if(hh<4){
		*r = 0;
		*g = (int)(x*255.0);
		*b = (int)(c*255.0);
	}
	else if(hh<5){
		*r = (int)(x*255.0);
		*g = 0;
		*b = (int)(c*255.0);
	}
	else if(hh<6){
		*r = (int)(c*255.0);
		*g = 0;
		*b = (int)(x*255.0);
	}
	m = (int)((vv-c)*255.0);
	*r += m;
	*g += m;
	*b += m;
}

void RGB_to_HSV(int r,int g,int b,int *h,int *s,int *v)//convert 0-255 RGB values to 0-255(0-360 for H) HSV
{
	float rr, gg, bb, a,x,c,d;
	rr = r/255.0f;//normalize values
	gg = g/255.0f;
	bb = b/255.0f;
	a = std::min(rr,gg);
	a = std::min(a,bb);
	x = std::max(rr,gg);
	x = std::max(x,bb);
	if (a==x)//greyscale
	{
		*h = 0;
		*s = 0;
		*v = (int)(a*255.0);
	}
	else
	{
 		c = (rr==a) ? gg-bb : ((bb==a) ? rr-gg : bb-rr);
 		d = (rr==a) ? 3.f : ((bb==a) ? 1.f : 5.f);
 		*h = (int)(60.0*(d - c/(x - a)));
 		*s = (int)(255.0*((x - a)/x));
 		*v = (int)(255.0*x);
	}
}

bool byteStringEqualsString(const ByteString &str, const char *data, size_t size)
{
	return str.size() == size && !memcmp(str.data(), data, size);
}


=== src\Misc.h ===

#pragma once
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstddef>
#include <vector>

template<class Signed>
inline std::pair<Signed, Signed> floorDiv(Signed a, Signed b)
{
	auto quo = a / b;
	auto rem = a % b;
	if (a < Signed(0) && rem)
	{
		quo -= Signed(1);
		rem += b;
	}
	return { quo, rem };
}

template<class Signed>
inline std::pair<Signed, Signed> ceilDiv(Signed a, Signed b)
{
	return floorDiv(a + b - Signed(1), b);
}

//Linear interpolation
template <typename T> inline T LinearInterpolate(T val1, T val2, T lowerCoord, T upperCoord, T coord)
{
	if(lowerCoord == upperCoord) return val1;
	return (((val2 - val1) / (upperCoord - lowerCoord)) * (coord - lowerCoord)) + val1;
}


//Signum function
inline int isign(int i)
{
	if (i<0)
		return -1;
	if (i>0)
		return 1;
	return 0;
}

inline int isign(float i)
{
	if (i<0)
		return -1;
	if (i>0)
		return 1;
	return 0;
}

inline int iabs(int i)
{
	return i * isign(i);
}

inline unsigned clamp_flt(float f, float min, float max)
{
	if (f<min)
		return 0;
	if (f>max)
		return 255;
	return (int)(255.0f*(f-min)/(max-min));
}

inline float restrict_flt(float f, float min, float max)
{
	// Fix crash in certain cases when f is nan
	if (!std::isfinite(f))
		return min;
	if (f < min)
		return min;
	if (f > max)
		return max;
	return f;
}

void HSV_to_RGB(int h,int s,int v,int *r,int *g,int *b);
void RGB_to_HSV(int r,int g,int b,int *h,int *s,int *v);

class ByteString;

bool byteStringEqualsString(const ByteString &str, const char *data, size_t size);
template<size_t N>
// TODO: use std::literals::string_literals::operator""s if we get rid of ByteString
bool byteStringEqualsLiteral(const ByteString &str, const char (&lit)[N])
{
	return byteStringEqualsString(str, lit, N - 1U);
}


=== src\PowderToy.cpp ===

#include "PowderToySDL.h"
#include "Format.h"
#include "X86KillDenormals.h"
#include "prefs/GlobalPrefs.h"
#include "client/Client.h"
#include "client/GameSave.h"
#include "client/SaveFile.h"
#include "client/SaveInfo.h"
#include "client/http/requestmanager/RequestManager.h"
#include "client/http/GetSaveRequest.h"
#include "client/http/GetSaveDataRequest.h"
#include "common/platform/Platform.h"
#include "graphics/Graphics.h"
#include "simulation/SaveRenderer.h"
#include "simulation/SimulationData.h"
#include "common/tpt-rand.h"
#include "gui/game/Favorite.h"
#include "gui/Style.h"
#include "gui/game/GameController.h"
#include "gui/game/GameView.h"
#include "gui/game/IntroText.h"
#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/interface/Engine.h"
#include "gui/interface/TextWrapper.h"
#include "Config.h"
#include "SimulationConfig.h"
#include <optional>
#include <climits>
#include <iostream>
#include <csignal>
#include <SDL.h>
#include <exception>
#include <cstdlib>

void LoadWindowPosition()
{
	if (Client::Ref().IsFirstRun())
	{
		return;
	}

	auto &prefs = GlobalPrefs::Ref();
	int savedWindowX = prefs.Get("WindowX", INT_MAX);
	int savedWindowY = prefs.Get("WindowY", INT_MAX);

	int borderTop, borderLeft;
	SDL_GetWindowBordersSize(sdl_window, &borderTop, &borderLeft, nullptr, nullptr);
	// Sometimes (Windows), the border size may not be reported for 200+ frames
	// So just have a default of 5 to ensure the window doesn't get stuck where it can't be moved
	if (borderTop == 0)
		borderTop = 5;

	int numDisplays = SDL_GetNumVideoDisplays();
	SDL_Rect displayBounds;
	bool ok = false;
	for (int i = 0; i < numDisplays; i++)
	{
		SDL_GetDisplayBounds(i, &displayBounds);
		if (savedWindowX + borderTop > displayBounds.x && savedWindowY + borderLeft > displayBounds.y &&
				savedWindowX + borderTop < displayBounds.x + displayBounds.w &&
				savedWindowY + borderLeft < displayBounds.y + displayBounds.h)
		{
			ok = true;
			break;
		}
	}
	if (ok)
		SDL_SetWindowPosition(sdl_window, savedWindowX + borderLeft, savedWindowY + borderTop);
}

void SaveWindowPosition()
{
	int x, y;
	SDL_GetWindowPosition(sdl_window, &x, &y);

	int borderTop, borderLeft;
	SDL_GetWindowBordersSize(sdl_window, &borderTop, &borderLeft, nullptr, nullptr);

	auto &prefs = GlobalPrefs::Ref();
	prefs.Set("WindowX", x - borderLeft);
	prefs.Set("WindowY", y - borderTop);
}

void LargeScreenDialog()
{
	StringBuilder message;
	auto scale = ui::Engine::Ref().windowFrameOps.scale;
	message << "Switching to " << scale << "x size mode since your screen was determined to be large enough: ";
	message << desktopWidth << "x" << desktopHeight << " detected, " << WINDOWW * scale << "x" << WINDOWH * scale << " required";
	message << "\nTo undo this, hit Cancel. You can change this in settings at any time.";
	new ConfirmPrompt("Large screen detected", message.Build(), { nullptr, []() {
		GlobalPrefs::Ref().Set("Scale", 1);
		ui::Engine::Ref().windowFrameOps.scale = 1;
	} });
}

void TickClient()
{
	Client::Ref().Tick();
}

static void BlueScreen(String detailMessage, std::optional<std::vector<String>> stackTrace)
{
	auto &engine = ui::Engine::Ref();
	engine.g->BlendFilledRect(engine.g->Size().OriginRect(), 0x1172A9_rgb .WithAlpha(0xD2));

	auto crashPrevLogPath = ByteString("crash.prev.log");
	auto crashLogPath = ByteString("crash.log");
	Platform::RenameFile(crashLogPath, crashPrevLogPath, true);

	StringBuilder crashInfo;
	crashInfo << "ERROR - Details: " << detailMessage << "\n";
	crashInfo << "An unrecoverable fault has occurred, please report it by visiting the website below\n\n  " << SERVER << "\n\n";
	crashInfo << "An attempt will be made to save all of this information to " << crashLogPath.FromUtf8() << " in your data folder.\n";
	crashInfo << "Please attach this file to your report.\n\n";
	crashInfo << "Version: " << VersionInfo().FromUtf8() << "\n";
	crashInfo << "Tag: " << VCS_TAG << "\n";
	crashInfo << "Date: " << format::UnixtimeToDate(time(nullptr), "%Y-%m-%dT%H:%M:%SZ", false).FromUtf8() << "\n";
	if (stackTrace)
	{
		crashInfo << "Stack trace; Main is at 0x" << Format::Hex() << intptr_t(Main) << ":\n";
		for (auto &item : *stackTrace)
		{
			crashInfo << " - " << item << "\n";
		}
	}
	else
	{
		crashInfo << "Stack trace not available\n";
	}
	String errorText = crashInfo.Build();
	constexpr auto width = 440;
	ui::TextWrapper tw;
	tw.Update(errorText, true, width);
	engine.g->BlendText(ui::Point((engine.g->Size().X - width) / 2, 80), tw.WrappedText(), 0xFFFFFF_rgb .WithAlpha(0xFF));

	auto crashLogData = errorText.ToUtf8();
	std::cerr << crashLogData << std::endl;
	Platform::WriteFile(crashLogData, crashLogPath);

	//Death loop
	SDL_Event event;
	auto running = true;
	while (running)
	{
		while (SDL_PollEvent(&event))
		{
			if (event.type == SDL_QUIT)
			{
				running = false;
			}
		}
		blit(engine.g->Data());
	}

	// Don't use Platform::Exit, we're practically zombies at this point anyway.
#if defined(__MINGW32__) || defined(__APPLE__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)
	// Come on...
	exit(-1);
#else
	quick_exit(-1);
#endif
}

static struct
{
	int sig;
	const char *message;
} signalMessages[] = {
	{ SIGSEGV, "Memory read/write error" },
	{ SIGFPE, "Floating point exception" },
	{ SIGILL, "Program execution exception" },
	{ SIGABRT, "Unexpected program abort" },
	{ 0, nullptr },
};

static void SigHandler(int signal)
{
	const char *message = "Unknown signal";
	for (auto *msg = signalMessages; msg->message; ++msg)
	{
		if (msg->sig == signal)
		{
			message = msg->message;
			break;
		}
	}
	BlueScreen(ByteString(message).FromUtf8(), Platform::StackTrace());
}

static void TerminateHandler()
{
	ByteString err = "std::terminate called without a current exception";
	auto eptr = std::current_exception();
	try
	{
		if (eptr)
		{
			std::rethrow_exception(eptr);
		}
	}
	catch (const std::exception &e)
	{
		err = "unhandled exception: " + ByteString(e.what());
	}
	catch (...)
	{
		err = "unhandled exception not derived from std::exception, cannot determine reason";
	}
	BlueScreen(err.FromUtf8(), Platform::StackTrace());
}

constexpr int SCALE_MAXIMUM = 10;
constexpr int SCALE_MARGIN = 30;

int GuessBestScale()
{
	const int widthNoMargin = desktopWidth - SCALE_MARGIN;
	const int widthGuess = widthNoMargin / WINDOWW;

	const int heightNoMargin = desktopHeight - SCALE_MARGIN;
	const int heightGuess = heightNoMargin / WINDOWH;

	int guess = std::min(widthGuess, heightGuess);
	if(guess < 1 || guess > SCALE_MAXIMUM)
		guess = 1;

	return guess;
}

struct ExplicitSingletons
{
	// These need to be listed in the order they are populated in main.
	std::unique_ptr<GlobalPrefs> globalPrefs;
	http::RequestManagerPtr requestManager;
	std::unique_ptr<Client> client;
	std::unique_ptr<SaveRenderer> saveRenderer;
	std::unique_ptr<Favorite> favorite;
	std::unique_ptr<ui::Engine> engine;
	std::unique_ptr<SimulationData> simulationData;
	std::unique_ptr<GameController> gameController;
};
static std::unique_ptr<ExplicitSingletons> explicitSingletons;

int main(int argc, char *argv[])
{
	Platform::SetupCrt();
	return Platform::InvokeMain(argc, argv);
}

int Main(int argc, char *argv[])
{
	Platform::Atexit([]() {
		SaveWindowPosition();
		// Unregister dodgy error handlers so they don't try to show the blue screen when the window is closed
		for (auto *msg = signalMessages; msg->message; ++msg)
		{
			signal(msg->sig, SIG_DFL);
		}
		SDLClose();
		explicitSingletons.reset();
	});
	explicitSingletons = std::make_unique<ExplicitSingletons>();


	// https://bugzilla.libsdl.org/show_bug.cgi?id=3796
	if (SDL_Init(0) < 0)
	{
		fprintf(stderr, "Initializing SDL: %s\n", SDL_GetError());
		return 1;
	}

	Platform::originalCwd = Platform::GetCwd();

	using Argument = std::optional<ByteString>;
	std::map<ByteString, Argument> arguments;

	for (auto i = 1; i < argc; ++i)
	{
		auto str = ByteString(argv[i]);
		if (str.BeginsWith("file://"))
		{
			arguments.insert({ "open", format::URLDecode(str.substr(7 /* length of the "file://" prefix */)) });
		}
		else if (str.BeginsWith("ptsave:"))
		{
			arguments.insert({ "ptsave", str });
		}
		else if (auto split = str.SplitBy(':'))
		{
			arguments.insert({ split.Before(), split.After() });
		}
		else if (auto split = str.SplitBy('='))
		{
			arguments.insert({ split.Before(), split.After() });
		}
		else if (str == "open" || str == "ptsave" || str == "ddir")
		{
			if (i + 1 < argc)
			{
				arguments.insert({ str, argv[i + 1] });
				i += 1;
			}
			else
			{
				std::cerr << "no value provided for command line parameter " << str << std::endl;
			}
		}
		else
		{
			arguments.insert({ str, "" }); // so .has_value() is true
		}
	}

	auto ddirArg = arguments["ddir"];
	if (ddirArg.has_value())
	{
		if (Platform::ChangeDir(ddirArg.value()))
			Platform::sharedCwd = Platform::GetCwd();
		else
			perror("failed to chdir to requested ddir");
	}
	else if constexpr (SHARED_DATA_FOLDER)
	{
		auto ddir = Platform::DefaultDdir();
		if (!Platform::FileExists("powder.pref"))
		{
			if (ddir.size())
			{
				if (!Platform::ChangeDir(ddir))
				{
					perror("failed to chdir to default ddir");
					ddir = {};
				}
			}
		}

		if (ddir.size())
		{
			Platform::sharedCwd = ddir;
		}
	}
	// We're now in the correct directory, time to get prefs.
	explicitSingletons->globalPrefs = std::make_unique<GlobalPrefs>();

	auto &prefs = GlobalPrefs::Ref();

	WindowFrameOps windowFrameOps{
		prefs.Get("Scale", 1),
		prefs.Get("Resizable", false),
		prefs.Get("Fullscreen", false),
		prefs.Get("AltFullscreen", false),
		prefs.Get("ForceIntegerScaling", true),
		prefs.Get("BlurryScaling", false),
	};
	auto graveExitsConsole = prefs.Get("GraveExitsConsole", true);
	momentumScroll = prefs.Get("MomentumScroll", true);
	showAvatars = prefs.Get("ShowAvatars", true);

	auto true_string = [](ByteString str) {
		str = str.ToLower();
		return str == "true" ||
		       str == "t" ||
		       str == "on" ||
		       str == "yes" ||
		       str == "y" ||
		       str == "1" ||
		       str == ""; // standalone "redirect" or "disable-bluescreen" or similar arguments
	};
	auto true_arg = [&true_string](Argument arg) {
		return arg.has_value() && true_string(arg.value());
	};

	auto kioskArg = arguments["kiosk"];
	if (kioskArg.has_value())
	{
		windowFrameOps.fullscreen = true_string(kioskArg.value());
		prefs.Set("Fullscreen", windowFrameOps.fullscreen);
	}

	auto redirectStd = prefs.Get("RedirectStd", false);
	if (true_arg(arguments["console"]))
	{
		Platform::AllocConsole();
	}
	else if (true_arg(arguments["redirect"]) || redirectStd)
	{
		FILE *new_stdout = freopen("stdout.log", "w", stdout);
		FILE *new_stderr = freopen("stderr.log", "w", stderr);
		if (!new_stdout || !new_stderr)
		{
			Platform::Exit(42);
		}
	}

	auto scaleArg = arguments["scale"];
	if (scaleArg.has_value())
	{
		try
		{
			windowFrameOps.scale = scaleArg.value().ToNumber<int>();
			prefs.Set("Scale", windowFrameOps.scale);
		}
		catch (const std::runtime_error &e)
		{
			std::cerr << "failed to set scale: " << e.what() << std::endl;
		}
	}

	auto clientConfig = [&prefs](Argument arg, ByteString name, ByteString defaultValue) {
		ByteString value;
		if (arg.has_value())
		{
			value = arg.value();
			if (value == "")
			{
				value = defaultValue;
			}
			prefs.Set(name, value);
		}
		else
		{
			value = prefs.Get(name, defaultValue);
		}
		return value;
	};
	ByteString proxyString = clientConfig(arguments["proxy"], "Proxy", "");
	ByteString cafileString = clientConfig(arguments["cafile"], "CAFile", "");
	ByteString capathString = clientConfig(arguments["capath"], "CAPath", "");
	bool disableNetwork = true_arg(arguments["disable-network"]);
	explicitSingletons->requestManager = http::RequestManager::Create(proxyString, cafileString, capathString, disableNetwork);

	explicitSingletons->client = std::make_unique<Client>();
	Client::Ref().SetAutoStartupRequest(prefs.Get("AutoStartupRequest", true));
	Client::Ref().Initialize();
	Client::Ref().SetRedirectStd(redirectStd);

	explicitSingletons->saveRenderer = std::make_unique<SaveRenderer>();
	explicitSingletons->favorite = std::make_unique<Favorite>();
	explicitSingletons->engine = std::make_unique<ui::Engine>();

	// TODO: maybe bind the maximum allowed scale to screen size somehow
	if(windowFrameOps.scale < 1 || windowFrameOps.scale > SCALE_MAXIMUM)
		windowFrameOps.scale = 1;

	auto &engine = ui::Engine::Ref();
	engine.g = new Graphics();
	engine.GraveExitsConsole = graveExitsConsole;
	engine.MomentumScroll = momentumScroll;
	engine.ShowAvatars = showAvatars;
	engine.Begin();
	engine.SetFastQuit(prefs.Get("FastQuit", true));
	engine.SetGlobalQuit(prefs.Get("GlobalQuit", true));
	engine.TouchUI = prefs.Get("TouchUI", DEFAULT_TOUCH_UI);
	engine.windowFrameOps = windowFrameOps;

	SDLOpen();

	if (Client::Ref().IsFirstRun() && FORCE_WINDOW_FRAME_OPS == forceWindowFrameOpsNone)
	{
		auto guessed = GuessBestScale();
		if (engine.windowFrameOps.scale != guessed)
		{
			engine.windowFrameOps.scale = guessed;
			prefs.Set("Scale", guessed);
			showLargeScreenDialog = true;
		}
	}

	bool enableBluescreen = USE_BLUESCREEN && !true_arg(arguments["disable-bluescreen"]);
	if (enableBluescreen)
	{
		//Get ready to catch any dodgy errors
		for (auto *msg = signalMessages; msg->message; ++msg)
		{
			signal(msg->sig, SigHandler);
		}
		std::set_terminate(TerminateHandler);
	}

	if constexpr (X86)
	{
		X86KillDenormals();
	}

	explicitSingletons->simulationData = std::make_unique<SimulationData>();
	explicitSingletons->gameController = std::make_unique<GameController>();
	auto *gameController = explicitSingletons->gameController.get();
	engine.ShowWindow(gameController->GetView());
	gameController->InitCommandInterface();

	auto openArg = arguments["open"];
	if (openArg.has_value())
	{
		if constexpr (DEBUG)
		{
			std::cout << "Loading " << openArg.value() << std::endl;
		}
		if (Platform::FileExists(openArg.value()))
		{
			try
			{
				std::vector<char> gameSaveData;
				if (!Platform::ReadFile(gameSaveData, openArg.value()))
				{
					new ErrorMessage("Error", "Could not read file");
				}
				else
				{
					auto newFile = std::make_unique<SaveFile>(openArg.value());
					auto newSave = std::make_unique<GameSave>(std::move(gameSaveData));
					newFile->SetGameSave(std::move(newSave));
					gameController->LoadSaveFile(std::move(newFile));
				}

			}
			catch (std::exception & e)
			{
				new ErrorMessage("Error", "Could not open save file:\n" + ByteString(e.what()).FromUtf8()) ;
			}
		}
		else
		{
			new ErrorMessage("Error", "Could not open file");
		}
	}

	auto ptsaveArg = arguments["ptsave"];
	if (ptsaveArg.has_value())
	{
		engine.g->Clear();
		engine.g->DrawRect(RectSized(engine.g->Size() / 2 - Vec2(100, 25), Vec2(200, 50)), 0xB4B4B4_rgb);
		String loadingText = "Loading save...";
		engine.g->BlendText(engine.g->Size() / 2 - Vec2((Graphics::TextSize(loadingText).X - 1) / 2, 5), loadingText, style::Colour::InformationTitle);

		blit(engine.g->Data());
		try
		{
			ByteString saveIdPart;
			if (ByteString::Split split = ptsaveArg.value().SplitBy(':'))
			{
				if (split.Before() != "ptsave")
					throw std::runtime_error("Not a ptsave link");
				saveIdPart = split.After().SplitBy('#').Before();
			}
			else
				throw std::runtime_error("Invalid save link");

			if (!saveIdPart.size())
				throw std::runtime_error("No Save ID");
			if constexpr (DEBUG)
			{
				std::cout << "Got Ptsave: id: " << saveIdPart << std::endl;
			}
			ByteString saveHistoryPart = "0";
			if (auto split = saveIdPart.SplitBy('@'))
			{
				saveHistoryPart = split.After();
				saveIdPart = split.Before();
			}
			int saveId = saveIdPart.ToNumber<int>();
			int saveHistory = saveHistoryPart.ToNumber<int>();
			gameController->OpenSavePreview(saveId, saveHistory, savePreviewUrl);
		}
		catch (std::exception & e)
		{
			new ErrorMessage("Error", ByteString(e.what()).FromUtf8());
			Platform::MarkPresentable();
		}
	}
	else
	{
		Platform::MarkPresentable();
	}

	MainLoop();

	Platform::Exit(0);
	return 0;
}


=== src\PowderToyFontEditor.cpp ===

#include "PowderToySDL.h"
#include "graphics/Graphics.h"
#include "common/platform/Platform.h"
#include "common/tpt-rand.h"
#include "gui/font/FontEditor.h"
#include "gui/interface/Engine.h"
#include "Config.h"
#include "SimulationConfig.h"
#include <iostream>
#include <memory>

void LoadWindowPosition()
{
}

void SaveWindowPosition()
{
}

void LargeScreenDialog()
{
}

void TickClient()
{
}

struct ExplicitSingletons
{
	// These need to be listed in the order they are populated in main.
	std::unique_ptr<ui::Engine> engine;
};
static std::unique_ptr<ExplicitSingletons> explicitSingletons;

int main(int argc, char * argv[])
{
	Platform::SetupCrt();
	Platform::Atexit([]() {
		SDLClose();
		explicitSingletons.reset();
	});
	explicitSingletons = std::make_unique<ExplicitSingletons>();
	
	WindowFrameOps windowFrameOps;
	if (argc >= 3)
	{
		std::istringstream ss(argv[2]);
		int buf;
		if (ss >> buf)
		{
			windowFrameOps.scale = buf;
		}
	}

	// TODO: maybe bind the maximum allowed scale to screen size somehow
	if (windowFrameOps.scale < 1 || windowFrameOps.scale > 10)
	{
		windowFrameOps.scale = 1;
	}

	explicitSingletons->engine = std::make_unique<ui::Engine>();

	auto &engine = ui::Engine::Ref();
	engine.g = new Graphics();
	engine.windowFrameOps = windowFrameOps;

	SDLOpen();

	engine.Begin();
	engine.SetFastQuit(true);
	engine.SetGlobalQuit(true);

	if (argc >= 2)
	{
		engine.ShowWindow(new FontEditor(argv[1]));
	}
	else
	{
		std::cerr << "path to font.bz2 not supplied" << std::endl;
		Platform::Exit(1);
	}

	while (engine.Running())
	{
		auto delay = EngineProcess();
		if (delay.has_value())
		{
			SDL_Delay(std::max(*delay, UINT64_C(1)));
		}
	}
	Platform::Exit(0);
	return 0;
}


=== src\PowderToyRenderer.cpp ===

#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include "graphics/Renderer.h"
#include "common/String.h"
#include "common/tpt-rand.h"
#include "Format.h"
#include "gui/interface/Engine.h"
#include "client/GameSave.h"
#include "simulation/Simulation.h"
#include "simulation/SimulationData.h"
#include "common/platform/Platform.h"
#include <ctime>
#include <iostream>
#include <fstream>
#include <vector>

int main(int argc, char *argv[])
{
	if (!argv[1] || !argv[2]) {
		std::cout << "Usage: " << argv[0] << " <inputFilename> <outputPrefix>" << std::endl;
		return 1;
	}
	auto inputFilename = ByteString(argv[1]);
	auto outputFilename = ByteString(argv[2]) + ".png";

	auto simulationData = std::make_unique<SimulationData>();

	std::vector<char> fileData;
	if (!Platform::ReadFile(fileData, inputFilename))
	{
		return 1;
	}

	std::unique_ptr<GameSave> gameSave;
	try
	{
		gameSave = std::make_unique<GameSave>(fileData, false);
	}
	catch (ParseException &e)
	{
		//Render the save again later or something? I don't know
		if (ByteString(e.what()).FromUtf8() == "Save from newer version")
			throw e;
	}

	Simulation * sim = new Simulation();
	Renderer * ren = new Renderer();
	ren->sim = sim;

	if (gameSave)
	{
		sim->Load(gameSave.get(), true, { 0, 0 });

		//Render save
		RendererSettings rendererSettings;
		rendererSettings.decorationLevel = RendererSettings::decorationAntiClickbait;
		ren->ApplySettings(rendererSettings);
		ren->ClearAccumulation();
		ren->Clear();
		ren->ApproximateAccumulation();
		ren->RenderSimulation();
	}
	else
	{
		ren->Clear();
		int w = Graphics::TextSize("Save file invalid").X + 15, x = (XRES-w)/2, y = (YRES-24)/2;
		ren->DrawRect(RectSized(Vec2{ x, y }, Vec2{ w, 24 }), 0xC0C0C0_rgb);
		ren->BlendText({ x+8, y+8 }, "Save file invalid", 0xC0C0F0_rgb .WithAlpha(255));
	}

	auto &video = ren->GetVideo();
	if (auto data = VideoBuffer(video.data(), RES, video.Size().X).ToPNG())
		Platform::WriteFile(*data, outputFilename);
}


=== src\PowderToySDL.cpp ===

#include "PowderToySDL.h"
#include "SimulationConfig.h"
#include "WindowIcon.h"
#include "Config.h"
#include "gui/interface/Engine.h"
#include "graphics/Graphics.h"
#include "common/platform/Platform.h"
#include "common/clipboard/Clipboard.h"
#include "FrameSchedule.h"
#include <iostream>

int desktopWidth = 1280;
int desktopHeight = 1024;
SDL_Window *sdl_window = nullptr;
SDL_Renderer *sdl_renderer = nullptr;
SDL_Texture *sdl_texture = nullptr;
bool vsyncHint = false;
WindowFrameOps currentFrameOps;
bool momentumScroll = true;
bool showAvatars = true;
bool showLargeScreenDialog = false;
int mousex = 0;
int mousey = 0;
int mouseButton = 0;
bool mouseDown = false;
bool calculatedInitialMouse = false;
bool hasMouseMoved = false;
double correctedFrameTimeAvg = 0;
static bool prevContributesToFps = false;

static FrameSchedule tickSchedule;
static FrameSchedule drawSchedule;
static FrameSchedule clientTickSchedule;
static FrameSchedule fpsUpdateSchedule;

void StartTextInput()
{
	SDL_StartTextInput();
}

void StopTextInput()
{
	SDL_StopTextInput();
}

void SetTextInputRect(int x, int y, int w, int h)
{
	// Why does SDL_SetTextInputRect not take logical coordinates???
	SDL_Rect rect;
#if SDL_VERSION_ATLEAST(2, 0, 18)
	int wx, wy, wwx, why;
	SDL_RenderLogicalToWindow(sdl_renderer, float(x), float(y), &wx, &wy);
	SDL_RenderLogicalToWindow(sdl_renderer, float(x + w), float(y + h), &wwx, &why);
	rect.x = wx;
	rect.y = wy;
	rect.w = wwx - wx;
	rect.h = why - wy;
#else
	// TODO: use SDL_RenderLogicalToWindow when ubuntu deigns to update to sdl 2.0.18
	auto scale = ui::Engine::Ref().windowFrameOps.scale;
	rect.x = x * scale;
	rect.y = y * scale;
	rect.w = w * scale;
	rect.h = h * scale;
#endif
	SDL_SetTextInputRect(&rect);
}

void ClipboardPush(ByteString text)
{
	SDL_SetClipboardText(text.c_str());
}

ByteString ClipboardPull()
{
	return ByteString(SDL_GetClipboardText());
}

int GetModifiers()
{
	return SDL_GetModState();
}

unsigned int GetTicks()
{
	return SDL_GetTicks();
}

uint64_t GetNowNs()
{
	return uint64_t(SDL_GetTicks()) * UINT64_C(1'000'000);
}

static void CalculateMousePosition(int *x, int *y)
{
	int globalMx, globalMy;
	SDL_GetGlobalMouseState(&globalMx, &globalMy);
	int windowX, windowY;
	SDL_GetWindowPosition(sdl_window, &windowX, &windowY);

	if (x)
		*x = (globalMx - windowX) / currentFrameOps.scale;
	if (y)
		*y = (globalMy - windowY) / currentFrameOps.scale;
}

void blit(pixel *vid)
{
	SDL_UpdateTexture(sdl_texture, nullptr, vid, WINDOWW * sizeof (Uint32));
	// need to clear the renderer if there are black edges (fullscreen, or resizable window)
	if (currentFrameOps.fullscreen || currentFrameOps.resizable)
		SDL_RenderClear(sdl_renderer);
	SDL_RenderCopy(sdl_renderer, sdl_texture, nullptr, nullptr);
	SDL_RenderPresent(sdl_renderer);
}

void UpdateRefreshRate()
{
	RefreshRate refreshRate;
	int displayIndex = SDL_GetWindowDisplayIndex(sdl_window);
	if (displayIndex >= 0)
	{
		SDL_DisplayMode displayMode;
		if (!SDL_GetCurrentDisplayMode(displayIndex, &displayMode) && displayMode.refresh_rate)
		{
			refreshRate = RefreshRateQueried{ displayMode.refresh_rate };
		}
	}
	ui::Engine::Ref().SetRefreshRate(refreshRate);
}

void SDLOpen()
{
	if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0)
	{
		fprintf(stderr, "Initializing SDL (video subsystem): %s\n", SDL_GetError());
		Platform::Exit(-1);
	}
	Clipboard::Init();

	SDLSetScreen();

	int displayIndex = SDL_GetWindowDisplayIndex(sdl_window);
	if (displayIndex >= 0)
	{
		SDL_Rect rect;
		if (!SDL_GetDisplayUsableBounds(displayIndex, &rect))
		{
			desktopWidth = rect.w;
			desktopHeight = rect.h;
		}
	}
	UpdateRefreshRate();

	StopTextInput();
}

void SDLClose()
{
	if (SDL_GetWindowFlags(sdl_window) & SDL_WINDOW_OPENGL)
	{
		// * nvidia-460 egl registers callbacks with x11 that end up being called
		//   after egl is unloaded unless we grab it here and release it after
		//   sdl closes the display. this is an nvidia driver weirdness but
		//   technically an sdl bug. glfw has this fixed:
		//   https://github.com/glfw/glfw/commit/9e6c0c747be838d1f3dc38c2924a47a42416c081
		SDL_GL_LoadLibrary(nullptr);
		SDL_QuitSubSystem(SDL_INIT_VIDEO);
		SDL_GL_UnloadLibrary();
	}
	SDL_Quit();
}

void SDLSetScreen()
{
	auto newFrameOps = ui::Engine::Ref().windowFrameOps;
	auto newVsyncHint = false; // TODO: DrawLimitVsync
	if (FORCE_WINDOW_FRAME_OPS == forceWindowFrameOpsEmbedded)
	{
		newFrameOps.resizable = false;
		newFrameOps.fullscreen = false;
		newFrameOps.changeResolution = false;
		newFrameOps.forceIntegerScaling = false;
	}
	if (FORCE_WINDOW_FRAME_OPS == forceWindowFrameOpsHandheld)
	{
		newFrameOps.resizable = false;
		newFrameOps.fullscreen = true;
		newFrameOps.changeResolution = false;
		newFrameOps.forceIntegerScaling = false;
	}

	auto currentFrameOpsNorm = currentFrameOps.Normalize();
	auto newFrameOpsNorm = newFrameOps.Normalize();
	auto recreate = !sdl_window ||
	                // Recreate the window when toggling fullscreen, due to occasional issues
	                newFrameOpsNorm.fullscreen       != currentFrameOpsNorm.fullscreen       ||
	                // Also recreate it when enabling resizable windows, to fix bugs on windows,
	                //  see https://github.com/jacob1/The-Powder-Toy/issues/24
	                newFrameOpsNorm.resizable        != currentFrameOpsNorm.resizable        ||
	                newFrameOpsNorm.changeResolution != currentFrameOpsNorm.changeResolution ||
	                newFrameOpsNorm.blurryScaling    != currentFrameOpsNorm.blurryScaling    ||
	                newVsyncHint != vsyncHint;

	if (!(recreate ||
	      newFrameOpsNorm.scale               != currentFrameOpsNorm.scale               ||
	      newFrameOpsNorm.forceIntegerScaling != currentFrameOpsNorm.forceIntegerScaling))
	{
		return;
	}

	auto size = WINDOW * newFrameOpsNorm.scale;
	if (sdl_window && newFrameOpsNorm.resizable)
	{
		SDL_GetWindowSize(sdl_window, &size.X, &size.Y);
	}

	if (recreate)
	{
		if (sdl_texture)
		{
			SDL_DestroyTexture(sdl_texture);
			sdl_texture = nullptr;
		}
		if (sdl_renderer)
		{
			SDL_DestroyRenderer(sdl_renderer);
			sdl_renderer = nullptr;
		}
		if (sdl_window)
		{
			SaveWindowPosition();
			SDL_DestroyWindow(sdl_window);
			sdl_window = nullptr;
		}

		unsigned int flags = 0;
		unsigned int rendererFlags = 0;
		if (newFrameOpsNorm.fullscreen)
		{
			flags = newFrameOpsNorm.changeResolution ? SDL_WINDOW_FULLSCREEN : SDL_WINDOW_FULLSCREEN_DESKTOP;
		}
		if (newFrameOpsNorm.resizable)
		{
			flags |= SDL_WINDOW_RESIZABLE;
		}
		if (vsyncHint)
		{
			rendererFlags |= SDL_RENDERER_PRESENTVSYNC;
		}
		sdl_window = SDL_CreateWindow(APPNAME, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, size.X, size.Y, flags);
		if (!sdl_window)
		{
			fprintf(stderr, "SDL_CreateWindow failed: %s\n", SDL_GetError());
			Platform::Exit(-1);
		}
		if constexpr (SET_WINDOW_ICON)
		{
			WindowIcon(sdl_window);
		}
		SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1");
		SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, newFrameOpsNorm.blurryScaling ? "linear" : "nearest");
		sdl_renderer = SDL_CreateRenderer(sdl_window, -1, rendererFlags);
		if (!sdl_renderer)
		{
			fprintf(stderr, "SDL_CreateRenderer failed; available renderers:\n");
			int num = SDL_GetNumRenderDrivers();
			for (int i = 0; i < num; ++i)
			{
				SDL_RendererInfo info;
				SDL_GetRenderDriverInfo(i, &info);
				fprintf(stderr, " - %s\n", info.name);
			}
			Platform::Exit(-1);
		}
		SDL_RenderSetLogicalSize(sdl_renderer, WINDOWW, WINDOWH);
		sdl_texture = SDL_CreateTexture(sdl_renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, WINDOWW, WINDOWH);
		if (!sdl_texture)
		{
			fprintf(stderr, "SDL_CreateTexture failed: %s\n", SDL_GetError());
			Platform::Exit(-1);
		}
		SDL_RaiseWindow(sdl_window);
		Clipboard::RecreateWindow();
	}
	SDL_RenderSetIntegerScale(sdl_renderer, newFrameOpsNorm.forceIntegerScaling ? SDL_TRUE : SDL_FALSE);
	if (!(newFrameOpsNorm.resizable && SDL_GetWindowFlags(sdl_window) & SDL_WINDOW_MAXIMIZED))
	{
		SDL_SetWindowSize(sdl_window, size.X, size.Y);
		LoadWindowPosition();
	}
	ApplyFpsLimit();
	if (newFrameOpsNorm.fullscreen)
	{
		SDL_RaiseWindow(sdl_window);
	}
	currentFrameOps = newFrameOps;
	vsyncHint = newVsyncHint;
}

static void EventProcess(const SDL_Event &event)
{
	auto &engine = ui::Engine::Ref();
	switch (event.type)
	{
	case SDL_QUIT:
		if (ALLOW_QUIT && (engine.GetFastQuit() || engine.CloseWindow()))
		{
			engine.Exit();
		}
		break;
	case SDL_KEYDOWN:
		if (SDL_GetModState() & KMOD_GUI)
		{
			break;
		}
		if (engine.GetGlobalQuit() && ALLOW_QUIT && !event.key.repeat && event.key.keysym.sym == 'q' && (event.key.keysym.mod&KMOD_CTRL) && !(event.key.keysym.mod&KMOD_ALT))
			engine.ConfirmExit();
		else
			engine.onKeyPress(event.key.keysym.sym, event.key.keysym.scancode, event.key.repeat, event.key.keysym.mod&KMOD_SHIFT, event.key.keysym.mod&KMOD_CTRL, event.key.keysym.mod&KMOD_ALT);
		break;
	case SDL_KEYUP:
		if (SDL_GetModState() & KMOD_GUI)
		{
			break;
		}
		engine.onKeyRelease(event.key.keysym.sym, event.key.keysym.scancode, event.key.repeat, event.key.keysym.mod&KMOD_SHIFT, event.key.keysym.mod&KMOD_CTRL, event.key.keysym.mod&KMOD_ALT);
		break;
	case SDL_TEXTINPUT:
		if (SDL_GetModState() & KMOD_GUI)
		{
			break;
		}
		engine.onTextInput(ByteString(event.text.text).FromUtf8());
		break;
	case SDL_TEXTEDITING:
		if (SDL_GetModState() & KMOD_GUI)
		{
			break;
		}
		engine.onTextEditing(ByteString(event.edit.text).FromUtf8(), event.edit.start);
		break;
	case SDL_MOUSEWHEEL:
	{
		// int x = event.wheel.x;
		int y = event.wheel.y;
		if (event.wheel.direction == SDL_MOUSEWHEEL_FLIPPED)
		{
			// x *= -1;
			y *= -1;
		}

		engine.onMouseWheel(mousex, mousey, y); // TODO: pass x?
		break;
	}
	case SDL_MOUSEMOTION:
		mousex = event.motion.x;
		mousey = event.motion.y;
		engine.onMouseMove(mousex, mousey);

		hasMouseMoved = true;
		break;
	case SDL_DROPFILE:
		engine.onFileDrop(event.drop.file);
		SDL_free(event.drop.file);
		break;
	case SDL_MOUSEBUTTONDOWN:
		// if mouse hasn't moved yet, sdl will send 0,0. We don't want that
		if (hasMouseMoved)
		{
			mousex = event.button.x;
			mousey = event.button.y;
		}
		mouseButton = event.button.button;
		engine.onMouseDown(mousex, mousey, mouseButton);

		mouseDown = true;
		if constexpr (!DEBUG)
		{
			SDL_CaptureMouse(SDL_TRUE);
		}
		break;
	case SDL_MOUSEBUTTONUP:
		// if mouse hasn't moved yet, sdl will send 0,0. We don't want that
		if (hasMouseMoved)
		{
			mousex = event.button.x;
			mousey = event.button.y;
		}
		mouseButton = event.button.button;
		engine.onMouseUp(mousex, mousey, mouseButton);

		mouseDown = false;
		if constexpr (!DEBUG)
		{
			SDL_CaptureMouse(SDL_FALSE);
		}
		break;
	case SDL_WINDOWEVENT:
	{
		switch (event.window.event)
		{
		case SDL_WINDOWEVENT_SHOWN:
			if (!calculatedInitialMouse)
			{
				//initial mouse coords, sdl won't tell us this if mouse hasn't moved
				CalculateMousePosition(&mousex, &mousey);
				engine.initialMouse(mousex, mousey);
				engine.onMouseMove(mousex, mousey);
				calculatedInitialMouse = true;
			}
			break;

		case SDL_WINDOWEVENT_DISPLAY_CHANGED:
			UpdateRefreshRate();
			break;
		}
		break;
	}
	}
}

std::optional<uint64_t> EngineProcess()
{
	auto &engine = ui::Engine::Ref();

	{
		auto nowNs = GetNowNs();
		if (clientTickSchedule.HasElapsed(nowNs))
		{
			TickClient();
			clientTickSchedule.SetNow(nowNs);
		}
		clientTickSchedule.Arm(10);
		if (fpsUpdateSchedule.HasElapsed(nowNs))
		{
			engine.SetFps(1e9f / correctedFrameTimeAvg);
			fpsUpdateSchedule.SetNow(nowNs);
		}
		fpsUpdateSchedule.Arm(5);
	}

	if (showLargeScreenDialog)
	{
		showLargeScreenDialog = false;
		LargeScreenDialog();
	}

	SDL_Event event;
	while (SDL_PollEvent(&event))
	{
		EventProcess(event);
	}

	std::optional<uint64_t> delay;
	auto nowNs = GetNowNs();
	auto effectiveDrawLimit = engine.GetEffectiveDrawCap();
	auto doDraw = !effectiveDrawLimit || drawSchedule.HasElapsed(nowNs);
	auto fpsLimit = ui::Engine::Ref().GetFpsLimit();
	auto doSimTick = true;
	if (std::holds_alternative<FpsLimitExplicit>(fpsLimit))
	{
		doSimTick = tickSchedule.HasElapsed(nowNs);
	}
	else if (std::holds_alternative<FpsLimitFollowDraw>(fpsLimit))
	{
		doSimTick = doDraw;
	}
	if (doDraw)
	{
		engine.Tick();
	}
	if (doSimTick)
	{
		auto thisContributesToFps = engine.GetContributesToFps();
		if (prevContributesToFps && thisContributesToFps)
		{
			auto correctedFrameTime = tickSchedule.GetFrameTime();
			correctedFrameTimeAvg = correctedFrameTimeAvg + (correctedFrameTime - correctedFrameTimeAvg) * 0.05;
		}
		prevContributesToFps = thisContributesToFps;
		engine.SimTick();
		tickSchedule.SetNow(nowNs);
	}
	if (doDraw)
	{
		engine.Draw();
		drawSchedule.SetNow(nowNs);
		SDLSetScreen();
		blit(engine.g->Data());
	}
	if (effectiveDrawLimit)
	{
		delay = drawSchedule.Arm(float(*effectiveDrawLimit)) / UINT64_C(1'000'000);
	}
	if (auto *fpsLimitExplicit = std::get_if<FpsLimitExplicit>(&fpsLimit))
	{
		auto simDelay = tickSchedule.Arm(fpsLimitExplicit->value) / UINT64_C(1'000'000);
		if (delay.has_value() && simDelay < *delay)
		{
			delay = simDelay;
		}
	}
	else if (std::holds_alternative<FpsLimitNone>(fpsLimit))
	{
		delay.reset();
	}
	return delay;
}


=== src\PowderToySDL.h ===

#pragma once
#include "common/String.h"
#include "graphics/Pixel.h"
#include "gui/WindowFrameOps.h"
#include "FpsLimit.h"
#include <cstdint>
#include <SDL.h>
#include <variant>
#include <optional>

extern int desktopWidth;
extern int desktopHeight;
extern SDL_Window *sdl_window;
extern SDL_Renderer *sdl_renderer;
extern SDL_Texture *sdl_texture;
extern bool momentumScroll;
extern bool showAvatars;
extern bool showLargeScreenDialog;
extern int mousex;
extern int mousey;
extern int mouseButton;
extern bool mouseDown;
extern bool calculatedInitialMouse;
extern bool hasMouseMoved;

void MainLoop();
std::optional<uint64_t> EngineProcess();
void StartTextInput();
void StopTextInput();
void SetTextInputRect(int x, int y, int w, int h);
void ClipboardPush(ByteString text);
ByteString ClipboardPull();
int GetModifiers();
unsigned int GetTicks();
uint64_t GetNowNs();
void blit(pixel *vid);
void SDLOpen();
void SDLClose();
void SDLSetScreen();
void LoadWindowPosition();
void SaveWindowPosition();
void LargeScreenDialog();
void TickClient();
void ApplyFpsLimit();


=== src\PowderToySDLCommon.cpp ===

#include "PowderToySDL.h"
#include "gui/interface/Engine.h"

void MainLoop()
{
	while (ui::Engine::Ref().Running())
	{
		auto delay = EngineProcess();
		if (delay.has_value())
		{
			SDL_Delay(std::max(*delay, UINT64_C(1)));
		}
	}
}

void ApplyFpsLimit()
{
}


=== src\PowderToySDLEmscripten.cpp ===

#include "PowderToySDL.h"
#include "gui/interface/Engine.h"
#include <emscripten.h>
#include <iostream>

namespace Platform
{
	void MaybeTriggerSyncFs();
}

static void MainLoopBody()
{
	EngineProcess();
	Platform::MaybeTriggerSyncFs();
}

void ApplyFpsLimit()
{
	static bool mainLoopSet = false;
	if (!mainLoopSet)
	{
		emscripten_set_main_loop(MainLoopBody, 0, 0);
		mainLoopSet = true;
	}
	// this generally attempts to replicate the behaviour of EngineProcess
	std::optional<float> drawLimit;
	auto &engine = ui::Engine::Ref();
	auto fpsLimit = engine.GetFpsLimit();
	if (auto *fpsLimitExplicit = std::get_if<FpsLimitExplicit>(&fpsLimit))
	{
		drawLimit = fpsLimitExplicit->value;
	}
	else if (std::holds_alternative<FpsLimitFollowDraw>(fpsLimit))
	{
		auto effectiveDrawLimit = engine.GetEffectiveDrawCap();
		if (effectiveDrawLimit)
		{
			drawLimit = float(*effectiveDrawLimit);
		}
		// else // TODO: DrawLimitVsync
		// {
		// 	if (std::holds_alternative<DrawLimitVsync>(engine.GetDrawingFrequencyLimit()))
		// 	{
		// 		emscripten_set_main_loop_timing(EM_TIMING_RAF, 1);
		// 		std::cerr << "implicit fps limit via vsync" << std::endl;
		// 		return;
		// 	}
		// }
	}
	int delay = 0; // no cap
	if (drawLimit.has_value())
	{
		delay = int(1000.f / *drawLimit);
	}
	emscripten_set_main_loop_timing(EM_TIMING_SETTIMEOUT, delay);
	std::cerr << "explicit fps limit: " << delay << "ms delays" << std::endl;
}

// Is actually only called once at startup, the real main loop body is MainLoopBody.
void MainLoop()
{
	ApplyFpsLimit();
	MainLoopBody();
}


=== src\Probability.cpp ===

/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "Probability.h"
#include "common/tpt-rand.h"
#include <numeric>
#include <cstdlib>

namespace Probability
{

float binomial_gte1(int n, float p)
{
	return 1.0f - std::pow(1.0f-p, n);
}

SmallKBinomialGenerator::SmallKBinomialGenerator(unsigned int n, float p, unsigned int maxK_)
{
	maxK = maxK_;
	cdf = new float[maxK];

	float *pdf = new float[maxK];
	// initial values, k=0:
	float pTerm = std::pow(1.0f-p, static_cast<float>(n)); // the p^k * (1-p)^(n-k) term
	unsigned int coeffN = 1, coeffD = 1; // (N / D) evaluates to the same result as the n!/(k!(n-k)!) term
	for (unsigned int k=0; k<maxK; k++)
	{
		pdf[k] = pTerm * (float(coeffN) / coeffD);
		pTerm *= p/(1.0f-p);
		coeffN *= n-k; // Part of the n! will no longer cancelled out by (n-k)!
		coeffD *= k+1; // k! (k+1 because this is for next k)
	}

	std::partial_sum(pdf, pdf+maxK, cdf);
	delete[] pdf;
}

SmallKBinomialGenerator::~SmallKBinomialGenerator()
{
	delete[] cdf;
}

unsigned int SmallKBinomialGenerator::calc(float randFloat)
{
	for (unsigned int k=0; k<maxK; k++)
	{
		if (randFloat<cdf[k])
			return k;
	}
	return maxK;
}

}


=== src\Probability.h ===

/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
// This file is used for EMP, to simulate many EMP going off at once at the end of the frame
#include <cmath>

namespace Probability
{
	// X ~ binomial(n,p), returns P(X>=1)
	// e.g. If a reaction has n chances of occurring, each time with probability p, this returns the probability that it occurs at least once.
	float binomial_gte1(int n, float p);

	class SmallKBinomialGenerator
	{
	protected:
		float *cdf;
		unsigned int maxK;
	public:
		// Class to generate numbers from a binomial distribution, up to a maximum value (maxK).
		// Results which would have been above maxK return maxK.
		// Note: maxK must be small, otherwise the method used in this class is inefficient. (n and p can be any valid value)
		SmallKBinomialGenerator(unsigned int n, float p, unsigned int maxK_);
		~SmallKBinomialGenerator();
		unsigned int calc(float randFloat);
	};
}


=== src\SDLCompat.cpp ===

#if defined(_MSC_VER) && (_MSC_VER >= 1900)

#include <cstdio>

FILE _iob[] = { *stdin, *stdout, *stderr };
extern "C" FILE * __cdecl __iob_func(void)
{
	return _iob;
}

#endif


=== src\SimulationConfig.h ===

#pragma once
#include <cstdint>
#include <common/Vec2.h>

constexpr int MENUSIZE = 40;
constexpr int BARSIZE  = 17;

constexpr float M_GRAV = 6.67300e-1f;

//CELL, the size of the pressure, gravity, and wall maps. Larger than 1 to prevent extreme lag
constexpr int CELL = 4;
constexpr Vec2<int> CELLS = Vec2(153, 96);
constexpr Vec2<int> RES = CELLS * CELL;

constexpr int XCELLS = CELLS.X;
constexpr int YCELLS = CELLS.Y;
constexpr int NCELL  = XCELLS * YCELLS;
constexpr int XRES   = RES.X;
constexpr int YRES   = RES.Y;
constexpr int NPART  = XRES * YRES;

constexpr int XCNTR = XRES / 2;
constexpr int YCNTR = YRES / 2;

constexpr Vec2<int> WINDOW = RES + Vec2(BARSIZE, MENUSIZE);

constexpr int WINDOWW = WINDOW.X;
constexpr int WINDOWH = WINDOW.Y;

constexpr int MAXSIGNS = 16;

constexpr int   ISTP            = CELL / 2;
constexpr float CFDS            = 4.0f / CELL;
constexpr float MAX_VELOCITY = 1e4f;

//Air constants
constexpr float AIR_TSTEPP = 0.3f;
constexpr float AIR_TSTEPV = 0.4f;
constexpr float AIR_VADV   = 0.3f;
constexpr float AIR_VLOSS  = 0.999f;
constexpr float AIR_PLOSS  = 0.9999f;

constexpr int NGOL = 24;

enum DefaultBrushes
{
	BRUSH_CIRCLE,
	BRUSH_SQUARE,
	BRUSH_TRIANGLE,
	NUM_DEFAULTBRUSHES,
};

//Photon constants
constexpr int SURF_RANGE     = 10;
constexpr int NORMAL_MIN_EST =  3;
constexpr int NORMAL_INTERP  = 20;
constexpr int NORMAL_FRAC    = 16;

constexpr auto REFRACT = UINT32_C(0x80000000);

/* heavy flint glass, for awesome refraction/dispersion
   this way you can make roof prisms easily */
constexpr float GLASS_IOR  = 1.9f;
constexpr float GLASS_DISP = 0.07f;

constexpr float R_TEMP = 22;

constexpr bool LATENTHEAT = false;


=== src\VcsTag.template.h ===

#pragma once

constexpr char VCS_TAG[] = "@VCS_TAG@";


=== src\WindowIcon.cpp ===

#include "Format.h"
#include "graphics/VideoBuffer.h"
#include "WindowIcon.h"

#include "icon_exe_png.h"

void WindowIcon(SDL_Window *window)
{
	if (auto image = format::PixelsFromPNG(icon_exe_png.AsCharSpan()))
	{
		SDL_Surface *icon = SDL_CreateRGBSurfaceFrom(image->data(), image->Size().X, image->Size().Y, 32, image->Size().Y * sizeof(pixel), 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
		SDL_SetWindowIcon(window, icon);
		SDL_FreeSurface(icon);
	}
}


=== src\WindowIcon.h ===

#pragma once
#include <SDL.h>

void WindowIcon(SDL_Window *window);


=== src\X86KillDenormals.cpp ===

#include "X86KillDenormals.h"
#include <xmmintrin.h>
#include <pmmintrin.h>

void X86KillDenormals()
{
	_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
	_MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
}


=== src\X86KillDenormals.h ===

#pragma once

void X86KillDenormals();


=== src\bson\BSON.cpp ===

/* bson.c */

/*    Copyright 2009, 2010 10gen Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
#include "BSON.h"

#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <ctime>
#include <climits>


const int initialBufferSize = 128;

/* only need one of these */
static const int zero = 0;

/* Custom standard function pointers. */
void *( *bson_malloc_func )( size_t ) = malloc;
void *( *bson_realloc_func )( void *, size_t ) = realloc;
void  ( *bson_free )( void * ) = free;
bson_printf_func bson_printf = printf;
bson_fprintf_func bson_fprintf = fprintf;
bson_sprintf_func bson_sprintf = sprintf;

static int _bson_errprintf( const char *, ... );
bson_printf_func bson_errprintf = _bson_errprintf;

/* ObjectId fuzz functions. */
static int ( *oid_fuzz_func )( void ) = nullptr;
static int ( *oid_inc_func )( void )  = nullptr;

/* ----------------------------
   READING
   ------------------------------ */

bson *bson_empty( bson *obj ) {
	static char data[] = "\005\0\0\0\0";
	bson_init_data( obj, data );
	obj->finished = 1;
	obj->err = 0;
	obj->stackPos = 0;
	return obj;
}

int bson_copy( bson *out, const bson *in ) {
	if ( !out ) return BSON_ERROR;
	if ( !in->finished ) return BSON_ERROR;
	bson_init_size( out, bson_size( in ) );
	memcpy( out->data, in->data, bson_size( in ) );
	out->finished = 1;

	return BSON_OK;
}

int bson_init_data( bson *b, char *data ) {
	b->data = data;
	b->dataSize = INT_MAX; // no overflow detection for bson_iterator_next
	return BSON_OK;
}

int bson_init_data_size( bson *b, char *data, int size ) {
	b->data = data;
	b->dataSize = size; // used for overflow detection for bson_iterator_next
	return BSON_OK;
}

int bson_init_finished_data( bson *b, char *data ) {
	bson_init_data( b, data );
	b->stackPos = 0;
	b->finished = 1;
	return BSON_OK;
}

static void _bson_reset( bson *b ) {
	b->finished = 0;
	b->stackPos = 0;
	b->err = 0;
	b->errstr = nullptr;
}

int bson_size( const bson *b ) {
	int i;
	if ( ! b || ! b->data )
		return 0;
	bson_little_endian32( &i, b->data );
	return i;
}

const char *bson_data( bson *b ) {
	return (const char *)b->data;
}

static char hexbyte( char hex ) {
	switch ( hex ) {
	case '0':
		return 0x0;
	case '1':
		return 0x1;
	case '2':
		return 0x2;
	case '3':
		return 0x3;
	case '4':
		return 0x4;
	case '5':
		return 0x5;
	case '6':
		return 0x6;
	case '7':
		return 0x7;
	case '8':
		return 0x8;
	case '9':
		return 0x9;
	case 'a':
	case 'A':
		return 0xa;
	case 'b':
	case 'B':
		return 0xb;
	case 'c':
	case 'C':
		return 0xc;
	case 'd':
	case 'D':
		return 0xd;
	case 'e':
	case 'E':
		return 0xe;
	case 'f':
	case 'F':
		return 0xf;
	default:
		return 0x0; /* something smarter? */
	}
}

void bson_oid_from_string( bson_oid_t *oid, const char *str ) {
	int i;
	for ( i=0; i<12; i++ ) {
		oid->bytes[i] = ( hexbyte( str[2*i] ) << 4 ) | hexbyte( str[2*i + 1] );
	}
}

void bson_oid_to_string( const bson_oid_t *oid, char *str ) {
	static const char hex[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
	int i;
	for ( i=0; i<12; i++ ) {
		str[2*i]	 = hex[( oid->bytes[i] & 0xf0 ) >> 4];
		str[2*i + 1] = hex[ oid->bytes[i] & 0x0f	  ];
	}
	str[24] = '\0';
}

void bson_set_oid_fuzz( int ( *func )( void ) ) {
	oid_fuzz_func = func;
}

void bson_set_oid_inc( int ( *func )( void ) ) {
	oid_inc_func = func;
}

void bson_oid_gen( bson_oid_t *oid ) {
	static int incr = 0;
	static int fuzz = 0;
	int i;
	int t = time( nullptr );

	if( oid_inc_func )
		i = oid_inc_func();
	else
		i = incr++;

	if ( !fuzz ) {
		if ( oid_fuzz_func )
			fuzz = oid_fuzz_func();
		else {
			srand( t );
			fuzz = rand();
		}
	}

	bson_big_endian32( &oid->ints[0], &t );
	oid->ints[1] = fuzz;
	bson_big_endian32( &oid->ints[2], &i );
}

time_t bson_oid_generated_time( bson_oid_t *oid ) {
	time_t out;
	bson_big_endian32( &out, &oid->ints[0] );

	return out;
}

void bson_print( bson *b ) {
	bson_print_raw( b->data , 0 );
}

void bson_print_raw( const char *data , int depth ) {
	bson_iterator i;
	const char *key;
	int temp;
	bson_timestamp_t ts;
	char oidhex[25];
	bson scope;
	bson_iterator_from_buffer( &i, data );

	while ( bson_iterator_next( &i ) ) {
		bson_type t = bson_iterator_type( &i );
		if ( t == 0 )
			break;
		key = bson_iterator_key( &i );

		for ( temp=0; temp<=depth; temp++ )
			bson_printf( "\t" );
		bson_printf( "%s : %d \t " , key , t );
		switch ( t ) {
		case BSON_DOUBLE:
			bson_printf( "%f" , bson_iterator_double( &i ) );
			break;
		case BSON_STRING:
			bson_printf( "%s" , bson_iterator_string( &i ) );
			break;
		case BSON_SYMBOL:
			bson_printf( "SYMBOL: %s" , bson_iterator_string( &i ) );
			break;
		case BSON_OID:
			bson_oid_to_string( bson_iterator_oid( &i ), oidhex );
			bson_printf( "%s" , oidhex );
			break;
		case BSON_BOOL:
			bson_printf( "%s" , bson_iterator_bool( &i ) ? "true" : "false" );
			break;
		case BSON_DATE:
			bson_printf( "%ld" , ( long int )bson_iterator_date( &i ) );
			break;
		case BSON_BINDATA:
			bson_printf( "BSON_BINDATA" );
			break;
		case BSON_UNDEFINED:
			bson_printf( "BSON_UNDEFINED" );
			break;
		case BSON_NULL:
			bson_printf( "BSON_NULL" );
			break;
		case BSON_REGEX:
			bson_printf( "BSON_REGEX: %s", bson_iterator_regex( &i ) );
			break;
		case BSON_CODE:
			bson_printf( "BSON_CODE: %s", bson_iterator_code( &i ) );
			break;
		case BSON_CODEWSCOPE:
			bson_printf( "BSON_CODE_W_SCOPE: %s", bson_iterator_code( &i ) );
			bson_init( &scope );
			bson_iterator_code_scope( &i, &scope );
			bson_printf( "\n\t SCOPE: " );
			bson_print( &scope );
			break;
		case BSON_INT:
			bson_printf( "%d" , bson_iterator_int( &i ) );
			break;
		case BSON_LONG:
			bson_printf( "%lld" , ( uint64_t )bson_iterator_long( &i ) );
			break;
		case BSON_TIMESTAMP:
			ts = bson_iterator_timestamp( &i );
			bson_printf( "i: %d, t: %d", ts.i, ts.t );
			break;
		case BSON_OBJECT:
		case BSON_ARRAY:
			bson_printf( "\n" );
			bson_print_raw( bson_iterator_value( &i ) , depth + 1 );
			break;
		default:
			bson_errprintf( "can't print type : %d\n" , t );
		}
		bson_printf( "\n" );
	}
}

/* ----------------------------
   ITERATOR
   ------------------------------ */

void bson_iterator_init( bson_iterator *i, const bson *b ) {
	i->cur = b->data + 4;
	i->first = 1;
	i->last = b->data + b->dataSize;
}

void bson_iterator_from_buffer( bson_iterator *i, const char *buffer ) {
	i->cur = buffer + 4;
	i->first = 1;
	i->last = nullptr;
}

bson_type bson_find( bson_iterator *it, const bson *obj, const char *name ) {
	bson_iterator_init( it, (bson *)obj );
	while( bson_iterator_next( it ) ) {
		if ( strcmp( name, bson_iterator_key( it ) ) == 0 )
			break;
	}
	return bson_iterator_type( it );
}

bson_bool_t bson_iterator_more( const bson_iterator *i ) {
	if (i->last && i->cur >= i->last)
		return BSON_EOO;
	return *( i->cur );
}

bson_type bson_iterator_next( bson_iterator *i ) {
	int ds;

	if ( i->first ) {
		i->first = 0;
		return ( bson_type )( *i->cur );
	}

	switch ( bson_iterator_type( i ) ) {
	case BSON_EOO:
		return BSON_EOO; /* don't advance */
	case BSON_UNDEFINED:
	case BSON_NULL:
		ds = 0;
		break;
	case BSON_BOOL:
		ds = 1;
		break;
	case BSON_INT:
		ds = 4;
		break;
	case BSON_LONG:
	case BSON_DOUBLE:
	case BSON_TIMESTAMP:
	case BSON_DATE:
		ds = 8;
		break;
	case BSON_OID:
		ds = 12;
		break;
	case BSON_STRING:
	case BSON_SYMBOL:
	case BSON_CODE:
		ds = 4 + bson_iterator_int_raw( i );
		break;
	case BSON_BINDATA:
		ds = 5 + bson_iterator_int_raw( i );
		break;
	case BSON_OBJECT:
	case BSON_ARRAY:
	case BSON_CODEWSCOPE:
		ds = bson_iterator_int_raw( i );
		break;
	case BSON_DBREF:
		ds = 4+12 + bson_iterator_int_raw( i );
		break;
	case BSON_REGEX: {
		const char *s = bson_iterator_value( i );
		const char *p = s;
		p += strlen( p )+1;
		p += strlen( p )+1;
		ds = p-s;
		break;
	}

	default: {
		char msg[] = "unknown type: 000000000000";
		bson_numstr( msg+14, ( unsigned )( i->cur[0] ) );
		bson_fatal_msg( 0, msg );
		return (bson_type)0;
	}
	}

	i->cur += 1 + strlen( i->cur + 1 ) + 1 + ds;

	if (i->last && i->cur >= i->last)
		return BSON_EOO;
	return ( bson_type )( *i->cur );
}

bson_type bson_iterator_type( const bson_iterator *i ) {
	return ( bson_type )i->cur[0];
}

const char *bson_iterator_key( const bson_iterator *i ) {
	return i->cur + 1;
}

const char *bson_iterator_value( const bson_iterator *i ) {
	const char *t = i->cur + 1;
	t += strlen( t ) + 1;
	return t;
}

/* types */

int bson_iterator_int_raw( const bson_iterator *i ) {
	int out;
	bson_little_endian32( &out, bson_iterator_value( i ) );
	return out;
}

double bson_iterator_double_raw( const bson_iterator *i ) {
	double out;
	bson_little_endian64( &out, bson_iterator_value( i ) );
	return out;
}

int64_t bson_iterator_long_raw( const bson_iterator *i ) {
	int64_t out;
	bson_little_endian64( &out, bson_iterator_value( i ) );
	return out;
}

bson_bool_t bson_iterator_bool_raw( const bson_iterator *i ) {
	return bson_iterator_value( i )[0];
}

bson_oid_t *bson_iterator_oid( const bson_iterator *i ) {
	return ( bson_oid_t * )bson_iterator_value( i );
}

int bson_iterator_int( const bson_iterator *i ) {
	switch ( bson_iterator_type( i ) ) {
	case BSON_INT:
		return bson_iterator_int_raw( i );
	case BSON_LONG:
		return bson_iterator_long_raw( i );
	case BSON_DOUBLE:
		return int(bson_iterator_double_raw( i ));
	default:
		return 0;
	}
}

double bson_iterator_double( const bson_iterator *i ) {
	switch ( bson_iterator_type( i ) ) {
	case BSON_INT:
		return bson_iterator_int_raw( i );
	case BSON_LONG:
		return double(bson_iterator_long_raw( i ));
	case BSON_DOUBLE:
		return bson_iterator_double_raw( i );
	default:
		return 0;
	}
}

int64_t bson_iterator_long( const bson_iterator *i ) {
	switch ( bson_iterator_type( i ) ) {
	case BSON_INT:
		return bson_iterator_int_raw( i );
	case BSON_LONG:
		return bson_iterator_long_raw( i );
	case BSON_DOUBLE:
		return int64_t(bson_iterator_double_raw( i ));
	default:
		return 0;
	}
}

bson_timestamp_t bson_iterator_timestamp( const bson_iterator *i ) {
	bson_timestamp_t ts;
	bson_little_endian32( &( ts.i ), bson_iterator_value( i ) );
	bson_little_endian32( &( ts.t ), bson_iterator_value( i ) + 4 );
	return ts;
}

bson_bool_t bson_iterator_bool( const bson_iterator *i ) {
	switch ( bson_iterator_type( i ) ) {
	case BSON_BOOL:
		return bson_iterator_bool_raw( i );
	case BSON_INT:
		return bson_iterator_int_raw( i ) != 0;
	case BSON_LONG:
		return bson_iterator_long_raw( i ) != 0;
	case BSON_DOUBLE:
		return bson_iterator_double_raw( i ) != 0;
	case BSON_EOO:
	case BSON_NULL:
		return 0;
	default:
		return 1;
	}
}

const char *bson_iterator_string( const bson_iterator *i ) {
	return bson_iterator_value( i ) + 4;
}

int bson_iterator_string_len( const bson_iterator *i ) {
	return bson_iterator_int_raw( i );
}

const char *bson_iterator_code( const bson_iterator *i ) {
	switch ( bson_iterator_type( i ) ) {
	case BSON_STRING:
	case BSON_CODE:
		return bson_iterator_value( i ) + 4;
	case BSON_CODEWSCOPE:
		return bson_iterator_value( i ) + 8;
	default:
		return nullptr;
	}
}

void bson_iterator_code_scope( const bson_iterator *i, bson *scope ) {
	if ( bson_iterator_type( i ) == BSON_CODEWSCOPE ) {
		int code_len;
		bson_little_endian32( &code_len, bson_iterator_value( i )+4 );
		bson_init_data( scope, (char*)((void *)(bson_iterator_value(i)+8+code_len )));
		_bson_reset( scope );
		scope->finished = 1;
	} else {
		bson_empty( scope );
	}
}

bson_date_t bson_iterator_date( const bson_iterator *i ) {
	return bson_iterator_long_raw( i );
}

time_t bson_iterator_time_t( const bson_iterator *i ) {
	return bson_iterator_date( i ) / 1000;
}

int bson_iterator_bin_len( const bson_iterator *i ) {
	return ( bson_iterator_bin_type( i ) == BSON_BIN_BINARY_OLD )
		   ? bson_iterator_int_raw( i ) - 4
		   : bson_iterator_int_raw( i );
}

char bson_iterator_bin_type( const bson_iterator *i ) {
	return bson_iterator_value( i )[4];
}

const char *bson_iterator_bin_data( const bson_iterator *i ) {
	return ( bson_iterator_bin_type( i ) == BSON_BIN_BINARY_OLD )
		   ? bson_iterator_value( i ) + 9
		   : bson_iterator_value( i ) + 5;
}

const char *bson_iterator_regex( const bson_iterator *i ) {
	return bson_iterator_value( i );
}

const char *bson_iterator_regex_opts( const bson_iterator *i ) {
	const char *p = bson_iterator_value( i );
	return p + strlen( p ) + 1;

}

void bson_iterator_subobject( const bson_iterator *i, bson *sub ) {
	bson_init_data( sub, ( char * )bson_iterator_value( i ) );
	_bson_reset( sub );
	sub->finished = 1;
}

void bson_iterator_subiterator( const bson_iterator *i, bson_iterator *sub ) {
	bson_iterator_from_buffer( sub, bson_iterator_value( i ) );
}

/* ----------------------------
   BUILDING
   ------------------------------ */

static void _bson_init_size( bson *b, int size ) {
	if( size == 0 )
		b->data = nullptr;
	else
		b->data = ( char * )bson_malloc( size );
	b->dataSize = size;
	b->cur = b->data + 4;
	_bson_reset( b );
}

void bson_init( bson *b ) {
	_bson_init_size( b, initialBufferSize );
}

void bson_init_size( bson *b, int size ) {
	_bson_init_size( b, size );
}

static void bson_append_byte( bson *b, char c ) {
	b->cur[0] = c;
	b->cur++;
}

static void bson_append( bson *b, const void *data, int len ) {
	memcpy( b->cur , data , len );
	b->cur += len;
}

static void bson_append32( bson *b, const void *data ) {
	bson_little_endian32( b->cur, data );
	b->cur += 4;
}

static void bson_append64( bson *b, const void *data ) {
	bson_little_endian64( b->cur, data );
	b->cur += 8;
}

int bson_ensure_space( bson *b, const int bytesNeeded ) {
	int pos = b->cur - b->data;
	char *orig = b->data;
	int new_size;

	if ( pos + bytesNeeded <= b->dataSize )
		return BSON_OK;

	new_size = int(1.5 * ( b->dataSize + bytesNeeded ));

	if( new_size < b->dataSize ) {
		if( ( b->dataSize + bytesNeeded ) < INT_MAX )
			new_size = INT_MAX;
		else {
			b->err = BSON_SIZE_OVERFLOW;
			return BSON_ERROR;
		}
	}

	b->data = (char*)bson_realloc( b->data, new_size );
	if ( !b->data )
		bson_fatal_msg( !!b->data, "realloc() failed" );

	b->dataSize = new_size;
	b->cur += b->data - orig;

	return BSON_OK;
}

int bson_finish( bson *b ) {
	int i;

	if( b->err & BSON_NOT_UTF8 )
		return BSON_ERROR;

	if ( ! b->finished ) {
		if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;
		bson_append_byte( b, 0 );
		i = b->cur - b->data;
		bson_little_endian32( b->data, &i );
		b->finished = 1;
	}

	return BSON_OK;
}

void bson_destroy( bson *b ) {
	if (b->data)
		bson_free( b->data );
	b->err = 0;
	b->data = nullptr;
	b->cur = nullptr;
	b->finished = 1;
}

static int bson_append_estart( bson *b, int type, const char *name, const int dataSize ) {
	const int len = strlen( name ) + 1;

	if ( b->finished ) {
		b->err |= BSON_ALREADY_FINISHED;
		return BSON_ERROR;
	}

	if ( bson_ensure_space( b, 1 + len + dataSize ) == BSON_ERROR ) {
		return BSON_ERROR;
	}

	if( bson_check_field_name( b, ( const char * )name, len - 1 ) == BSON_ERROR ) {
		bson_builder_error( b );
		return BSON_ERROR;
	}

	bson_append_byte( b, ( char )type );
	bson_append( b, name, len );
	return BSON_OK;
}

/* ----------------------------
   BUILDING TYPES
   ------------------------------ */

int bson_append_int( bson *b, const char *name, const int i ) {
	if ( bson_append_estart( b, BSON_INT, name, 4 ) == BSON_ERROR )
		return BSON_ERROR;
	bson_append32( b , &i );
	return BSON_OK;
}

int bson_append_long( bson *b, const char *name, const int64_t i ) {
	if ( bson_append_estart( b , BSON_LONG, name, 8 ) == BSON_ERROR )
		return BSON_ERROR;
	bson_append64( b , &i );
	return BSON_OK;
}

int bson_append_double( bson *b, const char *name, const double d ) {
	if ( bson_append_estart( b, BSON_DOUBLE, name, 8 ) == BSON_ERROR )
		return BSON_ERROR;
	bson_append64( b , &d );
	return BSON_OK;
}

int bson_append_bool( bson *b, const char *name, const bson_bool_t i ) {
	if ( bson_append_estart( b, BSON_BOOL, name, 1 ) == BSON_ERROR )
		return BSON_ERROR;
	bson_append_byte( b , i != 0 );
	return BSON_OK;
}

int bson_append_null( bson *b, const char *name ) {
	if ( bson_append_estart( b , BSON_NULL, name, 0 ) == BSON_ERROR )
		return BSON_ERROR;
	return BSON_OK;
}

int bson_append_undefined( bson *b, const char *name ) {
	if ( bson_append_estart( b, BSON_UNDEFINED, name, 0 ) == BSON_ERROR )
		return BSON_ERROR;
	return BSON_OK;
}

static int bson_append_string_base( bson *b, const char *name,
							 const char *value, int len, bson_type type ) {

	int sl = len + 1;
	if ( bson_check_string( b, ( const char * )value, sl - 1 ) == BSON_ERROR )
		return BSON_ERROR;
	if ( bson_append_estart( b, type, name, 4 + sl ) == BSON_ERROR ) {
		return BSON_ERROR;
	}
	bson_append32( b , &sl );
	bson_append( b , value , sl - 1 );
	bson_append( b , "\0" , 1 );
	return BSON_OK;
}

int bson_append_string( bson *b, const char *name, const char *value ) {
	return bson_append_string_base( b, name, value, strlen ( value ), BSON_STRING );
}

int bson_append_symbol( bson *b, const char *name, const char *value ) {
	return bson_append_string_base( b, name, value, strlen ( value ), BSON_SYMBOL );
}

int bson_append_code( bson *b, const char *name, const char *value ) {
	return bson_append_string_base( b, name, value, strlen ( value ), BSON_CODE );
}

int bson_append_string_n( bson *b, const char *name, const char *value, int len ) {
	return bson_append_string_base( b, name, value, len, BSON_STRING );
}

int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {
	return bson_append_string_base( b, name, value, len, BSON_SYMBOL );
}

int bson_append_code_n( bson *b, const char *name, const char *value, int len ) {
	return bson_append_string_base( b, name, value, len, BSON_CODE );
}

int bson_append_code_w_scope_n( bson *b, const char *name,
								const char *code, int len, const bson *scope ) {

	int sl = len + 1;
	int size = 4 + 4 + sl + bson_size( scope );
	if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )
		return BSON_ERROR;
	bson_append32( b, &size );
	bson_append32( b, &sl );
	bson_append( b, code, sl );
	bson_append( b, scope->data, bson_size( scope ) );
	return BSON_OK;
}

int bson_append_code_w_scope( bson *b, const char *name, const char *code, const bson *scope ) {
	return bson_append_code_w_scope_n( b, name, code, strlen ( code ), scope );
}

int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {
	if ( type == BSON_BIN_BINARY_OLD ) {
		int subtwolen = len + 4;
		if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )
			return BSON_ERROR;
		bson_append32( b, &subtwolen );
		bson_append_byte( b, type );
		bson_append32( b, &len );
		bson_append( b, str, len );
	} else {
		if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )
			return BSON_ERROR;
		bson_append32( b, &len );
		bson_append_byte( b, type );
		bson_append( b, str, len );
	}
	return BSON_OK;
}

int bson_append_oid( bson *b, const char *name, const bson_oid_t *oid ) {
	if ( bson_append_estart( b, BSON_OID, name, 12 ) == BSON_ERROR )
		return BSON_ERROR;
	bson_append( b , oid , 12 );
	return BSON_OK;
}

int bson_append_new_oid( bson *b, const char *name ) {
	bson_oid_t oid;
	bson_oid_gen( &oid );
	return bson_append_oid( b, name, &oid );
}

int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {
	const int plen = strlen( pattern )+1;
	const int olen = strlen( opts )+1;
	if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )
		return BSON_ERROR;
	if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )
		return BSON_ERROR;
	bson_append( b , pattern , plen );
	bson_append( b , opts , olen );
	return BSON_OK;
}

int bson_append_bson( bson *b, const char *name, const bson *bson ) {
	if ( bson_append_estart( b, BSON_OBJECT, name, bson_size( bson ) ) == BSON_ERROR )
		return BSON_ERROR;
	bson_append( b , bson->data , bson_size( bson ) );
	return BSON_OK;
}

int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {
	bson_iterator next = *elem;
	int size;

	bson_iterator_next( &next );
	size = next.cur - elem->cur;

	if ( name_or_null == nullptr ) {
		if( bson_ensure_space( b, size ) == BSON_ERROR )
			return BSON_ERROR;
		bson_append( b, elem->cur, size );
	} else {
		int data_size = size - 2 - strlen( bson_iterator_key( elem ) );
		bson_append_estart( b, elem->cur[0], name_or_null, data_size );
		bson_append( b, bson_iterator_value( elem ), data_size );
	}

	return BSON_OK;
}

int bson_append_timestamp( bson *b, const char *name, bson_timestamp_t *ts ) {
	if ( bson_append_estart( b, BSON_TIMESTAMP, name, 8 ) == BSON_ERROR ) return BSON_ERROR;

	bson_append32( b , &( ts->i ) );
	bson_append32( b , &( ts->t ) );

	return BSON_OK;
}

int bson_append_date( bson *b, const char *name, bson_date_t millis ) {
	if ( bson_append_estart( b, BSON_DATE, name, 8 ) == BSON_ERROR ) return BSON_ERROR;
	bson_append64( b , &millis );
	return BSON_OK;
}

int bson_append_time_t( bson *b, const char *name, time_t secs ) {
	return bson_append_date( b, name, ( bson_date_t )secs * 1000 );
}

int bson_append_start_object( bson *b, const char *name ) {
	if ( bson_append_estart( b, BSON_OBJECT, name, 5 ) == BSON_ERROR ) return BSON_ERROR;
	b->stack[ b->stackPos++ ] = b->cur - b->data;
	bson_append32( b , &zero );
	return BSON_OK;
}

int bson_append_start_array( bson *b, const char *name ) {
	if ( bson_append_estart( b, BSON_ARRAY, name, 5 ) == BSON_ERROR ) return BSON_ERROR;
	b->stack[ b->stackPos++ ] = b->cur - b->data;
	bson_append32( b , &zero );
	return BSON_OK;
}

int bson_append_finish_object( bson *b ) {
	char *start;
	int i;
	if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;
	bson_append_byte( b , 0 );

	start = b->data + b->stack[ --b->stackPos ];
	i = b->cur - start;
	bson_little_endian32( start, &i );

	return BSON_OK;
}

int bson_append_finish_array( bson *b ) {
	return bson_append_finish_object( b );
}


/* Error handling and allocators. */

static bson_err_handler err_handler = nullptr;

bson_err_handler set_bson_err_handler( bson_err_handler func ) {
	bson_err_handler old = err_handler;
	err_handler = func;
	return old;
}

void *bson_malloc( int size ) {
	void *p;
	p = bson_malloc_func( size );
	bson_fatal_msg( !!p, "malloc() failed" );
	return p;
}

void *bson_realloc( void *ptr, int size ) {
	void *p;
	p = bson_realloc_func( ptr, size );
	bson_fatal_msg( !!p, "realloc() failed" );
	return p;
}

int _bson_errprintf( const char *format, ... ) {
	va_list ap;
	int ret;
	va_start( ap, format );
	ret = vfprintf( stderr, format, ap );
	va_end( ap );

	return ret;
}

/**
 * This method is invoked when a non-fatal bson error is encountered.
 * Calls the error handler if available.
 *
 *  @param
 */
void bson_builder_error( bson *b ) {
	if( err_handler )
		err_handler( "BSON error." );
}

void bson_fatal( int ok ) {
	bson_fatal_msg( ok, "" );
}

void bson_fatal_msg( int ok , const char *msg ) {
	if ( ok )
		return;

	if ( err_handler ) {
		err_handler( msg );
	}

	bson_errprintf( "error: %s\n" , msg );
	abort();
}


/* Efficiently copy an integer to a string. */

void bson_numstr( char *str, int i ) {
	if( i < 1000 )
		memcpy( str, bson_numstrs[i], 4 );
	else
		bson_sprintf( str,"%d", i );
}

/* encoding.c */

/*
 * Copyright 2009-2011 10gen, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions Copyright 2001 Unicode, Inc.
 *
 * Disclaimer
 *
 * This source code is provided as is by Unicode, Inc. No claims are
 * made as to fitness for any particular purpose. No warranties of any
 * kind are expressed or implied. The recipient agrees to determine
 * applicability of information provided. If this file has been
 * purchased on magnetic or optical media from Unicode, Inc., the
 * sole remedy for any claim will be exchange of defective media
 * within 90 days of receipt.
 *
 * Limitations on Rights to Redistribute This Code
 *
 * Unicode, Inc. hereby grants the right to freely use the information
 * supplied in this file in the creation of products supporting the
 * Unicode Standard, and to make copies of this file in any form
 * for internal or external distribution as long as this notice
 * remains attached.
 */

/*
 * Index into the table below with the first byte of a UTF-8 sequence to
 * get the number of trailing bytes that are supposed to follow it.
 */
static const char trailingBytesForUTF8[256] = {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
};

/* --------------------------------------------------------------------- */

/*
 * Utility routine to tell whether a sequence of bytes is legal UTF-8.
 * This must be called with the length pre-determined by the first byte.
 * The length can be set by:
 *  length = trailingBytesForUTF8[*source]+1;
 * and the sequence is illegal right away if there aren't that many bytes
 * available.
 * If presented with a length > 4, this returns 0.  The Unicode
 * definition of UTF-8 goes up to 4-byte sequences.
 */
static int isLegalUTF8( const unsigned char *source, int length ) {
	unsigned char a;
	const unsigned char *srcptr = source + length;
	switch ( length ) {
	default:
		return 0;
		/* Everything else falls through when "true"... */
	case 4:
		if ( ( a = ( *--srcptr ) ) < 0x80 || a > 0xBF ) return 0;
	case 3:
		if ( ( a = ( *--srcptr ) ) < 0x80 || a > 0xBF ) return 0;
	case 2:
		if ( ( a = ( *--srcptr ) ) > 0xBF ) return 0;
		switch ( *source ) {
			/* no fall-through in this inner switch */
		case 0xE0:
			if ( a < 0xA0 ) return 0;
			break;
		case 0xF0:
			if ( a < 0x90 ) return 0;
			break;
		case 0xF4:
			if ( a > 0x8F ) return 0;
			break;
		default:
			if ( a < 0x80 ) return 0;
		}
	case 1:
		if ( *source >= 0x80 && *source < 0xC2 ) return 0;
		if ( *source > 0xF4 ) return 0;
	}
	return 1;
}

static int bson_validate_string( bson *b, const unsigned char *string,
                                 const int length, const char check_utf8, const char check_dot,
                                 const char check_dollar ) {

	int position = 0;
	int sequence_length = 1;

	if( check_dollar && string[0] == '$' ) {
		b->err |= BSON_FIELD_INIT_DOLLAR;
	}

	while ( position < length ) {
		if ( check_dot && *( string + position ) == '.' ) {
			b->err |= BSON_FIELD_HAS_DOT;
		}

		if ( check_utf8 ) {
			sequence_length = trailingBytesForUTF8[*( string + position )] + 1;
			if ( ( position + sequence_length ) > length ) {
				b->err |= BSON_NOT_UTF8;
				return BSON_ERROR;
			}
			if ( !isLegalUTF8( string + position, sequence_length ) ) {
				b->err |= BSON_NOT_UTF8;
				return BSON_ERROR;
			}
		}
		position += sequence_length;
	}

	return BSON_OK;
}


int bson_check_string( bson *b, const char *string,
                       const int length ) {

	return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}

int bson_check_field_name( bson *b, const char *string,
                           const int length ) {

	return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );
}


=== src\bson\BSON.h ===

/**
 * @file bson.h
 * @brief BSON Declarations
 */

/*    Copyright 2009-2011 10gen Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

#pragma once
#include <ctime>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <cstdarg>
#include <climits>
#include <cstdint>

constexpr int BSON_OK = 0;
constexpr int BSON_ERROR = -1;

static const char bson_numstrs[1000][4] = {
	"0",  "1",  "2",  "3",  "4",  "5",  "6",  "7",  "8",  "9",
	"10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
	"20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
	"30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
	"40", "41", "42", "43", "44", "45", "46", "47", "48", "49",
	"50", "51", "52", "53", "54", "55", "56", "57", "58", "59",
	"60", "61", "62", "63", "64", "65", "66", "67", "68", "69",
	"70", "71", "72", "73", "74", "75", "76", "77", "78", "79",
	"80", "81", "82", "83", "84", "85", "86", "87", "88", "89",
	"90", "91", "92", "93", "94", "95", "96", "97", "98", "99",

	"100", "101", "102", "103", "104", "105", "106", "107", "108", "109",
	"110", "111", "112", "113", "114", "115", "116", "117", "118", "119",
	"120", "121", "122", "123", "124", "125", "126", "127", "128", "129",
	"130", "131", "132", "133", "134", "135", "136", "137", "138", "139",
	"140", "141", "142", "143", "144", "145", "146", "147", "148", "149",
	"150", "151", "152", "153", "154", "155", "156", "157", "158", "159",
	"160", "161", "162", "163", "164", "165", "166", "167", "168", "169",
	"170", "171", "172", "173", "174", "175", "176", "177", "178", "179",
	"180", "181", "182", "183", "184", "185", "186", "187", "188", "189",
	"190", "191", "192", "193", "194", "195", "196", "197", "198", "199",

	"200", "201", "202", "203", "204", "205", "206", "207", "208", "209",
	"210", "211", "212", "213", "214", "215", "216", "217", "218", "219",
	"220", "221", "222", "223", "224", "225", "226", "227", "228", "229",
	"230", "231", "232", "233", "234", "235", "236", "237", "238", "239",
	"240", "241", "242", "243", "244", "245", "246", "247", "248", "249",
	"250", "251", "252", "253", "254", "255", "256", "257", "258", "259",
	"260", "261", "262", "263", "264", "265", "266", "267", "268", "269",
	"270", "271", "272", "273", "274", "275", "276", "277", "278", "279",
	"280", "281", "282", "283", "284", "285", "286", "287", "288", "289",
	"290", "291", "292", "293", "294", "295", "296", "297", "298", "299",

	"300", "301", "302", "303", "304", "305", "306", "307", "308", "309",
	"310", "311", "312", "313", "314", "315", "316", "317", "318", "319",
	"320", "321", "322", "323", "324", "325", "326", "327", "328", "329",
	"330", "331", "332", "333", "334", "335", "336", "337", "338", "339",
	"340", "341", "342", "343", "344", "345", "346", "347", "348", "349",
	"350", "351", "352", "353", "354", "355", "356", "357", "358", "359",
	"360", "361", "362", "363", "364", "365", "366", "367", "368", "369",
	"370", "371", "372", "373", "374", "375", "376", "377", "378", "379",
	"380", "381", "382", "383", "384", "385", "386", "387", "388", "389",
	"390", "391", "392", "393", "394", "395", "396", "397", "398", "399",

	"400", "401", "402", "403", "404", "405", "406", "407", "408", "409",
	"410", "411", "412", "413", "414", "415", "416", "417", "418", "419",
	"420", "421", "422", "423", "424", "425", "426", "427", "428", "429",
	"430", "431", "432", "433", "434", "435", "436", "437", "438", "439",
	"440", "441", "442", "443", "444", "445", "446", "447", "448", "449",
	"450", "451", "452", "453", "454", "455", "456", "457", "458", "459",
	"460", "461", "462", "463", "464", "465", "466", "467", "468", "469",
	"470", "471", "472", "473", "474", "475", "476", "477", "478", "479",
	"480", "481", "482", "483", "484", "485", "486", "487", "488", "489",
	"490", "491", "492", "493", "494", "495", "496", "497", "498", "499",

	"500", "501", "502", "503", "504", "505", "506", "507", "508", "509",
	"510", "511", "512", "513", "514", "515", "516", "517", "518", "519",
	"520", "521", "522", "523", "524", "525", "526", "527", "528", "529",
	"530", "531", "532", "533", "534", "535", "536", "537", "538", "539",
	"540", "541", "542", "543", "544", "545", "546", "547", "548", "549",
	"550", "551", "552", "553", "554", "555", "556", "557", "558", "559",
	"560", "561", "562", "563", "564", "565", "566", "567", "568", "569",
	"570", "571", "572", "573", "574", "575", "576", "577", "578", "579",
	"580", "581", "582", "583", "584", "585", "586", "587", "588", "589",
	"590", "591", "592", "593", "594", "595", "596", "597", "598", "599",

	"600", "601", "602", "603", "604", "605", "606", "607", "608", "609",
	"610", "611", "612", "613", "614", "615", "616", "617", "618", "619",
	"620", "621", "622", "623", "624", "625", "626", "627", "628", "629",
	"630", "631", "632", "633", "634", "635", "636", "637", "638", "639",
	"640", "641", "642", "643", "644", "645", "646", "647", "648", "649",
	"650", "651", "652", "653", "654", "655", "656", "657", "658", "659",
	"660", "661", "662", "663", "664", "665", "666", "667", "668", "669",
	"670", "671", "672", "673", "674", "675", "676", "677", "678", "679",
	"680", "681", "682", "683", "684", "685", "686", "687", "688", "689",
	"690", "691", "692", "693", "694", "695", "696", "697", "698", "699",

	"700", "701", "702", "703", "704", "705", "706", "707", "708", "709",
	"710", "711", "712", "713", "714", "715", "716", "717", "718", "719",
	"720", "721", "722", "723", "724", "725", "726", "727", "728", "729",
	"730", "731", "732", "733", "734", "735", "736", "737", "738", "739",
	"740", "741", "742", "743", "744", "745", "746", "747", "748", "749",
	"750", "751", "752", "753", "754", "755", "756", "757", "758", "759",
	"760", "761", "762", "763", "764", "765", "766", "767", "768", "769",
	"770", "771", "772", "773", "774", "775", "776", "777", "778", "779",
	"780", "781", "782", "783", "784", "785", "786", "787", "788", "789",
	"790", "791", "792", "793", "794", "795", "796", "797", "798", "799",

	"800", "801", "802", "803", "804", "805", "806", "807", "808", "809",
	"810", "811", "812", "813", "814", "815", "816", "817", "818", "819",
	"820", "821", "822", "823", "824", "825", "826", "827", "828", "829",
	"830", "831", "832", "833", "834", "835", "836", "837", "838", "839",
	"840", "841", "842", "843", "844", "845", "846", "847", "848", "849",
	"850", "851", "852", "853", "854", "855", "856", "857", "858", "859",
	"860", "861", "862", "863", "864", "865", "866", "867", "868", "869",
	"870", "871", "872", "873", "874", "875", "876", "877", "878", "879",
	"880", "881", "882", "883", "884", "885", "886", "887", "888", "889",
	"890", "891", "892", "893", "894", "895", "896", "897", "898", "899",

	"900", "901", "902", "903", "904", "905", "906", "907", "908", "909",
	"910", "911", "912", "913", "914", "915", "916", "917", "918", "919",
	"920", "921", "922", "923", "924", "925", "926", "927", "928", "929",
	"930", "931", "932", "933", "934", "935", "936", "937", "938", "939",
	"940", "941", "942", "943", "944", "945", "946", "947", "948", "949",
	"950", "951", "952", "953", "954", "955", "956", "957", "958", "959",
	"960", "961", "962", "963", "964", "965", "966", "967", "968", "969",
	"970", "971", "972", "973", "974", "975", "976", "977", "978", "979",
	"980", "981", "982", "983", "984", "985", "986", "987", "988", "989",
	"990", "991", "992", "993", "994", "995", "996", "997", "998", "999",
};

enum bson_error_t {
	BSON_SIZE_OVERFLOW = 1 /**< Trying to create a BSON object larger than INT_MAX. */
};

enum bson_validity_t {
	BSON_VALID = 0,				 /**< BSON is valid and UTF-8 compliant. */
	BSON_NOT_UTF8 = ( 1<<1 ),	   /**< A key or a string is not valid UTF-8. */
	BSON_FIELD_HAS_DOT = ( 1<<2 ),  /**< Warning: key contains '.' character. */
	BSON_FIELD_INIT_DOLLAR = ( 1<<3 ), /**< Warning: key starts with '$' character. */
	BSON_ALREADY_FINISHED = ( 1<<4 )  /**< Trying to modify a finished BSON object. */
};

enum bson_binary_subtype_t {
	BSON_BIN_BINARY = 0,
	BSON_BIN_FUNC = 1,
	BSON_BIN_BINARY_OLD = 2,
	BSON_BIN_UUID = 3,
	BSON_BIN_MD5 = 5,
	BSON_BIN_USER = 128
};

typedef enum {
	BSON_EOO = 0,
	BSON_DOUBLE = 1,
	BSON_STRING = 2,
	BSON_OBJECT = 3,
	BSON_ARRAY = 4,
	BSON_BINDATA = 5,
	BSON_UNDEFINED = 6,
	BSON_OID = 7,
	BSON_BOOL = 8,
	BSON_DATE = 9,
	BSON_NULL = 10,
	BSON_REGEX = 11,
	BSON_DBREF = 12, /**< Deprecated. */
	BSON_CODE = 13,
	BSON_SYMBOL = 14,
	BSON_CODEWSCOPE = 15,
	BSON_INT = 16,
	BSON_TIMESTAMP = 17,
	BSON_LONG = 18
} bson_type;

typedef int bson_bool_t;

typedef struct {
	const char *cur;
	bson_bool_t first;
	const char *last;
} bson_iterator;

typedef struct {
	char *data;
	char *cur;
	int dataSize;
	bson_bool_t finished;
	int stack[32];
	int stackPos;
	int err; /**< Bitfield representing errors or warnings on this buffer */
	char *errstr; /**< A string representation of the most recent error or warning. */
} bson;

#pragma pack(1)
typedef union {
	char bytes[12];
	int ints[3];
} bson_oid_t;
#pragma pack()

typedef int64_t bson_date_t; /* milliseconds since epoch UTC */

typedef struct {
	int i; /* increment */
	int t; /* time in seconds */
} bson_timestamp_t;

/* ----------------------------
   READING
   ------------------------------ */

/**
 * Size of a BSON object.
 *
 * @param b the BSON object.
 *
 * @return the size.
 */
int bson_size( const bson *b );

/**
 * Print a string representation of a BSON object.
 *
 * @param b the BSON object to print.
 */
void bson_print( bson *b );

/**
 * Return a pointer to the raw buffer stored by this bson object.
 *
 * @param b a BSON object
 */
const char *bson_data( bson *b );

/**
 * Print a string representation of a BSON object.
 *
 * @param bson the raw data to print.
 * @param depth the depth to recurse the object.x
 */
void bson_print_raw( const char *bson , int depth );

/**
 * Advance a bson_iterator to the named field.
 *
 * @param it the bson_iterator to use.
 * @param obj the BSON object to use.
 * @param name the name of the field to find.
 *
 * @return the type of the found object or BSON_EOO if it is not found.
 */
bson_type bson_find( bson_iterator *it, const bson *obj, const char *name );

/**
 * Initialize a bson_iterator.
 *
 * @param i the bson_iterator to initialize.
 * @param bson the BSON object to associate with the iterator.
 */
void bson_iterator_init( bson_iterator *i , const bson *b );

/**
 * Initialize a bson iterator from a const char* buffer. Note
 * that this is mostly used internally.
 *
 * @param i the bson_iterator to initialize.
 * @param buffer the buffer to point to.
 */
void bson_iterator_from_buffer( bson_iterator *i, const char *buffer );

/* more returns true for eoo. best to loop with bson_iterator_next(&it) */
/**
 * Check to see if the bson_iterator has more data.
 *
 * @param i the iterator.
 *
 * @return  returns true if there is more data.
 */
bson_bool_t bson_iterator_more( const bson_iterator *i );

/**
 * Point the iterator at the next BSON object.
 *
 * @param i the bson_iterator.
 *
 * @return the type of the next BSON object.
 */
bson_type bson_iterator_next( bson_iterator *i );

/**
 * Get the type of the BSON object currently pointed to by the iterator.
 *
 * @param i the bson_iterator
 *
 * @return  the type of the current BSON object.
 */
bson_type bson_iterator_type( const bson_iterator *i );

/**
 * Get the key of the BSON object currently pointed to by the iterator.
 *
 * @param i the bson_iterator
 *
 * @return the key of the current BSON object.
 */
const char *bson_iterator_key( const bson_iterator *i );

/**
 * Get the value of the BSON object currently pointed to by the iterator.
 *
 * @param i the bson_iterator
 *
 * @return  the value of the current BSON object.
 */
const char *bson_iterator_value( const bson_iterator *i );

/* these convert to the right type (return 0 if non-numeric) */
/**
 * Get the double value of the BSON object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return  the value of the current BSON object.
 */
double bson_iterator_double( const bson_iterator *i );

/**
 * Get the int value of the BSON object currently pointed to by the iterator.
 *
 * @param i the bson_iterator
 *
 * @return  the value of the current BSON object.
 */
int bson_iterator_int( const bson_iterator *i );

/**
 * Get the long value of the BSON object currently pointed to by the iterator.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
int64_t bson_iterator_long( const bson_iterator *i );

/* return the bson timestamp as a whole or in parts */
/**
 * Get the timestamp value of the BSON object currently pointed to by
 * the iterator.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
bson_timestamp_t bson_iterator_timestamp( const bson_iterator *i );

/**
 * Get the boolean value of the BSON object currently pointed to by
 * the iterator.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
/* false: boolean false, 0 in any type, or null */
/* true: anything else (even empty strings and objects) */
bson_bool_t bson_iterator_bool( const bson_iterator *i );

/**
 * Get the double value of the BSON object currently pointed to by the
 * iterator. Assumes the correct type is used.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
/* these assume you are using the right type */
double bson_iterator_double_raw( const bson_iterator *i );

/**
 * Get the int value of the BSON object currently pointed to by the
 * iterator. Assumes the correct type is used.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
int bson_iterator_int_raw( const bson_iterator *i );

/**
 * Get the long value of the BSON object currently pointed to by the
 * iterator. Assumes the correct type is used.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
int64_t bson_iterator_long_raw( const bson_iterator *i );

/**
 * Get the bson_bool_t value of the BSON object currently pointed to by the
 * iterator. Assumes the correct type is used.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
bson_bool_t bson_iterator_bool_raw( const bson_iterator *i );

/**
 * Get the bson_oid_t value of the BSON object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
bson_oid_t *bson_iterator_oid( const bson_iterator *i );

/**
 * Get the string value of the BSON object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return  the value of the current BSON object.
 */
/* these can also be used with bson_code and bson_symbol*/
const char *bson_iterator_string( const bson_iterator *i );

/**
 * Get the string length of the BSON object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the length of the current BSON object.
 */
int bson_iterator_string_len( const bson_iterator *i );

/**
 * Get the code value of the BSON object currently pointed to by the
 * iterator. Works with bson_code, bson_codewscope, and BSON_STRING
 * returns NULL for everything else.
 *
 * @param i the bson_iterator
 *
 * @return the code value of the current BSON object.
 */
/* works with bson_code, bson_codewscope, and BSON_STRING */
/* returns NULL for everything else */
const char *bson_iterator_code( const bson_iterator *i );

/**
 * Calls bson_empty on scope if not a bson_codewscope
 *
 * @param i the bson_iterator.
 * @param scope the bson scope.
 */
/* calls bson_empty on scope if not a bson_codewscope */
void bson_iterator_code_scope( const bson_iterator *i, bson *scope );

/**
 * Get the date value of the BSON object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the date value of the current BSON object.
 */
/* both of these only work with bson_date */
bson_date_t bson_iterator_date( const bson_iterator *i );

/**
 * Get the time value of the BSON object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the time value of the current BSON object.
 */
time_t bson_iterator_time_t( const bson_iterator *i );

/**
 * Get the length of the BSON binary object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the length of the current BSON binary object.
 */
int bson_iterator_bin_len( const bson_iterator *i );

/**
 * Get the type of the BSON binary object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the type of the current BSON binary object.
 */
char bson_iterator_bin_type( const bson_iterator *i );

/**
 * Get the value of the BSON binary object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON binary object.
 */
const char *bson_iterator_bin_data( const bson_iterator *i );

/**
 * Get the value of the BSON regex object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON regex object.
 */
const char *bson_iterator_regex( const bson_iterator *i );

/**
 * Get the options of the BSON regex object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator.
 *
 * @return the options of the current BSON regex object.
 */
const char *bson_iterator_regex_opts( const bson_iterator *i );

/* these work with BSON_OBJECT and BSON_ARRAY */
/**
 * Get the BSON subobject currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator.
 * @param sub the BSON subobject destination.
 */
void bson_iterator_subobject( const bson_iterator *i, bson *sub );

/**
 * Get a bson_iterator that on the BSON subobject.
 *
 * @param i the bson_iterator.
 * @param sub the iterator to point at the BSON subobject.
 */
void bson_iterator_subiterator( const bson_iterator *i, bson_iterator *sub );

/* str must be at least 24 hex chars + null byte */
/**
 * Create a bson_oid_t from a string.
 *
 * @param oid the bson_oid_t destination.
 * @param str a null terminated string comprised of at least 24 hex chars.
 */
void bson_oid_from_string( bson_oid_t *oid, const char *str );

/**
 * Create a string representation of the bson_oid_t.
 *
 * @param oid the bson_oid_t source.
 * @param str the string representation destination.
 */
void bson_oid_to_string( const bson_oid_t *oid, char *str );

/**
 * Create a bson_oid object.
 *
 * @param oid the destination for the newly created bson_oid_t.
 */
void bson_oid_gen( bson_oid_t *oid );

/**
 * Set a function to be used to generate the second four bytes
 * of an object id.
 *
 * @param func a pointer to a function that returns an int.
 */
void bson_set_oid_fuzz( int ( *func )( void ) );

/**
 * Set a function to be used to generate the incrementing part
 * of an object id (last four bytes). If you need thread-safety
 * in generating object ids, you should set this function.
 *
 * @param func a pointer to a function that returns an int.
 */
void bson_set_oid_inc( int ( *func )( void ) );

/**
 * Get the time a bson_oid_t was created.
 *
 * @param oid the bson_oid_t.
 */
time_t bson_oid_generated_time( bson_oid_t *oid ); /* Gives the time the OID was created */

/* ----------------------------
   BUILDING
   ------------------------------ */

/**
 *  Initialize a new bson object. If not created
 *  with bson_new, you must initialize each new bson
 *  object using this function.
 *
 *  @note When finished, you must pass the bson object to
 *      bson_destroy( ).
 */
void bson_init( bson *b );

/**
 * Initialize a BSON object, and point its data
 * pointer to the provided char*.
 *
 * @param b the BSON object to initialize.
 * @param data the raw BSON data.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_init_data( bson *b , char *data );


/**
 * Initialize a BSON object, point its data pointer
 * to the provided char*, and initialize the size
 *
 * @param b the BSON object to initialize.
 * @param data the raw BSON data.
 * @param size the size of the BSON data.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_init_data_size( bson *b , char *data , int size );

/**
 * Initialize a BSON object, and point its data
 * pointer to the provided char*. We assume
 * that the data represents a finished BSON object.
 *
 * @param b the BSON object to initialize.
 * @param data the raw BSON data.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_init_finished_data( bson *b, char *data );

/**
 * Initialize a BSON object, and set its
 * buffer to the given size.
 *
 * @param b the BSON object to initialize.
 * @param size the initial size of the buffer.
 *
 * @return BSON_OK or BSON_ERROR.
 */
void bson_init_size( bson *b, int size );

/**
 * Grow a bson object.
 *
 * @param b the bson to grow.
 * @param bytesNeeded the additional number of bytes needed.
 *
 * @return BSON_OK or BSON_ERROR with the bson error object set.
 *   Exits if allocation fails.
 */
int bson_ensure_space( bson *b, const int bytesNeeded );

/**
 * Finalize a bson object.
 *
 * @param b the bson object to finalize.
 *
 * @return the standard error code. To deallocate memory,
 *   call bson_destroy on the bson object.
 */
int bson_finish( bson *b );

/**
 * Destroy a bson object.
 *
 * @param b the bson object to destroy.
 *
 */
void bson_destroy( bson *b );

/**
 * Returns a pointer to a static empty BSON object.
 *
 * @param obj the BSON object to initialize.
 *
 * @return the empty initialized BSON object.
 */
/* returns pointer to static empty bson object */
bson *bson_empty( bson *obj );

/**
 * Make a complete copy of the a BSON object.
 * The source bson object must be in a finished
 * state; otherwise, the copy will fail.
 *
 * @param out the copy destination BSON object.
 * @param in the copy source BSON object.
 */
int bson_copy( bson *out, const bson *in ); /* puts data in new buffer. NOOP if out==NULL */

/**
 * Append a previously created bson_oid_t to a bson object.
 *
 * @param b the bson to append to.
 * @param name the key for the bson_oid_t.
 * @param oid the bson_oid_t to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_oid( bson *b, const char *name, const bson_oid_t *oid );

/**
 * Append a bson_oid_t to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the bson_oid_t.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_new_oid( bson *b, const char *name );

/**
 * Append an int to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the int.
 * @param i the int to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_int( bson *b, const char *name, const int i );

/**
 * Append an long to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the long.
 * @param i the long to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_long( bson *b, const char *name, const int64_t i );

/**
 * Append an double to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the double.
 * @param d the double to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_double( bson *b, const char *name, const double d );

/**
 * Append a string to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the string.
 * @param str the string to append.
 *
 * @return BSON_OK or BSON_ERROR.
*/
int bson_append_string( bson *b, const char *name, const char *str );

/**
 * Append len bytes of a string to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the string.
 * @param str the string to append.
 * @param len the number of bytes from str to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_string_n( bson *b, const char *name, const char *str, int len );

/**
 * Append a symbol to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the symbol.
 * @param str the symbol to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_symbol( bson *b, const char *name, const char *str );

/**
 * Append len bytes of a symbol to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the symbol.
 * @param str the symbol to append.
 * @param len the number of bytes from str to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_symbol_n( bson *b, const char *name, const char *str, int len );

/**
 * Append code to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the code.
 * @param str the code to append.
 * @param len the number of bytes from str to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_code( bson *b, const char *name, const char *str );

/**
 * Append len bytes of code to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the code.
 * @param str the code to append.
 * @param len the number of bytes from str to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_code_n( bson *b, const char *name, const char *str, int len );

/**
 * Append code to a bson with scope.
 *
 * @param b the bson to append to.
 * @param name the key for the code.
 * @param str the string to append.
 * @param scope a BSON object containing the scope.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_code_w_scope( bson *b, const char *name, const char *code, const bson *scope );

/**
 * Append len bytes of code to a bson with scope.
 *
 * @param b the bson to append to.
 * @param name the key for the code.
 * @param str the string to append.
 * @param len the number of bytes from str to append.
 * @param scope a BSON object containing the scope.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_code_w_scope_n( bson *b, const char *name, const char *code, int size, const bson *scope );

/**
 * Append binary data to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the data.
 * @param type the binary data type.
 * @param str the binary data.
 * @param len the length of the data.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_binary( bson *b, const char *name, char type, const char *str, int len );

/**
 * Append a bson_bool_t to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the boolean value.
 * @param v the bson_bool_t to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_bool( bson *b, const char *name, const bson_bool_t v );

/**
 * Append a null value to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the null value.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_null( bson *b, const char *name );

/**
 * Append an undefined value to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the undefined value.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_undefined( bson *b, const char *name );

/**
 * Append a regex value to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the regex value.
 * @param pattern the regex pattern to append.
 * @param the regex options.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts );

/**
 * Append bson data to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the bson data.
 * @param bson the bson object to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_bson( bson *b, const char *name, const bson *bson );

/**
 * Append a BSON element to a bson from the current point of an iterator.
 *
 * @param b the bson to append to.
 * @param name_or_null the key for the BSON element, or NULL.
 * @param elem the bson_iterator.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem );

/**
 * Append a bson_timestamp_t value to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the timestampe value.
 * @param ts the bson_timestamp_t value to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_timestamp( bson *b, const char *name, bson_timestamp_t *ts );

/* these both append a bson_date */
/**
 * Append a bson_date_t value to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the date value.
 * @param millis the bson_date_t to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_date( bson *b, const char *name, bson_date_t millis );

/**
 * Append a time_t value to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the date value.
 * @param secs the time_t to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_time_t( bson *b, const char *name, time_t secs );

/**
 * Start appending a new object to a bson.
 *
 * @param b the bson to append to.
 * @param name the name of the new object.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_start_object( bson *b, const char *name );

/**
 * Start appending a new array to a bson.
 *
 * @param b the bson to append to.
 * @param name the name of the new array.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_start_array( bson *b, const char *name );

/**
 * Finish appending a new object or array to a bson.
 *
 * @param b the bson to append to.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_finish_object( bson *b );

/**
 * Finish appending a new object or array to a bson. This
 * is simply an alias for bson_append_finish_object.
 *
 * @param b the bson to append to.
 *
 * @return BSON_OK or BSON_ERROR.
 */
int bson_append_finish_array( bson *b );

void bson_numstr( char *str, int i );

void bson_incnumstr( char *str );

/* Error handling and stadard library function over-riding. */
/* -------------------------------------------------------- */

/* bson_err_handlers shouldn't return!!! */
typedef void( *bson_err_handler )( const char *errmsg );

typedef int (*bson_printf_func)( const char *, ... );
typedef int (*bson_fprintf_func)( FILE *, const char *, ... );
typedef int (*bson_sprintf_func)( char *, const char *, ... );

extern void *( *bson_malloc_func )( size_t );
extern void *( *bson_realloc_func )( void *, size_t );
extern void ( *bson_free )( void * );

extern bson_printf_func bson_printf;
extern bson_fprintf_func bson_fprintf;
extern bson_sprintf_func bson_sprintf;

extern bson_printf_func bson_errprintf;

/**
 * Allocates memory and checks return value, exiting fatally if malloc() fails.
 *
 * @param size bytes to allocate.
 *
 * @return a pointer to the allocated memory.
 *
 * @sa malloc(3)
 */
void *bson_malloc( int size );

/**
 * Changes the size of allocated memory and checks return value,
 * exiting fatally if realloc() fails.
 *
 * @param ptr pointer to the space to reallocate.
 * @param size bytes to allocate.
 *
 * @return a pointer to the allocated memory.
 *
 * @sa realloc()
 */
void *bson_realloc( void *ptr, int size );

/**
 * Set a function for error handling.
 *
 * @param func a bson_err_handler function.
 *
 * @return the old error handling function, or NULL.
 */
bson_err_handler set_bson_err_handler( bson_err_handler func );

/* does nothing if ok != 0 */
/**
 * Exit fatally.
 *
 * @param ok exits if ok is equal to 0.
 */
void bson_fatal( int ok );

/**
 * Exit fatally with an error message.
  *
 * @param ok exits if ok is equal to 0.
 * @param msg prints to stderr before exiting.
 */
void bson_fatal_msg( int ok, const char *msg );

/**
 * Invoke the error handler, but do not exit.
 *
 * @param b the buffer object.
 */
void bson_builder_error( bson *b );

/* encoding.h */

/*
 * Copyright 2009-2011 10gen, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check that a field name is valid UTF8, does not start with a '$',
 * and contains no '.' characters. Set bson bit field appropriately.
 * Note that we don't need to check for '\0' because we're using
 * strlen(3), which stops at '\0'.
 *
 * @param b The bson object to which field name will be appended.
 * @param string The field name as char*.
 * @param length The length of the field name.
 *
 * @return BSON_OK if valid UTF8 and BSON_ERROR if not. All BSON strings must be
 *     valid UTF8. This function will also check whether the string
 *     contains '.' or starts with '$', since the validity of this depends on context.
 *     Set the value of b->err appropriately.
 */
int bson_check_field_name( bson *b, const char *string,
                           const int length );

/**
 * Check that a string is valid UTF8. Sets the buffer bit field appropriately.
 *
 * @param b The bson object to which string will be appended.
 * @param string The string to check.
 * @param length The length of the string.
 *
 * @return BSON_OK if valid UTF-8; otherwise, BSON_ERROR.
 *     Sets b->err on error.
 */
bson_bool_t bson_check_string( bson *b, const char *string,
                               const int length );

/* platform.h */

/**    Copyright 2009-2011 10gen Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */


/* all platform-specific ifdefs should go here */

/* big endian is only used for OID generation. little is used everywhere else */
//#ifdef BIG_ENDIAN
//#define bson_little_endian64(out, in) ( bson_swap_endian64(out, in) )
//#define bson_little_endian32(out, in) ( bson_swap_endian32(out, in) )
//#define bson_big_endian64(out, in) ( memcpy(out, in, 8) )
//#define bson_big_endian32(out, in) ( memcpy(out, in, 4) )
//#else
#define bson_little_endian64(out, in) ( memcpy(out, in, 8) )
#define bson_little_endian32(out, in) ( memcpy(out, in, 4) )
#define bson_big_endian64(out, in) ( bson_swap_endian64(out, in) )
#define bson_big_endian32(out, in) ( bson_swap_endian32(out, in) )
//#endif

static inline void bson_swap_endian64( void *outp, const void *inp ) {
	const char *in = ( const char * )inp;
	char *out = ( char * )outp;

	out[0] = in[7];
	out[1] = in[6];
	out[2] = in[5];
	out[3] = in[4];
	out[4] = in[3];
	out[5] = in[2];
	out[6] = in[1];
	out[7] = in[0];

}
static inline void bson_swap_endian32( void *outp, const void *inp ) {
	const char *in = ( const char * )inp;
	char *out = ( char * )outp;

	out[0] = in[3];
	out[1] = in[2];
	out[2] = in[1];
	out[3] = in[0];
}


=== src\bson\meson.build ===

common_files += files(
	'BSON.cpp',
)


=== src\bzip2\bz2wrap.cpp ===

#include "bz2wrap.h"
#include "bzlib.h"
#include <memory>
#include <functional>
#include <vector>
#include <algorithm>

static size_t outputSizeIncrement = 0x100000U;

BZ2WCompressResult BZ2WCompress(std::vector<char> &dest, std::span<const char> srcData, size_t maxSize)
{
	bz_stream stream;
	stream.bzalloc = nullptr;
	stream.bzfree = nullptr;
	stream.opaque = nullptr;
	if (BZ2_bzCompressInit(&stream, 9, 0, 0) != BZ_OK)
	{
		return BZ2WCompressNomem;
	}
	std::unique_ptr<bz_stream, std::function<int (bz_stream *)>> bz2Data(&stream, BZ2_bzCompressEnd);
	stream.next_in = const_cast<char *>(srcData.data()); // I hope bz2 doesn't actually write anything here...
	stream.avail_in = srcData.size();
	dest.resize(0);
	bool done = false;
	while (!done)
	{
		size_t oldSize = dest.size();
		size_t newSize = oldSize + outputSizeIncrement;
		if (maxSize && newSize > maxSize)
		{
			newSize = maxSize;
		}
		if (oldSize == newSize)
		{
			return BZ2WCompressLimit;
		}
		try
		{
			dest.resize(newSize);
		}
		catch (const std::bad_alloc &)
		{
			return BZ2WCompressNomem;
		}
		stream.next_out = &dest[stream.total_out_lo32];
		stream.avail_out = dest.size() - stream.total_out_lo32;
		if (BZ2_bzCompress(&stream, BZ_FINISH) == BZ_STREAM_END)
		{
			done = true;
		}
	}
	dest.resize(stream.total_out_lo32);
	return BZ2WCompressOk;
}

BZ2WDecompressResult BZ2WDecompress(std::vector<char> &dest, std::span<const char> srcData, size_t maxSize)
{
	bz_stream stream;
	stream.bzalloc = nullptr;
	stream.bzfree = nullptr;
	stream.opaque = nullptr;
	if (BZ2_bzDecompressInit(&stream, 0, 0) != BZ_OK)
	{
		return BZ2WDecompressNomem;
	}
	std::unique_ptr<bz_stream, std::function<int (bz_stream *)>> bz2Data(&stream, BZ2_bzDecompressEnd); 
	stream.next_in = const_cast<char *>(srcData.data()); // I hope bz2 doesn't actually write anything here...
	stream.avail_in = srcData.size();
	dest.resize(0);
	bool done = false;
	while (!done)
	{
		size_t oldSize = dest.size();
		size_t newSize = oldSize + outputSizeIncrement;
		if (maxSize && newSize > maxSize)
		{
			newSize = maxSize;
		}
		if (oldSize == newSize)
		{
			return BZ2WDecompressLimit;
		}
		try
		{
			dest.resize(newSize);
		}
		catch (const std::bad_alloc &)
		{
			return BZ2WDecompressNomem;
		}
		stream.next_out = &dest[stream.total_out_lo32];
		stream.avail_out = dest.size() - stream.total_out_lo32;
		switch (BZ2_bzDecompress(&stream))
		{
		case BZ_OK:
			if (!stream.avail_in && stream.avail_out)
			{
				return BZ2WDecompressEof;
			}
			break;

		case BZ_MEM_ERROR:
			return BZ2WDecompressNomem;

		case BZ_DATA_ERROR:
			return BZ2WDecompressBad;

		case BZ_DATA_ERROR_MAGIC:
			return BZ2WDecompressType;

		case BZ_STREAM_END:
			done = true;
			break;
		}
	}
	dest.resize(stream.total_out_lo32);
	return BZ2WDecompressOk;
}


=== src\bzip2\bz2wrap.h ===

#pragma once
#include <cstddef>
#include <span>
#include <vector>

enum BZ2WCompressResult
{
	BZ2WCompressOk,
	BZ2WCompressNomem,
	BZ2WCompressLimit,
};
BZ2WCompressResult BZ2WCompress(std::vector<char> &dest, std::span<const char> srcData, size_t maxSize = 0);

enum BZ2WDecompressResult
{
	BZ2WDecompressOk,
	BZ2WDecompressNomem,
	BZ2WDecompressLimit,
	BZ2WDecompressType,
	BZ2WDecompressBad,
	BZ2WDecompressEof,
};
BZ2WDecompressResult BZ2WDecompress(std::vector<char> &dest, std::span<const char> srcData, size_t maxSize = 0);


=== src\bzip2\meson.build ===

common_files += files(
	'bz2wrap.cpp',
)


=== src\client\AuthUserCommon.cpp ===

#include "Client.h"
#include "prefs/GlobalPrefs.h"

void Client::LoadAuthUser()
{
	auto &prefs = GlobalPrefs::Ref();
	authUser.UserID = prefs.Get("User.ID", 0);
	authUser.Username = prefs.Get("User.Username", ByteString(""));
	authUser.SessionID = prefs.Get("User.SessionID", ByteString(""));
	authUser.SessionKey = prefs.Get("User.SessionKey", ByteString(""));
	authUser.UserElevation = prefs.Get("User.Elevation", User::ElevationNone);
}

void Client::SaveAuthUser()
{
	auto &prefs = GlobalPrefs::Ref();
	Prefs::DeferWrite dw(prefs);
	if (authUser.UserID)
	{
		prefs.Set("User.ID", authUser.UserID);
		prefs.Set("User.SessionID", authUser.SessionID);
		prefs.Set("User.SessionKey", authUser.SessionKey);
		prefs.Set("User.Username", authUser.Username);
		prefs.Set("User.Elevation", authUser.UserElevation);
	}
	else
	{
		prefs.Clear("User");
	}
}


=== src\client\AuthUserEmscripten.cpp ===

#include "Client.h"
#include "prefs/GlobalPrefs.h"
#include <emscripten.h>
#include <iostream>

void Client::LoadAuthUser()
{
	ByteString newUsername, newSessionKey;
	if (EM_ASM_INT({
		return (document.querySelector("#PowderSessionInfo [name='Username']") &&
		        document.querySelector("#PowderSessionInfo [name='SessionKey']")) ? 1 : 0;
	}))
	{
		newUsername = ByteString(std::unique_ptr<char, decltype(&free)>((char *)EM_ASM_PTR({
			return stringToNewUTF8(document.querySelector("#PowderSessionInfo [name='Username']").value);
		}), free).get());
		newSessionKey = ByteString(std::unique_ptr<char, decltype(&free)>((char *)EM_ASM_PTR({
			return stringToNewUTF8(document.querySelector("#PowderSessionInfo [name='SessionKey']").value);
		}), free).get());
	}
	else
	{
		std::cerr << "required #PowderSessionInfo elements not found, can't authenticate" << std::endl;
	}
	if (newUsername.size() && newSessionKey.size())
	{
		authUser.UserID = -1; // Not quite valid but evaluates to true and that's all that matters for this codebase.
		authUser.Username = newUsername;
		authUser.SessionID = "(invalid)";
		authUser.SessionKey = newSessionKey;
		authUser.UserElevation = User::ElevationNone; // We don't deal with this in the browser.
	}
	else
	{
		authUser.UserID = 0;
	}
}

void Client::SaveAuthUser()
{
	// Nothing is; the cookie headers in the login and logout responses take care of state management.
}


=== src\client\Client.cpp ===

#include "Client.h"
#include "prefs/GlobalPrefs.h"
#include "client/http/StartupRequest.h"
#include "ClientListener.h"
#include "Format.h"
#include "client/GameSave.h"
#include "client/SaveFile.h"
#include "client/SaveInfo.h"
#include "client/UserInfo.h"
#include "common/platform/Platform.h"
#include "common/String.h"
#include "graphics/Graphics.h"
#include "gui/dialogues/ErrorMessage.h"
#include "prefs/Prefs.h"
#include "lua/CommandInterface.h"
#include "Config.h"
#include <cstring>
#include <cstdlib>
#include <vector>
#include <map>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <fstream>
#include <chrono>
#include <algorithm>
#include <set>

Client::Client():
	messageOfTheDay("The message of the day and notifications have not yet been fetched, you can enable this in Settings"),
	usingAltUpdateServer(false),
	updateAvailable(false),
	authUser(0, "")
{
	LoadAuthUser();
	auto &prefs = GlobalPrefs::Ref();
	firstRun = !prefs.BackedByFile();
}

void Client::MigrateStampsDef()
{
	std::vector<char> data;
	if (!Platform::ReadFile(data, ByteString::Build(STAMPS_DIR, PATH_SEP_CHAR, "stamps.def")))
	{
		return;
	}
	for (auto i = 0; i < int(data.size()); i += 10)
	{
		stampIDs.push_back(ByteString(data.data() + i, data.data() + i + 10));
	}
}

void Client::Initialize()
{
	auto &prefs = GlobalPrefs::Ref();
	if (prefs.Get("version.update", false))
	{
		prefs.Set("version.update", false);
		Platform::UpdateFinish();
	}

	stamps = std::make_unique<Prefs>(ByteString::Build(STAMPS_DIR, PATH_SEP_CHAR, "stamps.json"));
	stampIDs = stamps->Get("MostRecentlyUsedFirst", std::vector<ByteString>{});
	{
		Prefs::DeferWrite dw(*stamps);
		if (!stamps->BackedByFile())
		{
			MigrateStampsDef();
			WriteStamps();
		}
		RescanStamps();
	}

	if (autoStartupRequest)
	{
		BeginStartupRequest();
	}
}

bool Client::IsFirstRun()
{
	return firstRun;
}

void Client::SetMessageOfTheDay(String message)
{
	messageOfTheDay = message;
	notifyMessageOfTheDay();
}

String Client::GetMessageOfTheDay()
{
	return messageOfTheDay;
}

void Client::AddServerNotification(ServerNotification notification)
{
	serverNotifications.push_back(notification);
	notifyNewNotification(notification);
}

std::vector<ServerNotification> Client::GetServerNotifications()
{
	return serverNotifications;
}

void Client::BeginStartupRequest()
{
	if (versionCheckRequest)
	{
		return;
	}
	serverNotifications.clear();
	startupRequestError.reset();
	startupRequestStatus = StartupRequestStatus::inProgress;
	messageOfTheDay = "Fetching the message of the day...";
	versionCheckRequest = std::make_unique<http::StartupRequest>(false);
	versionCheckRequest->Start();
	if constexpr (USE_UPDATESERVER)
	{
		// use an alternate update server
		alternateVersionCheckRequest = std::make_unique<http::StartupRequest>(true);
		alternateVersionCheckRequest->Start();
		usingAltUpdateServer = true;
	}
}

void Client::Tick()
{
	auto applyUpdateInfo = false;
	if (versionCheckRequest && versionCheckRequest->CheckDone())
	{
		if (versionCheckRequest->StatusCode() == 618)
		{
			AddServerNotification({ "Failed to load SSL certificates", ByteString::Build(SERVER, "/FAQ.html") });
		}
		try
		{
			auto info = versionCheckRequest->Finish();
			if (!info.sessionGood && authUser.UserID)
			{
				SetAuthUser(User(0, ""));
			}
			if (!usingAltUpdateServer)
			{
				updateInfo = info.updateInfo;
				applyUpdateInfo = true;
				SetMessageOfTheDay(info.messageOfTheDay);
			}
			for (auto &notification : info.notifications)
			{
				AddServerNotification(notification);
			}
		}
		catch (const http::RequestError &ex)
		{
			if (!usingAltUpdateServer)
			{
				startupRequestError = ex.what();
				SetMessageOfTheDay(ByteString::Build("Error while fetching MotD: ", ex.what()).FromUtf8());
			}
		}
		versionCheckRequest.reset();
	}
	if (alternateVersionCheckRequest && alternateVersionCheckRequest->CheckDone())
	{
		try
		{
			auto info = alternateVersionCheckRequest->Finish();
			updateInfo = info.updateInfo;
			applyUpdateInfo = true;
			SetMessageOfTheDay(info.messageOfTheDay);
			for (auto &notification : info.notifications)
			{
				AddServerNotification(notification);
			}
		}
		catch (const http::RequestError &ex)
		{
			startupRequestError = ex.what();
			SetMessageOfTheDay(ByteString::Build("Error while checking for updates: ", ex.what()).FromUtf8());
		}
		alternateVersionCheckRequest.reset();
	}
	if (applyUpdateInfo && !IGNORE_UPDATES)
	{
		if (updateInfo)
		{
			notifyUpdateAvailable();
		}
	}
	if (startupRequestStatus != StartupRequestStatus::notYetDone)
	{
		if (versionCheckRequest || alternateVersionCheckRequest)
		{
			startupRequestStatus = StartupRequestStatus::inProgress;
		}
		else
		{
			startupRequestStatus = startupRequestError ? StartupRequestStatus::failed : StartupRequestStatus::succeeded;
		}
	}
}

std::optional<UpdateInfo> Client::GetUpdateInfo()
{
	return updateInfo;
}

void Client::notifyUpdateAvailable()
{
	for (std::vector<ClientListener*>::iterator iterator = listeners.begin(), end = listeners.end(); iterator != end; ++iterator)
	{
		(*iterator)->NotifyUpdateAvailable(this);
	}
}

void Client::notifyMessageOfTheDay()
{
	for (std::vector<ClientListener*>::iterator iterator = listeners.begin(), end = listeners.end(); iterator != end; ++iterator)
	{
		(*iterator)->NotifyMessageOfTheDay(this);
	}
}

void Client::notifyAuthUserChanged()
{
	for (std::vector<ClientListener*>::iterator iterator = listeners.begin(), end = listeners.end(); iterator != end; ++iterator)
	{
		(*iterator)->NotifyAuthUserChanged(this);
	}
}

void Client::notifyNewNotification(ServerNotification notification)
{
	for (std::vector<ClientListener*>::iterator iterator = listeners.begin(), end = listeners.end(); iterator != end; ++iterator)
	{
		(*iterator)->NotifyNewNotification(this, notification);
	}
}

void Client::AddListener(ClientListener * listener)
{
	listeners.push_back(listener);
}

void Client::RemoveListener(ClientListener * listener)
{
	for (std::vector<ClientListener*>::iterator iterator = listeners.begin(), end = listeners.end(); iterator != end; ++iterator)
	{
		if((*iterator) == listener)
		{
			listeners.erase(iterator);
			return;
		}
	}
}

Client::~Client()
{
}

void Client::SetAuthUser(User user)
{
	authUser = user;
	SaveAuthUser();
	notifyAuthUserChanged();
}

User Client::GetAuthUser()
{
	return authUser;
}

void Client::MoveStampToFront(ByteString stampID)
{
	auto it = std::find(stampIDs.begin(), stampIDs.end(), stampID);
	auto changed = false;
	if (it == stampIDs.end())
	{
		stampIDs.push_back(stampID);
		it = stampIDs.end() - 1;
		changed = true;
	}
	else if (it != stampIDs.begin())
	{
		changed = true;
	}
	if (changed)
	{
		std::rotate(stampIDs.begin(), it, it + 1);
		WriteStamps();
	}
}

std::unique_ptr<SaveFile> Client::GetStamp(ByteString stampID)
{
	ByteString stampFile = ByteString(ByteString::Build(STAMPS_DIR, PATH_SEP_CHAR, stampID, ".stm"));
	auto saveFile = LoadSaveFile(stampFile);
	if (!saveFile)
		saveFile = LoadSaveFile(stampID);
	else
		saveFile->SetDisplayName(stampID.FromUtf8());
	return saveFile;
}

void Client::DeleteStamp(ByteString stampID)
{
	auto it = std::remove(stampIDs.begin(), stampIDs.end(), stampID);
	if (it != stampIDs.end())
	{
		stampIDs.erase(it, stampIDs.end());
		Platform::RemoveFile(ByteString::Build(STAMPS_DIR, PATH_SEP_CHAR, stampID, ".stm"));
		WriteStamps();
	}
}

void Client::RenameStamp(ByteString stampID, ByteString newName)
{
	auto oldPath = ByteString::Build(STAMPS_DIR, PATH_SEP_CHAR, stampID, ".stm");
	auto newPath = ByteString::Build(STAMPS_DIR, PATH_SEP_CHAR, newName, ".stm");

	if (Platform::FileExists(newPath))
	{
		new ErrorMessage("Error renaming stamp", "A stamp with this name already exists.");
		return;
	}

	if (!Platform::RenameFile(oldPath, newPath, false))
	{
		new ErrorMessage("Error renaming stamp", "Could not rename the stamp.");
		return;
	}

	std::replace(stampIDs.begin(), stampIDs.end(), stampID, newName);
	WriteStamps();
}

ByteString Client::AddStamp(std::unique_ptr<GameSave> saveData)
{
	auto now = (uint64_t)time(nullptr);
	if (lastStampTime != now)
	{
		lastStampTime = now;
		lastStampName = 0;
	}
	else
	{
		lastStampName += 1;
	}
	ByteString saveID, filename;
	while (true)
	{
		saveID = ByteString::Build(Format::Hex(Format::Width(lastStampTime, 8)), Format::Hex(Format::Width(lastStampName, 2)));
		filename = ByteString::Build(STAMPS_DIR, PATH_SEP_CHAR, saveID, ".stm");
		if (!Platform::FileExists(filename))
		{
			break;
		}
		lastStampName += 1;
	}

	Platform::MakeDirectory(STAMPS_DIR);

	Json::Value stampInfo;
	stampInfo["type"] = "stamp";
	stampInfo["username"] = authUser.Username;
	stampInfo["name"] = filename;
	stampInfo["date"] = Json::Value::UInt64(now);
	if (authors.size() != 0)
	{
		// This is a stamp, always append full authorship info (even if same user)
		stampInfo["links"].append(Client::Ref().authors);
	}
	saveData->authors = stampInfo;

	std::vector<char> gameData;
	std::tie(std::ignore, gameData) = saveData->Serialise();
	if (!gameData.size())
		return "";

	Platform::WriteFile(gameData, filename);
	MoveStampToFront(saveID);
	return saveID;
}

void Client::RescanStamps()
{
	ByteString extension = ".stm";
	std::set<ByteString> stampFilesSet;
	for (auto &stampID : Platform::DirectorySearch("stamps", "", { extension }))
	{
		stampFilesSet.insert(stampID.substr(0, stampID.size() - extension.size()));
	}
	std::vector<ByteString> newStampIDs;
	auto changed = false;
	for (auto &stampID : stampIDs)
	{
		if (stampFilesSet.find(stampID) == stampFilesSet.end())
		{
			changed = true;
		}
		else
		{
			newStampIDs.push_back(stampID);
		}
	}
	auto stampIDsSet = std::set<ByteString>(stampIDs.begin(), stampIDs.end());
	for (auto &stampID : stampFilesSet)
	{
		if (stampIDsSet.find(stampID) == stampIDsSet.end())
		{
			newStampIDs.push_back(stampID);
			changed = true;
		}
	}
	if (changed)
	{
		stampIDs = newStampIDs;
		WriteStamps();
	}
}

void Client::WriteStamps()
{
	if (stampIDs.size())
	{
		stamps->Set("MostRecentlyUsedFirst", stampIDs);
	}
}

const std::vector<ByteString> &Client::GetStamps() const
{
	return stampIDs;
}

std::unique_ptr<SaveFile> Client::LoadSaveFile(ByteString filename)
{
	ByteString err;
	std::unique_ptr<SaveFile> file;
	if (Platform::FileExists(filename))
	{
		file = std::make_unique<SaveFile>(filename);
		try
		{
			std::vector<char> data;
			if (Platform::ReadFile(data, filename))
			{
				file->SetGameSave(std::make_unique<GameSave>(std::move(data)));
			}
			else
			{
				err = "failed to open";
			}
		}
		catch (const ParseException &e)
		{
			err = e.what();
		}
	}
	else
	{
		err = "does not exist";
	}
	if (err.size())
	{
		std::cerr << "Client: " << filename << ": " << err << std::endl;
		if (file)
		{
			file->SetLoadingError(err.FromUtf8());
		}
	}
	return file;
}

// stamp-specific wrapper for MergeAuthorInfo
// also used for clipboard and lua stamps
void Client::MergeStampAuthorInfo(Json::Value stampAuthors)
{
	if (stampAuthors.size())
	{
		// when loading stamp/clipboard, only append info to authorship info (since we aren't replacing the save)
		// unless there is nothing loaded currently, then set authors directly
		if (authors.size())
		{
			// Don't add if it's exactly the same
			if (stampAuthors["links"].size() == 1 && stampAuthors["links"][0] == Client::Ref().authors)
				return;
			if (authors["username"] != stampAuthors["username"])
			{
				// 2nd arg of MergeAuthorInfo needs to be an array
				Json::Value toAdd;
				toAdd.append(stampAuthors);
				MergeAuthorInfo(toAdd);
			}
			else if (stampAuthors["links"].size())
			{
				MergeAuthorInfo(stampAuthors["links"]);
			}
		}
		else
			authors = stampAuthors;
	}
}

// linksToAdd is an array (NOT an object) of links to add to authors["links"]
void Client::MergeAuthorInfo(Json::Value linksToAdd)
{
	for (Json::Value::ArrayIndex i = 0; i < linksToAdd.size(); i++)
	{
		// link is the same exact json we have open, don't do anything
		if (linksToAdd[i] == authors)
			return;

		bool hasLink = false;
		for (Json::Value::ArrayIndex j = 0; j < authors["links"].size(); j++)
		{
			// check everything in authors["links"] to see if it's the same json as what we are already adding
			if (authors["links"][j] == linksToAdd[i])
				hasLink = true;
		}
		if (!hasLink)
			authors["links"].append(linksToAdd[i]);
	}
}

// load current authors information into a json value (when saving everything: stamps, clipboard, local saves, and online saves)
void Client::SaveAuthorInfo(Json::Value *saveInto)
{
	if (authors.size() != 0)
	{
		// Different username? Save full original save info
		if (authors["username"] != (*saveInto)["username"])
			(*saveInto)["links"].append(authors);
		// This is probalby the same save
		// Don't append another layer of links, just keep existing links
		else if (authors["links"].size())
			(*saveInto)["links"] = authors["links"];
	}
}

String Client::DoMigration(ByteString fromDir, ByteString toDir)
{
	if (fromDir.at(fromDir.length() - 1) != '/')
		fromDir = fromDir + '/';
	if (toDir.at(toDir.length() - 1) != '/')
		toDir = toDir + '/';

	std::ofstream logFile(fromDir + "/migrationlog.txt", std::ios::out);
	logFile << "Running migration of data from " << fromDir + " to " << toDir << std::endl;

	// Get lists of files to migrate
	auto stamps = Platform::DirectorySearch(fromDir + "stamps", "", { ".stm" });
	auto saves = Platform::DirectorySearch(fromDir + "Saves", "", { ".cps", ".stm" });
	auto scripts = Platform::DirectorySearch(fromDir + "scripts", "", { ".lua", ".txt" });
	auto downloadedScripts = Platform::DirectorySearch(fromDir + "scripts/downloaded", "", { ".lua" });
	bool hasScriptinfo = Platform::FileExists(toDir + "scripts/downloaded/scriptinfo");
	auto screenshots = Platform::DirectorySearch(fromDir, "screenshot", { ".png" });
	bool hasAutorun = Platform::FileExists(fromDir + "autorun.lua");
	bool hasPref = Platform::FileExists(fromDir + "powder.pref");

	if (stamps.empty() && saves.empty() && scripts.empty() && downloadedScripts.empty() && screenshots.empty() && !hasAutorun && !hasPref)
	{
		logFile << "Nothing to migrate.";
		return "Nothing to migrate. This button is used to migrate data from pre-96.0 TPT installations to the shared directory";
	}

	StringBuilder result;
	std::stack<ByteString> dirsToDelete;

	// Migrate a list of files
	auto migrateList = [&](std::vector<ByteString> list, ByteString directory, String niceName) {
		result << '\n' << niceName << ": ";
		if (!list.empty() && !directory.empty())
			Platform::MakeDirectory(toDir + directory);
		int migratedCount = 0, failedCount = 0;
		for (auto &item : list)
		{
			std::string from = fromDir + directory + "/" + item;
			std::string to = toDir + directory + "/" + item;
			if (!Platform::FileExists(to))
			{
				if (Platform::RenameFile(from, to, false))
				{
					failedCount++;
					logFile << "failed to move " << from << " to " << to << std::endl;
				}
				else
				{
					migratedCount++;
					logFile << "moved " << from << " to " << to << std::endl;
				}
			}
			else
			{
				logFile << "skipping " << from << "(already exists)" << std::endl;
			}
		}

		dirsToDelete.push(directory);
		result << "\bt" << migratedCount << " migratated\x0E, \br" << failedCount << " failed\x0E";
		int duplicates = list.size() - migratedCount - failedCount;
		if (duplicates)
			result << ", " << list.size() - migratedCount - failedCount << " skipped (duplicate)";
	};

	// Migrate a single file
	auto migrateFile = [&fromDir, &toDir, &result, &logFile](ByteString filename) {
		ByteString from = fromDir + filename;
		ByteString to = toDir + filename;
		if (!Platform::FileExists(to))
		{
			if (Platform::RenameFile(from, to, false))
			{
				logFile << "failed to move " << from << " to " << to << std::endl;
				result << "\n\br" << filename.FromUtf8() << " migration failed\x0E";
			}
			else
			{
				logFile << "moved " << from << " to " << to << std::endl;
				result << '\n' << filename.FromUtf8() << " migrated";
			}
		}
		else
		{
			logFile << "skipping " << from << "(already exists)" << std::endl;
			result << '\n' << filename.FromUtf8() << " skipped (already exists)";
		}

		if (!Platform::RemoveFile(fromDir + filename)) {
			logFile << "failed to delete " << filename << std::endl;
		}
	};

	// Do actual migration
	Platform::RemoveFile(fromDir + "stamps/stamps.def");
	Platform::RemoveFile(fromDir + "stamps/stamps.json");
	migrateList(stamps, "stamps", "Stamps");
	migrateList(saves, "Saves", "Saves");
	if (!scripts.empty())
		migrateList(scripts, "scripts", "Scripts");
	if (!hasScriptinfo && !downloadedScripts.empty())
	{
		migrateList(downloadedScripts, "scripts/downloaded", "Downloaded scripts");
		migrateFile("scripts/downloaded/scriptinfo");
	}
	if (!screenshots.empty())
		migrateList(screenshots, "", "Screenshots");
	if (hasAutorun)
		migrateFile("autorun.lua");
	if (hasPref)
		migrateFile("powder.pref");

	// Delete leftover directories
	while (!dirsToDelete.empty())
	{
		ByteString toDelete = dirsToDelete.top();
		if (!Platform::DeleteDirectory(fromDir + toDelete)) {
			logFile << "failed to delete " << toDelete << std::endl;
		}
		dirsToDelete.pop();
	}

	// chdir into the new directory
	Platform::ChangeDir(toDir);

	RescanStamps();

	logFile << std::endl << std::endl << "Migration complete. Results: " << result.Build().ToUtf8();
	logFile.close();

	return result.Build();
}


=== src\client\Client.h ===

#pragma once
#include "common/String.h"
#include "common/ExplicitSingleton.h"
#include "StartupInfo.h"
#include "User.h"
#include <vector>
#include <cstdint>
#include <list>
#include <memory>
#include <optional>
#include <json/json.h>

class SaveInfo;
class SaveFile;
class GameSave;
class VideoBuffer;

class Prefs;
class RequestListener;
class ClientListener;
namespace http
{
	class StartupRequest;
}
class Client: public ExplicitSingleton<Client> {
public:
	enum class StartupRequestStatus
	{
		notYetDone,
		inProgress,
		succeeded,
		failed,
	};

private:
	bool autoStartupRequest = true;
	String messageOfTheDay;
	std::vector<ServerNotification> serverNotifications;

	std::unique_ptr<http::StartupRequest> versionCheckRequest;
	std::unique_ptr<http::StartupRequest> alternateVersionCheckRequest;
	bool usingAltUpdateServer;
	bool updateAvailable;
	std::optional<UpdateInfo> updateInfo;

	bool firstRun;
	bool redirectStd = false;

	std::vector<ByteString> stampIDs;
	uint64_t lastStampTime = 0;
	int lastStampName = 0;

	//Auth session
	User authUser;

	void notifyUpdateAvailable();
	void notifyAuthUserChanged();
	void notifyMessageOfTheDay();
	void notifyNewNotification(ServerNotification notification);

	// Save stealing info
	Json::Value authors;

	std::unique_ptr<Prefs> stamps;
	void MigrateStampsDef();
	void WriteStamps();

	void LoadAuthUser();
	void SaveAuthUser();

	StartupRequestStatus startupRequestStatus = StartupRequestStatus::notYetDone;
	std::optional<ByteString> startupRequestError;

public:

	std::vector<ClientListener*> listeners;

	// Save stealing info
	void MergeStampAuthorInfo(Json::Value linksToAdd);
	void MergeAuthorInfo(Json::Value linksToAdd);
	void OverwriteAuthorInfo(Json::Value overwrite) { authors = overwrite; }
	Json::Value GetAuthorInfo() { return authors; }
	void SaveAuthorInfo(Json::Value *saveInto);
	void ClearAuthorInfo() { authors.clear(); }
	bool IsAuthorsEmpty() { return authors.size() == 0; }

	std::optional<UpdateInfo> GetUpdateInfo();

	Client();
	~Client();

	ByteString FileOpenDialogue();
	//std::string FileSaveDialogue();

	void AddServerNotification(ServerNotification notification);
	std::vector<ServerNotification> GetServerNotifications();

	void SetMessageOfTheDay(String message);
	String GetMessageOfTheDay();

	void Initialize();
	bool IsFirstRun();

	void AddListener(ClientListener * listener);
	void RemoveListener(ClientListener * listener);

	std::unique_ptr<SaveFile> GetStamp(ByteString stampID);
	void DeleteStamp(ByteString stampID);
	void RenameStamp(ByteString stampID, ByteString newName);
	ByteString AddStamp(std::unique_ptr<GameSave> saveData);
	void RescanStamps();
	const std::vector<ByteString> &GetStamps() const;
	void MoveStampToFront(ByteString stampID);

	std::unique_ptr<SaveFile> LoadSaveFile(ByteString filename);

	void SetAuthUser(User user);
	User GetAuthUser();
	void Tick();
	
	String DoMigration(ByteString fromDir, ByteString toDir);

	bool GetRedirectStd()
	{
		return redirectStd;
	}

	void SetRedirectStd(bool newRedirectStd)
	{
		redirectStd = newRedirectStd;
	}

	bool GetAutoStartupRequest()
	{
		return autoStartupRequest;
	}

	void SetAutoStartupRequest(bool newAutoStartupRequest)
	{
		autoStartupRequest = newAutoStartupRequest;
	}

	void BeginStartupRequest();
	StartupRequestStatus GetStartupRequestStatus() const
	{
		return startupRequestStatus;
	}
	std::optional<ByteString> GetStartupRequestError() const
	{
		return startupRequestError;
	}
};


=== src\client\ClientListener.h ===

#pragma once
#include "common/String.h"
#include "client/ServerNotification.h"

class Client;
class ClientListener
{
public:
	ClientListener() {}
	virtual ~ClientListener() {}

	virtual void NotifyUpdateAvailable(Client * sender) {}
	virtual void NotifyAuthUserChanged(Client * sender) {}
	virtual void NotifyMessageOfTheDay(Client * sender) {}
	virtual void NotifyNewNotification(Client * sender, ServerNotification notification) {}
};



=== src\client\Comment.h ===

#pragma once
#include "User.h"

struct Comment
{
	ByteString authorName;
	User::Elevation authorElevation;
	bool authorIsSelf;
	bool authorIsBanned;
	String content;
};


=== src\client\GameSave.cpp ===

#include "GameSave.h"
#include "bzip2/bz2wrap.h"
#include "Format.h"
#include "simulation/Simulation.h"
#include "simulation/ElementClasses.h"
#include "simulation/elements/PIPE.h"
#include "common/tpt-compat.h"
#include "bson/BSON.h"
#include "graphics/Renderer.h"
#include "Config.h"
#include <iostream>
#include <cmath>
#include <climits>
#include <memory>
#include <set>
#include <cmath>
#include <algorithm>

constexpr auto currentVersion = UPSTREAM_VERSION.displayVersion;
constexpr auto nextVersion = Version(99, 3);
static_assert(!ALLOW_FAKE_NEWER_VERSION || nextVersion >= currentVersion);

constexpr auto effectiveVersion = ALLOW_FAKE_NEWER_VERSION ? nextVersion : currentVersion;

static void ConvertJsonToBson(bson *b, Json::Value j, int depth = 0);
static void ConvertBsonToJson(bson_iterator *b, Json::Value *j, int depth = 0);
static void CheckBsonFieldUser(bson_iterator iter, const char *field, unsigned char **data, unsigned int *fieldLen);
static void CheckBsonFieldBool(bson_iterator iter, const char *field, bool *flag);
static void CheckBsonFieldInt(bson_iterator iter, const char *field, int *setting);
static void CheckBsonFieldLong(bson_iterator iter, const char *field, int64_t *setting);
static void CheckBsonFieldFloat(bson_iterator iter, const char *field, float *setting);

GameSave::GameSave(Vec2<int> newBlockSize)
{
	setSize(newBlockSize);
}

GameSave::GameSave(const std::vector<char> &data, bool newWantAuthors)
{
	wantAuthors = newWantAuthors;

	try
	{
		Expand(data);
	}
	catch(ParseException & e)
	{
		std::cout << e.what() << std::endl;
		throw;
	}
}

void GameSave::MapPalette()
{
	// - the palette is always right
	//   - there are palettes with missing entries but there are no palettes with incorrect entries
	//   - for every (identifier, number) pair in the palette
	//     - if the identifier is recognized, map the number to the appropriate element
	//     - if not, map it to 0
	//       - complain about the identifier if the corresponding number is actually used
	// - to handle every number not covered by the palette
	//   - in the case of any 98.0+ save, the palette is comprehensive
	//     - except for the few cases already handled below
	//       - e.g RSSS et al not having CarriesTypeIn set properly until 98.2
	//       - can handle mistakes like this with similar extra code later
	//     - map any number seen used to 0 and complain about the number
	//   - in the case of any pre-98.0 save, the palette may not be comprehensive
	//     - in the case of saves from 78.1 and newer
	//       - identity-map only ranges of numbers that are known to have existed
	//         at the point in time in vanilla when the save was made, based on this->version
	//       - this is still not perfect because it lets numbers slip that a mod freed up a
	//         vanilla element from and reused for one of its own elements, but that's fine
	//     - in the case of saves older than that
	//       - pretend that they are 78.1 in terms of validity of element numbers, this is good enough

	std::vector<int> partMap(PT_NUM, 0);
	std::vector<bool> ignoreMissingErrors(PT_NUM, false);
	if (version <= Version(98, 2))
	{
		ignoreMissingErrors[PT_ICEI] = true;
		ignoreMissingErrors[PT_SNOW] = true;
		ignoreMissingErrors[PT_RSST] = true;
		ignoreMissingErrors[PT_RSSS] = true;
	}

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	std::map<ByteString, int> missingElementIdentifiers;
	if (version < Version(98, 0))
	{
		struct CoarsePaletteInfo
		{
			Version<2> firstVersion; // the first version to which this entry applies
			int maxValid;            // almost all element numbers in the range [1, maxValid] are valid, but see golHoleFirst
			int golHoleFirst;        // the element numbers in the range [golHoleFirst, golHoleLast] are not valid
			int golHoleLast;
		};
		static const std::vector<CoarsePaletteInfo> cpi = {
			// must be sorted by firstVersion
			{ Version(78, 1), 160, 144, 146 }, // 147 isn't allocated in this version but other elements
			                                   // in certain states are loaded as 147, so leave it alone
			{ Version(79, 0), 160, 145, 146 }, // similarly
			{ Version(80, 0), 160, 146, 146 }, // similarly
			{ Version(80, 5), 160, 146, 146 },
			{ Version(81, 7), 161, 146, 146 },
			{ Version(83, 0), 162, 146, 146 },
			{ Version(83, 4), 163, 146, 146 },
			{ Version(84, 0), 166, 146, 146 },
			{ Version(86, 0), 169, 146, 146 },
			{ Version(87, 1), 172, 146, 146 },
			{ Version(89, 0), 176, 146, 146 },
			{ Version(90, 0), 178, 146, 146 },
			{ Version(91, 0), 179, 146, 146 },
			{ Version(92, 0), 185, 146, 146 },
			{ Version(94, 0), 186, 146, 146 },
			{ Version(96, 0), 191, 146, 146 },
		};
		auto found = cpi[0]; // pretend everything is at least from the first version in the list
		for (auto &info : std::span(cpi.begin() + 1, cpi.end()))
		{
			if (info.firstVersion <= version)
			{
				found = info;
			}
		}
		for (int i = 1; i <= found.maxValid; i++)
		{
			if (i >= found.golHoleFirst && i <= found.golHoleLast)
			{
				continue;
			}
			partMap[i] = i;
		}
	}
	for (auto &pi : palette)
	{
		if (pi.second > 0 && pi.second < PT_NUM)
		{
			int myId = 0;
			for (int i = 0; i < PT_NUM; i++)
			{
				if (elements[i].Enabled && elements[i].Identifier == pi.first)
				{
					myId = i;
				}
			}
			partMap[pi.second] = myId;
			if (!myId)
			{
				missingElementIdentifiers.insert(pi);
			}
		}
	}
	auto paletteLookup = [this, &partMap](int type, bool ignoreMissingErrors) {
		if (type > 0 && type < PT_NUM)
		{
			auto carriedType = partMap[type];
			if (!carriedType) // type is not 0 so this shouldn't be 0 either
			{
				if (ignoreMissingErrors)
					return type;
				missingElements.ids.insert(type);
			}
			type = carriedType;
		}
		return type;
	};

	unsigned int pmapmask = (1<<pmapbits)-1;
	auto &possiblyCarriesType = Particle::PossiblyCarriesType();
	auto &properties = Particle::GetProperties();
	for (int n = 0; n < NPART && n < particlesCount; n++)
	{
		Particle &tempPart = particles[n];
		if (tempPart.type <= 0 || tempPart.type >= PT_NUM)
		{
			continue;
		}
		tempPart.type = paletteLookup(tempPart.type, false);
		for (auto index : possiblyCarriesType)
		{
			if (elements[tempPart.type].CarriesTypeIn & (1U << index))
			{
				auto *prop = reinterpret_cast<int *>(reinterpret_cast<char *>(&tempPart) + properties[index].Offset);
				auto carriedType = *prop & int(pmapmask);
				auto extra = *prop >> pmapbits;
				carriedType = paletteLookup(carriedType, ignoreMissingErrors[tempPart.type]);
				*prop = PMAP(extra, carriedType);
			}
		}
	}
	for (const auto &pi : missingElementIdentifiers)
	{
		if (missingElements.ids.find(pi.second) != missingElements.ids.end())
		{
			missingElements.identifiers.insert(pi);
		}
	}
}

void GameSave::Expand(const std::vector<char> &data)
{
	try
	{
	if(data.size() > 15)
	{
		if ((data[0]==0x66 && data[1]==0x75 && data[2]==0x43) || (data[0]==0x50 && data[1]==0x53 && data[2]==0x76))
		{
			readPSv(data);
		}
		else if(data[0] == 'O' && data[1] == 'P' && data[2] == 'S')
		{
			if (data[3] != '1')
				throw ParseException(ParseException::WrongVersion, "Save format from newer version");
			readOPS(data);
		}
		else
		{
			std::cerr << "Got Magic number '" << data[0] << data[1] << data[2] << "'" << std::endl;
			throw ParseException(ParseException::Corrupt, "Invalid save format");
		}
		MapPalette();
	}
	else
	{
		throw ParseException(ParseException::Corrupt, "No data");
	}
	}
	catch (const std::bad_alloc &)
	{
		throw ParseException(ParseException::Corrupt, "Cannot allocate memory");
	}
}

void GameSave::setSize(Vec2<int> newBlockSize)
{
	blockSize = newBlockSize;

	particlesCount = 0;
	particles = std::vector<Particle>(NPART);

	blockMap = PlaneAdapter<std::vector<unsigned char>>(blockSize, 0);
	fanVelX = PlaneAdapter<std::vector<float>>(blockSize, 0.0f);
	fanVelY = PlaneAdapter<std::vector<float>>(blockSize, 0.0f);
	pressure = PlaneAdapter<std::vector<float>>(blockSize, 0.0f);
	velocityX = PlaneAdapter<std::vector<float>>(blockSize, 0.0f);
	velocityY = PlaneAdapter<std::vector<float>>(blockSize, 0.0f);
	ambientHeat = PlaneAdapter<std::vector<float>>(blockSize, 0.0f);
	blockAir = PlaneAdapter<std::vector<unsigned char>>(blockSize, 0);
	blockAirh = PlaneAdapter<std::vector<unsigned char>>(blockSize, 0);
	gravMass = PlaneAdapter<std::vector<float>>(blockSize, 0.f);
	gravMask = PlaneAdapter<std::vector<uint32_t>>(blockSize, UINT32_C(0xFFFFFFFF));
	gravForceX = PlaneAdapter<std::vector<float>>(blockSize, 0.f);
	gravForceY = PlaneAdapter<std::vector<float>>(blockSize, 0.f);
}

std::pair<bool, std::vector<char>> GameSave::Serialise() const
{
	try
	{
		return serialiseOPS();
	}
	catch (const std::bad_alloc &)
	{
		std::cout << "Save error, out of memory" << std::endl;
	}
	catch (BuildException & e)
	{
		std::cout << e.what() << std::endl;
	}
	return { false, {} };
}

void GameSave::Transform(Mat2<int> transform, Vec2<int> nudge)
{
	// undo translation by rotation
	auto br  = transform * (blockSize * CELL - Vec2{ 1, 1 });
	auto bbr = transform * (blockSize        - Vec2{ 1, 1 });
	auto translate  = Vec2{ std::max(0,  -br.X), std::max(0,  -br.Y) };
	auto btranslate = Vec2{ std::max(0, -bbr.X), std::max(0, -bbr.Y) };
	auto newBlockS = transform * blockSize;
	newBlockS.X = std::abs(newBlockS.X);
	newBlockS.Y = std::abs(newBlockS.Y);
	translate += nudge;

	// Grow as needed.
	assert((Vec2{ CELL, CELL }.OriginRect().Contains(nudge)));
	if (nudge.X) newBlockS.X += 1;
	if (nudge.Y) newBlockS.Y += 1;

	// TODO: allow transforms to yield bigger saves. For this we'd need SaveRenderer (the singleton, not Renderer)
	// to fully render them (possible with stitching) and Simulation::Load to be able to take only the part that fits.
	newBlockS = newBlockS.Clamp(RectBetween({ 0, 0 }, CELLS));
	auto newPartS = newBlockS * CELL;

	// Prepare to patch pipes.
	std::array<int, 8> pipeOffsetMap;
	{
		std::transform(Element_PIPE_offsets.begin(), Element_PIPE_offsets.end(), pipeOffsetMap.begin(), [transform](auto offset) {
			auto it = std::find(Element_PIPE_offsets.begin(), Element_PIPE_offsets.end(), transform * offset);
			assert(it != Element_PIPE_offsets.end());
			return int(it - Element_PIPE_offsets.begin());
		});
	}

	// Translate signs.
	for (auto i = 0U; i < signs.size(); i++)
	{
		auto newPos = transform * Vec2{ signs[i].x, signs[i].y } + translate;
		if (!newPartS.OriginRect().Contains(newPos))
		{
			signs[i].text.clear();
			continue;
		}
		signs[i].x = newPos.X;
		signs[i].y = newPos.Y;
	}

	// Translate particles.
	for (int i = 0; i < particlesCount; i++)
	{
		if (!particles[i].type)
		{
			continue;
		}
		{
			// * We want particles to retain their distance from the centre of the particle grid cell
			//   they are in, but more importantly we also don't want them to change grid cells,
			//   so we just get rid of the edge cases.
			constexpr auto threshold = 0.001f;
			auto boundaryDiffX = particles[i].x - (floor(particles[i].x) + 0.5f);
			if (fabs(boundaryDiffX) < threshold)
			{
				particles[i].x += copysign(threshold, boundaryDiffX);
			}
			auto boundaryDiffY = particles[i].y - (floor(particles[i].y) + 0.5f);
			if (fabs(boundaryDiffY) < threshold)
			{
				particles[i].y += copysign(threshold, boundaryDiffY);
			}
		}
		if (particles[i].x - floor(particles[i].x) == 0.5f) particles[i].x += 0.001f;
		if (particles[i].y - floor(particles[i].y) == 0.5f) particles[i].y += 0.001f;
		auto newPos = transform * Vec2{ particles[i].x, particles[i].y } + translate;
		if (!newPartS.OriginRect().Contains(Vec2{ int(floor(newPos.X + 0.5f)), int(floor(newPos.Y + 0.5f)) }))
		{
			particles[i].type = PT_NONE;
			continue;
		}
		particles[i].x = newPos.X;
		particles[i].y = newPos.Y;
		auto newVel = transform * Vec2{ particles[i].vx, particles[i].vy };
		particles[i].vx = newVel.X;
		particles[i].vy = newVel.Y;
		if (particles[i].type == PT_PIPE || particles[i].type == PT_PPIP)
		{
			Element_PIPE_transformPatchOffsets(particles[i], pipeOffsetMap);
		}
	}

	// Translate blocky stuff.
	PlaneAdapter<std::vector<unsigned char>> newBlockMap(newBlockS, 0);
	PlaneAdapter<std::vector<float>> newFanVelX(newBlockS, 0.0f);
	PlaneAdapter<std::vector<float>> newFanVelY(newBlockS, 0.0f);
	PlaneAdapter<std::vector<float>> newPressure(newBlockS, 0.0f);
	PlaneAdapter<std::vector<float>> newVelocityX(newBlockS, 0.0f);
	PlaneAdapter<std::vector<float>> newVelocityY(newBlockS, 0.0f);
	PlaneAdapter<std::vector<float>> newAmbientHeat(newBlockS, 0.0f);
	PlaneAdapter<std::vector<unsigned char>> newBlockAir(newBlockS, 0);
	PlaneAdapter<std::vector<unsigned char>> newBlockAirh(newBlockS, 0);
	PlaneAdapter<std::vector<float>> newGravMass(newBlockS, 0.f);
	PlaneAdapter<std::vector<uint32_t>> newGravMask(newBlockS, UINT32_C(0xFFFFFFFF));
	PlaneAdapter<std::vector<float>> newGravForceX(newBlockS, 0.f);
	PlaneAdapter<std::vector<float>> newGravForceY(newBlockS, 0.f);
	for (auto bpos : blockSize.OriginRect())
	{
		auto newBpos = transform * bpos + btranslate;
		if (!newBlockS.OriginRect().Contains(newBpos))
		{
			continue;
		}
		if (blockMap[bpos])
		{
			newBlockMap[newBpos] = blockMap[bpos];
			if (blockMap[bpos] == WL_FAN)
			{
				auto newVel = transform * Vec2{ fanVelX[bpos], fanVelY[bpos] };
				newFanVelX[newBpos] = newVel.X;
				newFanVelY[newBpos] = newVel.Y;
			}
		}
		newPressure[newBpos] = pressure[bpos];
		newVelocityX[newBpos] = velocityX[bpos];
		newVelocityY[newBpos] = velocityY[bpos];
		newAmbientHeat[newBpos] = ambientHeat[bpos];
		newBlockAir[newBpos] = blockAir[bpos];
		newBlockAirh[newBpos] = blockAirh[bpos];
		newGravMass[newBpos] = gravMass[bpos];
		newGravMask[newBpos] = gravMask[bpos];
		newGravForceX[newBpos] = gravForceX[bpos];
		newGravForceY[newBpos] = gravForceY[bpos];
	}
	blockMap = std::move(newBlockMap);
	fanVelX = std::move(newFanVelX);
	fanVelY = std::move(newFanVelY);
	pressure = std::move(newPressure);
	velocityX = std::move(newVelocityX);
	velocityY = std::move(newVelocityY);
	ambientHeat = std::move(newAmbientHeat);
	blockAir = std::move(newBlockAir);
	blockAirh = std::move(newBlockAirh);
	gravMass = std::move(newGravMass);
	gravMask = std::move(newGravMask);
	gravForceX = std::move(newGravForceX);
	gravForceY = std::move(newGravForceY);

	blockSize = newBlockS;
}

static void CheckBsonFieldUser(bson_iterator iter, const char *field, unsigned char **data, unsigned int *fieldLen)
{
	if (!strcmp(bson_iterator_key(&iter), field))
	{
		if (bson_iterator_type(&iter)==BSON_BINDATA && ((unsigned char)bson_iterator_bin_type(&iter))==BSON_BIN_USER && (*fieldLen = bson_iterator_bin_len(&iter)) > 0)
		{
			*data = (unsigned char*)bson_iterator_bin_data(&iter);
		}
		else
		{
			fprintf(stderr, "Invalid datatype for %s: %d[%d] %d[%d] %d[%d]\n", field, bson_iterator_type(&iter), bson_iterator_type(&iter)==BSON_BINDATA, (unsigned char)bson_iterator_bin_type(&iter), ((unsigned char)bson_iterator_bin_type(&iter))==BSON_BIN_USER, bson_iterator_bin_len(&iter), bson_iterator_bin_len(&iter)>0);
		}
	}
}

static void CheckBsonFieldBool(bson_iterator iter, const char *field, bool *flag)
{
	if (!strcmp(bson_iterator_key(&iter), field))
	{
		if (bson_iterator_type(&iter) == BSON_BOOL)
		{
			*flag = bson_iterator_bool(&iter);
		}
		else
		{
			fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
		}
	}
}

static void CheckBsonFieldInt(bson_iterator iter, const char *field, int *setting)
{
	if (!strcmp(bson_iterator_key(&iter), field))
	{
		if (bson_iterator_type(&iter) == BSON_INT)
		{
			*setting = bson_iterator_int(&iter);
		}
		else
		{
			fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
		}
	}
}

static void CheckBsonFieldLong(bson_iterator iter, const char *field, int64_t *setting)
{
	if (!strcmp(bson_iterator_key(&iter), field))
	{
		if (bson_iterator_type(&iter) == BSON_LONG)
		{
			*setting = bson_iterator_long(&iter);
		}
		else
		{
			fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
		}
	}
}

static void CheckBsonFieldFloat(bson_iterator iter, const char *field, float *setting)
{
	if (!strcmp(bson_iterator_key(&iter), field))
	{
		if (bson_iterator_type(&iter) == BSON_DOUBLE)
		{
			*setting = float(bson_iterator_double(&iter));
		}
		else
		{
			fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
		}
	}
}

void GameSave::readOPS(const std::vector<char> &data)
{
	auto &builtinGol = SimulationData::builtinGol;

	Renderer::PopulateTables();

	auto *inputData = reinterpret_cast<const unsigned char *>(data.data());
	unsigned char *partsData = nullptr;
	unsigned char *partsPosData = nullptr;
	unsigned char *fanData = nullptr;
	unsigned char *wallData = nullptr;
	unsigned char *soapLinkData = nullptr;
	unsigned char *pressData = nullptr, *vxData = nullptr, *vyData = nullptr, *ambientData = nullptr, *blockAirData = nullptr, *gravityData = nullptr;
	unsigned int inputDataLen = data.size(), bsonDataLen = 0, partsDataLen, partsPosDataLen, fanDataLen, wallDataLen, soapLinkDataLen;
	unsigned int pressDataLen, vxDataLen, vyDataLen, ambientDataLen, blockAirDataLen, gravityDataLen;
	unsigned partsCount = 0;
	unsigned int savedVersion = inputData[4];
	version = { savedVersion, 0 };
	bool fakeNewerVersion = false; // used for development builds only

	bson b;
	b.data = nullptr;
	auto bson_deleter = [](bson * b) { bson_destroy(b); };
	// Use unique_ptr with a custom deleter to ensure that bson_destroy is called even when an exception is thrown
	std::unique_ptr<bson, decltype(bson_deleter)> b_ptr(&b, bson_deleter);

	//Block sizes
	auto blockP = Vec2{ 0, 0 };
	auto blockS = Vec2{ int(inputData[6]), int(inputData[7]) };

	//Full size, normalised
	auto partP = blockP * CELL;
	auto partS = blockS * CELL;

	//Incompatible cell size
	if (inputData[5] != CELL)
		throw ParseException(ParseException::InvalidDimensions, "Incorrect CELL size");

	if (!RectBetween({ 0, 0 }, CELLS).Contains(blockS))
		throw ParseException(ParseException::InvalidDimensions, "Save is of invalid size");

	//Too large/off screen
	if (!RectBetween({ 0, 0 }, CELLS).Contains(blockP + blockS))
		throw ParseException(ParseException::InvalidDimensions, "Save extends beyond canvas");

	setSize(blockS);

	bsonDataLen = ((unsigned)inputData[8]);
	bsonDataLen |= ((unsigned)inputData[9]) << 8;
	bsonDataLen |= ((unsigned)inputData[10]) << 16;
	bsonDataLen |= ((unsigned)inputData[11]) << 24;

	//Check for overflows, don't load saves larger than 200MB
	unsigned int toAlloc = bsonDataLen;
	if (toAlloc > 209715200 || !toAlloc)
		throw ParseException(ParseException::InvalidDimensions, "Save data too large, refusing");

	{
		std::vector<char> bsonData;
		switch (auto status = BZ2WDecompress(bsonData, std::span(reinterpret_cast<const char *>(inputData + 12), inputDataLen - 12), toAlloc))
		{
		case BZ2WDecompressOk: break;
		case BZ2WDecompressNomem: throw ParseException(ParseException::Corrupt, "Cannot allocate memory");
		default: throw ParseException(ParseException::Corrupt, String::Build("Cannot decompress: status ", int(status)));
		}

		bsonDataLen = bsonData.size();
		//Make sure bsonData is null terminated, since all string functions need null terminated strings
		//(bson_iterator_key returns a pointer into bsonData, which is then used with strcmp)
		bsonData.push_back(0);

		// apparently bson_* takes ownership of the data passed into it?????????
		auto *pleaseFixMe = (char *)malloc(bsonData.size());
		std::copy(bsonData.begin(), bsonData.end(), pleaseFixMe);
		bson_init_data_size(&b, pleaseFixMe, bsonDataLen);
	}

	set_bson_err_handler([](const char* err) { throw ParseException(ParseException::Corrupt, "BSON error when parsing save: " + ByteString(err).FromUtf8()); });

	std::vector<sign> tempSigns;

	{
		// find origin first so version is accurate by the time checks against it are made
		bson_iterator iter;
		bson_iterator_init(&iter, &b);
		while (bson_iterator_next(&iter))
		{
			if (!strcmp(bson_iterator_key(&iter), "origin"))
			{
				if (bson_iterator_type(&iter) == BSON_OBJECT)
				{
					bson_iterator subiter;
					bson_iterator_subiterator(&iter, &subiter);
					while (bson_iterator_next(&subiter))
					{
						if (bson_iterator_type(&subiter) == BSON_INT)
						{
							if (!strcmp(bson_iterator_key(&subiter), "minorVersion"))
							{
								version[1] = bson_iterator_int(&subiter);
							}
						}
					}
				}
				else
				{
					fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
				}
			}
		}
	}
	fromNewerVersion = version > currentVersion;

	bson_iterator iter;
	bson_iterator_init(&iter, &b);
	while (bson_iterator_next(&iter))
	{
		CheckBsonFieldUser(iter, "parts", &partsData, &partsDataLen);
		CheckBsonFieldUser(iter, "partsPos", &partsPosData, &partsPosDataLen);
		CheckBsonFieldUser(iter, "wallMap", &wallData, &wallDataLen);
		CheckBsonFieldUser(iter, "pressMap", &pressData, &pressDataLen);
		CheckBsonFieldUser(iter, "vxMap", &vxData, &vxDataLen);
		CheckBsonFieldUser(iter, "vyMap", &vyData, &vyDataLen);
		CheckBsonFieldUser(iter, "ambientMap", &ambientData, &ambientDataLen);
		CheckBsonFieldUser(iter, "blockAir", &blockAirData, &blockAirDataLen);
		CheckBsonFieldUser(iter, "gravity", &gravityData, &gravityDataLen);
		CheckBsonFieldUser(iter, "fanMap", &fanData, &fanDataLen);
		CheckBsonFieldUser(iter, "soapLinks", &soapLinkData, &soapLinkDataLen);
		CheckBsonFieldBool(iter, "legacyEnable", &legacyEnable);
		CheckBsonFieldBool(iter, "gravityEnable", &gravityEnable);
		CheckBsonFieldBool(iter, "aheat_enable", &aheatEnable);
		CheckBsonFieldBool(iter, "waterEEnabled", &waterEEnabled);
		CheckBsonFieldBool(iter, "paused", &paused);
		CheckBsonFieldInt(iter, "gravityMode", &gravityMode);
		CheckBsonFieldFloat(iter, "customGravityX", &customGravityX);
		CheckBsonFieldFloat(iter, "customGravityY", &customGravityY);
		CheckBsonFieldInt(iter, "airMode", &airMode);
		CheckBsonFieldFloat(iter, "ambientAirTemp", &ambientAirTemp);
		CheckBsonFieldInt(iter, "edgeMode", &edgeMode);
		CheckBsonFieldInt(iter, "pmapbits", &pmapbits);
		CheckBsonFieldBool(iter, "ensureDeterminism", &ensureDeterminism);
		CheckBsonFieldLong(iter, "frameCount", reinterpret_cast<int64_t *>(&frameCount));
		CheckBsonFieldLong(iter, "rngState0", reinterpret_cast<int64_t *>(&rngState[0]));
		CheckBsonFieldLong(iter, "rngState1", reinterpret_cast<int64_t *>(&rngState[1]));
		if (!strcmp(bson_iterator_key(&iter), "rngState"))
		{
			if (bson_iterator_type(&iter) == BSON_BINDATA && ((unsigned char)bson_iterator_bin_type(&iter)) == BSON_BIN_USER && bson_iterator_bin_len(&iter) == sizeof(rngState))
			{
				memcpy(&rngState, bson_iterator_bin_data(&iter), sizeof(rngState));
				hasRngState = true;
			}
			else
			{
				fprintf(stderr, "Invalid datatype for rngState: %d[%d] %d[%d] %d[%d]\n", bson_iterator_type(&iter), bson_iterator_type(&iter)==BSON_BINDATA, (unsigned char)bson_iterator_bin_type(&iter), ((unsigned char)bson_iterator_bin_type(&iter))==BSON_BIN_USER, bson_iterator_bin_len(&iter), bson_iterator_bin_len(&iter)>0);
			}
		}
		else if (!strcmp(bson_iterator_key(&iter), "signs"))
		{
			if (bson_iterator_type(&iter)==BSON_ARRAY)
			{
				bson_iterator subiter;
				bson_iterator_subiterator(&iter, &subiter);
				while (bson_iterator_next(&subiter))
				{
					if (!strcmp(bson_iterator_key(&subiter), "sign"))
					{
						if (bson_iterator_type(&subiter) == BSON_OBJECT)
						{
							bson_iterator signiter;
							bson_iterator_subiterator(&subiter, &signiter);

							sign tempSign("", 0, 0, sign::Left);
							while (bson_iterator_next(&signiter))
							{
								if (!strcmp(bson_iterator_key(&signiter), "text") && bson_iterator_type(&signiter) == BSON_STRING)
								{
									tempSign.text = format::CleanString(ByteString(bson_iterator_string(&signiter)).FromUtf8(), true, true, true).Substr(0, 45);
									if (version < Version(94, 2))
									{
										if (tempSign.text == "{t}")
										{
											tempSign.text = "Temp: {t}";
										}
										else if (tempSign.text == "{p}")
										{
											tempSign.text = "Pressure: {p}";
										}
									}
								}
								else if (!strcmp(bson_iterator_key(&signiter), "justification") && bson_iterator_type(&signiter) == BSON_INT)
								{
									tempSign.ju = (sign::Justification)bson_iterator_int(&signiter);
								}
								else if (!strcmp(bson_iterator_key(&signiter), "x") && bson_iterator_type(&signiter) == BSON_INT)
								{
									tempSign.x = bson_iterator_int(&signiter)+partP.X;
								}
								else if (!strcmp(bson_iterator_key(&signiter), "y") && bson_iterator_type(&signiter) == BSON_INT)
								{
									tempSign.y = bson_iterator_int(&signiter)+partP.Y;
								}
								else
								{
									fprintf(stderr, "Unknown sign property %s\n", bson_iterator_key(&signiter));
								}
							}
							tempSigns.push_back(tempSign);
						}
						else
						{
							fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&subiter));
						}
					}
				}
			}
			else
			{
				fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
			}
		}
		else if (!strcmp(bson_iterator_key(&iter), "stkm"))
		{
			if (bson_iterator_type(&iter) == BSON_OBJECT)
			{
				bson_iterator stkmiter;
				bson_iterator_subiterator(&iter, &stkmiter);
				while (bson_iterator_next(&stkmiter))
				{
					CheckBsonFieldBool(stkmiter, "rocketBoots1", &stkm.rocketBoots1);
					CheckBsonFieldBool(stkmiter, "rocketBoots2", &stkm.rocketBoots2);
					CheckBsonFieldBool(stkmiter, "fan1", &stkm.fan1);
					CheckBsonFieldBool(stkmiter, "fan2", &stkm.fan2);
					if (!strcmp(bson_iterator_key(&stkmiter), "rocketBootsFigh") && bson_iterator_type(&stkmiter) == BSON_ARRAY)
					{
						bson_iterator fighiter;
						bson_iterator_subiterator(&stkmiter, &fighiter);
						while (bson_iterator_next(&fighiter))
						{
							if (bson_iterator_type(&fighiter) == BSON_INT)
								stkm.rocketBootsFigh.push_back(bson_iterator_int(&fighiter));
						}
					}
					else if (!strcmp(bson_iterator_key(&stkmiter), "fanFigh") && bson_iterator_type(&stkmiter) == BSON_ARRAY)
					{
						bson_iterator fighiter;
						bson_iterator_subiterator(&stkmiter, &fighiter);
						while (bson_iterator_next(&fighiter))
						{
							if (bson_iterator_type(&fighiter) == BSON_INT)
								stkm.fanFigh.push_back(bson_iterator_int(&fighiter));
						}
					}
				}
			}
			else
			{
				fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
			}
		}
		else if (!strcmp(bson_iterator_key(&iter), "palette"))
		{
			palette.clear();
			if (bson_iterator_type(&iter) == BSON_ARRAY)
			{
				bson_iterator subiter;
				bson_iterator_subiterator(&iter, &subiter);
				while (bson_iterator_next(&subiter))
				{
					if (bson_iterator_type(&subiter) == BSON_INT)
					{
						ByteString id = bson_iterator_key(&subiter);
						int num = bson_iterator_int(&subiter);
						palette.push_back(PaletteItem(id, num));
					}
				}
			}
		}
		else if (!strcmp(bson_iterator_key(&iter), "minimumVersion"))
		{
			if (bson_iterator_type(&iter) == BSON_OBJECT)
			{
				Version<2> minimumVersion;
				{
					int major = INT_MAX, minor = INT_MAX;
					bson_iterator subiter;
					bson_iterator_subiterator(&iter, &subiter);
					while (bson_iterator_next(&subiter))
					{
						if (bson_iterator_type(&subiter) == BSON_INT)
						{
							if (!strcmp(bson_iterator_key(&subiter), "major"))
								major = bson_iterator_int(&subiter);
							else if (!strcmp(bson_iterator_key(&subiter), "minor"))
								minor = bson_iterator_int(&subiter);
						}
					}
					minimumVersion = Version(major, minor);
				}
				if (effectiveVersion < minimumVersion)
				{
					String errorMessage = String::Build("Save from a newer version: Requires version ", minimumVersion[0], ".", minimumVersion[1]);
					throw ParseException(ParseException::WrongVersion, errorMessage);
				}
				else if (ALLOW_FAKE_NEWER_VERSION && currentVersion < minimumVersion)
				{
					fakeNewerVersion = true;
				}
			}
			else
			{
				fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
			}
		}
		else if (wantAuthors && !strcmp(bson_iterator_key(&iter), "authors"))
		{
			if (bson_iterator_type(&iter) == BSON_OBJECT)
			{
				// we need to clear authors because the save may be read multiple times in the stamp browser (loading and rendering twice)
				// seems inefficient ...
				authors.clear();
				ConvertBsonToJson(&iter, &authors);
			}
			else
			{
				fprintf(stderr, "Wrong type for %s\n", bson_iterator_key(&iter));
			}
		}
	}

	auto paletteRemap = [this](auto maxVersion, ByteString from, ByteString to) {
		if (version <= maxVersion)
		{
			auto it = std::find_if(palette.begin(), palette.end(), [&from](auto &item) {
				return item.first == from;
			});
			if (it != palette.end())
			{
				it->first = to;
			}
		}
	};
	paletteRemap(Version(87, 1), "DEFAULT_PT_TUGN", "DEFAULT_PT_TUNG");
	paletteRemap(Version(90, 1), "DEFAULT_PT_REPL", "DEFAULT_PT_RPEL");
	paletteRemap(Version(92, 0), "DEFAULT_PT_E180", "DEFAULT_PT_HEAC");
	paletteRemap(Version(92, 0), "DEFAULT_PT_E181", "DEFAULT_PT_SAWD");
	paletteRemap(Version(92, 0), "DEFAULT_PT_E182", "DEFAULT_PT_POLO");
	paletteRemap(Version(93, 3), "DEFAULT_PT_RAYT", "DEFAULT_PT_LDTC");

	//Read wall and fan data
	if(wallData)
	{
		auto wallDataPlane = PlaneAdapter<PlaneBase<const unsigned char>>(blockS, std::in_place, wallData);
		unsigned int j = 0;
		if (blockS.X * blockS.Y > int(wallDataLen))
			throw ParseException(ParseException::Corrupt, "Not enough wall data");
		for (auto bpos : blockS.OriginRect().Range<LEFT_TO_RIGHT, TOP_TO_BOTTOM>())
		{
			unsigned char bm = 0;
			if (wallDataPlane[bpos])
				bm = wallDataPlane[bpos];

			switch (bm)
			{
			case O_WL_WALLELEC:     bm = WL_WALLELEC;     break;
			case O_WL_EWALL:        bm = WL_EWALL;        break;
			case O_WL_DETECT:       bm = WL_DETECT;       break;
			case O_WL_STREAM:       bm = WL_STREAM;       break;
			case O_WL_FAN:
			case O_WL_FANHELPER:    bm = WL_FAN;          break;
			case O_WL_ALLOWLIQUID:  bm = WL_ALLOWLIQUID;  break;
			case O_WL_DESTROYALL:   bm = WL_DESTROYALL;   break;
			case O_WL_ERASE:        bm = WL_ERASE;        break;
			case O_WL_WALL:         bm = WL_WALL;         break;
			case O_WL_ALLOWAIR:     bm = WL_ALLOWAIR;     break;
			case O_WL_ALLOWSOLID:   bm = WL_ALLOWPOWDER;  break;
			case O_WL_ALLOWALLELEC: bm = WL_ALLOWALLELEC; break;
			case O_WL_EHOLE:        bm = WL_EHOLE;        break;
			case O_WL_ALLOWGAS:     bm = WL_ALLOWGAS;     break;
			case O_WL_GRAV:         bm = WL_GRAV;         break;
			case O_WL_ALLOWENERGY:  bm = WL_ALLOWENERGY;  break;
			}

			if (bm == WL_FAN && fanData)
			{
				if(j+1 >= fanDataLen)
				{
					fprintf(stderr, "Not enough fan data\n");
				}
				fanVelX[blockP + bpos] = (fanData[j++]-127.0f)/64.0f;
				fanVelY[blockP + bpos] = (fanData[j++]-127.0f)/64.0f;
			}

			if (bm >= UI_WALLCOUNT)
				bm = 0;
			blockMap[blockP + bpos] = bm;
		}
	}

	//Read pressure data
	if (pressData)
	{
		unsigned int j = 0;
		unsigned char i, i2;
		if (blockS.X * blockS.Y > int(pressDataLen))
			throw ParseException(ParseException::Corrupt, "Not enough pressure data");
		for (auto bpos : blockS.OriginRect().Range<LEFT_TO_RIGHT, TOP_TO_BOTTOM>())
		{
			i = pressData[j++];
			i2 = pressData[j++];
			pressure[blockP + bpos] = ((i+(i2<<8))/128.0f)-256;
		}
		hasPressure = true;
	}

	//Read vx data
	if (vxData)
	{
		unsigned int j = 0;
		unsigned char i, i2;
		if (blockS.X * blockS.Y > int(vxDataLen))
			throw ParseException(ParseException::Corrupt, "Not enough vx data");
		for (auto bpos : blockS.OriginRect().Range<LEFT_TO_RIGHT, TOP_TO_BOTTOM>())
		{
			i = vxData[j++];
			i2 = vxData[j++];
			velocityX[blockP + bpos] = ((i+(i2<<8))/128.0f)-256;
		}
	}

	//Read vy data
	if (vyData)
	{
		unsigned int j = 0;
		unsigned char i, i2;
		if (blockS.X * blockS.Y > int(vyDataLen))
			throw ParseException(ParseException::Corrupt, "Not enough vy data");
		for (auto bpos : blockS.OriginRect().Range<LEFT_TO_RIGHT, TOP_TO_BOTTOM>())
		{
			i = vyData[j++];
			i2 = vyData[j++];
			velocityY[blockP + bpos] = ((i+(i2<<8))/128.0f)-256;
		}
	}

	//Read ambient data
	if (ambientData)
	{
		unsigned int i = 0, tempTemp;
		if (blockS.X * blockS.Y > int(ambientDataLen))
			throw ParseException(ParseException::Corrupt, "Not enough ambient heat data");
		for (auto bpos : blockS.OriginRect().Range<LEFT_TO_RIGHT, TOP_TO_BOTTOM>())
		{
			tempTemp = ambientData[i++];
			tempTemp |= (((unsigned)ambientData[i++]) << 8);
			ambientHeat[blockP + bpos] = float(tempTemp);
		}
		hasAmbientHeat = true;
	}

	if (blockAirData)
	{
		if (blockS.X * blockS.Y * 2 > int(blockAirDataLen))
			throw ParseException(ParseException::Corrupt, "Not enough block air data");
		auto blockAirDataPlane = PlaneAdapter<PlaneBase<const unsigned char>>(blockS, std::in_place, blockAirData);
		auto blockAirhDataPlane = PlaneAdapter<PlaneBase<const unsigned char>>(blockS, std::in_place, blockAirData + blockS.X * blockS.Y);
		for (auto bpos : blockS.OriginRect().Range<LEFT_TO_RIGHT, TOP_TO_BOTTOM>())
		{
			blockAir [blockP + bpos] = blockAirDataPlane [bpos];
			blockAirh[blockP + bpos] = blockAirhDataPlane[bpos];
		}
		hasBlockAirMaps = true;
	}

	if (gravityData)
	{
		if (blockS.X * blockS.Y * 4 > int(gravityDataLen))
		{
			throw ParseException(ParseException::Corrupt, "Not enough gravity data");
		}
		auto massDataPlane   = PlaneAdapter<PlaneBase<const float   >>(blockS, std::in_place, reinterpret_cast<const float    *>(gravityData                                          ));
		auto maskDataPlane   = PlaneAdapter<PlaneBase<const uint32_t>>(blockS, std::in_place, reinterpret_cast<const uint32_t *>(gravityData +     blockS.X * blockS.Y * sizeof(float)));
		auto forceXDataPlane = PlaneAdapter<PlaneBase<const float   >>(blockS, std::in_place, reinterpret_cast<const float    *>(gravityData + 2 * blockS.X * blockS.Y * sizeof(float)));
		auto forceYDataPlane = PlaneAdapter<PlaneBase<const float   >>(blockS, std::in_place, reinterpret_cast<const float    *>(gravityData + 3 * blockS.X * blockS.Y * sizeof(float)));
		for (auto bpos : blockS.OriginRect().Range<LEFT_TO_RIGHT, TOP_TO_BOTTOM>())
		{
			gravMass  [blockP + bpos] = massDataPlane  [bpos];
			gravMask  [blockP + bpos] = maskDataPlane  [bpos];
			gravForceX[blockP + bpos] = forceXDataPlane[bpos];
			gravForceY[blockP + bpos] = forceYDataPlane[bpos];
		}
		hasGravityMaps = true;
	}

	//Read particle data
	if (partsData && partsPosData)
	{
		int newIndex = 0, tempTemp;
		int posCount, posTotal, partsPosDataIndex = 0;
		if (partS.X * partS.Y * 3 > int(partsPosDataLen))
			throw ParseException(ParseException::Corrupt, "Not enough particle position data");

		partsCount = 0;

		unsigned int i = 0;
		newIndex = 0;
		for (auto pos : RectSized(partP, partS).Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
		{
			//Read total number of particles at this position
			posTotal = 0;
			posTotal |= partsPosData[partsPosDataIndex++]<<16;
			posTotal |= partsPosData[partsPosDataIndex++]<<8;
			posTotal |= partsPosData[partsPosDataIndex++];
			//Put the next posTotal particles at this position
			for (posCount = 0; posCount < posTotal; posCount++)
			{
				particlesCount = newIndex+1;
				//i+3 because we have 4 bytes of required fields (type (1), descriptor (2), temp (1))
				if (i+3 >= partsDataLen)
					throw ParseException(ParseException::Corrupt, "Ran past particle data buffer");
				unsigned int fieldDescriptor = (unsigned int)(partsData[i+1]);
				fieldDescriptor |= (unsigned int)(partsData[i+2]) << 8;

				if (newIndex < 0 || newIndex >= NPART)
					throw ParseException(ParseException::Corrupt, "Too many particles");

				//Clear the particle, ready for our new properties
				memset(&(particles[newIndex]), 0, sizeof(Particle));

				//Required fields
				particles[newIndex].type = partsData[i];
				particles[newIndex].x = float(pos.X);
				particles[newIndex].y = float(pos.Y);
				i+=3;

				// Read type (2nd byte)
				if (fieldDescriptor & 0x4000)
					particles[newIndex].type |= (((unsigned)partsData[i++]) << 8);

				//Read temp
				if(fieldDescriptor & 0x01)
				{
					//Full 16bit int
					tempTemp = partsData[i++];
					tempTemp |= (((unsigned)partsData[i++]) << 8);
					particles[newIndex].temp = float(tempTemp);
				}
				else
				{
					//1 Byte room temp offset
					tempTemp = partsData[i++];
					if (tempTemp >= 0x80)
					{
						tempTemp -= 0x100;
					}
					particles[newIndex].temp = tempTemp+294.15f;
				}

				// fieldDesc3
				if (fieldDescriptor & 0x8000)
				{
					if (i >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading third byte of field descriptor");
					fieldDescriptor |= (unsigned int)(partsData[i++]) << 16;
				}

				//Read life
				if(fieldDescriptor & 0x02)
				{
					if (i >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading life");
					particles[newIndex].life = partsData[i++];
					//i++;
					//Read 2nd byte
					if(fieldDescriptor & 0x04)
					{
						if (i >= partsDataLen)
							throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading life");
						particles[newIndex].life |= (((unsigned)partsData[i++]) << 8);
					}
				}

				//Read tmp
				if(fieldDescriptor & 0x08)
				{
					if (i >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading tmp");
					particles[newIndex].tmp = partsData[i++];
					//Read 2nd byte
					if(fieldDescriptor & 0x10)
					{
						if (i >= partsDataLen)
							throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading tmp");
						particles[newIndex].tmp |= (((unsigned)partsData[i++]) << 8);
						//Read 3rd and 4th bytes
						if(fieldDescriptor & 0x1000)
						{
							if (i+1 >= partsDataLen)
								throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading tmp");
							particles[newIndex].tmp |= (((unsigned)partsData[i++]) << 24);
							particles[newIndex].tmp |= (((unsigned)partsData[i++]) << 16);
						}
					}
				}

				//Read ctype
				if(fieldDescriptor & 0x20)
				{
					if (i >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading ctype");
					particles[newIndex].ctype = partsData[i++];
					//Read additional bytes
					if(fieldDescriptor & 0x200)
					{
						if (i+2 >= partsDataLen)
							throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading ctype");
						particles[newIndex].ctype |= (((unsigned)partsData[i++]) << 24);
						particles[newIndex].ctype |= (((unsigned)partsData[i++]) << 16);
						particles[newIndex].ctype |= (((unsigned)partsData[i++]) << 8);
					}
				}

				//Read dcolour
				if(fieldDescriptor & 0x40)
				{
					if (i+3 >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading deco");
					particles[newIndex].dcolour = (((unsigned)partsData[i++]) << 24);
					particles[newIndex].dcolour |= (((unsigned)partsData[i++]) << 16);
					particles[newIndex].dcolour |= (((unsigned)partsData[i++]) << 8);
					particles[newIndex].dcolour |= ((unsigned)partsData[i++]);
				}

				//Read vx
				if(fieldDescriptor & 0x80)
				{
					if (i >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading vx");
					particles[newIndex].vx = (partsData[i++]-127.0f)/16.0f;
				}

				//Read vy
				if(fieldDescriptor & 0x100)
				{
					if (i >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading vy");
					particles[newIndex].vy = (partsData[i++]-127.0f)/16.0f;
				}

				//Read tmp2
				if(fieldDescriptor & 0x400)
				{
					if (i >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading tmp2");
					particles[newIndex].tmp2 = partsData[i++];
					if(fieldDescriptor & 0x800)
					{
						if (i >= partsDataLen)
							throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading tmp2");
						particles[newIndex].tmp2 |= (((unsigned)partsData[i++]) << 8);
					}
				}

				//Read tmp3 and tmp4
				if(fieldDescriptor & 0x2000)
				{
					if (i+3 >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading tmp3 and tmp4");
					if (fieldDescriptor & 0x10000 && i+7 >= partsDataLen)
						throw ParseException(ParseException::Corrupt, "Ran past particle data buffer while loading high halves of tmp3 and tmp4");
					unsigned int tmp34;
					tmp34  = (unsigned int)partsData[i + 0];
					tmp34 |= (unsigned int)partsData[i + 1] << 8;
					if (fieldDescriptor & 0x10000)
					{
						tmp34 |= (unsigned int)partsData[i + 4] << 16;
						tmp34 |= (unsigned int)partsData[i + 5] << 24;
					}
					particles[newIndex].tmp3 = int(tmp34);
					tmp34  = (unsigned int)partsData[i + 2];
					tmp34 |= (unsigned int)partsData[i + 3] << 8;
					if (fieldDescriptor & 0x10000)
					{
						tmp34 |= (unsigned int)partsData[i + 6] << 16;
						tmp34 |= (unsigned int)partsData[i + 7] << 24;
					}
					particles[newIndex].tmp4 = int(tmp34);
					i += 4;
					if (fieldDescriptor & 0x10000)
						i += 4;
				}

				//Particle specific parsing:
				switch(particles[newIndex].type)
				{
				case PT_SOAP:
					//Clear soap links, links will be added back in if soapLinkData is present
					particles[newIndex].ctype &= ~6;
					break;
				case PT_BOMB:
					if (particles[newIndex].tmp!=0 && savedVersion < 81)
					{
						particles[newIndex].type = PT_EMBR;
						particles[newIndex].ctype = 0;
						if (particles[newIndex].tmp==1)
							particles[newIndex].tmp = 0;
					}
					break;
				case PT_DUST:
					if (particles[newIndex].life>0 && savedVersion < 81)
					{
						particles[newIndex].type = PT_EMBR;
						particles[newIndex].ctype = (particles[newIndex].tmp2<<16) | (particles[newIndex].tmp<<8) | particles[newIndex].ctype;
						particles[newIndex].tmp = 1;
					}
					break;
				case PT_FIRW:
					if (particles[newIndex].tmp>=2 && savedVersion < 81)
					{
						particles[newIndex].type = PT_EMBR;
						particles[newIndex].ctype = Renderer::firwTableAt(particles[newIndex].tmp - 4).Pack();
						particles[newIndex].tmp = 1;
					}
					break;
				case PT_PSTN:
					if (savedVersion < 87 && particles[newIndex].ctype)
						particles[newIndex].life = 1;
					if (savedVersion < 91)
						particles[newIndex].temp = 283.15f;
					break;
				case PT_FILT:
					if (savedVersion < 89)
					{
						if (particles[newIndex].tmp<0 || particles[newIndex].tmp>3)
							particles[newIndex].tmp = 6;
						particles[newIndex].ctype = 0;
					}
					break;
				case PT_QRTZ:
				case PT_PQRT:
					if (savedVersion < 89)
					{
						particles[newIndex].tmp2 = particles[newIndex].tmp;
						particles[newIndex].tmp = particles[newIndex].ctype;
						particles[newIndex].ctype = 0;
					}
					break;
				case PT_PHOT:
					if (savedVersion < 90)
					{
						particles[newIndex].flags |= FLAG_PHOTDECO;
					}
					break;
				case PT_VINE:
					if (savedVersion < 91)
					{
						particles[newIndex].tmp = 1;
					}
					break;
				case PT_DLAY:
					// correct DLAY temperature in older saves
					// due to either the +.5f now done in DLAY (higher temps), or rounding errors in the old DLAY code (room temperature temps),
					// the delay in all DLAY from older versions will always be one greater than it should
					if (savedVersion < 91)
					{
						particles[newIndex].temp = particles[newIndex].temp - 1.0f;
					}
					break;
				case PT_CRAY:
					if (savedVersion < 91)
					{
						if (particles[newIndex].tmp2)
						{
							particles[newIndex].ctype |= particles[newIndex].tmp2<<8;
							particles[newIndex].tmp2 = 0;
						}
					}
					break;
				case PT_CONV:
					if (savedVersion < 91)
					{
						if (particles[newIndex].tmp)
						{
							particles[newIndex].ctype |= particles[newIndex].tmp<<8;
							particles[newIndex].tmp = 0;
						}
					}
					break;
				case PT_PIPE:
				case PT_PPIP:
					if (savedVersion < 93 && !fakeNewerVersion)
					{
						if (particles[newIndex].ctype == 1)
							particles[newIndex].tmp |= 0x00020000; //PFLAG_INITIALIZING
						particles[newIndex].tmp |= (particles[newIndex].ctype-1)<<18;
						particles[newIndex].ctype = particles[newIndex].tmp&0xFF;
					}
					break;
				case PT_TSNS:
				case PT_HSWC:
				case PT_PSNS:
				case PT_PUMP:
					if (savedVersion < 93 && !fakeNewerVersion)
					{
						particles[newIndex].tmp = 0;
					}
					break;
				case PT_LIFE:
					if (savedVersion < 96 && !fakeNewerVersion)
					{
						if (particles[newIndex].ctype >= 0 && particles[newIndex].ctype < NGOL)
						{
							particles[newIndex].tmp2 = particles[newIndex].tmp;
							if (!particles[newIndex].dcolour)
								particles[newIndex].dcolour = builtinGol[particles[newIndex].ctype].colour.Pack();
							particles[newIndex].tmp = builtinGol[particles[newIndex].ctype].colour2.Pack();
						}
					}
				}
				if (PressureInTmp3(particles[newIndex].type))
				{
					// pavg[1] used to be saved as a u16, which PressureInTmp3 elements then treated as
					// an i16. tmp3 is now saved as a u32, or as a u16 if it's small enough. PressureInTmp3
					// elements will never use the upper 16 bits, and should still treat the lower 16 bits
					// as an i16, so they need sign extension.
					auto tmp3 = (unsigned int)(particles[newIndex].tmp3);
					if (tmp3 & 0x8000U)
					{
						tmp3 |= 0xFFFF0000U;
						particles[newIndex].tmp3 = int(tmp3);
					}
				}
				//note: PSv was used in version 77.0 and every version before, add something in PSv too if the element is that old
				newIndex++;
				partsCount++;
			}
		}

		if (i != partsDataLen)
			throw ParseException(ParseException::Corrupt, "Didn't reach end of particle data buffer");
	}

	if (soapLinkData)
	{
		unsigned int soapLinkDataPos = 0;
		for (unsigned int i = 0; i < partsCount; i++)
		{
			if (particles[i].type == PT_SOAP)
			{
				// Get the index of the particle forward linked from this one, if present in the save data
				unsigned int linkedIndex = 0;
				if (soapLinkDataPos+3 > soapLinkDataLen) break;
				linkedIndex |= soapLinkData[soapLinkDataPos++]<<16;
				linkedIndex |= soapLinkData[soapLinkDataPos++]<<8;
				linkedIndex |= soapLinkData[soapLinkDataPos++];
				// All indexes in soapLinkData and partsSimIndex have 1 added to them (0 means not saved/loaded)
				if (!linkedIndex || linkedIndex-1 >= partsCount)
					continue;
				linkedIndex = linkedIndex-1;

				//Attach the two particles
				particles[i].ctype |= 2;
				particles[i].tmp = linkedIndex;
				particles[linkedIndex].ctype |= 4;
				particles[linkedIndex].tmp2 = i;
			}
		}
	}

	if (tempSigns.size())
	{
		for (size_t i = 0; i < tempSigns.size(); i++)
		{
			if(signs.size() == MAXSIGNS)
				break;
			signs.push_back(tempSigns[i]);
		}
	}
}

#define MTOS_EXPAND(str) #str
#define MTOS(str) MTOS_EXPAND(str)
void GameSave::readPSv(const std::vector<char> &dataVec)
{
	auto &builtinGol = SimulationData::builtinGol;
	Renderer::PopulateTables();

	auto *saveData = reinterpret_cast<const unsigned char *>(dataVec.data());
	auto dataLength = int(dataVec.size());
	int q,p=0, pty, ty, legacy_beta=0;
	Vec2<int> blockP = { 0, 0 };
	int new_format = 0, ttv = 0;

	std::vector<sign> tempSigns;
	char tempSignText[255];
	sign tempSign("", 0, 0, sign::Left);

	auto &builtinElements = GetElements();

	//New file header uses PSv, replacing fuC. This is to detect if the client uses a new save format for temperatures
	//This creates a problem for old clients, that display and "corrupt" error instead of a "newer version" error

	if (dataLength<16)
		throw ParseException(ParseException::Corrupt, "No save data");
	if (!(saveData[2]==0x43 && saveData[1]==0x75 && saveData[0]==0x66) && !(saveData[2]==0x76 && saveData[1]==0x53 && saveData[0]==0x50))
		throw ParseException(ParseException::Corrupt, "Unknown format");
	if (saveData[2]==0x76 && saveData[1]==0x53 && saveData[0]==0x50) {
		new_format = 1;
	}
	if (saveData[4]>97) // this used to respect currentVersion but no valid PSv will ever have a version > 97 so it's ok to hardcode
		throw ParseException(ParseException::WrongVersion, "Save from newer version");
	version = { saveData[4], 0 };
	auto ver = version[0];

	if (ver<34)
	{
		legacyEnable = 1;
	}
	else
	{
		if (ver>=44) {
			legacyEnable = saveData[3]&0x01;
			paused = (saveData[3]>>1)&0x01;
			if (ver>=46) {
				gravityMode = ((saveData[3]>>2)&0x03);// | ((c[3]>>2)&0x01);
				airMode = ((saveData[3]>>4)&0x07);// | ((c[3]>>4)&0x02) | ((c[3]>>4)&0x01);
			}
			if (ver>=49) {
				gravityEnable = ((saveData[3]>>7)&0x01);
			}
		} else {
			if (saveData[3]==1||saveData[3]==0) {
				legacyEnable = saveData[3];
			} else {
				legacy_beta = 1;
			}
		}
	}

	auto blockS = Vec2{ int(saveData[6]), int(saveData[7]) };
	blockP = blockP.Clamp(blockS.OriginRect());

	if (saveData[5]!=CELL || blockP.X+blockS.X>XCELLS || blockP.Y+blockS.Y>YCELLS)
		throw ParseException(ParseException::InvalidDimensions, "Save too large");
	int size = (unsigned)saveData[8];
	size |= ((unsigned)saveData[9])<<8;
	size |= ((unsigned)saveData[10])<<16;
	size |= ((unsigned)saveData[11])<<24;

	if (size > 209715200 || !size)
		throw ParseException(ParseException::InvalidDimensions, "Save data too large");

	std::vector<char> bsonData;
	switch (auto status = BZ2WDecompress(bsonData, std::span(reinterpret_cast<const char *>(saveData + 12), dataLength - 12), size))
	{
	case BZ2WDecompressOk: break;
	case BZ2WDecompressNomem: throw ParseException(ParseException::Corrupt, "Cannot allocate memory");
	default: throw ParseException(ParseException::Corrupt, String::Build("Cannot decompress: status ", int(status)));
	}

	setSize(blockS);
	const auto *data = reinterpret_cast<const unsigned char *>(bsonData.data());
	dataLength = bsonData.size();

	if constexpr (DEBUG)
	{
		std::cout << "Parsing " << dataLength << " bytes of data, version " << ver << std::endl;
	}

	if (dataLength < blockS.X*blockS.Y)
		throw ParseException(ParseException::Corrupt, "Save data corrupt (missing data)");

	// normalize coordinates
	auto partS = blockS * CELL;
	auto partP = blockP * CELL;

	if (ver<46) {
		gravityMode = GRAV_VERTICAL;
		airMode = AIR_ON;
	}

	PlaneAdapter<std::vector<int>> particleIDMap(RES, 0);

	// load the required air state
	for (auto bpos : RectSized(blockP, blockS).Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		if (data[p])
		{
			//In old saves, ignore walls created by sign tool bug
			//Not ignoring other invalid walls or invalid walls in new saves, so that any other bugs causing them are easier to notice, find and fix
			if (ver>=44 && ver<71 && data[p]==O_WL_SIGN)
			{
				p++;
				continue;
			}
			auto bm = data[p];
			switch (bm)
			{
			case  1: bm = WL_WALL        ; break;
			case  2: bm = WL_DESTROYALL  ; break;
			case  3: bm = WL_ALLOWLIQUID ; break;
			case  4: bm = WL_FAN         ; break;
			case  5: bm = WL_STREAM      ; break;
			case  6: bm = WL_DETECT      ; break;
			case  7: bm = WL_EWALL       ; break;
			case  8: bm = WL_WALLELEC    ; break;
			case  9: bm = WL_ALLOWAIR    ; break;
			case 10: bm = WL_ALLOWPOWDER ; break;
			case 11: bm = WL_ALLOWALLELEC; break;
			case 12: bm = WL_EHOLE       ; break;
			case 13: bm = WL_ALLOWGAS    ; break;
			}

			if (ver>=44)
			{
				/* The numbers used to save walls were changed, starting in v44.
				 * The new numbers are ignored for older versions due to some corruption of bmap in saves from older versions.
				 */
				switch (bm)
				{
				case O_WL_WALLELEC:     bm = WL_WALLELEC    ; break;
				case O_WL_EWALL:        bm = WL_EWALL       ; break;
				case O_WL_DETECT:       bm = WL_DETECT      ; break;
				case O_WL_STREAM:       bm = WL_STREAM      ; break;
				case O_WL_FAN:
				case O_WL_FANHELPER:    bm = WL_FAN         ; break;
				case O_WL_ALLOWLIQUID:  bm = WL_ALLOWLIQUID ; break;
				case O_WL_DESTROYALL:   bm = WL_DESTROYALL  ; break;
				case O_WL_ERASE:        bm = WL_ERASE       ; break;
				case O_WL_WALL:         bm = WL_WALL        ; break;
				case O_WL_ALLOWAIR:     bm = WL_ALLOWAIR    ; break;
				case O_WL_ALLOWSOLID:   bm = WL_ALLOWPOWDER ; break;
				case O_WL_ALLOWALLELEC: bm = WL_ALLOWALLELEC; break;
				case O_WL_EHOLE:        bm = WL_EHOLE       ; break;
				case O_WL_ALLOWGAS:     bm = WL_ALLOWGAS    ; break;
				case O_WL_GRAV:         bm = WL_GRAV        ; break;
				case O_WL_ALLOWENERGY:  bm = WL_ALLOWENERGY ; break;
				}
			}

			if (bm >= UI_WALLCOUNT)
				bm = 0;
			blockMap[bpos] = bm;
		}

		p++;
	}
	for (auto bpos : RectSized(blockP, blockS).Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto dataPlane = PlaneAdapter<PlaneBase<const unsigned char>>(blockS, std::in_place, data);
		if (dataPlane[bpos - blockP]==4||(ver>=44 && dataPlane[bpos - blockP]==O_WL_FAN))
		{
			if (p >= dataLength)
				throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
			fanVelX[bpos] = (data[p++]-127.0f)/64.0f;
		}
	}
	for (auto bpos : RectSized(blockP, blockS).Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto dataPlane = PlaneAdapter<PlaneBase<const unsigned char>>(blockS, std::in_place, data);
		if (dataPlane[bpos - blockP]==4||(ver>=44 && dataPlane[bpos - blockP]==O_WL_FAN))
		{
			if (p >= dataLength)
				throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
			fanVelY[bpos] = (data[p++]-127.0f)/64.0f;
		}
	}

	// load the particle map
	{
		auto k = 0;
		pty = p;
		for (auto pos : RectSized(partP, partS).Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
		{
			if (p >= dataLength)
				throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
			auto j=data[p++];
			if (int(j) >= PT_NUM) { // not possible these days since PMAPBITS >= 8
				j = PT_DUST;//throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
			}
			if (j)
			{
				memset(&particles[k], 0, sizeof(Particle));
				particles[k].type = j;
				if (j == PT_COAL)
					particles[k].tmp = 50;
				if (j == PT_FUSE)
					particles[k].tmp = 50;
				if (j == PT_PHOT)
					particles[k].ctype = 0x3fffffff;
				if (j == PT_SOAP)
					particles[k].ctype = 0;
				if (j==PT_BIZR || j==PT_BIZRG || j==PT_BIZRS)
					particles[k].ctype = 0x47FFFF;
				particles[k].x = (float)pos.X;
				particles[k].y = (float)pos.Y;
				particleIDMap[pos - partP] = k+1;
				particlesCount = ++k;
			}
		}
	}

	// load particle properties
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto i = particleIDMap[pos];
		if (i)
		{
			i--;
			if (p+1 >= dataLength)
				throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
			if (i < NPART)
			{
				particles[i].vx = (data[p++]-127.0f)/16.0f;
				particles[i].vy = (data[p++]-127.0f)/16.0f;
			}
			else
				p += 2;
		}
	}
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto i = particleIDMap[pos];
		if (i)
		{
			if (ver>=44) {
				if (p >= dataLength) {
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				}
				if (i <= NPART) {
					ttv = (data[p++])<<8;
					ttv |= (data[p++]);
					particles[i-1].life = ttv;
				} else {
					p+=2;
				}
			} else {
				if (p >= dataLength)
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				if (i <= NPART)
					particles[i-1].life = data[p++]*4;
				else
					p++;
			}
		}
	}
	if (ver>=44) {
		for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
		{
			auto i = particleIDMap[pos];
			if (i)
			{
				if (p >= dataLength) {
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				}
				if (i <= NPART) {
					ttv = (data[p++])<<8;
					ttv |= (data[p++]);
					particles[i-1].tmp = ttv;
					if (ver<53 && !particles[i-1].tmp)
						for (q = 0; q < NGOL; q++) {
							if (particles[i-1].type==builtinGol[q].oldtype && (builtinGol[q].ruleset >> 17)==0)
								particles[i-1].tmp = (builtinGol[q].ruleset >> 17)+1;
						}
					if (ver>=51 && ver<53 && particles[i-1].type==PT_PBCN)
					{
						particles[i-1].tmp2 = particles[i-1].tmp;
						particles[i-1].tmp = 0;
					}
				} else {
					p+=2;
				}
			}
		}
	}
	auto dataPlanePty = PlaneAdapter<PlaneBase<const unsigned char>>(partS, std::in_place, data + pty);
	if (ver>=53) {
		for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
		{
			auto i = particleIDMap[pos];
			ty = dataPlanePty[pos];
			if (i && (ty==PT_PBCN || (ty==PT_TRON && ver>=77)))
			{
				if (p >= dataLength)
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				if (i <= NPART)
					particles[i-1].tmp2 = data[p++];
				else
					p++;
			}
		}
	}
	//Read ALPHA component
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto i = particleIDMap[pos];
		if (i)
		{
			if (ver>=49) {
				if (p >= dataLength) {
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				}
				if (i <= NPART) {
					particles[i-1].dcolour = data[p++]<<24;
				} else {
					p++;
				}
			}
		}
	}
	//Read RED component
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto i = particleIDMap[pos];
		if (i)
		{
			if (ver>=49) {
				if (p >= dataLength) {
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				}
				if (i <= NPART) {
					particles[i-1].dcolour |= data[p++]<<16;
				} else {
					p++;
				}
			}
		}
	}
	//Read GREEN component
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto i = particleIDMap[pos];
		if (i)
		{
			if (ver>=49) {
				if (p >= dataLength) {
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				}
				if (i <= NPART) {
					particles[i-1].dcolour |= data[p++]<<8;
				} else {
					p++;
				}
			}
		}
	}
	//Read BLUE component
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto i = particleIDMap[pos];
		if (i)
		{
			if (ver>=49) {
				if (p >= dataLength) {
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				}
				if (i <= NPART) {
					particles[i-1].dcolour |= data[p++];
				} else {
					p++;
				}
			}
		}
	}
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto i = particleIDMap[pos];
		ty = dataPlanePty[pos];
		if (i)
		{
			if (ver>=34&&legacy_beta==0)
			{
				if (p >= dataLength)
				{
					throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
				}
				if (i <= NPART)
				{
					if (ver>=42) {
						if (new_format) {
							ttv = (data[p++])<<8;
							ttv |= (data[p++]);
							if (particles[i-1].type==PT_PUMP) {
								particles[i-1].temp = ttv + 0.15;//fix PUMP saved at 0, so that it loads at 0.
							} else {
								particles[i-1].temp = float(ttv);
							}
						} else {
							particles[i-1].temp = float((data[p++]*((MAX_TEMP+(-MIN_TEMP))/255))+MIN_TEMP);
						}
					} else {
						particles[i-1].temp = float(((data[p++]*((O_MAX_TEMP+(-O_MIN_TEMP))/255))+O_MIN_TEMP)+273);
					}
				}
				else
				{
					p++;
					if (new_format) {
						p++;
					}
				}
			}
			else
			{
				particles[i-1].temp = builtinElements[particles[i-1].type].DefaultProperties.temp;
			}
		}
	}
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		auto i = particleIDMap[pos];
		int gnum = 0;
		ty = dataPlanePty[pos];
		if (i && (ty==PT_CLNE || (ty==PT_PCLN && ver>=43) || (ty==PT_BCLN && ver>=44) || (ty==PT_SPRK && ver>=21) || (ty==PT_LAVA && ver>=34) || (ty==PT_PIPE && ver>=43) || (ty==PT_LIFE && ver>=51) || (ty==PT_PBCN && ver>=52) || (ty==PT_WIRE && ver>=55) || (ty==PT_STOR && ver>=59) || (ty==PT_CONV && ver>=60)))
		{
			if (p >= dataLength)
				throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
			if (i <= NPART)
				particles[i-1].ctype = data[p++];
			else
				p++;
		}
		// no more particle properties to load, so we can change type here without messing up loading
		if (i && i<=NPART)
		{
			if (ver<90 && particles[i-1].type == PT_PHOT)
			{
				particles[i-1].flags |= FLAG_PHOTDECO;
			}
			if (ver<79 && particles[i-1].type == PT_SPNG)
			{
				if (fabs(particles[i-1].vx)>0.0f || fabs(particles[i-1].vy)>0.0f)
					particles[i-1].flags |= FLAG_MOVABLE;
			}

			if (ver<48 && (ty==OLD_PT_WIND || (ty==PT_BRAY&&particles[i-1].life==0)))
			{
				// Replace invisible particles with something sensible and add decoration to hide it
				particles[i-1].dcolour = 0xFF000000;
				particles[i-1].type = PT_DMND;
			}
			if(ver<51 && ((ty>=78 && ty<=89) || (ty>=134 && ty<=146 && ty!=141))){
				//Replace old GOL
				particles[i-1].type = PT_LIFE;
				for (gnum = 0; gnum<NGOL; gnum++){
					if (ty==builtinGol[gnum].oldtype)
						particles[i-1].ctype = gnum;
				}
				ty = PT_LIFE;
			}
			if(ver<52 && (ty==PT_CLNE || ty==PT_PCLN || ty==PT_BCLN)){
				//Replace old GOL ctypes in clone
				for (gnum = 0; gnum<NGOL; gnum++){
					if (particles[i-1].ctype==builtinGol[gnum].oldtype)
					{
						particles[i-1].ctype = PT_LIFE;
						particles[i-1].tmp = gnum;
					}
				}
			}
			if (particles[i-1].type == PT_LIFE)
			{
				particles[i-1].tmp2 = particles[i-1].tmp;
				particles[i-1].tmp = 0;
				if (particles[i-1].ctype >= 0 && particles[i-1].ctype < NGOL)
				{
					if (!particles[i-1].dcolour)
						particles[i-1].dcolour = builtinGol[particles[i-1].ctype].colour.Pack();
					particles[i-1].tmp = builtinGol[particles[i-1].ctype].colour2.Pack();
				}
			}
			if(ty==PT_LCRY){
				if(ver<67)
				{
					//New LCRY uses TMP not life
					if(particles[i-1].life>=10)
					{
						particles[i-1].life = 10;
						particles[i-1].tmp2 = 10;
						particles[i-1].tmp = 3;
					}
					else if(particles[i-1].life<=0)
					{
						particles[i-1].life = 0;
						particles[i-1].tmp2 = 0;
						particles[i-1].tmp = 0;
					}
					else if(particles[i-1].life < 10 && particles[i-1].life > 0)
					{
						particles[i-1].tmp = 1;
					}
				}
				else
				{
					particles[i-1].tmp2 = particles[i-1].life;
				}
			}

			if (ver<81)
			{
				if (particles[i-1].type==PT_BOMB && particles[i-1].tmp!=0)
				{
					particles[i-1].type = PT_EMBR;
					particles[i-1].ctype = 0;
					if (particles[i-1].tmp==1)
						particles[i-1].tmp = 0;
				}
				if (particles[i-1].type==PT_DUST && particles[i-1].life>0)
				{
					particles[i-1].type = PT_EMBR;
					particles[i-1].ctype = (particles[i-1].tmp2<<16) | (particles[i-1].tmp<<8) | particles[i-1].ctype;
					particles[i-1].tmp = 1;
				}
				if (particles[i-1].type==PT_FIRW && particles[i-1].tmp>=2)
				{
					particles[i-1].type = PT_EMBR;
					particles[i-1].ctype = Renderer::firwTableAt(particles[i-1].tmp-4).Pack();
					particles[i-1].tmp = 1;
				}
			}
			if (ver < 89)
			{
				if (particles[i-1].type == PT_FILT)
				{
					if (particles[i-1].tmp<0 || particles[i-1].tmp>3)
						particles[i-1].tmp = 6;
					particles[i-1].ctype = 0;
				}
				else if (particles[i-1].type == PT_QRTZ || particles[i-1].type == PT_PQRT)
				{
					particles[i-1].tmp2 = particles[i-1].tmp;
					particles[i-1].tmp = particles[i-1].ctype;
					particles[i-1].ctype = 0;
				}
			}
			if (ver < 91)
			{
				if (particles[i-1].type == PT_VINE)
					particles[i-1].tmp = 1;
				else if (particles[i-1].type == PT_CONV)
				{
					if (particles[i-1].tmp)
					{
						particles[i-1].ctype |= particles[i-1].tmp<<8;
						particles[i-1].tmp = 0;
					}
				}
			}
			if (ver < 93)
			{
				if (particles[i-1].type == PT_PIPE || particles[i-1].type == PT_PPIP)
				{
					if (particles[i-1].ctype == 1)
						particles[i-1].tmp |= 0x00020000; //PFLAG_INITIALIZING
					particles[i-1].tmp |= (particles[i-1].ctype-1)<<18;
					particles[i-1].ctype = particles[i-1].tmp&0xFF;
				}
				else if (particles[i-1].type == PT_HSWC || particles[i-1].type == PT_PUMP)
				{
					particles[i-1].tmp = 0;
				}
			}
		}
	}

	if (p == dataLength) // no sign data, "version 1" PSv
		return;

	auto signCount = data[p++];
	for (auto i = 0; i < signCount; i++)
	{
		if (p+6 > dataLength)
			throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
		{
			int x = data[p++];
			x |= ((unsigned)data[p++])<<8;
			tempSign.x = x+partP.X;
		}
		{
			int y = data[p++];
			y |= ((unsigned)data[p++])<<8;
			tempSign.y = y+partP.Y;
		}
		{
			int ju = data[p++];
			tempSign.ju = (sign::Justification)ju;
		}
		{
			int l = data[p++];
			if (p+l > dataLength)
				throw ParseException(ParseException::Corrupt, "Not enough data at line " MTOS(__LINE__) " in " MTOS(__FILE__));
			if(l>254)
				l = 254;
			memcpy(tempSignText, &data[p], l);
			tempSignText[l] = 0;
			p += l;
		}
		tempSign.text = format::CleanString(ByteString(tempSignText).FromUtf8(), true, true, true).Substr(0, 45);
		if (tempSign.text == "{t}")
		{
			tempSign.text = "Temp: {t}";
		}
		else if (tempSign.text == "{p}")
		{
			tempSign.text = "Pressure: {p}";
		}
		tempSigns.push_back(tempSign);
	}

	for (size_t i = 0; i < tempSigns.size(); i++)
	{
		if(signs.size() == MAXSIGNS)
			break;
		signs.push_back(tempSigns[i]);
	}
}
#undef MTOS
#undef MTOS_EXPAND

std::pair<bool, std::vector<char>> GameSave::serialiseOPS() const
{
	if (blockSize.X > 255 || blockSize.Y > 255)
	{
		throw BuildException("simulation size not supported by the save format");
	}

	// minimum version this save is compatible with
	// when building, this number may be increased depending on what elements are used
	// or what properties are detected
	auto minimumVersion = Version(90, 2);
	auto RESTRICTVERSION = [&minimumVersion](auto major, auto minor = 0) {
		// restrict the minimum version this save can be opened with
		auto version = Version(major, minor);
		if (minimumVersion < version)
		{
			minimumVersion = version;
		}
	};

	//Get coords in blocks
	auto blockP = Vec2{ 0, 0 };

	//Snap full coords to block size
	auto partP = blockP * CELL;

	//Original size + offset of original corner from snapped corner, rounded up by adding CELL-1
	auto blockS = blockSize;
	auto partS = blockS * CELL;

	// Copy fan and wall data
	PlaneAdapter<std::vector<unsigned char>> wallData(blockSize);
	bool hasWallData = false;
	std::vector<unsigned char> fanData(blockSize.X*blockSize.Y*2);
	std::vector<unsigned char> pressData(blockSize.X*blockSize.Y*2);
	std::vector<unsigned char> vxData(blockSize.X*blockSize.Y*2);
	std::vector<unsigned char> vyData(blockSize.X*blockSize.Y*2);
	std::vector<unsigned char> ambientData(blockSize.X*blockSize.Y*2, 0);

	std::vector<unsigned char> blockAirData(blockSize.X * blockSize.Y * 2);
	PlaneAdapter<PlaneBase<unsigned char>> blockAirDataPlane (blockSize, std::in_place, blockAirData.data()                            );
	PlaneAdapter<PlaneBase<unsigned char>> blockAirhDataPlane(blockSize, std::in_place, blockAirData.data() + blockSize.X * blockSize.Y);

	std::vector<unsigned char> gravityData(blockSize.X * blockSize.Y * 4 * sizeof(float));
	PlaneAdapter<PlaneBase<float   >> massDataPlane  (blockSize, std::in_place, reinterpret_cast<float    *>(gravityData.data()                                                ));
	PlaneAdapter<PlaneBase<uint32_t>> maskDataPlane  (blockSize, std::in_place, reinterpret_cast<uint32_t *>(gravityData.data() +     blockSize.X * blockSize.Y * sizeof(float)));
	PlaneAdapter<PlaneBase<float   >> forceXDataPlane(blockSize, std::in_place, reinterpret_cast<float    *>(gravityData.data() + 2 * blockSize.X * blockSize.Y * sizeof(float)));
	PlaneAdapter<PlaneBase<float   >> forceYDataPlane(blockSize, std::in_place, reinterpret_cast<float    *>(gravityData.data() + 3 * blockSize.X * blockSize.Y * sizeof(float)));

	unsigned int wallDataLen = blockSize.X*blockSize.Y, fanDataLen = 0, pressDataLen = 0, vxDataLen = 0, vyDataLen = 0, ambientDataLen = 0;

	for (auto bpos : RectSized(blockP, blockS).Range<LEFT_TO_RIGHT, TOP_TO_BOTTOM>())
	{
		wallData[bpos - blockP] = blockMap[bpos];
		if (blockMap[bpos])
			hasWallData = true;

		if (hasPressure)
		{
			//save pressure and x/y velocity grids
			float pres = std::max(-255.0f,std::min(255.0f,pressure[bpos]))+256.0f;
			float velX = std::max(-255.0f,std::min(255.0f,velocityX[bpos]))+256.0f;
			float velY = std::max(-255.0f,std::min(255.0f,velocityY[bpos]))+256.0f;
			pressData[pressDataLen++] = (unsigned char)((int)(pres*128)&0xFF);
			pressData[pressDataLen++] = (unsigned char)((int)(pres*128)>>8);

			vxData[vxDataLen++] = (unsigned char)((int)(velX*128)&0xFF);
			vxData[vxDataLen++] = (unsigned char)((int)(velX*128)>>8);

			vyData[vyDataLen++] = (unsigned char)((int)(velY*128)&0xFF);
			vyData[vyDataLen++] = (unsigned char)((int)(velY*128)>>8);

			blockAirDataPlane [bpos - blockP] = blockAir [bpos];
			blockAirhDataPlane[bpos - blockP] = blockAirh[bpos];

			massDataPlane  [bpos - blockP] = gravMass  [bpos];
			maskDataPlane  [bpos - blockP] = gravMask  [bpos];
			forceXDataPlane[bpos - blockP] = gravForceX[bpos];
			forceYDataPlane[bpos - blockP] = gravForceY[bpos];
		}

		if (hasAmbientHeat)
		{
			int tempTemp = (int)(ambientHeat[bpos]+0.5f);
			ambientData[ambientDataLen++] = tempTemp;
			ambientData[ambientDataLen++] = tempTemp >> 8;
		}

		if (blockMap[bpos] == WL_FAN)
		{
			{
				auto i = (int)(fanVelX[bpos]*64.0f+127.5f);
				if (i<0) i=0;
				if (i>255) i=255;
				fanData[fanDataLen++] = i;
			}
			{
				auto i = (int)(fanVelY[bpos]*64.0f+127.5f);
				if (i<0) i=0;
				if (i>255) i=255;
				fanData[fanDataLen++] = i;
			}
		}
		else if (blockMap[bpos] == WL_STASIS)
		{
			RESTRICTVERSION(94, 0);
		}
	}

	//Index positions of all particles, using linked lists
	//partsPosFirstMap is pmap for the first particle in each position
	//partsPosLastMap is pmap for the last particle in each position
	//partsPosCount is the number of particles in each position
	//partsPosLink contains, for each particle, (i<<8)|1 of the next particle in the same position
	PlaneAdapter<std::vector<unsigned>> partsPosFirstMap(partS, 0);
	PlaneAdapter<std::vector<unsigned>> partsPosLastMap(partS, 0);
	PlaneAdapter<std::vector<unsigned>> partsPosCount(partS, 0);
	std::vector<unsigned> partsPosLink(NPART, 0);
	unsigned int soapCount = 0;
	for(auto i = 0; i < particlesCount; i++)
	{
		if(particles[i].type)
		{
			auto pos = Vec2{ (int)(particles[i].x+0.5f), (int)(particles[i].y+0.5f) };
			//Coordinates relative to top left corner of saved area
			if (!partsPosFirstMap[pos - partP])
			{
				//First entry in list
				partsPosFirstMap[pos - partP] = (i<<8)|1;
				partsPosLastMap[pos - partP] = (i<<8)|1;
			}
			else
			{
				//Add to end of list
				partsPosLink[partsPosLastMap[pos - partP]>>8] = (i<<8)|1;//link to current end of list
				partsPosLastMap[pos - partP] = (i<<8)|1;//set as new end of list
			}
			partsPosCount[pos - partP]++;
		}
	}

	//Store number of particles in each position
	std::vector<unsigned char> partsPosData(partS.X * partS.Y * 3);
	unsigned int partsPosDataLen = 0;
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		unsigned int posCount = partsPosCount[pos];
		partsPosData[partsPosDataLen++] = (posCount&0x00FF0000)>>16;
		partsPosData[partsPosDataLen++] = (posCount&0x0000FF00)>>8;
		partsPosData[partsPosDataLen++] = (posCount&0x000000FF);
	}

	//Copy parts data
	/* Field descriptor [1+2] format:
	 |      15      |      14       |      13       |      12       |      11       |      10       |       9       |       8       |       7       |       6       |       5       |       4       |       3       |       2       |       1       |       0       |
	 |  fieldDesc3  |    type[2]    |  tmp3/4[1+2]  |   tmp[3+4]    |   tmp2[2]     |     tmp2      |   ctype[2]    |      vy       |      vx       |  decorations  |   ctype[1]    |    tmp[2]     |    tmp[1]     |    life[2]    |    life[1]    | temp dbl len  |
	 life[2] means a second byte (for a 16 bit field) if life[1] is present
	 fieldDesc3 means Field descriptor [3] exists
	   Field descriptor [3] format:
	 |      23      |      22       |      21       |      20       |      19       |      18       |      17       |      16       |
	 |   RESERVED   |     FREE      |     FREE      |     FREE      |     FREE      |     FREE      |     FREE      |  tmp3/4[3+4]  |
	 last bit is reserved. If necessary, use it to signify that fieldDescriptor will have another byte
	 That way, if we ever need a 25th bit, we won't have to change the save format
	 */

	auto &builtinElements = GetElements();
	auto &possiblyCarriesType = Particle::PossiblyCarriesType();
	auto &properties = Particle::GetProperties();
	// Allocate enough space to store all Particles and 3 bytes on top of that per Particle, for the field descriptors.
	// In practice, a Particle will never need as much space in the save as in memory; this is just an upper bound to simplify allocation.
	std::vector<unsigned char> partsData(NPART * (sizeof(Particle)+3));
	unsigned int partsDataLen = 0;
	std::vector<unsigned> partsSaveIndex(NPART);
	unsigned int partsCount = 0;
	std::fill(partsSaveIndex.data(), partsSaveIndex.data() + NPART, 0);
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	std::set<int> paletteSet;
	for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
	{
		//Find the first particle in this position
		auto i = partsPosFirstMap[pos];

		//Loop while there is a pmap entry
		while (i)
		{
			unsigned int fieldDesc = 0;
			int tempTemp, vTemp;

			//Turn pmap entry into a particles index
			i = i>>8;

			//Store saved particle index+1 for this partsptr index (0 means not saved)
			partsSaveIndex[i] = (partsCount++) + 1;

			auto part = particles[i];
			paletteSet.insert(part.type);
			for (auto index : possiblyCarriesType)
			{
				if (elements[part.type].CarriesTypeIn & (1U << index))
				{
					auto *prop = reinterpret_cast<int *>(reinterpret_cast<char *>(&part) + properties[index].Offset);
					if (sd.IsElement(TYP(*prop)))
					{
						paletteSet.insert(TYP(*prop));
					}
					else
					{
						*prop = PMAP(ID(*prop), 0);
					}
				}
			}

			//Type (required)
			partsData[partsDataLen++] = part.type;

			//Location of the field descriptor
			int fieldDesc3Loc = 0;
			int fieldDescLoc = partsDataLen++;
			partsDataLen++;

			auto tmp3 = (unsigned int)(part.tmp3);
			auto tmp4 = (unsigned int)(part.tmp4);
			if ((tmp3 || tmp4) && (!PressureInTmp3(part.type) || hasPressure))
			{
				fieldDesc |= 1 << 13;
				// The tmp3 of PressureInTmp3 elements is okay to truncate because the loading code
				// sign extends it anyway, expecting the value to not be higher in magnitude than
				// 256 (max pressure value) * 64 (tmp3 multiplicative bias).
				if (((tmp3 >> 16) || (tmp4 >> 16)) && !PressureInTmp3(part.type))
				{
					fieldDesc |= 1 << 15;
					fieldDesc |= 1 << 16;
					RESTRICTVERSION(97, 0);
				}
			}

			// Extra type byte if necessary
			if (part.type & 0xFF00)
			{
				partsData[partsDataLen++] = part.type >> 8;
				fieldDesc |= 1 << 14;
				RESTRICTVERSION(93, 0);
			}

			//Extra Temperature (2nd byte optional, 1st required), 1 to 2 bytes
			//Store temperature as an offset of 21C(294.15K) or go into a 16byte int and store the whole thing
			if(fabs(part.temp-294.15f)<127)
			{
				tempTemp = int(floor(part.temp-294.15f+0.5f));
				partsData[partsDataLen++] = tempTemp;
			}
			else
			{
				fieldDesc |= 1;
				tempTemp = (int)(part.temp+0.5f);
				partsData[partsDataLen++] = tempTemp;
				partsData[partsDataLen++] = tempTemp >> 8;
			}

			if (fieldDesc & (1 << 15))
			{
				fieldDesc3Loc = partsDataLen++;
			}

			//Life (optional), 1 to 2 bytes
			if(part.life)
			{
				int life = part.life;
				if (life > 0xFFFF)
					life = 0xFFFF;
				else if (life < 0)
					life = 0;
				fieldDesc |= 1 << 1;
				partsData[partsDataLen++] = life;
				if (life & 0xFF00)
				{
					fieldDesc |= 1 << 2;
					partsData[partsDataLen++] = life >> 8;
				}
			}

			//Tmp (optional), 1, 2, or 4 bytes
			if(part.tmp)
			{
				fieldDesc |= 1 << 3;
				partsData[partsDataLen++] = part.tmp;
				if(part.tmp & 0xFFFFFF00)
				{
					fieldDesc |= 1 << 4;
					partsData[partsDataLen++] = part.tmp >> 8;
					if(part.tmp & 0xFFFF0000)
					{
						fieldDesc |= 1 << 12;
						partsData[partsDataLen++] = (part.tmp&0xFF000000)>>24;
						partsData[partsDataLen++] = (part.tmp&0x00FF0000)>>16;
					}
				}
			}

			//Ctype (optional), 1 or 4 bytes
			if(part.ctype)
			{
				fieldDesc |= 1 << 5;
				partsData[partsDataLen++] = part.ctype;
				if(part.ctype & 0xFFFFFF00)
				{
					fieldDesc |= 1 << 9;
					partsData[partsDataLen++] = (part.ctype&0xFF000000)>>24;
					partsData[partsDataLen++] = (part.ctype&0x00FF0000)>>16;
					partsData[partsDataLen++] = (part.ctype&0x0000FF00)>>8;
				}
			}

			//Dcolour (optional), 4 bytes
			if(part.dcolour && (part.dcolour & 0xFF000000 || part.type == PT_LIFE))
			{
				fieldDesc |= 1 << 6;
				partsData[partsDataLen++] = (part.dcolour&0xFF000000)>>24;
				partsData[partsDataLen++] = (part.dcolour&0x00FF0000)>>16;
				partsData[partsDataLen++] = (part.dcolour&0x0000FF00)>>8;
				partsData[partsDataLen++] = (part.dcolour&0x000000FF);
			}

			//VX (optional), 1 byte
			if(fabs(part.vx) > 0.001f)
			{
				fieldDesc |= 1 << 7;
				vTemp = (int)(part.vx*16.0f+127.5f);
				if (vTemp<0) vTemp=0;
				if (vTemp>255) vTemp=255;
				partsData[partsDataLen++] = vTemp;
			}

			//VY (optional), 1 byte
			if(fabs(part.vy) > 0.001f)
			{
				fieldDesc |= 1 << 8;
				vTemp = (int)(part.vy*16.0f+127.5f);
				if (vTemp<0) vTemp=0;
				if (vTemp>255) vTemp=255;
				partsData[partsDataLen++] = vTemp;
			}

			//Tmp2 (optional), 1 or 2 bytes
			if(part.tmp2)
			{
				fieldDesc |= 1 << 10;
				partsData[partsDataLen++] = part.tmp2;
				if(part.tmp2 & 0xFF00)
				{
					fieldDesc |= 1 << 11;
					partsData[partsDataLen++] = part.tmp2 >> 8;
				}
			}

			//tmp3 and tmp4, 4 bytes
			if (fieldDesc & (1 << 13))
			{
				partsData[partsDataLen++] = tmp3     ;
				partsData[partsDataLen++] = tmp3 >> 8;
				partsData[partsDataLen++] = tmp4     ;
				partsData[partsDataLen++] = tmp4 >> 8;
				if (fieldDesc & (1 << 16))
				{
					partsData[partsDataLen++] = tmp3 >> 16;
					partsData[partsDataLen++] = tmp3 >> 24;
					partsData[partsDataLen++] = tmp4 >> 16;
					partsData[partsDataLen++] = tmp4 >> 24;
				}
			}

			//Write the field descriptor
			partsData[fieldDescLoc] = fieldDesc;
			partsData[fieldDescLoc+1] = fieldDesc>>8;
			if (fieldDesc & (1 << 15))
			{
				partsData[fieldDesc3Loc] = fieldDesc>>16;
			}

			if (part.type == PT_SOAP)
				soapCount++;

			if (part.type == PT_RPEL && part.ctype)
			{
				RESTRICTVERSION(91, 4);
			}
			else if (part.type == PT_NWHL && part.tmp)
			{
				RESTRICTVERSION(91, 5);
			}
			if (part.type == PT_HEAC || part.type == PT_SAWD || part.type == PT_POLO
					|| part.type == PT_RFRG || part.type == PT_RFGL || part.type == PT_LSNS)
			{
				RESTRICTVERSION(92, 0);
			}
			else if ((part.type == PT_FRAY || part.type == PT_INVIS) && part.tmp)
			{
				RESTRICTVERSION(92, 0);
			}
			else if (part.type == PT_PIPE || part.type == PT_PPIP)
			{
				RESTRICTVERSION(93, 0);
			}
			if (part.type == PT_TSNS || part.type == PT_PSNS
			        || part.type == PT_HSWC || part.type == PT_PUMP)
			{
				if (part.tmp == 1)
				{
					RESTRICTVERSION(93, 0);
				}
			}
			if (PMAPBITS > 8)
			{
				for (auto index : possiblyCarriesType)
				{
					if (builtinElements[part.type].CarriesTypeIn & (1U << index))
					{
						auto *prop = reinterpret_cast<const int *>(reinterpret_cast<const char *>(&part) + properties[index].Offset);
						if (TYP(*prop) > 0xFF)
						{
							RESTRICTVERSION(93, 0);
						}
					}
				}
			}
			if (part.type == PT_LDTC)
			{
				RESTRICTVERSION(94, 0);
			}
			if (part.type == PT_TSNS || part.type == PT_PSNS)
			{
				if (part.tmp == 2)
				{
					RESTRICTVERSION(94, 0);
				}
			}
			if (part.type == PT_LSNS)
			{
				if (part.tmp >= 1 && part.tmp <= 3)
				{
					RESTRICTVERSION(95, 0);
				}
			}
			if (part.type == PT_LIFE)
			{
				RESTRICTVERSION(96, 0);
			}
			if (part.type == PT_GLAS && part.life > 0)
			{
				RESTRICTVERSION(97, 0);
			}
			if (PressureInTmp3(part.type))
			{
				RESTRICTVERSION(97, 0);
			}
			if (part.type == PT_CONV && part.tmp2 != 0)
			{
				RESTRICTVERSION(97, 0);
			}
			if (part.type == PT_RSST || part.type == PT_RSSS)
			{
				RESTRICTVERSION(98, 0);
			}
			if (part.type == PT_ETRD && (part.tmp || part.tmp2))
			{
				RESTRICTVERSION(98, 0);
			}

			//Get the pmap entry for the next particle in the same position
			i = partsPosLink[i];
		}
	}

	std::vector<PaletteItem> paletteData;
	for (int ID : paletteSet)
	{
		paletteData.push_back(GameSave::PaletteItem(elements[ID].Identifier, ID));
	}

	unsigned int soapLinkDataLen = 0;
	std::vector<unsigned char> soapLinkData(3*soapCount);
	if (soapCount)
	{

		//Iterate through particles in the same order that they were saved
		for (auto pos : partS.OriginRect().Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
		{
			//Find the first particle in this position
			auto i = partsPosFirstMap[pos];

			//Loop while there is a pmap entry
			while (i)
			{
				//Turn pmap entry into a partsptr index
				i = i>>8;

				if (particles[i].type==PT_SOAP)
				{
					//Only save forward link for each particle, back links can be deduced from other forward links
					//linkedIndex is index within saved particles + 1, 0 means not saved or no link

					unsigned linkedIndex = 0;
					if ((particles[i].ctype&2) && particles[i].tmp>=0 && particles[i].tmp<NPART)
					{
						linkedIndex = partsSaveIndex[particles[i].tmp];
					}
					soapLinkData[soapLinkDataLen++] = (linkedIndex&0xFF0000)>>16;
					soapLinkData[soapLinkDataLen++] = (linkedIndex&0x00FF00)>>8;
					soapLinkData[soapLinkDataLen++] = (linkedIndex&0x0000FF);
				}

				//Get the pmap entry for the next particle in the same position
				i = partsPosLink[i];
			}
		}
	}

	for (size_t i = 0; i < signs.size(); i++)
	{
		if(signs[i].text.length() && partS.OriginRect().Contains({ signs[i].x, signs[i].y }))
		{
			int x, y, w, h;
			bool v95 = false;
			signs[i].getDisplayText(nullptr, x, y, w, h, true, &v95);
			if (v95)
			{
				RESTRICTVERSION(95, 0);
			}
		}
	}

	bson b;
	b.data = nullptr;
	auto bson_deleter = [](bson * b) { bson_destroy(b); };
	// Use unique_ptr with a custom deleter to ensure that bson_destroy is called even when an exception is thrown
	std::unique_ptr<bson, decltype(bson_deleter)> b_ptr(&b, bson_deleter);

	set_bson_err_handler([](const char* err) { throw BuildException("BSON error when parsing save: " + ByteString(err).FromUtf8()); });
	bson_init(&b);
	bson_append_start_object(&b, "origin");
	bson_append_int(&b, "majorVersion", int(effectiveVersion[0]));
	bson_append_int(&b, "minorVersion", int(effectiveVersion[1]));
	bson_append_int(&b, "buildNum", APP_VERSION.build);
	bson_append_int(&b, "modId", MOD_ID);
	bson_append_string(&b, "releaseType", ByteString(1, IDENT_RELTYPE).c_str());
	bson_append_string(&b, "platform", IDENT_PLATFORM);
	bson_append_string(&b, "ident", IDENT);
	bson_append_finish_object(&b);
	if (gravityMode == GRAV_CUSTOM)
	{
		bson_append_double(&b, "customGravityX", double(customGravityX));
		bson_append_double(&b, "customGravityY", double(customGravityY));
		RESTRICTVERSION(97, 0);
	}
	bson_append_start_object(&b, "minimumVersion");
	bson_append_int(&b, "major", int(minimumVersion[0]));
	bson_append_int(&b, "minor", int(minimumVersion[1]));
	bson_append_finish_object(&b);


	bson_append_bool(&b, "waterEEnabled", waterEEnabled);
	bson_append_bool(&b, "legacyEnable", legacyEnable);
	bson_append_bool(&b, "gravityEnable", gravityEnable);
	bson_append_bool(&b, "aheat_enable", aheatEnable);
	bson_append_bool(&b, "paused", paused);
	bson_append_int(&b, "gravityMode", gravityMode);
	bson_append_int(&b, "airMode", airMode);
	if (fabsf(ambientAirTemp - (R_TEMP + 273.15f)) > 0.0001f)
	{
		bson_append_double(&b, "ambientAirTemp", double(ambientAirTemp));
		RESTRICTVERSION(96, 0);
	}
	bson_append_int(&b, "edgeMode", edgeMode);

	if (stkm.hasData())
	{
		bson_append_start_object(&b, "stkm");
		if (stkm.rocketBoots1)
			bson_append_bool(&b, "rocketBoots1", stkm.rocketBoots1);
		if (stkm.rocketBoots2)
			bson_append_bool(&b, "rocketBoots2", stkm.rocketBoots2);
		if (stkm.fan1)
			bson_append_bool(&b, "fan1", stkm.fan1);
		if (stkm.fan2)
			bson_append_bool(&b, "fan2", stkm.fan2);
		if (stkm.rocketBootsFigh.size())
		{
			bson_append_start_array(&b, "rocketBootsFigh");
			for (unsigned int fighNum : stkm.rocketBootsFigh)
				bson_append_int(&b, "num", fighNum);
			bson_append_finish_array(&b);
		}
		if (stkm.fanFigh.size())
		{
			bson_append_start_array(&b, "fanFigh");
			for (unsigned int fighNum : stkm.fanFigh)
				bson_append_int(&b, "num", fighNum);
			bson_append_finish_array(&b);
		}
		bson_append_finish_object(&b);
	}

	bson_append_int(&b, "pmapbits", pmapbits);
	if (partsDataLen)
	{
		bson_append_binary(&b, "parts", (char)BSON_BIN_USER, reinterpret_cast<const char *>(partsData.data()), partsDataLen);

		if (paletteData.size())
		{
			bson_append_start_array(&b, "palette");
			for(auto iter = paletteData.begin(), end = paletteData.end(); iter != end; ++iter)
			{
				bson_append_int(&b, (*iter).first.c_str(), (*iter).second);
			}
			bson_append_finish_array(&b);
		}

		if (partsPosDataLen)
			bson_append_binary(&b, "partsPos", (char)BSON_BIN_USER, reinterpret_cast<const char *>(partsPosData.data()), partsPosDataLen);
	}
	if (hasWallData)
		bson_append_binary(&b, "wallMap", (char)BSON_BIN_USER, (const char *)wallData.data(), wallDataLen);
	if (fanDataLen)
		bson_append_binary(&b, "fanMap", (char)BSON_BIN_USER, reinterpret_cast<const char *>(fanData.data()), fanDataLen);
	if (hasPressure && pressDataLen)
		bson_append_binary(&b, "pressMap", (char)BSON_BIN_USER, reinterpret_cast<const char *>(pressData.data()), pressDataLen);
	if (hasPressure && vxDataLen)
		bson_append_binary(&b, "vxMap", (char)BSON_BIN_USER, reinterpret_cast<const char *>(vxData.data()), vxDataLen);
	if (hasPressure && vyDataLen)
		bson_append_binary(&b, "vyMap", (char)BSON_BIN_USER, reinterpret_cast<const char *>(vyData.data()), vyDataLen);
	if (hasAmbientHeat && this->aheatEnable && ambientDataLen)
		bson_append_binary(&b, "ambientMap", (char)BSON_BIN_USER, reinterpret_cast<const char *>(ambientData.data()), ambientDataLen);
	if (soapLinkDataLen)
		bson_append_binary(&b, "soapLinks", (char)BSON_BIN_USER, reinterpret_cast<const char *>(soapLinkData.data()), soapLinkDataLen);
	bson_append_binary(&b, "blockAir", (char)BSON_BIN_USER, reinterpret_cast<const char *>(blockAirData.data()), blockAirData.size());
	if (ensureDeterminism)
	{
		bson_append_bool(&b, "ensureDeterminism", ensureDeterminism);
		bson_append_long(&b, "frameCount", int64_t(frameCount));
		bson_append_binary(&b, "rngState", (char)BSON_BIN_USER, reinterpret_cast<const char *>(&rngState), sizeof(rngState));
		RESTRICTVERSION(98, 0);
	}
	if (gravityEnable)
	{
		bson_append_binary(&b, "gravity", (char)BSON_BIN_USER, reinterpret_cast<const char *>(gravityData.data()), gravityData.size());
	}
	unsigned int signsCount = 0;
	for (size_t i = 0; i < signs.size(); i++)
	{
		if(signs[i].text.length() && partS.OriginRect().Contains({ signs[i].x, signs[i].y }))
		{
			signsCount++;
		}
	}
	if (signsCount)
	{
		bson_append_start_array(&b, "signs");
		for (size_t i = 0; i < signs.size(); i++)
		{
			if(signs[i].text.length() && partS.OriginRect().Contains({ signs[i].x, signs[i].y }))
			{
				bson_append_start_object(&b, "sign");
				bson_append_string(&b, "text", signs[i].text.ToUtf8().c_str());
				bson_append_int(&b, "justification", signs[i].ju);
				bson_append_int(&b, "x", signs[i].x);
				bson_append_int(&b, "y", signs[i].y);
				bson_append_finish_object(&b);
			}
		}
		bson_append_finish_array(&b);
	}
	if (authors.size())
	{
		bson_append_start_object(&b, "authors");
		ConvertJsonToBson(&b, authors);
		bson_append_finish_object(&b);
	}
	if (bson_finish(&b) == BSON_ERROR)
		throw BuildException("Error building bson data");

	unsigned char *finalData = (unsigned char*)bson_data(&b);
	unsigned int finalDataLen = bson_size(&b);


	std::vector<char> outputData;
	switch (auto status = BZ2WCompress(outputData, std::span(reinterpret_cast<const char *>(finalData), finalDataLen)))
	{
	case BZ2WCompressOk: break;
	case BZ2WCompressNomem: throw BuildException(String::Build("Save error, out of memory"));
	default: throw BuildException(String::Build("Cannot compress: status ", int(status)));
	}
	auto compressedSize = int(outputData.size());

	if constexpr (DEBUG)
	{
		printf("compressed data: %d\n", compressedSize);
	}
	outputData.resize(compressedSize + 12);

	auto header = (unsigned char *)&outputData[compressedSize];
	header[0] = 'O';
	header[1] = 'P';
	header[2] = 'S';
	header[3] = '1';
	header[4] = effectiveVersion[0];
	header[5] = CELL;
	header[6] = blockS.X;
	header[7] = blockS.Y;
	header[8] = finalDataLen;
	header[9] = finalDataLen >> 8;
	header[10] = finalDataLen >> 16;
	header[11] = finalDataLen >> 24;

	// move header to front
	std::rotate(outputData.begin(), outputData.begin() + compressedSize, outputData.end());

	// Mark save as incompatible with latest release
	bool fakeFromNewerVersion = ALLOW_FAKE_NEWER_VERSION && currentVersion < minimumVersion;
	return { fakeFromNewerVersion, outputData };
}

static void ConvertBsonToJson(bson_iterator *iter, Json::Value *j, int depth)
{
	bson_iterator subiter;
	bson_iterator_subiterator(iter, &subiter);
	while (bson_iterator_next(&subiter))
	{
		ByteString key = bson_iterator_key(&subiter);
		if (bson_iterator_type(&subiter) == BSON_STRING)
			(*j)[key] = bson_iterator_string(&subiter);
		else if (bson_iterator_type(&subiter) == BSON_BOOL)
			(*j)[key] = bson_iterator_bool(&subiter);
		else if (bson_iterator_type(&subiter) == BSON_INT)
			(*j)[key] = bson_iterator_int(&subiter);
		else if (bson_iterator_type(&subiter) == BSON_LONG)
			(*j)[key] = (Json::Value::UInt64)bson_iterator_long(&subiter);
		else if (bson_iterator_type(&subiter) == BSON_ARRAY && depth < 5)
		{
			bson_iterator arrayiter;
			bson_iterator_subiterator(&subiter, &arrayiter);
			int length = 0, length2 = 0;
			while (bson_iterator_next(&arrayiter))
			{
				if (bson_iterator_type(&arrayiter) == BSON_OBJECT && !strcmp(bson_iterator_key(&arrayiter), "part"))
				{
					Json::Value tempPart;
					ConvertBsonToJson(&arrayiter, &tempPart, depth + 1);
					(*j)["links"].append(tempPart);
					length++;
				}
				else if (bson_iterator_type(&arrayiter) == BSON_INT && !strcmp(bson_iterator_key(&arrayiter), "saveID"))
				{
					(*j)["links"].append(bson_iterator_int(&arrayiter));
				}
				length2++;
				if (length > (int)(40 / ((depth+1) * (depth+1))) || length2 > 50)
					break;
			}
		}
	}
}

std::set<int> GetNestedSaveIDs(Json::Value j)
{
	Json::Value::Members members = j.getMemberNames();
	std::set<int> saveIDs = std::set<int>();
	for (Json::Value::Members::iterator iter = members.begin(), end = members.end(); iter != end; ++iter)
	{
		ByteString member = *iter;
		if (member == "id" && j[member].isInt())
			saveIDs.insert(j[member].asInt());
		else if (j[member].isArray())
		{
			for (Json::Value::ArrayIndex i = 0; i < j[member].size(); i++)
			{
				// only supports objects and ints here because that is all we need
				if (j[member][i].isInt())
				{
					saveIDs.insert(j[member][i].asInt());
					continue;
				}
				if (!j[member][i].isObject())
					continue;
				std::set<int> nestedSaveIDs = GetNestedSaveIDs(j[member][i]);
				saveIDs.insert(nestedSaveIDs.begin(), nestedSaveIDs.end());
			}
		}
	}
	return saveIDs;
}

// converts a json object to bson
static void ConvertJsonToBson(bson *b, Json::Value j, int depth)
{
	Json::Value::Members members = j.getMemberNames();
	for (Json::Value::Members::iterator iter = members.begin(), end = members.end(); iter != end; ++iter)
	{
		ByteString member = *iter;
		if (j[member].isString())
			bson_append_string(b, member.c_str(), j[member].asCString());
		else if (j[member].isBool())
			bson_append_bool(b, member.c_str(), j[member].asBool());
		else if (j[member].type() == Json::intValue)
			bson_append_int(b, member.c_str(), j[member].asInt());
		else if (j[member].type() == Json::uintValue)
			bson_append_long(b, member.c_str(), j[member].asInt64());
		else if (j[member].isArray())
		{
			bson_append_start_array(b, member.c_str());
			std::set<int> saveIDs = std::set<int>();
			int length = 0;
			for (Json::Value::ArrayIndex i = 0; i < j[member].size(); i++)
			{
				// only supports objects and ints here because that is all we need
				if (j[member][i].isInt())
				{
					saveIDs.insert(j[member][i].asInt());
					continue;
				}
				if (!j[member][i].isObject())
					continue;
				if (depth > 4 || length > (int)(40 / ((depth+1) * (depth+1))))
				{
					std::set<int> nestedSaveIDs = GetNestedSaveIDs(j[member][i]);
					saveIDs.insert(nestedSaveIDs.begin(), nestedSaveIDs.end());
				}
				else
				{
					bson_append_start_object(b, "part");
					ConvertJsonToBson(b, j[member][i], depth+1);
					bson_append_finish_object(b);
				}
				length++;
			}
			for (std::set<int>::iterator iter = saveIDs.begin(), end = saveIDs.end(); iter != end; ++iter)
			{
				bson_append_int(b, "saveID", *iter);
			}
			bson_append_finish_array(b);
		}
	}
}

bool GameSave::PressureInTmp3(int type)
{
	return type == PT_QRTZ || type == PT_GLAS || type == PT_TUNG;
}

GameSave& GameSave::operator << (Particle &v)
{
	if(particlesCount<NPART && v.type)
	{
		particles[particlesCount++] = v;
	}
	return *this;
}

GameSave& GameSave::operator << (sign &v)
{
	if(signs.size()<MAXSIGNS && v.text.length())
		signs.push_back(v);
	return *this;
}


=== src\client\GameSave.h ===

#pragma once
#include "common/Plane.h"
#include "common/String.h"
#include "common/tpt-rand.h"
#include "common/Version.h"
#include "simulation/Sign.h"
#include "simulation/Particle.h"
#include "simulation/MissingElements.h"
#include "simulation/gravity/GravityData.h"
#include "Misc.h"
#include "SimulationConfig.h"
#include <vector>
#include <array>
#include <json/json.h>

struct sign;
struct Particle;

struct ParseException: public std::exception {
	enum ParseResult { OK = 0, Corrupt, WrongVersion, InvalidDimensions, InternalError, MissingElement };
	ByteString message;
	ParseResult result;
public:
	ParseException(ParseResult result, String message): message(message.ToUtf8()), result(result) {}
	const char * what() const throw() override
	{
		return message.c_str();
	}
	~ParseException() throw() {}
};

struct BuildException: public std::exception {
	ByteString message;
public:
	BuildException(String message): message(message.ToUtf8()) {}
	const char * what() const throw() override
	{
		return message.c_str();
	}
	~BuildException() throw() {}
};

class StkmData
{
public:
	bool rocketBoots1 = false;
	bool rocketBoots2 = false;
	bool fan1 = false;
	bool fan2 = false;
	std::vector<unsigned int> rocketBootsFigh;
	std::vector<unsigned int> fanFigh;

	bool hasData() const
	{
		return rocketBoots1 || rocketBoots2 || fan1 || fan2
		        || rocketBootsFigh.size() || fanFigh.size();
	}
};

class GameSave
{
	// number of pixels translated. When translating CELL pixels, shift all CELL grids
	void readOPS(const std::vector<char> &data);
	void readPSv(const std::vector<char> &data);
	std::pair<bool, std::vector<char>> serialiseOPS() const;

	void MapPalette();

public:
	Vec2<int> blockSize = { 0, 0 };
	bool fromNewerVersion = false;
	Version<2> version{};
	bool hasPressure = false;
	bool hasAmbientHeat = false;
	bool hasBlockAirMaps = false;
	bool hasGravityMaps = false;
	bool ensureDeterminism = false; // only taken seriously by serializeOPS; readOPS may set this even if the save does not have everything required for determinism
	bool hasRngState = false; // only written by readOPS, never read
	RNG::State rngState;
	uint64_t frameCount = 0;

	//Simulation data
	int particlesCount = 0;
	std::vector<Particle> particles;
	PlaneAdapter<std::vector<unsigned char>> blockMap;
	PlaneAdapter<std::vector<float>> fanVelX;
	PlaneAdapter<std::vector<float>> fanVelY;
	PlaneAdapter<std::vector<float>> pressure;
	PlaneAdapter<std::vector<float>> velocityX;
	PlaneAdapter<std::vector<float>> velocityY;
	PlaneAdapter<std::vector<float>> ambientHeat;
	PlaneAdapter<std::vector<unsigned char>> blockAir;
	PlaneAdapter<std::vector<unsigned char>> blockAirh;
	PlaneAdapter<std::vector<float>> gravMass;
	PlaneAdapter<std::vector<uint32_t>> gravMask;
	PlaneAdapter<std::vector<float>> gravForceX;
	PlaneAdapter<std::vector<float>> gravForceY;

	//Simulation Options
	bool waterEEnabled = false;
	bool legacyEnable = false;
	bool gravityEnable = false;
	bool aheatEnable = false;
	bool paused = false;
	int gravityMode = 0;
	float customGravityX = 0.0f;
	float customGravityY = 0.0f;
	int airMode = 0;
	float ambientAirTemp = R_TEMP + 273.15f;
	int edgeMode = 0;
	bool wantAuthors = true;

	MissingElements missingElements;

	//Signs
	std::vector<sign> signs;
	StkmData stkm;

	//Element palette
	typedef std::pair<ByteString, int> PaletteItem;
	std::vector<PaletteItem> palette;

	// author information
	Json::Value authors;

	int pmapbits = 8; // default to 8 bits for older saves

	GameSave(Vec2<int> newBlockSize);
	GameSave(const std::vector<char> &data, bool newWantAuthors = true);
	void setSize(Vec2<int> newBlockSize);
	// return value is [ fakeFromNewerVersion, gameData ]
	std::pair<bool, std::vector<char>> Serialise() const;
	void Transform(Mat2<int> transform, Vec2<int> nudge);

	void Expand(const std::vector<char> &data);

	static bool PressureInTmp3(int type);

	GameSave& operator << (Particle &v);
	GameSave& operator << (sign &v);
};


=== src\client\LoginInfo.h ===

#pragma once
#include "User.h"
#include "ServerNotification.h"
#include <vector>

struct LoginInfo
{
	User user;
	std::vector<ServerNotification> notifications;
};


=== src\client\meson.build ===

client_files = files(
	'SaveFile.cpp',
	'SaveInfo.cpp',
	'ThumbnailRendererTask.cpp',
	'Client.cpp',
	'GameSave.cpp',
	'User.cpp',
)
if host_platform == 'emscripten'
	client_files += files('AuthUserEmscripten.cpp')
else
	client_files += files('AuthUserCommon.cpp')
endif

subdir('http')

powder_files += client_files

render_files += files(
	'GameSave.cpp',
)


=== src\client\SaveFile.cpp ===

#include "SaveFile.h"
#include "GameSave.h"
#include "common/platform/Platform.h"

SaveFile::SaveFile(ByteString filename, bool newLazyLoad):
	filename(filename),
	displayName(filename.FromUtf8()),
	loadingError(""),
	lazyLoad(newLazyLoad)
{

}

const GameSave *SaveFile::LazyGetGameSave() // non-owning
{
	if (!gameSave && !loadingError.size() && lazyLoad)
	{
		try
		{
			std::vector<char> data;
			if (Platform::ReadFile(data, filename))
			{
				gameSave = std::make_unique<GameSave>(std::move(data));
			}
			else
			{
				loadingError = "cannot access file";
			}
		}
		catch(std::exception & e)
		{
			loadingError = ByteString(e.what()).FromUtf8();
		}
	}
	return gameSave.get();
}

const GameSave *SaveFile::GetGameSave() const
{
	return gameSave.get();
}

std::unique_ptr<GameSave> SaveFile::TakeGameSave()
{
	return std::move(gameSave);
}

void SaveFile::LazyUnload()
{
	if (lazyLoad)
	{
		gameSave.reset();
	}
}

void SaveFile::SetGameSave(std::unique_ptr<GameSave> newGameSave)
{
	gameSave = std::move(newGameSave);
}

const ByteString &SaveFile::GetName() const
{
	return filename;
}

void SaveFile::SetFileName(ByteString fileName)
{
	this->filename = fileName;
}

const String &SaveFile::GetDisplayName() const
{
	return displayName;
}

void SaveFile::SetDisplayName(String displayName)
{
	this->displayName = displayName;
}

const String &SaveFile::GetError() const
{
	return loadingError;
}

void SaveFile::SetLoadingError(String error)
{
	loadingError = error;
}


=== src\client\SaveFile.h ===

#pragma once
#include "common/String.h"
#include <memory>

class GameSave;

class SaveFile {
public:
	SaveFile(ByteString filename, bool newLazyLoad = false);

	const GameSave *LazyGetGameSave();
	const GameSave *GetGameSave() const;
	std::unique_ptr<GameSave> TakeGameSave();
	void SetGameSave(std::unique_ptr<GameSave> newSameSave);
	const String &GetDisplayName() const;
	void SetDisplayName(String displayName);
	const ByteString &GetName() const;
	void SetFileName(ByteString fileName);
	const String &GetError() const;
	void SetLoadingError(String error);

	void LazyUnload();
private:
	std::unique_ptr<GameSave> gameSave;
	ByteString filename;
	String displayName;
	String loadingError;
	bool lazyLoad;
};


=== src\client\SaveInfo.cpp ===

#include "SaveInfo.h"
#include "GameSave.h"

SaveInfo::SaveInfo(int _id, time_t _createdDate, time_t _updatedDate, int _votesUp, int _votesDown, ByteString _userName, String _name):
	id(_id),
	createdDate(_createdDate),
	updatedDate(_updatedDate),
	votesUp(_votesUp),
	votesDown(_votesDown),
	vote(0),
	Favourite(false),
	Comments(0),
	Views(0),
	Version(0),
	userName(_userName),
	name(_name),
	Description(""),
	Published(false)
{

}

SaveInfo::SaveInfo(int _id, time_t _createdDate, time_t _updatedDate, int _votesUp, int _votesDown, int _vote, ByteString _userName, String _name, String description_, bool published_, std::list<ByteString> tags_):
	id(_id),
	createdDate(_createdDate),
	updatedDate(_updatedDate),
	votesUp(_votesUp),
	votesDown(_votesDown),
	vote(_vote),
	Favourite(false),
	Comments(0),
	Views(0),
	Version(0),
	userName(_userName),
	name(_name),
	Description(description_),
	Published(published_)
{
	std::list<ByteString> tagsSorted = tags_;
	tagsSorted.sort();
	tags=tagsSorted;
}

void SaveInfo::SetName(String name)
{
	this->name = name;
}
const String &SaveInfo::GetName() const
{
	return name;
}

void SaveInfo::SetDescription(String description)
{
	Description = description;
}
const String &SaveInfo::GetDescription() const
{
	return Description;
}

void SaveInfo::SetPublished(bool published)
{
	Published = published;
}
bool SaveInfo::GetPublished() const
{
	return Published;
}

void SaveInfo::SetVote(int vote)
{
	this->vote = vote;
}
int SaveInfo::GetVote() const
{
	return vote;
}

void SaveInfo::SetUserName(ByteString userName)
{
	this->userName = userName;
}

const ByteString &SaveInfo::GetUserName() const
{
	return userName;
}

void SaveInfo::SetID(int id)
{
	this->id = id;
}
int SaveInfo::GetID() const
{
	return id;
}

void SaveInfo::SetVotesUp(int votesUp)
{
	this->votesUp = votesUp;
}
int SaveInfo::GetVotesUp() const
{
	return votesUp;
}

void SaveInfo::SetVotesDown(int votesDown)
{
	this->votesDown = votesDown;
}
int SaveInfo::GetVotesDown() const
{
	return votesDown;
}

void SaveInfo::SetVersion(int version)
{
	this->Version = version;
}
int SaveInfo::GetVersion() const
{
	return Version;
}

void SaveInfo::SetTags(std::list<ByteString> tags)
{
	std::list<ByteString> tagsSorted = tags;
	tagsSorted.sort();
	this->tags=tagsSorted;
}

std::list<ByteString> SaveInfo::GetTags() const
{
	return tags;
}

const GameSave *SaveInfo::GetGameSave() const
{
	return gameSave.get();
}

std::unique_ptr<GameSave> SaveInfo::TakeGameSave()
{
	return std::move(gameSave);
}

void SaveInfo::SetGameSave(std::unique_ptr<GameSave> newGameSave)
{
	gameSave = std::move(newGameSave);
}

std::unique_ptr<SaveInfo> SaveInfo::CloneInfo() const
{
	auto clone = std::make_unique<SaveInfo>(id, createdDate, updatedDate, votesUp, votesDown, vote, userName, name, Description, Published, tags);
	clone->Favourite = false;
	clone->Comments = Comments;
	clone->Views = Views;
	clone->Version = Version;
	clone->tags.sort();
	return clone;
}


=== src\client\SaveInfo.h ===

#pragma once
#include "common/String.h"
#include <list>
#include <memory>
#include <ctime>

class GameSave;

class SaveInfo
{
private:
public:
	int id;
	time_t createdDate;
	time_t updatedDate;
	int votesUp, votesDown;
	int vote;
	bool Favourite;
	int Comments;
	int Views;
	int Version;

	ByteString userName;

	String name;
	String Description;
	bool Published;

	std::list<ByteString> tags;
	std::unique_ptr<GameSave> gameSave;

	SaveInfo(int _id, time_t _createdDate, time_t _updatedDate, int _votesUp, int _votesDown, ByteString _userName, String _name);

	SaveInfo(int _id, time_t _createdDate, time_t _updatedDate, int _votesUp, int _votesDown, int _vote, ByteString _userName, String _name, String description_, bool published_, std::list<ByteString> tags);

	void SetName(String name);
	const String &GetName() const;

	void SetDescription(String description);
	const String &GetDescription() const;

	void SetPublished(bool published);
	bool GetPublished() const;

	void SetUserName(ByteString userName);
	const ByteString &GetUserName() const;

	void SetID(int id);
	int GetID() const;

	void SetVote(int vote);
	int GetVote() const;

	void SetVotesUp(int votesUp);
	int GetVotesUp() const;

	void SetVotesDown(int votesDown);
	int GetVotesDown() const;

	void SetVersion(int version);
	int GetVersion() const;

	void SetTags(std::list<ByteString> tags);
	std::list<ByteString> GetTags() const;

	const GameSave *GetGameSave() const;
	std::unique_ptr<GameSave> TakeGameSave();
	void SetGameSave(std::unique_ptr<GameSave> newGameSave);

	std::unique_ptr<SaveInfo> CloneInfo() const;
};


=== src\client\Search.h ===

#pragma once

namespace http
{
	enum Category
	{
		categoryNone,
		categoryMyOwn,
		categoryFavourites,
	};

	enum Sort
	{
		sortByVotes,
		sortByDate,
	};

	enum Period
	{
		allSaves,
		todaySaves,
		weekSaves,
		monthSaves,
		yearSaves,
	};
}


=== src\client\ServerNotification.h ===

#pragma once
#include "common/String.h"

struct ServerNotification
{
	String text;
	ByteString link;
};


=== src\client\StartupInfo.h ===

#pragma once
#include "common/String.h"
#include "ServerNotification.h"
#include <vector>
#include <optional>

struct UpdateInfo
{
	enum Channel
	{
		channelStable,
		channelBeta,
		channelSnapshot,
	};
	Channel channel;
	ByteString file;
	String changeLog;
	int major = 0;
	int minor = 0;
	int build = 0;
};

struct StartupInfo
{
	bool sessionGood = false;
	String messageOfTheDay;
	std::vector<ServerNotification> notifications;
	std::optional<UpdateInfo> updateInfo;
};


=== src\client\ThumbnailRendererTask.cpp ===

#include "ThumbnailRendererTask.h"

#include <cmath>

#include "graphics/VideoBuffer.h"
#include "simulation/SaveRenderer.h"
#include "client/GameSave.h"

int ThumbnailRendererTask::queueSize = 0;

int ThumbnailRendererTask::QueueSize()
{
	return queueSize;
}

ThumbnailRendererTask::ThumbnailRendererTask(GameSave const &save, Vec2<int> size, RendererSettings::DecorationLevel newDecorationLevel, bool fire):
	save(std::make_unique<GameSave>(save)),
	size(size),
	decorationLevel(newDecorationLevel),
	fire(fire)
{
	queueSize += 1;
}

ThumbnailRendererTask::~ThumbnailRendererTask()
{
	queueSize -= 1;
}

bool ThumbnailRendererTask::doWork()
{
	RendererSettings rendererSettings;
	rendererSettings.decorationLevel = decorationLevel;
	thumbnail = SaveRenderer::Ref().Render(save.get(), fire, rendererSettings);
	if (thumbnail)
	{
		thumbnail->ResizeToFit(size, true);
		size = thumbnail->Size();
		return true;
	}
	else
	{
		return false;
	}
}

std::unique_ptr<VideoBuffer> ThumbnailRendererTask::Finish()
{
	auto ptr = std::move(thumbnail);
	AbandonableTask::Finish();
	return ptr;
}



=== src\client\ThumbnailRendererTask.h ===

#pragma once
#include "common/Vec2.h"
#include "tasks/AbandonableTask.h"
#include "graphics/RendererSettings.h"

#include <memory>

class GameSave;
class VideoBuffer;
class ThumbnailRendererTask : public AbandonableTask
{
	std::unique_ptr<GameSave> save;
	Vec2<int> size;
	RendererSettings::DecorationLevel decorationLevel;
	bool fire;
	std::unique_ptr<VideoBuffer> thumbnail;

	static int queueSize;

public:
	ThumbnailRendererTask(GameSave const &, Vec2<int> size, RendererSettings::DecorationLevel newDecorationLevel, bool fire);
	virtual ~ThumbnailRendererTask();

	virtual bool doWork() override;
	std::unique_ptr<VideoBuffer> Finish();

	static int QueueSize();
};


=== src\client\User.cpp ===

#include "User.h"

static const std::vector<std::pair<User::Elevation, ByteString>> elevationStrings = {
	{ User::ElevationAdmin  , "Admin"   },
	{ User::ElevationMod    , "Mod"     },
	{ User::ElevationHalfMod, "HalfMod" },
	{ User::ElevationNone   , "None"    },
};

User::Elevation User::ElevationFromString(ByteString str)
{
	auto it = std::find_if(elevationStrings.begin(), elevationStrings.end(), [&str](auto &item) {
		return item.second == str;
	});
	if (it != elevationStrings.end())
	{
		return it->first;
	}
	return ElevationNone;
}

ByteString User::ElevationToString(Elevation elevation)
{
	auto it = std::find_if(elevationStrings.begin(), elevationStrings.end(), [elevation](auto &item) {
		return item.first == elevation;
	});
	if (it != elevationStrings.end())
	{
		return it->second;
	}
	return "None";
}


=== src\client\User.h ===

#pragma once
#include "common/String.h"


class User
{
public:
	enum Elevation
	{
		ElevationNone,
		ElevationHalfMod,
		ElevationMod,
		ElevationAdmin,
	};
	static Elevation ElevationFromString(ByteString str);
	static ByteString ElevationToString(Elevation elevation);

	int UserID;
	ByteString Username;
	ByteString SessionID;
	ByteString SessionKey;
	Elevation UserElevation;
	User(int id, ByteString username):
		UserID(id),
		Username(username),
		SessionID(""),
		SessionKey(""),
		UserElevation(ElevationNone)
	{

	}
};



=== src\client\UserInfo.h ===

#pragma once
#include "common/String.h"

class UserInfo
{
public:
	int UserID;
	int age;
	ByteString username;
	String biography;
	String location;
	ByteString website;

	int saveCount;
	float averageScore;
	int highestScore;

	int topicCount;
	int topicReplies;
	int reputation;

	UserInfo(int id, int age, ByteString username, String biography, String location, ByteString website, int saveCount, float averageScore, int highestScore, int topicCount, int topicReplies, int reputation):
		UserID(id),
		age(age),
		username(username),
		biography(biography),
		location(location),
		website(website),
		saveCount(saveCount),
		averageScore(averageScore),
		highestScore(highestScore),
		topicCount(topicCount),
		topicReplies(topicReplies),
		reputation(reputation)
	{ }
	UserInfo() {}
};


=== src\client\http\AddCommentRequest.cpp ===

#include "AddCommentRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	AddCommentRequest::AddCommentRequest(int saveID, String comment) :
		APIRequest(ByteString::Build(SERVER, "/Browse/Comments.json?ID=", saveID), authRequire, true)
	{
		auto user = Client::Ref().GetAuthUser();
		AddPostData(FormData{
			{ "Comment", comment.ToUtf8() },
			{ "Key", user.SessionKey },
		});
	}

	void AddCommentRequest::Finish()
	{
		APIRequest::Finish();
	}
}


=== src\client\http\AddCommentRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class AddCommentRequest : public APIRequest
	{
	public:
		AddCommentRequest(int saveID, String comment);

		void Finish();
	};
}


=== src\client\http\AddTagRequest.cpp ===

#include "AddTagRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	AddTagRequest::AddTagRequest(int saveID, ByteString tag) :
		APIRequest(ByteString::Build(SERVER, "/Browse/EditTag.json?Op=add&ID=", saveID, "&Tag=", tag, "&Key=", Client::Ref().GetAuthUser().SessionKey), authRequire, true)
	{
	}

	std::list<ByteString> AddTagRequest::Finish()
	{
		auto result = APIRequest::Finish();
		std::list<ByteString> tags;
		try
		{
			for (auto &tag : result["Tags"])
			{
				tags.push_back(tag.asString());
			}
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return tags;
	}
}


=== src\client\http\AddTagRequest.h ===

#pragma once
#include "APIRequest.h"
#include <list>

namespace http
{
	class AddTagRequest : public APIRequest
	{
	public:
		AddTagRequest(int saveID, ByteString tag);

		std::list<ByteString> Finish();
	};
}


=== src\client\http\APIRequest.cpp ===

#include "APIRequest.h"
#include "client/Client.h"

namespace http
{
	APIRequest::APIRequest(ByteString url, AuthMode authMode, bool newCheckStatus) : Request(url), checkStatus(newCheckStatus)
	{
		auto user = Client::Ref().GetAuthUser();
		if (authMode == authRequire && !user.UserID)
		{
			FailEarly("Not authenticated");
			return;
		}
		if (authMode != authOmit && user.UserID)
		{
			AuthHeaders(ByteString::Build(user.UserID), user.SessionID);
		}
	}

	Json::Value APIRequest::Finish()
	{
		auto [ status, data ] = Request::Finish();
		ParseResponse(data, status, checkStatus ? responseJson : responseData);
		Json::Value document;
		try
		{
			std::istringstream ss(data);
			ss >> document;
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return document;
	}
}


=== src\client\http\APIRequest.h ===

#pragma once
#include "Request.h"
#include "common/String.h"
#include <json/json.h>

namespace http
{
	class APIRequest : public Request
	{
		bool checkStatus;

	public:
		enum AuthMode
		{
			authRequire,
			authUse,
			authOmit,
		};
		APIRequest(ByteString url, AuthMode authMode, bool newCheckStatus);

		Json::Value Finish();
	};
}


=== src\client\http\DeleteSaveRequest.cpp ===

#include "DeleteSaveRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	DeleteSaveRequest::DeleteSaveRequest(int saveID) :
		APIRequest(ByteString::Build(SERVER, "/Browse/Delete.json?ID=", saveID, "&Mode=Delete&Key=", Client::Ref().GetAuthUser().SessionKey), authRequire, true)
	{
	}

	void DeleteSaveRequest::Finish()
	{
		APIRequest::Finish();
	}
}


=== src\client\http\DeleteSaveRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class DeleteSaveRequest : public APIRequest
	{
	public:
		DeleteSaveRequest(int saveID);

		void Finish();
	};
}


=== src\client\http\ExecVoteRequest.cpp ===

#include "ExecVoteRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	ExecVoteRequest::ExecVoteRequest(int saveID, int newDirection) :
		APIRequest(ByteString::Build(SERVER, "/Vote.api"), authRequire, false),
		direction(newDirection)
	{
		AddPostData(FormData{
			{ "ID", ByteString::Build(saveID) },
			{ "Action", direction ? (direction == 1 ? "Up" : "Down") : "Reset" },
			{ "Key", Client::Ref().GetAuthUser().SessionKey },
		});
	}

	void ExecVoteRequest::Finish()
	{
		auto [ status, data ] = Request::Finish();
		ParseResponse(data, status, responseOk);
	}
}


=== src\client\http\ExecVoteRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class ExecVoteRequest : public APIRequest
	{
		int direction;

	public:
		ExecVoteRequest(int saveID, int newDirection);

		void Finish();

		int Direction() const
		{
			return direction;
		}
	};
}


=== src\client\http\FavouriteSaveRequest.cpp ===

#include "FavouriteSaveRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	static ByteString Url(int saveID, bool favourite)
	{
		ByteStringBuilder builder;
		builder << SERVER << "/Browse/Favourite.json?ID=" << saveID << "&Key=" << Client::Ref().GetAuthUser().SessionKey;
		if (!favourite)
		{
			builder << "&Mode=Remove";
		}
		return builder.Build();
	}

	FavouriteSaveRequest::FavouriteSaveRequest(int saveID, bool newFavourite) :
		APIRequest(Url(saveID, newFavourite), authRequire, true),
		favourite(newFavourite)
	{
	}

	void FavouriteSaveRequest::Finish()
	{
		APIRequest::Finish();
	}
}


=== src\client\http\FavouriteSaveRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class FavouriteSaveRequest : public APIRequest
	{
		bool favourite;

	public:
		FavouriteSaveRequest(int saveID, bool newFavourite);

		void Finish();

		bool Favourite() const
		{
			return favourite;
		}
	};
}


=== src\client\http\GetCommentsRequest.cpp ===

#include "GetCommentsRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	GetCommentsRequest::GetCommentsRequest(int saveID, int start, int count) :
		APIRequest(ByteString::Build(SERVER, "/Browse/Comments.json?ID=", saveID, "&Start=", start, "&Count=", count), authOmit, false)
	{
	}

	std::vector<Comment> GetCommentsRequest::Finish()
	{
		auto result = APIRequest::Finish();
		std::vector<Comment> comments;
		auto user = Client::Ref().GetAuthUser();
		try
		{
			for (auto &comment : result)
			{
				comments.push_back({
					comment["Username"].asString(),
					User::ElevationFromString(comment["Elevation"].asString()),
					comment["Username"].asString() == user.Username,
					comment["IsBanned"].asBool(),
					ByteString(comment["Text"].asString()).FromUtf8(),
				});
			}
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return comments;
	}
}


=== src\client\http\GetCommentsRequest.h ===

#pragma once
#include "APIRequest.h"
#include "client/Comment.h"

namespace http
{
	class GetCommentsRequest : public APIRequest
	{
	public:
		GetCommentsRequest(int saveID, int start, int count);

		std::vector<Comment> Finish();
	};
}


=== src\client\http\GetSaveDataRequest.cpp ===

#include "GetSaveDataRequest.h"
#include "Config.h"

namespace http
{
	static ByteString Url(int saveID, int saveDate)
	{
		ByteStringBuilder builder;
		builder << STATICSERVER << "/" << saveID;
		if (saveDate)
		{
			builder << "_" << saveDate;
		}
		builder << ".cps";
		return builder.Build();
	}

	GetSaveDataRequest::GetSaveDataRequest(int saveID, int saveDate) : Request(Url(saveID, saveDate))
	{
	}

	std::vector<char> GetSaveDataRequest::Finish()
	{
		auto [ status, data ] = Request::Finish();
		ParseResponse(data, status, responseData);
		return std::vector<char>(data.begin(), data.end());
	}
}


=== src\client\http\GetSaveDataRequest.h ===

#pragma once
#include "Request.h"

namespace http
{
	class GetSaveDataRequest : public Request
	{
	public:
		GetSaveDataRequest(int saveID, int saveDate);

		std::vector<char> Finish();
	};
}


=== src\client\http\GetSaveRequest.cpp ===

#include "GetSaveRequest.h"
#include "client/Client.h"
#include "client/SaveInfo.h"
#include "client/GameSave.h"
#include "Config.h"

namespace http
{
	static ByteString Url(int saveID, int saveDate)
	{
		ByteStringBuilder builder;
		builder << SERVER << "/Browse/View.json?ID=" << saveID;
		if (saveDate)
		{
			builder << "&Date=" << saveDate;
		}
		return builder.Build();
	}

	GetSaveRequest::GetSaveRequest(int saveID, int saveDate) : Request(Url(saveID, saveDate))
	{
		auto user = Client::Ref().GetAuthUser();
		if (user.UserID)
		{
			// This is needed so we know how we rated this save.
			AuthHeaders(ByteString::Build(user.UserID), user.SessionID);
		}
	}

	std::unique_ptr<SaveInfo> GetSaveRequest::Finish()
	{
		auto [ status, data ] = Request::Finish();
		ParseResponse(data, status, responseData);
		std::unique_ptr<SaveInfo> saveInfo;
		try
		{
			Json::Value document;
			std::istringstream ss(data);
			ss >> document;
			std::list<ByteString> tags;
			for (auto &tag : document["Tags"])
			{
				tags.push_back(tag.asString());
			}
			saveInfo = std::make_unique<SaveInfo>(
				document["ID"].asInt(),
				document["DateCreated"].asInt64(),
				document["Date"].asInt64(),
				document["ScoreUp"].asInt(),
				document["ScoreDown"].asInt(),
				document["ScoreMine"].asInt(),
				document["Username"].asString(),
				ByteString(document["Name"].asString()).FromUtf8(),
				ByteString(document["Description"].asString()).FromUtf8(),
				document["Published"].asBool(),
				tags
			);
			saveInfo->Comments = document["Comments"].asInt();
			saveInfo->Favourite = document["Favourite"].asBool();
			saveInfo->Views = document["Views"].asInt();
			saveInfo->Version = document["Version"].asInt();
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return saveInfo;
	}
}


=== src\client\http\GetSaveRequest.h ===

#pragma once
#include "Request.h"
#include <memory>

class SaveInfo;

namespace http
{
	class GetSaveRequest : public Request
	{
	public:
		GetSaveRequest(int saveID, int saveDate);

		std::unique_ptr<SaveInfo> Finish();
	};
}


=== src\client\http\GetUserInfoRequest.cpp ===

#include "GetUserInfoRequest.h"
#include "client/UserInfo.h"
#include "Config.h"

namespace http
{
	GetUserInfoRequest::GetUserInfoRequest(ByteString username) :
		APIRequest(ByteString::Build(SERVER, "/User.json?Name=", username), authOmit, false)
	{
	}

	UserInfo GetUserInfoRequest::Finish()
	{
		auto result = APIRequest::Finish();
		UserInfo userInfo;
		try
		{
			auto &user = result["User"];
			userInfo = UserInfo(
				user["ID"].asInt(),
				user["Age"].asInt(),
				user["Username"].asString(),
				ByteString(user["Biography"].asString()).FromUtf8(),
				ByteString(user["Location"].asString()).FromUtf8(),
				user["Website"].asString(),
				user["Saves"]["Count"].asInt(),
				user["Saves"]["AverageScore"].asFloat(),
				user["Saves"]["HighestScore"].asInt(),
				user["Forum"]["Topics"].asInt(),
				user["Forum"]["Replies"].asInt(),
				user["Forum"]["Reputation"].asInt()
			);
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return userInfo;
	}
}



=== src\client\http\GetUserInfoRequest.h ===

#pragma once
#include "APIRequest.h"
#include "client/UserInfo.h"

namespace http
{
	class GetUserInfoRequest : public APIRequest
	{
	public:
		GetUserInfoRequest(ByteString username);

		UserInfo Finish();
	};
}


=== src\client\http\ImageRequest.cpp ===

#include "ImageRequest.h"
#include "graphics/VideoBuffer.h"
#include "client/Client.h"
#include <iostream>

namespace http
{
	ImageRequest::ImageRequest(ByteString url, Vec2<int> newRequestedSize) : Request(url), requestedSize(newRequestedSize)
	{
	}

	std::unique_ptr<VideoBuffer> ImageRequest::Finish()
	{
		auto [ status, data ] = Request::Finish();
		ParseResponse(data, status, responseData);
		auto vb = VideoBuffer::FromPNG(data);
		if (vb)
		{
			vb->Resize(requestedSize, true);
		}
		else
		{
			vb = std::make_unique<VideoBuffer>(Vec2(15, 16));
			vb->BlendChar(Vec2(2, 4), 0xE06E, 0xFFFFFF_rgb .WithAlpha(0xFF));
		}
		return vb;
	}
}



=== src\client\http\ImageRequest.h ===

#pragma once
#include "common/String.h"
#include "common/Vec2.h"
#include "Request.h"
#include <memory>

class VideoBuffer;

namespace http
{
	class ImageRequest : public Request
	{
		Vec2<int> requestedSize;

	public:
		ImageRequest(ByteString url, Vec2<int> newRequestedSize);

		std::unique_ptr<VideoBuffer> Finish();
	};
}


=== src\client\http\LoginRequest.cpp ===

#include "LoginRequest.h"
#include "Config.h"
#include "client/Client.h"
#include <json/json.h>

namespace http
{
	LoginRequest::LoginRequest(ByteString username, ByteString password) : Request(ByteString::Build(SERVER, "/Login.json"))
	{
		AddPostData(FormData{
			{ "name", username },
			{ "pass", password },
		});
	}

	LoginInfo LoginRequest::Finish()
	{
		auto [ status, data ] = Request::Finish();
		ParseResponse(data, status, responseJson);
		LoginInfo loginInfo = { { 0, "" }, {} };
		try
		{
			Json::Value document;
			std::istringstream ss(data);
			ss >> document;
			loginInfo.user.Username = document["Username"].asString();
			loginInfo.user.UserID = document["UserID"].asInt();
			loginInfo.user.SessionID = document["SessionID"].asString();
			loginInfo.user.SessionKey = document["SessionKey"].asString();
			loginInfo.user.UserElevation = User::ElevationFromString(document["Elevation"].asString());
			for (auto &item : document["Notifications"])
			{
				loginInfo.notifications.push_back({
					ByteString(item["Text"].asString()).FromUtf8(),
					item["Link"].asString(),
				});
			}
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return loginInfo;
	}
}


=== src\client\http\LoginRequest.h ===

#pragma once
#include "Request.h"
#include "client/LoginInfo.h"

namespace http
{
	class LoginRequest : public Request
	{
	public:
		LoginRequest(ByteString username, ByteString password);

		LoginInfo Finish();
	};
}


=== src\client\http\LogoutRequest.cpp ===

#include "LogoutRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	LogoutRequest::LogoutRequest() :
		APIRequest(ByteString::Build(SERVER, "/Logout.json?Key=" + Client::Ref().GetAuthUser().SessionKey), authRequire, true)
	{
	}

	void LogoutRequest::Finish()
	{
		APIRequest::Finish();
	}
}


=== src\client\http\LogoutRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class LogoutRequest : public APIRequest
	{
	public:
		LogoutRequest();

		void Finish();
	};
}


=== src\client\http\meson.build ===

client_files += files(
	'APIRequest.cpp',
	'GetUserInfoRequest.cpp',
	'ImageRequest.cpp',
	'Request.cpp',
	'SaveUserInfoRequest.cpp',
	'ThumbnailRequest.cpp',
	'AddTagRequest.cpp',
	'RemoveTagRequest.cpp',
	'GetSaveRequest.cpp',
	'PublishSaveRequest.cpp',
	'UnpublishSaveRequest.cpp',
	'ReportSaveRequest.cpp',
	'FavouriteSaveRequest.cpp',
	'AddCommentRequest.cpp',
	'DeleteSaveRequest.cpp',
	'LoginRequest.cpp',
	'GetSaveDataRequest.cpp',
	'ExecVoteRequest.cpp',
	'UploadSaveRequest.cpp',
	'StartupRequest.cpp',
	'UpdateRequest.cpp',
	'SearchSavesRequest.cpp',
	'SearchTagsRequest.cpp',
	'GetCommentsRequest.cpp',
	'LogoutRequest.cpp',
)

subdir('requestmanager')


=== src\client\http\PostData.h ===

#pragma once
#include "common/String.h"
#include <vector>
#include <variant>
#include <optional>

namespace http
{
	struct Header
	{
		ByteString name;
		ByteString value;
	};
	struct FormItem
	{
		ByteString name;
		ByteString value;
		std::optional<ByteString> filename;
		std::optional<ByteString> contentType;
	};
	using StringData = ByteString;
	using FormData = std::vector<FormItem>;
	using PostData = std::variant<StringData, FormData>;
};


=== src\client\http\PublishSaveRequest.cpp ===

#include "PublishSaveRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	PublishSaveRequest::PublishSaveRequest(int saveID) :
		APIRequest(ByteString::Build(SERVER, "/Browse/View.json?ID=", saveID, "&Key=", Client::Ref().GetAuthUser().SessionKey), authRequire, true)
	{
		AddPostData(FormData{
			{ "ActionPublish", "bagels" },
		});
	}

	void PublishSaveRequest::Finish()
	{
		APIRequest::Finish();
	}
}


=== src\client\http\PublishSaveRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class PublishSaveRequest : public APIRequest
	{
	public:
		PublishSaveRequest(int saveID);

		void Finish();
	};
}


=== src\client\http\RemoveTagRequest.cpp ===

#include "RemoveTagRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	RemoveTagRequest::RemoveTagRequest(int saveID, ByteString tag) :
		APIRequest(ByteString::Build(SERVER, "/Browse/EditTag.json?Op=delete&ID=", saveID, "&Tag=", tag, "&Key=", Client::Ref().GetAuthUser().SessionKey), authRequire, true)
	{
	}

	std::list<ByteString> RemoveTagRequest::Finish()
	{
		auto result = APIRequest::Finish();
		std::list<ByteString> tags;
		try
		{
			for (auto &tag : result["Tags"])
			{
				tags.push_back(tag.asString());
			}
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return tags;
	}
}


=== src\client\http\RemoveTagRequest.h ===

#pragma once
#include "APIRequest.h"
#include <list>

namespace http
{
	class RemoveTagRequest : public APIRequest
	{
	public:
		RemoveTagRequest(int saveID, ByteString tag);

		std::list<ByteString> Finish();
	};
}


=== src\client\http\ReportSaveRequest.cpp ===

#include "ReportSaveRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	ReportSaveRequest::ReportSaveRequest(int saveID, String message) :
		APIRequest(ByteString::Build(SERVER, "/Browse/Report.json?ID=", saveID, "&Key=", Client::Ref().GetAuthUser().SessionKey), authRequire, true)
	{
		AddPostData(FormData{
			{ "Reason", message.ToUtf8() },
		});
	}

	void ReportSaveRequest::Finish()
	{
		APIRequest::Finish();
	}
}


=== src\client\http\ReportSaveRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class ReportSaveRequest : public APIRequest
	{
	public:
		ReportSaveRequest(int saveID, String message);

		void Finish();
	};
}


=== src\client\http\Request.cpp ===

#include "Request.h"
#include "requestmanager/RequestManager.h"
#include <memory>
#include <iostream>
#include <cstring>
#include <json/json.h>

namespace http
{
	Request::Request(ByteString newUri)
	{
		handle = RequestHandle::Create();
		handle->uri = newUri;
	}

	Request::~Request()
	{
		bool tryUnregister;
		{
			std::lock_guard lk(handle->stateMx);
			tryUnregister = handle->state == RequestHandle::running;
		}
		if (tryUnregister)
		{
			// At this point it may have already finished and been unregistered but that's ok,
			// attempting to unregister a request multiple times is allowed. We only do the
			// state-checking dance so we don't wake up RequestManager if we don't have to.
			// In fact, we could just not unregister requests here at all, they'd just run to
			// completion and be unregistered later. All this does is cancel them early.
			RequestManager::Ref().UnregisterRequest(*this);
		}
	}

	void Request::FailEarly(ByteString error)
	{
		assert(handle->state == RequestHandle::ready);
		handle->failEarly = error;
	}

	void Request::Verb(ByteString newVerb)
	{
		assert(handle->state == RequestHandle::ready);
		handle->verb = newVerb;
	}

	void Request::AddHeader(Header header)
	{
		assert(handle->state == RequestHandle::ready);
		handle->headers.push_back(header);
	}

	void Request::AddPostData(PostData data)
	{
		assert(handle->state == RequestHandle::ready);
		// Even if the map is empty, calling this function signifies you want to do a POST request
		handle->isPost = true;
		handle->postData = data;
	}

	void Request::AuthHeaders(ByteString ID, ByteString session)
	{
		assert(handle->state == RequestHandle::ready);
		if (ID.size() && ID != "-1") // -1 is an emscripten hack, see AuthUserEmscripten.cpp
		{
			if (session.size())
			{
				AddHeader({ "X-Auth-User-Id", ID });
				AddHeader({ "X-Auth-Session-Key", session });
			}
			else
			{
				AddHeader({ "X-Auth-User", ID });
			}
		}
	}

	void Request::Start()
	{
		assert(handle->state == RequestHandle::ready);
		handle->state = RequestHandle::running;
		RequestManager::Ref().RegisterRequest(*this);
	}

	bool Request::CheckDone() const
	{
		std::lock_guard lk(handle->stateMx);
		assert(handle->state == RequestHandle::running || handle->state == RequestHandle::done);
		return handle->state == RequestHandle::done;
	}

	std::pair<int64_t, int64_t> Request::CheckProgress() const
	{
		std::lock_guard lk(handle->stateMx);
		assert(handle->state == RequestHandle::running || handle->state == RequestHandle::done);
		return { handle->bytesTotal, handle->bytesDone };
	}

	const std::vector<Header> &Request::ResponseHeaders() const
	{
		std::lock_guard lk(handle->stateMx);
		assert(handle->state == RequestHandle::done);
		return handle->responseHeaders;
	}

	void Request::Wait()
	{
		std::unique_lock lk(handle->stateMx);
		assert(handle->state == RequestHandle::running);
		handle->stateCv.wait(lk, [this]() {
			return handle->state == RequestHandle::done;
		});
	}

	int Request::StatusCode() const
	{
		{
			std::unique_lock lk(handle->stateMx);
			assert(handle->state == RequestHandle::done);
		}
		return handle->statusCode;
	}

	std::pair<int, ByteString> Request::Finish()
	{
		{
			std::unique_lock lk(handle->stateMx);
			assert(handle->state == RequestHandle::done);
		}
		handle->state = RequestHandle::dead;
		if (handle->error)
		{
			throw RequestError(*handle->error);
		}
		return std::pair{ handle->statusCode, std::move(handle->responseData) };
	}

	void RequestHandle::MarkDone()
	{
		{
			std::lock_guard lk(stateMx);
			assert(state == RequestHandle::running);
			state = RequestHandle::done;
		}
		stateCv.notify_one();
		if (error)
		{
			std::cerr << *error << std::endl;
		}
		else if (statusCode >= 400)
		{
			std::cerr << "status code " << statusCode << " for request to " << uri << std::endl;
		}
	}

	const char *StatusText(int ret)
	{
		switch (ret)
		{
		case 0:   return "Status code 0 (bug?)";
		case 100: return "Continue";
		case 101: return "Switching Protocols";
		case 102: return "Processing";
		case 200: return "OK";
		case 201: return "Created";
		case 202: return "Accepted";
		case 203: return "Non-Authoritative Information";
		case 204: return "No Content";
		case 205: return "Reset Content";
		case 206: return "Partial Content";
		case 207: return "Multi-Status";
		case 300: return "Multiple Choices";
		case 301: return "Moved Permanently";
		case 302: return "Found";
		case 303: return "See Other";
		case 304: return "Not Modified";
		case 305: return "Use Proxy";
		case 306: return "Switch Proxy";
		case 307: return "Temporary Redirect";
		case 400: return "Bad Request";
		case 401: return "Unauthorized";
		case 402: return "Payment Required";
		case 403: return "Forbidden";
		case 404: return "Not Found";
		case 405: return "Method Not Allowed";
		case 406: return "Not Acceptable";
		case 407: return "Proxy Authentication Required";
		case 408: return "Request Timeout";
		case 409: return "Conflict";
		case 410: return "Gone";
		case 411: return "Length Required";
		case 412: return "Precondition Failed";
		case 413: return "Request Entity Too Large";
		case 414: return "Request URI Too Long";
		case 415: return "Unsupported Media Type";
		case 416: return "Requested Range Not Satisfiable";
		case 417: return "Expectation Failed";
		case 418: return "I'm a teapot";
		case 422: return "Unprocessable Entity";
		case 423: return "Locked";
		case 424: return "Failed Dependency";
		case 425: return "Unordered Collection";
		case 426: return "Upgrade Required";
		case 444: return "No Response";
		case 450: return "Blocked by Windows Parental Controls";
		case 499: return "Client Closed Request";
		case 500: return "Internal Server Error";
		case 501: return "Not Implemented";
		case 502: return "Bad Gateway";
		case 503: return "Service Unavailable";
		case 504: return "Gateway Timeout";
		case 505: return "HTTP Version Not Supported";
		case 506: return "Variant Also Negotiates";
		case 507: return "Insufficient Storage";
		case 509: return "Bandwidth Limit Exceeded";
		case 510: return "Not Extended";
		case 600: return "Internal Client Error";
		case 601: return "Unsupported Protocol";
		case 602: return "Server Not Found";
		case 603: return "Malformed Response";
		case 604: return "Network Not Available";
		case 605: return "Request Timed Out";
		case 606: return "Malformed URL";
		case 607: return "Connection Refused";
		case 608: return "Proxy Server Not Found";
		case 609: return "SSL: Invalid Certificate Status";
		case 611: return "Too Many Redirects";
		case 612: return "SSL: Connect Error";
		case 613: return "SSL: Crypto Engine Not Found";
		case 614: return "SSL: Failed to Set Default Crypto Engine";
		case 615: return "SSL: Local Certificate Issue";
		case 616: return "SSL: Unable to Use Specified Cipher";
		case 617: return "SSL: Failed to Initialise Crypto Engine";
		case 618: return "SSL: Failed to Load CACERT File";
		case 619: return "SSL: Failed to Load CRL File";
		case 620: return "SSL: Issuer Check Failed";
		case 621: return "SSL: Pinned Public Key Mismatch";
		}
		return "Unknown Status Code";
	}

	void Request::ParseResponse(const ByteString &result, int status, ResponseType responseType)
	{
		// no server response, return "Malformed Response"
		if (status == 200 && !result.size())
		{
			status = 603;
		}
		if (status == 302)
		{
			return;
		}
		if (status != 200)
		{
			throw RequestError(ByteString::Build("HTTP Error ", status, ": ", http::StatusText(status)));
		}

		switch (responseType)
		{
		case responseOk:
			if (strncmp(result.c_str(), "OK", 2))
			{
				throw RequestError(result);
			}
			break;

		case responseJson:
			{
				std::istringstream ss(result);
				Json::Value root;
				int status;
				try
				{
					ss >> root;
					// assume everything is fine if an empty [] is returned
					if (root.size() == 0)
					{
						return;
					}
					status = root.get("Status", 1).asInt();
				}
				catch (const std::exception &ex)
				{
					// sometimes the server returns a 200 with the text "Error: 401"
					if (!strncmp(result.c_str(), "Error: ", 7))
					{
						status = ByteString(result.begin() + 7, result.end()).ToNumber<int>();
						throw RequestError(ByteString::Build("HTTP Error ", status, ": ", http::StatusText(status)));
					}
					throw RequestError("Could not read response: " + ByteString(ex.what()));
				}

				if (status != 1)
				{
					throw RequestError(ByteString(root.get("Error", "Unspecified Error").asString()));
				}
			}
			break;

		case responseData:
			// no further processing required
			break;
		}
	}
}


=== src\client\http\Request.h ===

#pragma once
#include "common/String.h"
#include "PostData.h"
#include <map>
#include <utility>
#include <vector>
#include <mutex>
#include <condition_variable>
#include <optional>

namespace http
{
	struct RequestHandle;

	// Thrown by Finish and ParseResponse
	struct RequestError : public std::runtime_error
	{
		using runtime_error::runtime_error;
	};

	class Request
	{
		std::shared_ptr<RequestHandle> handle;

	public:
		Request(ByteString newUri);
		Request(const Request &) = delete;
		Request &operator =(const Request &) = delete;
		~Request();

		void FailEarly(ByteString error);

		void Verb(ByteString newVerb);
		void AddHeader(Header header);

		void AddPostData(PostData data);
		void AuthHeaders(ByteString ID, ByteString session);

		void Start();
		bool CheckDone() const;

		std::pair<int64_t, int64_t> CheckProgress() const; // total, done
		const std::vector<Header> &ResponseHeaders() const;
		void Wait();

		int StatusCode() const; // status
		std::pair<int, ByteString> Finish(); // status, data

		enum ResponseType
		{
			responseOk,
			responseJson,
			responseData,
		};
		static void ParseResponse(const ByteString &result, int status, ResponseType responseType);

		friend class RequestManager;
	};

	const char *StatusText(int code);
}


=== src\client\http\SaveUserInfoRequest.cpp ===

#include "SaveUserInfoRequest.h"
#include "Config.h"

namespace http
{
	SaveUserInfoRequest::SaveUserInfoRequest(UserInfo info) :
		APIRequest(ByteString::Build(SERVER, "/Profile.json"), authRequire, true)
	{
		AddPostData(FormData{
			{ "Location", info.location.ToUtf8() },
			{ "Biography", info.biography.ToUtf8() },
		});
	}

	void SaveUserInfoRequest::Finish()
	{
		APIRequest::Finish();
	}
}



=== src\client\http\SaveUserInfoRequest.h ===

#pragma once
#include "APIRequest.h"
#include "client/UserInfo.h"

namespace http
{
	class SaveUserInfoRequest : public APIRequest
	{
	public:
		SaveUserInfoRequest(UserInfo info);

		void Finish();
	};
}


=== src\client\http\SearchSavesRequest.cpp ===

#include <ctime>
#include "SearchSavesRequest.h"
#include "Config.h"
#include "client/Client.h"
#include "client/GameSave.h"
#include "Format.h"

namespace http
{
	static ByteString Url(int start, int count, ByteString query, Period period, Sort sort, Category category)
	{
		ByteStringBuilder builder;
		builder << SERVER << "/Browse.json?Start=" << start << "&Count=" << count;
		auto appendToQuery = [&query](ByteString str) {
			if (query.size())
			{
				query += " ";
			}
			query += str;
		};

		time_t currentTime = time(nullptr);

		if(period)
		{
			switch (period)
			{
				case todaySaves:
					currentTime -= 60*60*24; // One day
					break;
				case weekSaves:
					currentTime -= 60*60*24*7; // One week
					break;
				case monthSaves:
					currentTime -= 60*60*24*31; // One month
					break;
				case yearSaves:
					currentTime -= 60*60*24*365; // One year
					break;
				default:
					break;
			}

			struct tm currentTimeData = *localtime(&currentTime);
			ByteStringBuilder afterQuery;

			afterQuery << "after:" << currentTimeData.tm_year+1900 << "-" <<
			       	(currentTimeData.tm_mon < 9 ? "0" : "") << currentTimeData.tm_mon+1 << "-" <<
			       	(currentTimeData.tm_mday < 10 ? "0" : "") << currentTimeData.tm_mday;
			appendToQuery(afterQuery.Build());
		}

		switch (sort)
		{
		case sortByDate:
			appendToQuery("sort:date");
			break;

		default:
			break;
		}
		auto user = Client::Ref().GetAuthUser();
		switch (category)
		{
		case categoryFavourites:
			builder << "&Category=Favourites";
			break;

		case categoryMyOwn:
			assert(user.UserID);
			appendToQuery("user:" + user.Username);
			break;

		default:
			break;
		}
		if (query.size())
		{
			builder << "&Search_Query=" << format::URLEncode(query);
		}
		return builder.Build();
	}

	SearchSavesRequest::SearchSavesRequest(int start, int count, ByteString query, Period period, Sort sort, Category category) : APIRequest(Url(start, count, query, period, sort, category), authUse, false)
	{
	}

	std::pair<int, std::vector<std::unique_ptr<SaveInfo>>> SearchSavesRequest::Finish()
	{
		std::vector<std::unique_ptr<SaveInfo>> saves;
		auto result = APIRequest::Finish();
		int count;
		try
		{
			count = result["Count"].asInt();
			for (auto &save : result["Saves"])
			{
				auto saveInfo = std::make_unique<SaveInfo>(
					save["ID"].asInt(),
					save["Created"].asInt64(),
					save["Updated"].asInt64(),
					save["ScoreUp"].asInt(),
					save["ScoreDown"].asInt(),
					save["Username"].asString(),
					ByteString(save["Name"].asString()).FromUtf8()
				);
				saveInfo->Version = save["Version"].asInt();
				saveInfo->SetPublished(save["Published"].asBool());
				saves.push_back(std::move(saveInfo));
			}
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return std::pair{ count, std::move(saves) };
	}
}


=== src\client\http\SearchSavesRequest.h ===

#pragma once
#include "APIRequest.h"
#include "client/SaveInfo.h"
#include "client/Search.h"

namespace http
{
	class SearchSavesRequest : public APIRequest
	{
	public:
		SearchSavesRequest(int start, int count, ByteString query, Period period, Sort sort, Category category);

		std::pair<int, std::vector<std::unique_ptr<SaveInfo>>> Finish();
	};
}


=== src\client\http\SearchTagsRequest.cpp ===

#include "SearchTagsRequest.h"
#include "Config.h"
#include "Format.h"

namespace http
{
	static ByteString Url(int start, int count, ByteString query)
	{
		ByteStringBuilder builder;
		builder << SERVER << "/Browse/Tags.json?Start=" << start << "&Count=" << count;
		if (query.size())
		{
			builder << "&Search_Query=" << format::URLEncode(query);
		}
		return builder.Build();
	}

	SearchTagsRequest::SearchTagsRequest(int start, int count, ByteString query) : APIRequest(Url(start, count, query), authOmit, false)
	{
	}

	std::vector<std::pair<ByteString, int>> SearchTagsRequest::Finish()
	{
		std::vector<std::pair<ByteString, int>> tags;
		auto result = APIRequest::Finish();
		try
		{
			for (auto &tag : result["Tags"])
			{
				tags.push_back({
					tag["Tag"].asString(),
					tag["Count"].asInt(),
				});
			}
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return tags;
	}
}


=== src\client\http\SearchTagsRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class SearchTagsRequest : public APIRequest
	{
	public:
		SearchTagsRequest(int start, int count, ByteString query);

		std::vector<std::pair<ByteString, int>> Finish();
	};
}


=== src\client\http\StartupRequest.cpp ===

#include "StartupRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	// TODO: update Client::messageOfTheDay
	StartupRequest::StartupRequest(bool newAlternate) :
		Request(ByteString::Build(newAlternate ? UPDATESERVER : SERVER, "/Startup.json")),
		alternate(newAlternate)
	{
		auto user = Client::Ref().GetAuthUser();
		if (user.UserID)
		{
			if (alternate)
			{
				// Cursed
				AuthHeaders(user.Username, "");
			}
			else
			{
				AuthHeaders(ByteString::Build(user.UserID), user.SessionID);
			}
		}
	}

	StartupInfo StartupRequest::Finish()
	{
		auto [ status, data ] = Request::Finish();
		ParseResponse(data, status, responseJson);
		StartupInfo startupInfo;
		try
		{
			Json::Value document;
			std::istringstream ss(data);
			ss >> document;
			startupInfo.sessionGood = document["Session"].asBool();
			startupInfo.messageOfTheDay = ByteString(document["MessageOfTheDay"].asString()).FromUtf8();
			for (auto &notification : document["Notifications"])
			{
				startupInfo.notifications.push_back({
					ByteString(notification["Text"].asString()).FromUtf8(),
					notification["Link"].asString()
				});
			}
			if constexpr (!IGNORE_UPDATES)
			{
				auto &versions = document["Updates"];
				auto parseUpdate = [this, &versions, &startupInfo](ByteString key, UpdateInfo::Channel channel) {
					if (!versions.isMember(key))
					{
						return;
					}
					auto &info = versions[key];
					if (info.isNull())
					{
						return;
					}
					auto getOr = [&info](ByteString key, int defaultValue) -> int {
						if (!info.isMember(key))
						{
							return defaultValue;
						}
						return info[key].asInt();
					};
					auto build = getOr(key == "Snapshot" ? "Snapshot" : "Build", 0);
					if (size_t(build) <= APP_VERSION.build)
					{
						return;
					}
					startupInfo.updateInfo = UpdateInfo{
						channel,
						ByteString::Build(alternate ? UPDATESERVER : SERVER, info["File"].asString()),
						ByteString(info["Changelog"].asString()).FromUtf8(),
						getOr("Major", 0),
						getOr("Minor", 0),
						build,
					};
				};
				if constexpr (SNAPSHOT || MOD)
				{
					parseUpdate("Snapshot", UpdateInfo::channelSnapshot);
				}
				else
				{
					parseUpdate("Stable", UpdateInfo::channelStable);
					if (!startupInfo.updateInfo.has_value())
					{
						parseUpdate("Beta", UpdateInfo::channelBeta);
					}
				}
			}
		}
		catch (const std::exception &ex)
		{
			throw RequestError("Could not read response: " + ByteString(ex.what()));
		}
		return startupInfo;
	}
}


=== src\client\http\StartupRequest.h ===

#pragma once
#include "APIRequest.h"
#include "client/StartupInfo.h"

namespace http
{
	class StartupRequest : public Request
	{
		bool alternate;

	public:
		StartupRequest(bool newAlternate);

		StartupInfo Finish();
	};
}


=== src\client\http\ThumbnailRequest.cpp ===

#include "ThumbnailRequest.h"
#include "Config.h"

namespace http
{
	ThumbnailRequest::ThumbnailRequest(int saveID, int saveDate, Vec2<int> size) :
		ImageRequest((
			saveDate
			? ByteString::Build(STATICSERVER, "/", saveID, "_", saveDate, "_small.png")
			: ByteString::Build(STATICSERVER, "/", saveID, "_small.png")
		), size)
	{
	}
}



=== src\client\http\ThumbnailRequest.h ===

#pragma once
#include "ImageRequest.h"

namespace http
{
	class ThumbnailRequest : public ImageRequest
	{
	public:
		ThumbnailRequest(int saveID, int saveDate, Vec2<int> size);
	};
}


=== src\client\http\UnpublishSaveRequest.cpp ===

#include "UnpublishSaveRequest.h"
#include "client/Client.h"
#include "Config.h"

namespace http
{
	UnpublishSaveRequest::UnpublishSaveRequest(int saveID) :
		APIRequest(ByteString::Build(SERVER, "/Browse/Delete.json?ID=", saveID, "&Mode=Unpublish&Key=", Client::Ref().GetAuthUser().SessionKey), authRequire, true)
	{
	}

	void UnpublishSaveRequest::Finish()
	{
		APIRequest::Finish();
	}
}



=== src\client\http\UnpublishSaveRequest.h ===

#pragma once
#include "APIRequest.h"

namespace http
{
	class UnpublishSaveRequest : public APIRequest
	{
	public:
		UnpublishSaveRequest(int saveID);

		void Finish();
	};
}


=== src\client\http\UpdateRequest.cpp ===



=== src\client\http\UpdateRequest.h ===



=== src\client\http\UploadSaveRequest.cpp ===

#include "UploadSaveRequest.h"
#include "client/SaveInfo.h"
#include "client/Client.h"
#include "client/GameSave.h"
#include "Config.h"

namespace http
{
	UploadSaveRequest::UploadSaveRequest(const SaveInfo &saveInfo) : Request(ByteString::Build(SERVER, "/Save.api"))
	{
		auto [ fromNewerVersion, gameData ] = saveInfo.GetGameSave()->Serialise();
		if (!gameData.size())
		{
			FailEarly("Cannot serialize game save");
			return;
		}
		else if (ALLOW_FAKE_NEWER_VERSION && fromNewerVersion && saveInfo.GetPublished())
		{
			FailEarly("Cannot publish save, incompatible with latest release version");
			return;
		}
		auto user = Client::Ref().GetAuthUser();
		if (!user.UserID)
		{
			FailEarly("Not authenticated");
			return;
		}
		AuthHeaders(ByteString::Build(user.UserID), user.SessionID);
		AddPostData(FormData{
			{ "Name", saveInfo.GetName().ToUtf8() },
			{ "Description", saveInfo.GetDescription().ToUtf8() },
			{ "Data", ByteString(gameData.begin(), gameData.end()), "save.bin" },
			{ "Publish", saveInfo.GetPublished() ? "Public" : "Private" },
			{ "Key", user.SessionKey },
		});
	}

	int UploadSaveRequest::Finish()
	{
		auto [ status, data ] = Request::Finish();
		ParseResponse(data, status, responseOk);
		int saveID = ByteString(data.begin() + 3, data.end()).ToNumber<int>();
		if (!saveID)
		{
			throw RequestError("Server did not return Save ID");
		}
		return saveID;
	}
}


=== src\client\http\UploadSaveRequest.h ===

#pragma once
#include "Request.h"

class SaveInfo;

namespace http
{
	class UploadSaveRequest : public Request
	{
	public:
		UploadSaveRequest(const SaveInfo &saveInfo);

		int Finish();
	};
}


=== src\client\http\requestmanager\AndroidCertProvider.cpp ===

#include "CurlError.h"
#include "common/platform/Android.h"
#include "Config.h"
#include <iostream>
#include <android/log.h>

namespace http
{
	void UseSystemCertProvider(CURL *easy)
	{
		struct DoOnce
		{
			ByteString certificateBundle;

			DoOnce()
			{
				auto certificateBundleOpt = Platform::CallActivityStringFunc("getCertificateBundle");
				if (certificateBundleOpt)
				{
					certificateBundle = *certificateBundleOpt;
					__android_log_print(ANDROID_LOG_ERROR, APPID, "certificate bundle loaded");
				}
			}
		};

		static DoOnce doOnce;
		if (doOnce.certificateBundle.size())
		{
			curl_blob blob;
			blob.data = doOnce.certificateBundle.data();
			blob.len = doOnce.certificateBundle.size();
			blob.flags = CURL_BLOB_COPY;
			HandleCURLcode(curl_easy_setopt(easy, CURLOPT_CAINFO_BLOB, &blob));
		}
	}
}


=== src\client\http\requestmanager\Common.cpp ===

#include "RequestManager.h"
#include "client/http/Request.h"
#include "Config.h"

namespace http
{
	RequestManager::RequestManager(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork) :
		proxy(newProxy),
		cafile(newCafile),
		capath(newCapath),
		disableNetwork(newDisableNetwork)
	{
		auto apiVersion = Version(97, 0);
		userAgent = ByteString::Build(
			"PowderToy/", DISPLAY_VERSION[0], ".", DISPLAY_VERSION[1],
			" (", IDENT_PLATFORM,
			"; NO", // Unused, used to be SSE level.
			"; M", MOD_ID,
			"; P", PACKAGE_MODE,
			"; ", IDENT,
			") TPTPP/", apiVersion[0], ".", apiVersion[1], ".", APP_VERSION.build, IDENT_RELTYPE, ".", APP_VERSION.build
		);
	}

	void RequestManager::RegisterRequest(Request &request)
	{
		if (request.handle->failEarly)
		{
			request.handle->error = request.handle->failEarly.value();
			request.handle->statusCode = 600;
			request.handle->MarkDone();
			return;
		}
		if (disableNetwork)
		{
			request.handle->statusCode = 604;
			request.handle->error = "network disabled upon request";
			request.handle->MarkDone();
			return;
		}
		RegisterRequestImpl(request);
	}

	void RequestManager::UnregisterRequest(Request &request)
	{
		UnregisterRequestImpl(request);
	}
}


=== src\client\http\requestmanager\CurlError.h ===

#pragma once
#include <curl/curl.h> // Has to come first because windows(tm).
#include <stdexcept>

namespace http
{
	struct CurlError : public std::runtime_error
	{
		using runtime_error::runtime_error;
	};

	void UseSystemCertProvider(CURL *easy);
	void SetupCurlEasyCiphers(CURL *easy);
	void HandleCURLcode(CURLcode code);
	void HandleCURLMcode(CURLMcode code);
}


=== src\client\http\requestmanager\Emscripten.cpp ===

#include "RequestManager.h"
#include "client/http/Request.h"
#include <algorithm>
#include <emscripten.h>
#include <emscripten/threading.h>

namespace http
{
	struct RequestHandleHttp : public RequestHandle
	{
		RequestHandleHttp() : RequestHandle(CtorTag{})
		{
		}

		bool gotResponse = false;
		int id = -1;
	};
}

EMSCRIPTEN_KEEPALIVE extern "C" void RequestManager_UpdateRequestStatusThunk(http::RequestHandleHttp *handle);

namespace http
{
	std::shared_ptr<RequestHandle> RequestHandle::Create()
	{
		return std::make_shared<RequestHandleHttp>();
	}

	struct RequestManagerImpl : public RequestManager
	{
		using RequestManager::RequestManager;

		RequestManagerImpl(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork);
		~RequestManagerImpl();

		// State shared between Request threads and the worker thread.
		std::vector<std::shared_ptr<RequestHandle>> requestHandlesToRegister;
		std::vector<std::shared_ptr<RequestHandle>> requestHandlesToUnregister;
		std::mutex sharedStateMx;

		std::vector<std::shared_ptr<RequestHandle>> requestHandles;
		void RegisterRequestHandle(std::shared_ptr<RequestHandle> requestHandle);
		void UnregisterRequestHandle(std::shared_ptr<RequestHandle> requestHandle);

		void HandleWake();
		void Wake();

		void UpdateRequestStatus(RequestHandleHttp *handle);
	};

	RequestManagerImpl::RequestManagerImpl(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork) :
		RequestManager(newProxy, newCafile, newCapath, newDisableNetwork)
	{
		EM_ASM({
			Module.emscriptenRequestManager = {};
			Module.emscriptenRequestManager.requests = [];
			Module.emscriptenRequestManager.updateRequestStatusThunk = Module.cwrap(
				'RequestManager_UpdateRequestStatusThunk',
				null,
				[ 'number' ]
			);
		});
	}

	RequestManagerImpl::~RequestManagerImpl()
	{
		// Nothing, we never really exit.
	}

	void RequestManager::RegisterRequestImpl(Request &request)
	{
		auto manager = static_cast<RequestManagerImpl *>(this);
		{
			std::lock_guard lk(manager->sharedStateMx);
			manager->requestHandlesToRegister.push_back(request.handle);
		}
		manager->Wake();
	}

	void RequestManager::UnregisterRequestImpl(Request &request)
	{
		auto manager = static_cast<RequestManagerImpl *>(this);
		{
			std::lock_guard lk(manager->sharedStateMx);
			manager->requestHandlesToUnregister.push_back(request.handle);
		}
		manager->Wake();
	}

	void RequestManagerImpl::HandleWake()
	{
		{
			std::lock_guard lk(sharedStateMx);
			for (auto &requestHandle : requestHandles)
			{
				if (requestHandle->statusCode)
				{
					requestHandlesToUnregister.push_back(requestHandle);
				}
			}
			for (auto &requestHandle : requestHandlesToRegister)
			{
				// Must not be present
				assert(std::find(requestHandles.begin(), requestHandles.end(), requestHandle) == requestHandles.end());
				requestHandles.push_back(requestHandle);
				RegisterRequestHandle(requestHandle);
			}
			requestHandlesToRegister.clear();
			for (auto &requestHandle : requestHandlesToUnregister)
			{
				auto eraseFrom = std::remove(requestHandles.begin(), requestHandles.end(), requestHandle);
				// Must either not be present
				if (eraseFrom != requestHandles.end())
				{
					// Or be present exactly once
					assert(eraseFrom + 1 == requestHandles.end());
					UnregisterRequestHandle(requestHandle);
					requestHandles.erase(eraseFrom, requestHandles.end());
					requestHandle->MarkDone();
				}
			}
			requestHandlesToUnregister.clear();
		}
	}

	static void HandleWakeThunk()
	{
		auto manager = static_cast<RequestManagerImpl *>(&RequestManager::Ref());
		manager->HandleWake();
	}

	void RequestManagerImpl::Wake()
	{
		emscripten_async_run_in_main_runtime_thread(EM_FUNC_SIG_V, &HandleWakeThunk);
	}

	void RequestManagerImpl::RegisterRequestHandle(std::shared_ptr<RequestHandle> requestHandle)
	{
		auto handle = static_cast<RequestHandleHttp *>(requestHandle.get());
		handle->id = EM_ASM_INT({
			let id = 0;
			while (Module.emscriptenRequestManager.requests[id])
			{
				id += 1;
			}
			let request = {};
			request.fetchResource = UTF8ToString($0);
			request.fetchBody = undefined;
			request.fetchHeaders = new Headers(); 
			Module.emscriptenRequestManager.requests[id] = request;
			return id;
		}, requestHandle->uri.c_str());
		{
			auto userAgentSet = false;
			for (auto &header : handle->headers)
			{
				if (header.name.ToLower() == "user-agent")
				{
					userAgentSet = true;
				}
			}
			if (!userAgentSet)
			{
				handle->headers.push_back({ "user-agent", userAgent });
			}
		}
		for (auto &header : handle->headers)
		{
			EM_ASM({
				Module.emscriptenRequestManager.requests[$0].fetchHeaders.append(
					UTF8ToString($1),
					UTF8ToString($2)
				);
			}, handle->id, header.name.c_str(), header.value.c_str());
		}
		auto &postData = handle->postData;
		if (std::holds_alternative<http::FormData>(postData) && std::get<http::FormData>(postData).size())
		{
			auto &formData = std::get<http::FormData>(postData);
			EM_ASM({
				Module.emscriptenRequestManager.requests[$0].fetchBody = new FormData();
			}, handle->id);
			for (auto &field : formData)
			{
				if (field.filename.has_value())
				{
					EM_ASM({
						Module.emscriptenRequestManager.requests[$0].fetchBody.append(
							UTF8ToString($1),
							new Blob([ HEAP8.slice($2, $2 + $3) ]),
							UTF8ToString($4)
						);
					}, handle->id, field.name.c_str(), field.value.data(), field.value.size(), field.filename->c_str());
				}
				else
				{
					EM_ASM({
						Module.emscriptenRequestManager.requests[$0].fetchBody.append(
							UTF8ToString($1),
							UTF8ToString($2)
						)
					}, handle->id, field.name.c_str(), field.value.c_str());
				}
			}
		}
		else if (std::holds_alternative<http::StringData>(postData) && std::get<http::StringData>(postData).size())
		{
			auto &stringData = std::get<http::StringData>(postData);
			EM_ASM({
				Module.emscriptenRequestManager.requests[$0].fetchBody = new DataView(
					HEAP8.buffer,
					HEAP8.byteOffset + $1,
					$2
				);
			}, handle->id, stringData.data(), stringData.size());
		}
		if (handle->isPost)
		{
			EM_ASM({
				Module.emscriptenRequestManager.requests[$0].fetchMethod = 'POST';
			}, handle->id);
		}
		else
		{
			EM_ASM({
				Module.emscriptenRequestManager.requests[$0].fetchMethod = 'GET';
			}, handle->id);
		}
		if (requestHandle->verb)
		{
			EM_ASM({
				Module.emscriptenRequestManager.requests[$0].fetchMethod = UTF8ToString($1);
			}, handle->id, requestHandle->verb->c_str());
		}
		EM_ASM({
			let request = Module.emscriptenRequestManager.requests[$0];
			let token = $1;
			request.status = 0;
			request.bytesTotal = -1;
			request.bytesDone = 0;
			request.alive = true;
			let updateRequestStatus = () => {
				if (request.alive) {
					Module.emscriptenRequestManager.updateRequestStatusThunk(token);
				}
			};
			request.fetchController = new AbortController();
			fetch(request.fetchResource, {
				method: request.fetchMethod,
				headers: request.fetchHeaders,
				body: request.fetchBody,
				signal: request.fetchController.signal,
			}).then(response => {
				request.statusEarly = response.status;
				let contentLength = response.headers.get('content-length');
				if (contentLength) {
					request.bytesTotal = parseInt(contentLength, 10);
				}
				let reader = response.body.getReader();
				let stream = new ReadableStream({
					start(controller) {
						function read() {
							reader.read().then(({ done, value }) => {
								if (done) {
									return controller.close();
								}
								request.bytesDone += value.byteLength;
								updateRequestStatus();
								controller.enqueue(value);
								read();
							}).catch(err => {
								controller.error(err);
							});
						}
						read();
					}
				});
				request.responseHeaders = [];
				for (let [ name, value ] of response.headers.entries()) {
					request.responseHeaders.push({
						name: name,
						value: value
					});
				}
				return new Response(stream, {
					headers: response.headers
				});
			}).then(output => {
				return output.arrayBuffer();
			}).then(data => {
				request.status = request.statusEarly;
				request.responseData = data;
				updateRequestStatus();
			}).catch(err => {
				console.error(err);
				if (!request.status) {
					request.status = 600;
				}
				updateRequestStatus();
			});
		}, handle->id, handle);
	}

	void RequestManagerImpl::UpdateRequestStatus(RequestHandleHttp *handle)
	{
		assert(handle->id >= 0);
		handle->bytesTotal = EM_ASM_INT({
			return Module.emscriptenRequestManager.requests[$0].bytesTotal;
		}, handle->id);
		handle->bytesDone = EM_ASM_INT({
			return Module.emscriptenRequestManager.requests[$0].bytesDone;
		}, handle->id);
		handle->statusCode = EM_ASM_INT({
			return Module.emscriptenRequestManager.requests[$0].status;
		}, handle->id);
		if (!handle->gotResponse && handle->statusCode)
		{
			auto responseDataSize = EM_ASM_INT({
				let responseData = Module.emscriptenRequestManager.requests[$0].responseData;
				if (responseData) {
					return responseData.byteLength;
				}
				return 0;
			}, handle->id);
			if (responseDataSize)
			{
				handle->responseData.resize(responseDataSize);
				EM_ASM({
					let responseData = Module.emscriptenRequestManager.requests[$0].responseData;
					writeArrayToMemory(new Int8Array(responseData), $1);
				}, handle->id, handle->responseData.data());
			}
			auto headerCount = EM_ASM_INT({
				let responseHeaders = Module.emscriptenRequestManager.requests[$0].responseHeaders;
				if (responseHeaders) {
					return responseHeaders.length;
				}
				return 0;
			}, handle->id);
			handle->responseHeaders.resize(headerCount);
			for (auto i = 0; i < headerCount; ++i)
			{
				handle->responseHeaders[i].name = ByteString(std::unique_ptr<char, decltype(&free)>((char *)EM_ASM_PTR({
					return stringToNewUTF8(Module.emscriptenRequestManager.requests[$0].responseHeaders[$1].name);
				}, handle->id, i), free).get());
				handle->responseHeaders[i].value = ByteString(std::unique_ptr<char, decltype(&free)>((char *)EM_ASM_PTR({
					return stringToNewUTF8(Module.emscriptenRequestManager.requests[$0].responseHeaders[$1].value);
				}, handle->id, i), free).get());
			}
			handle->gotResponse = true;
			HandleWake();
		}
	}

	void RequestManagerImpl::UnregisterRequestHandle(std::shared_ptr<RequestHandle> requestHandle)
	{
		auto handle = static_cast<RequestHandleHttp *>(requestHandle.get());
		assert(handle->id >= 0);
		EM_ASM({
			let request = Module.emscriptenRequestManager.requests[$0];
			request.alive = false;
			request.fetchController.abort();
			Module.emscriptenRequestManager.requests[$0] = null;
		}, handle->id);
		handle->id = -1;
	}

	RequestManagerPtr RequestManager::Create(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork)
	{
		return RequestManagerPtr(new RequestManagerImpl(newProxy, newCafile, newCapath, newDisableNetwork));
	}

	void RequestManagerDeleter::operator ()(RequestManager *ptr) const
	{
		delete static_cast<RequestManagerImpl *>(ptr);
	}
}

void RequestManager_UpdateRequestStatusThunk(http::RequestHandleHttp *handle)
{
	auto manager = static_cast<http::RequestManagerImpl *>(&http::RequestManager::Ref());
	manager->UpdateRequestStatus(handle);
}


=== src\client\http\requestmanager\Libcurl.cpp ===

#include <curl/curl.h> // Has to come first because windows(tm).
#include "RequestManager.h"
#include "client/http/Request.h"
#include "CurlError.h"
#include "Config.h"
#include <iostream>

#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 55, 0)
# define REQUEST_USE_CURL_OFFSET_T
#endif
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 56, 0)
# define REQUEST_USE_CURL_MIMEPOST
#endif
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 61, 0)
# define REQUEST_USE_CURL_TLSV13CL
#endif
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 68, 0)
# define REQUEST_USE_CURL_MULTI_POLL
#endif

constexpr long curlMaxHostConnections   = 1;
constexpr long curlMaxConcurrentStreams = httpMaxConcurrentStreams;
constexpr long curlConnectTimeoutS      = httpConnectTimeoutS;

namespace http
{
	void HandleCURLcode(CURLcode code)
	{
		if (code != CURLE_OK)
		{
			throw CurlError(curl_easy_strerror(code));
		}
	};

	void HandleCURLMcode(CURLMcode code)
	{
		if (code != CURLM_OK && code != CURLM_CALL_MULTI_PERFORM)
		{
			throw CurlError(curl_multi_strerror(code));
		}
	};

#ifndef REQUEST_USE_CURL_MIMEPOST
	void HandleCURLFORMcode(CURLFORMcode code)
	{
		if (code != CURL_FORMADD_OK)
		{
			throw CurlError(ByteString::Build("CURLFORMcode ", code));
		}
	};
#endif

	struct RequestHandleHttp : public RequestHandle
	{
		curl_slist *curlHeaders = nullptr;
#ifdef REQUEST_USE_CURL_MIMEPOST
		curl_mime *curlPostFields = nullptr;
#else
		curl_httppost *curlPostFieldsFirst = NULL;
		curl_httppost *curlPostFieldsLast = NULL;
#endif
		CURL *curlEasy = nullptr;
		char curlErrorBuffer[CURL_ERROR_SIZE];
		bool curlAddedToMulti = false;
		bool gotStatusLine = false;

		RequestHandleHttp() : RequestHandle(CtorTag{})
		{
		}

		static size_t HeaderDataHandler(char *ptr, size_t size, size_t count, void *userdata)
		{
			auto *handle = (RequestHandleHttp *)userdata;
			auto bytes = size * count;
			if (bytes >= 2 && ptr[bytes - 2] == '\r' && ptr[bytes - 1] == '\n')
			{
				if (bytes > 2 && handle->gotStatusLine) // Don't include header list terminator or the status line.
				{
					auto line = ByteString(ptr, ptr + bytes - 2);
					if (auto split = line.SplitBy(':'))
					{
						auto value = split.After();
						while (value.size() && (value.front() == ' ' || value.front() == '\t'))
						{
							value = value.Substr(1);
						}
						while (value.size() && (value.back() == ' ' || value.back() == '\t'))
						{
							value = value.Substr(0, value.size() - 1);
						}
						handle->responseHeaders.push_back({ split.Before().ToLower(), value });
					}
					else
					{
						std::cerr << "skipping weird header: " << line << std::endl;
					}
				}
				handle->gotStatusLine = true;
				return bytes;
			}
			return 0;
		}

		static size_t WriteDataHandler(char *ptr, size_t size, size_t count, void *userdata)
		{
			auto *handle = (RequestHandleHttp *)userdata;
			auto bytes = size * count;
			handle->responseData.append(ptr, bytes);
			return bytes;
		}
	};

	std::shared_ptr<RequestHandle> RequestHandle::Create()
	{
		return std::make_shared<RequestHandleHttp>();
	}

	struct RequestManagerImpl : public RequestManager
	{
		using RequestManager::RequestManager;

		RequestManagerImpl(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork);
		~RequestManagerImpl();

		std::thread worker;
		void Worker();
		void WorkerInit();
		void WorkerPerform();
		void WorkerExit();

		// State shared between Request threads and the worker thread.
		std::vector<std::shared_ptr<RequestHandle>> requestHandlesToRegister;
		std::vector<std::shared_ptr<RequestHandle>> requestHandlesToUnregister;
		bool running = true;
		std::mutex sharedStateMx;

		std::vector<std::shared_ptr<RequestHandle>> requestHandles;
		void RegisterRequestHandle(std::shared_ptr<RequestHandle> requestHandle);
		void UnregisterRequestHandle(std::shared_ptr<RequestHandle> requestHandle);

		bool curlGlobalInit = false;
		CURLM *curlMulti = nullptr;

		void Wake()
		{
#ifdef REQUEST_USE_CURL_MULTI_POLL
			curl_multi_wakeup(curlMulti);
#endif
		}

		void Wait()
		{
			int dontcare;
#ifdef REQUEST_USE_CURL_MULTI_POLL
			HandleCURLMcode(curl_multi_poll(curlMulti, nullptr, 0, 100000, &dontcare));
#else
			constexpr auto TickMs = 100;
			if (requestHandles.size())
			{
				HandleCURLMcode(curl_multi_wait(curlMulti, NULL, 0, TickMs, &dontcare));
			}
			else
			{
				std::this_thread::sleep_for(std::chrono::milliseconds(TickMs));
				return;
			}
#endif
		}
	};

	RequestManagerImpl::RequestManagerImpl(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork) :
		RequestManager(newProxy, newCafile, newCapath, newDisableNetwork)
	{
		worker = std::thread([this]() {
			Worker();
		});
	}

	RequestManagerImpl::~RequestManagerImpl()
	{
		{
			std::lock_guard lk(sharedStateMx);
			running = false;
		}
		Wake();
		worker.join();
	}

	void RequestManagerImpl::WorkerInit()
	{
		if (!curl_global_init(CURL_GLOBAL_DEFAULT))
		{
			curlGlobalInit = true;
			curlMulti = curl_multi_init();
			if (curlMulti)
			{
				HandleCURLMcode(curl_multi_setopt(curlMulti, CURLMOPT_MAX_HOST_CONNECTIONS, curlMaxHostConnections));
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 67, 0)
				HandleCURLMcode(curl_multi_setopt(curlMulti, CURLMOPT_MAX_CONCURRENT_STREAMS, curlMaxConcurrentStreams));
#endif
			}
		}
	}

	void RequestManagerImpl::WorkerPerform()
	{
		auto manager = static_cast<RequestManagerImpl *>(this);
		manager->Wait();
		int dontcare;
		HandleCURLMcode(curl_multi_perform(manager->curlMulti, &dontcare));
		while (auto msg = curl_multi_info_read(manager->curlMulti, &dontcare))
		{
			if (msg->msg == CURLMSG_DONE)
			{
				RequestHandleHttp *handle;
				HandleCURLcode(curl_easy_getinfo(msg->easy_handle, CURLINFO_PRIVATE, &handle));
				handle->statusCode = 600;
				switch (msg->data.result)
				{
				case CURLE_OK:
					{
						long code;
						HandleCURLcode(curl_easy_getinfo(msg->easy_handle, CURLINFO_RESPONSE_CODE, &code));
						assert(code);
						handle->statusCode = int(code);
					}
					break;
				
				case CURLE_UNSUPPORTED_PROTOCOL:     handle->statusCode = 601; break;
				case CURLE_COULDNT_RESOLVE_HOST:     handle->statusCode = 602; break;
				case CURLE_OPERATION_TIMEDOUT:       handle->statusCode = 605; break;
				case CURLE_URL_MALFORMAT:            handle->statusCode = 606; break;
				case CURLE_COULDNT_CONNECT:          handle->statusCode = 607; break;
				case CURLE_COULDNT_RESOLVE_PROXY:    handle->statusCode = 608; break;
				case CURLE_TOO_MANY_REDIRECTS:       handle->statusCode = 611; break;
				case CURLE_SSL_CONNECT_ERROR:        handle->statusCode = 612; break;
				case CURLE_SSL_ENGINE_NOTFOUND:      handle->statusCode = 613; break;
				case CURLE_SSL_ENGINE_SETFAILED:     handle->statusCode = 614; break;
				case CURLE_SSL_CERTPROBLEM:          handle->statusCode = 615; break;
				case CURLE_SSL_CIPHER:               handle->statusCode = 616; break;
				case CURLE_SSL_ENGINE_INITFAILED:    handle->statusCode = 617; break;
				case CURLE_SSL_CACERT_BADFILE:       handle->statusCode = 618; break;
				case CURLE_SSL_CRL_BADFILE:          handle->statusCode = 619; break;
				case CURLE_SSL_ISSUER_ERROR:         handle->statusCode = 620; break;
				case CURLE_SSL_PINNEDPUBKEYNOTMATCH: handle->statusCode = 621; break;
				case CURLE_SSL_INVALIDCERTSTATUS:    handle->statusCode = 609; break;
				case CURLE_HTTP2:
				case CURLE_HTTP2_STREAM:
				case CURLE_FAILED_INIT:
				case CURLE_NOT_BUILT_IN:
				default:
					break;
				}
				if (handle->statusCode >= 600)
				{
					handle->error = handle->curlErrorBuffer;
				}
			}
		}
		for (auto &requestHandle : requestHandles)
		{
			auto handle = static_cast<RequestHandleHttp *>(requestHandle.get());
			if (handle->curlEasy)
			{
#ifdef REQUEST_USE_CURL_OFFSET_T
				curl_off_t total, done;
				HandleCURLcode(curl_easy_getinfo(handle->curlEasy, CURLINFO_CONTENT_LENGTH_DOWNLOAD_T, &total)); // stores -1 if unknown
				HandleCURLcode(curl_easy_getinfo(handle->curlEasy, CURLINFO_SIZE_DOWNLOAD_T, &done));
#else
				double total, done;
				HandleCURLcode(curl_easy_getinfo(handle->curlEasy, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &total)); // stores -1 if unknown
				HandleCURLcode(curl_easy_getinfo(handle->curlEasy, CURLINFO_SIZE_DOWNLOAD, &done));
#endif
				handle->bytesTotal = int64_t(total);
				handle->bytesDone = int64_t(done);
			}
			else
			{
				handle->bytesTotal = -1;
				handle->bytesDone = 0;
			}
		}
	}

	void RequestManagerImpl::WorkerExit()
	{
		curl_multi_cleanup(curlMulti);
		curlMulti = nullptr;
		curl_global_cleanup();
	}

	void RequestManagerImpl::Worker()
	{
		WorkerInit();
		while (true)
		{
			{
				std::lock_guard lk(sharedStateMx);
				// Register new handles first. This always succeeds even if the handle is "failed early" so that
				// a single MarkDone call could be issued on all handles further down in this block.
				for (auto &requestHandle : requestHandlesToRegister)
				{
					// Must not be present
					assert(std::find(requestHandles.begin(), requestHandles.end(), requestHandle) == requestHandles.end());
					requestHandles.push_back(requestHandle);
					RegisterRequestHandle(requestHandle);
				}
				requestHandlesToRegister.clear();
				// Then unregister done handles. As explained above, registering a new handle may also immediately mark
				// it done and we won't be coming back here until Wait() returns, so this has to come second.
				for (auto &requestHandle : requestHandles)
				{
					if (requestHandle->statusCode)
					{
						requestHandlesToUnregister.push_back(requestHandle);
					}
				}
				// Actually unregister handles queued to be unregistered. They can be queued just above, or from another thread.
				// Thus, it's ok for them to be in the queue multiple times, but it's not ok to try to unregister them multiple times.
				for (auto &requestHandle : requestHandlesToUnregister)
				{
					auto eraseFrom = std::remove(requestHandles.begin(), requestHandles.end(), requestHandle);
					// Must either not be present
					if (eraseFrom != requestHandles.end())
					{
						// Or be present exactly once
						assert(eraseFrom + 1 == requestHandles.end());
						UnregisterRequestHandle(requestHandle);
						requestHandles.erase(eraseFrom, requestHandles.end());
						requestHandle->MarkDone();
					}
				}
				requestHandlesToUnregister.clear();
				if (!running)
				{
					break;
				}
			}
			WorkerPerform();
		}
		// assert(!requestHandles.size()); // TODO: enable again once the rest of the codebase is actual c++
		WorkerExit();
	}

	void RequestManager::RegisterRequestImpl(Request &request)
	{
		auto manager = static_cast<RequestManagerImpl *>(this);
		{
			std::lock_guard lk(manager->sharedStateMx);
			manager->requestHandlesToRegister.push_back(request.handle);
		}
		manager->Wake();
	}

	void RequestManager::UnregisterRequestImpl(Request &request)
	{
		auto manager = static_cast<RequestManagerImpl *>(this);
		{
			std::lock_guard lk(manager->sharedStateMx);
			manager->requestHandlesToUnregister.push_back(request.handle);
		}
		manager->Wake();
	}

	void RequestManagerImpl::RegisterRequestHandle(std::shared_ptr<RequestHandle> requestHandle)
	{
		auto manager = static_cast<RequestManagerImpl *>(this);
		auto handle = static_cast<RequestHandleHttp *>(requestHandle.get());
		auto failEarly = [&requestHandle](int statusCode, ByteString error) {
			requestHandle->statusCode = statusCode;
			requestHandle->error = error;
		};
		if (!manager->curlGlobalInit)
		{
			return failEarly(600, "no CURL");
		}
		if (!manager->curlMulti)
		{
			return failEarly(600, "no CURL multi handle");
		}
		try
		{
			handle->curlEasy = curl_easy_init();
			if (!handle->curlEasy)
			{
				return failEarly(600, "no CURL easy handle");
			} 
			for (auto &header : handle->headers)
			{
				auto *newHeaders = curl_slist_append(handle->curlHeaders, (header.name + ": " + header.value).c_str());
				if (!newHeaders)
				{
					// Hopefully this is what a NULL from curl_slist_append means.
					HandleCURLcode(CURLE_OUT_OF_MEMORY);
				}
				handle->curlHeaders = newHeaders;
			}
			{
				auto &postData = handle->postData;
				if (std::holds_alternative<http::FormData>(postData) && std::get<http::FormData>(postData).size())
				{
					auto &formData = std::get<http::FormData>(postData);
#ifdef REQUEST_USE_CURL_MIMEPOST
					handle->curlPostFields = curl_mime_init(handle->curlEasy);
					if (!handle->curlPostFields)
					{
						// Hopefully this is what a NULL from curl_mime_init means.
						HandleCURLcode(CURLE_OUT_OF_MEMORY);
					}
					for (auto &field : formData)
					{
						curl_mimepart *part = curl_mime_addpart(handle->curlPostFields);
						if (!part)
						{
							// Hopefully this is what a NULL from curl_mime_addpart means.
							HandleCURLcode(CURLE_OUT_OF_MEMORY);
						}
						HandleCURLcode(curl_mime_data(part, field.value.data(), field.value.size()));
						HandleCURLcode(curl_mime_name(part, field.name.c_str()));
						if (field.filename.has_value())
						{
							HandleCURLcode(curl_mime_filename(part, field.filename->c_str()));
						}
						if (field.contentType.has_value())
						{
							HandleCURLcode(curl_mime_type(part, field.contentType->c_str()));
						}
					}
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_MIMEPOST, handle->curlPostFields));
#else
					for (auto &field : formData)
					{
						if (field.filename.has_value())
						{
							HandleCURLFORMcode(curl_formadd(&handle->curlPostFieldsFirst, &handle->curlPostFieldsLast,
								CURLFORM_COPYNAME, field.name.c_str(),
								CURLFORM_BUFFER, field.filename->c_str(),
								CURLFORM_BUFFERPTR, field.value.data(),
								CURLFORM_BUFFERLENGTH, field.value.size(),
							CURLFORM_END));
						}
						else
						{
							HandleCURLFORMcode(curl_formadd(&handle->curlPostFieldsFirst, &handle->curlPostFieldsLast,
								CURLFORM_COPYNAME, field.name.c_str(),
								CURLFORM_PTRCONTENTS, field.value.data(),
								CURLFORM_CONTENTLEN, field.value.size(),
							CURLFORM_END));
						}
					}
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_HTTPPOST, handle->curlPostFieldsFirst));
#endif
				}
				else if (std::holds_alternative<http::StringData>(postData) && std::get<http::StringData>(postData).size())
				{
					auto &stringData = std::get<http::StringData>(postData);
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_POSTFIELDS, stringData.data()));
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_POSTFIELDSIZE_LARGE, curl_off_t(stringData.size())));
				}
				else if (handle->isPost)
				{
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_POST, 1L));
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_POSTFIELDS, ""));
				}
				else
				{
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_HTTPGET, 1L));
				}
				if (handle->verb)
				{
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_CUSTOMREQUEST, handle->verb->c_str()));
				}
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_FOLLOWLOCATION, 1L));
				if constexpr (ENFORCE_HTTPS)
				{
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 85, 0)
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_PROTOCOLS_STR, "https"));
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_REDIR_PROTOCOLS_STR, "https"));
#else
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_PROTOCOLS, CURLPROTO_HTTPS));
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTPS));
#endif
				}
				else
				{
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 85, 0)
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_PROTOCOLS_STR, "https,http"));
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_REDIR_PROTOCOLS_STR, "https,http"));
#else
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_PROTOCOLS, CURLPROTO_HTTPS | CURLPROTO_HTTP));
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTPS | CURLPROTO_HTTP));
#endif
				}
				SetupCurlEasyCiphers(handle->curlEasy);
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_MAXREDIRS, 10L));
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_ERRORBUFFER, handle->curlErrorBuffer));
				handle->curlErrorBuffer[0] = 0;
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_CONNECTTIMEOUT, curlConnectTimeoutS));
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_HTTPHEADER, handle->curlHeaders));
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_URL, handle->uri.c_str()));
				if (proxy.size())
				{
					HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_PROXY, proxy.c_str()));
				}
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_PRIVATE, (void *)handle));
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_USERAGENT, userAgent.c_str()));
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_HEADERDATA, (void *)handle));
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_HEADERFUNCTION, &RequestHandleHttp::HeaderDataHandler));
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_WRITEDATA, (void *)handle));
				HandleCURLcode(curl_easy_setopt(handle->curlEasy, CURLOPT_WRITEFUNCTION, &RequestHandleHttp::WriteDataHandler));
			}
		}
		catch (const CurlError &ex)
		{
			return failEarly(600, ex.what());
		}
		HandleCURLMcode(curl_multi_add_handle(manager->curlMulti, handle->curlEasy));
		handle->curlAddedToMulti = true;
	}

	void RequestManagerImpl::UnregisterRequestHandle(std::shared_ptr<RequestHandle> requestHandle)
	{
		auto manager = static_cast<RequestManagerImpl *>(this);
		auto handle = static_cast<RequestHandleHttp *>(requestHandle.get());
		if (handle->curlAddedToMulti)
		{
			HandleCURLMcode(curl_multi_remove_handle(manager->curlMulti, handle->curlEasy));
			handle->curlAddedToMulti = false;
		}
		curl_easy_cleanup(handle->curlEasy);
#ifdef REQUEST_USE_CURL_MIMEPOST
		curl_mime_free(handle->curlPostFields);
#else
		curl_formfree(handle->curlPostFieldsFirst);
#endif
		curl_slist_free_all(handle->curlHeaders);
	}

	RequestManagerPtr RequestManager::Create(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork)
	{
		return RequestManagerPtr(new RequestManagerImpl(newProxy, newCafile, newCapath, newDisableNetwork));
	}

	void RequestManagerDeleter::operator ()(RequestManager *ptr) const
	{
		delete static_cast<RequestManagerImpl *>(ptr);
	}

	void SetupCurlEasyCiphers(CURL *easy)
	{
		if constexpr (SECURE_CIPHERS_ONLY)
		{
			curl_version_info_data *version_info = curl_version_info(CURLVERSION_NOW);
			ByteString ssl_type = version_info->ssl_version;
			if (ssl_type.Contains("OpenSSL") || ssl_type.Contains("mbedTLS"))
			{
				HandleCURLcode(curl_easy_setopt(easy, CURLOPT_SSL_CIPHER_LIST,
					"ECDHE-ECDSA-AES256-GCM-SHA384" ":"
					"ECDHE-ECDSA-AES128-GCM-SHA256" ":"
					"ECDHE-ECDSA-AES256-SHA384"     ":"
					"DHE-RSA-AES256-GCM-SHA384"     ":"
					"ECDHE-RSA-AES256-GCM-SHA384"   ":"
					"ECDHE-RSA-AES128-GCM-SHA256"   ":"
					"ECDHE-ECDSA-AES128-SHA"        ":"
					"ECDHE-ECDSA-AES128-SHA256"     ":"
					"ECDHE-RSA-CHACHA20-POLY1305"   ":"
					"ECDHE-RSA-AES256-SHA384"       ":"
					"ECDHE-RSA-AES128-SHA256"       ":"
					"ECDHE-ECDSA-CHACHA20-POLY1305" ":"
					"ECDHE-ECDSA-AES256-SHA"        ":"
					"ECDHE-RSA-AES128-SHA"          ":"
					"DHE-RSA-AES128-GCM-SHA256"
				));
#ifdef REQUEST_USE_CURL_TLSV13CL
				HandleCURLcode(curl_easy_setopt(easy, CURLOPT_TLS13_CIPHERS,
					"TLS_AES_256_GCM_SHA384"       ":"
					"TLS_CHACHA20_POLY1305_SHA256" ":"
					"TLS_AES_128_GCM_SHA256"       ":"
					"TLS_AES_128_CCM_8_SHA256"     ":"
					"TLS_AES_128_CCM_SHA256"
				));
#endif
			}
			else if (ssl_type.Contains("Schannel"))
			{
				// TODO: add more cipher algorithms
				HandleCURLcode(curl_easy_setopt(easy, CURLOPT_SSL_CIPHER_LIST, "CALG_ECDH_EPHEM"));
			}
		}
		// TODO: Find out what TLS1.2 is supported on, might need to also allow TLS1.0
		HandleCURLcode(curl_easy_setopt(easy, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2));
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 70, 0)
		HandleCURLcode(curl_easy_setopt(easy, CURLOPT_SSL_OPTIONS, CURLSSLOPT_REVOKE_BEST_EFFORT));
#elif defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 44, 0)
		HandleCURLcode(curl_easy_setopt(easy, CURLOPT_SSL_OPTIONS, CURLSSLOPT_NO_REVOKE));
#endif

		auto &capath = http::RequestManager::Ref().Capath();
		auto &cafile = http::RequestManager::Ref().Cafile();
		if (capath.size())
		{
			HandleCURLcode(curl_easy_setopt(easy, CURLOPT_CAPATH, capath.c_str()));
		}
		else if (cafile.size())
		{
			HandleCURLcode(curl_easy_setopt(easy, CURLOPT_CAINFO, cafile.c_str()));
		}
		else if constexpr (USE_SYSTEM_CERT_PROVIDER)
		{
			UseSystemCertProvider(easy);
		}
	}
}


=== src\client\http\requestmanager\meson.build ===

client_files += files(
	'Common.cpp',
)

use_system_cert_provider = false
if not enable_http
	client_files += files('Null.cpp')
elif host_platform == 'emscripten'
	client_files += files('Emscripten.cpp')
else
	client_files += files('Libcurl.cpp')
	if host_platform == 'windows'
		use_system_cert_provider = true
		client_files += files('WindowsCertProvider.cpp')
		powder_deps += cpp_compiler.find_library('crypt32')
	endif
	if host_platform == 'android'
		use_system_cert_provider = true
		client_files += files('AndroidCertProvider.cpp')
	endif
endif
conf_data.set('NOHTTP', (not enable_http).to_string())
conf_data.set('USE_SYSTEM_CERT_PROVIDER', use_system_cert_provider.to_string())


=== src\client\http\requestmanager\Null.cpp ===

#include "RequestManager.h"
#include "client/http/Request.h"

namespace http
{
	std::shared_ptr<RequestHandle> RequestHandle::Create()
	{
		return std::make_shared<RequestHandle>(CtorTag{});
	}

	void RequestManager::RegisterRequestImpl(Request &request)
	{
		request.handle->statusCode = 604;
		request.handle->error = "network support not compiled in";
		request.handle->MarkDone();
	}

	void RequestManager::UnregisterRequestImpl(Request &request)
	{
	}

	RequestManagerPtr RequestManager::Create(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork)
	{
		return RequestManagerPtr(new RequestManager(newProxy, newCafile, newCapath, newDisableNetwork));
	}

	void RequestManagerDeleter::operator ()(RequestManager *ptr) const
	{
		delete ptr;
	}
}


=== src\client\http\requestmanager\RequestManager.h ===

#pragma once
#include "common/ExplicitSingleton.h"
#include "common/String.h"
#include "client/http/PostData.h"
#include <atomic>
#include <cstdint>
#include <thread>
#include <vector>
#include <memory>
#include <mutex>
#include <condition_variable>
#include <optional>
#include <utility>

namespace http
{
	class Request;

	struct RequestHandle
	{
	protected:
		struct CtorTag
		{
		};

	public:
		ByteString uri;
		std::optional<ByteString> verb;
		bool isPost = false;
		PostData postData;
		std::vector<Header> headers;

		enum State
		{
			ready,
			running,
			done,
			dead,
		};
		State state = ready;
		std::mutex stateMx;
		std::condition_variable stateCv;
		std::atomic<int64_t> bytesTotal = -1;
		std::atomic<int64_t> bytesDone = 0;
		int statusCode = 0;
		ByteString responseData;
		std::vector<Header> responseHeaders;
		std::optional<ByteString> error;
		std::optional<ByteString> failEarly;

		RequestHandle(CtorTag)
		{
		}

		RequestHandle(const RequestHandle &) = delete;
		RequestHandle &operator =(const RequestHandle &) = delete;

		void MarkDone();

		static std::shared_ptr<RequestHandle> Create();
	};

	class RequestManager;
	struct RequestManagerDeleter
	{
		void operator ()(RequestManager *ptr) const;
	};
	using RequestManagerPtr = std::unique_ptr<RequestManager, RequestManagerDeleter>;
	class RequestManager : public ExplicitSingleton<RequestManager>
	{
	protected:
		ByteString proxy;
		ByteString cafile;
		ByteString capath;
		ByteString userAgent;
		bool disableNetwork;

		RequestManager(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork);

		void RegisterRequestImpl(Request &request);
		void UnregisterRequestImpl(Request &request);

	public:
		void RegisterRequest(Request &request);
		void UnregisterRequest(Request &request);

		bool DisableNetwork() const
		{
			return disableNetwork;
		}

		const ByteString &Cafile() const
		{
			return cafile;
		}

		const ByteString &Capath() const
		{
			return capath;
		}

		static RequestManagerPtr Create(ByteString newProxy, ByteString newCafile, ByteString newCapath, bool newDisableNetwork);
	};
}


=== src\client\http\requestmanager\WindowsCertProvider.cpp ===

#include "CurlError.h"
#include "common/String.h"
#include <wincrypt.h> // crypt32.lib is pulled in by tpt-libs
#include <iostream>
#include <memory>

namespace http
{
	// see https://stackoverflow.com/questions/9507184/can-openssl-on-windows-use-the-system-certificate-store
	void UseSystemCertProvider(CURL *easy)
	{
		struct DoOnce
		{
			ByteString allPems;

			void InitPem()
			{
				struct StoreDeleter
				{
					typedef HCERTSTORE pointer;

					void operator ()(HCERTSTORE p) const
					{
						::CertCloseStore(p, 0);
					}
				};
				using StorePtr = std::unique_ptr<void, StoreDeleter>;
				struct ContextDeleter
				{
					typedef PCCERT_CONTEXT pointer;

					void operator ()(PCCERT_CONTEXT p) const
					{
						::CertFreeCertificateContext(p);
					}
				};
				using ContextPtr = std::unique_ptr<void, ContextDeleter>;

				auto die = [](ByteString message) {
					std::cerr << "failed to enumerate system certificates: " << message << ": " << GetLastError() << std::endl;
				};
				auto store = StorePtr(::CertOpenSystemStore(0, L"ROOT"), StoreDeleter{});
				if (!store)
				{
					return die("CertOpenSystemStore failed");
				}
				ContextPtr context;
				while (true)
				{
					context = ContextPtr(::CertEnumCertificatesInStore(store.get(), context.release()), ContextDeleter{});
					if (!context)
					{
						if (::GetLastError() != DWORD(CRYPT_E_NOT_FOUND))
						{
							return die("CertEnumCertificatesInStore failed");
						}
						break;
					}
					DWORD pemLength;
					// get required buffer size first
					if (!CryptBinaryToStringA(context->pbCertEncoded, context->cbCertEncoded, CRYPT_STRING_BASE64HEADER, nullptr, &pemLength))
					{
						return die("CryptBinaryToStringA failed");
					}
					std::vector<char> pem(pemLength);
					// actually get the data
					if (!CryptBinaryToStringA(context->pbCertEncoded, context->cbCertEncoded, CRYPT_STRING_BASE64HEADER, pem.data(), &pemLength))
					{
						return die("CryptBinaryToStringA failed");
					}
					allPems += ByteString(pem.data(), pem.data() + pem.size() - 1); // buffer includes the zero terminator, omit that
				}
				if (!allPems.size())
				{
					die("no system certificates");
				}
			}

			DoOnce()
			{
				InitPem();
			}
		};

		static DoOnce doOnce;
		if (doOnce.allPems.size())
		{
			curl_blob blob;
			blob.data = doOnce.allPems.data();
			blob.len = doOnce.allPems.size();
			blob.flags = CURL_BLOB_COPY;
			HandleCURLcode(curl_easy_setopt(easy, CURLOPT_CAINFO_BLOB, &blob));
		}
	}
}


=== src\common\Defer.h ===

#pragma once
#include <utility>

template<class Func>
class Defer
{
	Func func;

public:
	Defer(Func &&newFunc) : func(std::forward<Func>(newFunc))
	{
	}

	Defer(const Defer &) = delete;
	Defer &operator =(const Defer &) = delete;

	~Defer()
	{
		func();
	}
};


=== src\common\ExplicitSingleton.h ===

#pragma once
#include <cassert>

template<class Type>
class ExplicitSingleton
{
	static Type *&Instance()
	{
		// [dcl.fct.spec]: A static local variable in an extern inline function always refers to the same object.
		static Type *instance = nullptr;
		return instance;
	}

public:
	ExplicitSingleton()
	{
		auto &instance = Instance();
		assert(!instance);
		instance = static_cast<Type *>(this);
	}

	~ExplicitSingleton()
	{
		Instance() = nullptr;
	}

	static Type &Ref()
	{
		return *Instance();
	}

	static const Type &CRef()
	{
		return Ref();
	}
};


=== src\common\Format.h ===

#pragma once

#include <functional>
#include <ios>

#include "common/String.h"

/*
	The following formatting specifiers can be written into a
	ByteStringBuilder or a StringBuilder:

	Format::Oct(value)
	Format::Dec(value)
	Format::Hex(value)
		Write the value in the specified base.

	Format::Uppercase(value)
	Format::NoUppercase(value)
		Toggle uppercase characters in hexadecimal and scientific form.

	Format::ShowPoint(value)
	Format::NoShowPoint(value)
		In floats, toggle always displaying the decimal point even if
		the number is an integer.

	Format::Fixed(value)
	Format::Scientific(value)
		Display the float with a fixed number of digits after the
		decimal point, or force using the scientific notation.

	Format::Precision(value, size_t precision)
		Fix the number of digits of precision used for floats. By
		default also enables the Fixed mode.

	Format::Width(value, size_t width)
		Fix the number of characters used to represent the value. By
		default also sets the fill to the digit '0'.

	All of the above can be written into builders with the value argument
	omitted. In that case the specifiers will affect all future writes to
	the builder.

	The following formatting specifiers can be passed to string functions
	SplitNumber and ToNumber:

	Format::Oct()
	Format::Dec()
	Format::Hex()
		Read the value in the specified base.

	Format::SkipWS()
	Format::NoSkipWS()
		Toggle ignoring the whitespace when reading a number.
*/

template<typename T> class FormatProxy
{
	T const &value;
	inline FormatProxy(T const &_value): value(_value) {}
public:
	inline void Write(StringBuilder &b) { b << value; }
};

namespace Format
{
	template<typename T, std::ios_base::fmtflags set, std::ios_base::fmtflags reset> struct FlagsOverride
	{
		T value;
		inline FlagsOverride(T _value): value(_value) {}
	};
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> struct FlagsOverride<void, set, reset>
	{
		inline FlagsOverride() {}
	};

	template<typename T> struct FillOverride
	{
		T value;
		size_t fill;
		inline FillOverride(T _value, size_t _fill): value(_value), fill(_fill) {}
	};
	template<> struct FillOverride<void>
	{
		String::value_type fill;
		inline FillOverride(size_t _fill): fill(_fill) {}
	};

	template<typename T> struct WidthOverride
	{
		T value;
		size_t width;
		inline WidthOverride(T _value, size_t _width): value(_value), width(_width) {}
	};
	template<> struct WidthOverride<void>
	{
		size_t width;
		inline WidthOverride(size_t _width): width(_width) {}
	};

	template<typename T> struct PrecisionOverride
	{
		T value;
		size_t precision;
		inline PrecisionOverride(T _value, size_t _precision): value(_value), precision(_precision) {}
	};
	template<> struct PrecisionOverride<void>
	{
		size_t precision;
		inline PrecisionOverride(size_t _precision): precision(_precision) {}
	};

	template<typename T> inline FlagsOverride<T, std::ios_base::oct, std::ios_base::basefield> Oct(T value) { return FlagsOverride<T, std::ios_base::oct, std::ios_base::basefield>(value); }
	template<typename T> inline FlagsOverride<T, std::ios_base::dec, std::ios_base::basefield> Dec(T value) { return FlagsOverride<T, std::ios_base::dec, std::ios_base::basefield>(value); }
	template<typename T> inline FlagsOverride<T, std::ios_base::hex, std::ios_base::basefield> Hex(T value) { return FlagsOverride<T, std::ios_base::hex, std::ios_base::basefield>(value); }
	inline FlagsOverride<void, std::ios_base::oct, std::ios_base::basefield> Oct() { return FlagsOverride<void, std::ios_base::oct, std::ios_base::basefield>(); }
	inline FlagsOverride<void, std::ios_base::dec, std::ios_base::basefield> Dec() { return FlagsOverride<void, std::ios_base::dec, std::ios_base::basefield>(); }
	inline FlagsOverride<void, std::ios_base::hex, std::ios_base::basefield> Hex() { return FlagsOverride<void, std::ios_base::hex, std::ios_base::basefield>(); }

	template<typename T> inline FlagsOverride<T, std::ios_base::uppercase, std::ios_base::uppercase> Uppercase(T value) { return FlagsOverride<T, std::ios_base::uppercase, std::ios_base::uppercase>(value); }
	template<typename T> inline FlagsOverride<T, std::ios_base::showpoint, std::ios_base::showpoint> ShowPoint(T value) { return FlagsOverride<T, std::ios_base::showpoint, std::ios_base::showpoint>(value); }
	template<typename T> inline FlagsOverride<T, EmptyFmtFlags, std::ios_base::uppercase> NoUppercase(T value) { return FlagsOverride<T, EmptyFmtFlags, std::ios_base::uppercase>(value); }
	template<typename T> inline FlagsOverride<T, EmptyFmtFlags, std::ios_base::showpoint> NoShowPoint(T value) { return FlagsOverride<T, EmptyFmtFlags, std::ios_base::showpoint>(value); }
	inline FlagsOverride<void, std::ios_base::uppercase, std::ios_base::uppercase> Uppercase() { return FlagsOverride<void, std::ios_base::uppercase, std::ios_base::uppercase>(); }
	inline FlagsOverride<void, std::ios_base::showpoint, std::ios_base::showpoint> ShowPoint() { return FlagsOverride<void, std::ios_base::showpoint, std::ios_base::showpoint>(); }
	inline FlagsOverride<void, std::ios_base::skipws, std::ios_base::skipws> SkipWS() { return FlagsOverride<void, std::ios_base::skipws, std::ios_base::skipws>(); }
	inline FlagsOverride<void, EmptyFmtFlags, std::ios_base::uppercase> NoUppercase() { return FlagsOverride<void, EmptyFmtFlags, std::ios_base::uppercase>(); }
	inline FlagsOverride<void, EmptyFmtFlags, std::ios_base::showpoint> NoShowPoint() { return FlagsOverride<void, EmptyFmtFlags, std::ios_base::showpoint>(); }
	inline FlagsOverride<void, EmptyFmtFlags, std::ios_base::skipws> NoSkipWS() { return FlagsOverride<void, EmptyFmtFlags, std::ios_base::skipws>(); }

	template<typename T> inline FlagsOverride<T, std::ios_base::fixed, std::ios_base::floatfield> Fixed(T value) { return FlagsOverride<T, std::ios_base::fixed, std::ios_base::floatfield>(value); }
	template<typename T> inline FlagsOverride<T, std::ios_base::scientific, std::ios_base::floatfield> Scientific(T value) { return FlagsOverride<T, std::ios_base::scientific, std::ios_base::floatfield>(value); }
	template<typename T> inline FlagsOverride<T, EmptyFmtFlags, std::ios_base::floatfield> FloatDefault(T value) { return FlagsOverride<T, EmptyFmtFlags, std::ios_base::floatfield>(value); }
	inline FlagsOverride<void, std::ios_base::fixed, std::ios_base::floatfield> Fixed() { return FlagsOverride<void, std::ios_base::fixed, std::ios_base::floatfield>(); }
	inline FlagsOverride<void, std::ios_base::scientific, std::ios_base::floatfield> Scientific() { return FlagsOverride<void, std::ios_base::scientific, std::ios_base::floatfield>(); }
	inline FlagsOverride<void, EmptyFmtFlags, std::ios_base::floatfield> FloatDefault() { return FlagsOverride<void, EmptyFmtFlags, std::ios_base::floatfield>(); }

	template<typename T> inline FillOverride<T> Fill(T value, String::value_type fill) { return FillOverride<T>(value, fill); }
	template<typename T> inline WidthOverride<T> Width(T value, size_t width) { return WidthOverride<T>(value, width); }
	template<typename T> inline PrecisionOverride<T> Precision(T value, size_t precision) { return PrecisionOverride<T>(value, precision); }
	inline FillOverride<void> Fill(String::value_type fill) { return FillOverride<void>(fill); }
	inline WidthOverride<void> Width(size_t width) { return WidthOverride<void>(width); }
	inline PrecisionOverride<void> Precision(size_t precision) { return PrecisionOverride<void>(precision); }
};

template<typename T, std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline ByteStringBuilder &operator<<(ByteStringBuilder &b, Format::FlagsOverride<T, set, reset> data)
{
	std::ios_base::fmtflags oldflags = b.flags;
	b.flags = (b.flags & ~reset) | set;
	b << data.value;
	b.flags = oldflags;
	return b;
}
template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline ByteStringBuilder &operator<<(ByteStringBuilder &b, Format::FlagsOverride<void, set, reset> data)
{
	b.flags = (b.flags & ~reset) | set;
	return b;
}

template<typename T> inline ByteStringBuilder &operator<<(ByteStringBuilder &b, Format::FillOverride<T> data)
{
	size_t oldfill = b.fill;
	b.fill = data.fill;
	b << data.value;
	b.fill = oldfill;
	return b;
}
inline ByteStringBuilder &operator<<(ByteStringBuilder &b, Format::FillOverride<void> data)
{
	b.fill = data.fill;
	return b;
}

template<typename T> inline ByteStringBuilder &operator<<(ByteStringBuilder &b, Format::WidthOverride<T> data)
{
	String::value_type oldfill = b.fill;
	if(oldfill == ' ')
		b.fill = '0';
	size_t oldwidth = b.width;
	b.width = data.width;
	b << data.value;
	b.width = oldwidth;
	b.fill = oldfill;
	return b;
}
inline ByteStringBuilder &operator<<(ByteStringBuilder &b, Format::WidthOverride<void> data)
{
	if(b.fill == ' ')
		b.fill = '0';
	b.width = data.width;
	return b;
}

template<typename T> inline ByteStringBuilder &operator<<(ByteStringBuilder &b, Format::PrecisionOverride<T> data)
{
	std::ios_base::fmtflags oldflags = b.flags;
	if(!(oldflags & std::ios_base::floatfield))
		b.flags |= std::ios_base::fixed;
	size_t oldprecision = b.precision;
	b.precision = data.precision;
	b << data.value;
	b.precision = oldprecision;
	b.flags = oldflags;
	return b;
}
inline ByteStringBuilder &operator<<(ByteStringBuilder &b, Format::PrecisionOverride<void> data)
{
	if(!(b.flags & std::ios_base::floatfield))
		b.flags |= std::ios_base::fixed;
	b.precision = data.precision;
	return b;
}

template<typename T, std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline StringBuilder &operator<<(StringBuilder &b, Format::FlagsOverride<T, set, reset> data)
{
	std::ios_base::fmtflags oldflags = b.flags;
	b.flags = (b.flags & ~reset) | set;
	b << data.value;
	b.flags = oldflags;
	return b;
}
template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline StringBuilder &operator<<(StringBuilder &b, Format::FlagsOverride<void, set, reset> data)
{
	b.flags = (b.flags & ~reset) | set;
	return b;
}

template<typename T> inline StringBuilder &operator<<(StringBuilder &b, Format::FillOverride<T> data)
{
	size_t oldfill = b.fill;
	b.fill = data.fill;
	b << data.value;
	b.fill = oldfill;
	return b;
}
inline StringBuilder &operator<<(StringBuilder &b, Format::FillOverride<void> data)
{
	b.fill = data.fill;
	return b;
}

template<typename T> inline StringBuilder &operator<<(StringBuilder &b, Format::WidthOverride<T> data)
{
	String::value_type oldfill = b.fill;
	if(oldfill == ' ')
		b.fill = '0';
	size_t oldwidth = b.width;
	b.width = data.width;
	b << data.value;
	b.width = oldwidth;
	b.fill = oldfill;
	return b;
}
inline StringBuilder &operator<<(StringBuilder &b, Format::WidthOverride<void> data)
{
	if(b.fill == ' ')
		b.fill = '0';
	b.width = data.width;
	return b;
}

template<typename T> inline StringBuilder &operator<<(StringBuilder &b, Format::PrecisionOverride<T> data)
{
	std::ios_base::fmtflags oldflags = b.flags;
	if(!(oldflags & std::ios_base::floatfield))
		b.flags |= std::ios_base::fixed;
	size_t oldprecision = b.precision;
	b.precision = data.precision;
	b << data.value;
	b.precision = oldprecision;
	b.flags = oldflags;
	return b;
}
inline StringBuilder &operator<<(StringBuilder &b, Format::PrecisionOverride<void> data)
{
	if(!(b.flags & std::ios_base::floatfield))
		b.flags |= std::ios_base::fixed;
	b.precision = data.precision;
	return b;
}


=== src\common\meson.build ===

common_files += files(
	'String.cpp',
	'tpt-rand.cpp',
)

subdir('clipboard')
subdir('platform')


=== src\common\Plane.h ===

#pragma once

#include <cstdint>
#include <cstddef>
#include <functional>
#include <limits>
#include <type_traits>
#include <utility>

#include "common/Vec2.h"

// TODO: std::span once we're C++20
template<class Item>
struct PlaneBase
{
	Item *base;

	PlaneBase(Item *newBase) : base(newBase)
	{
	}

	Item *begin()
	{
		return base;
	}

	const Item *begin() const
	{
		return base;
	}

	Item &operator [](size_t index)
	{
		return *(base + index);
	}

	const Item &operator [](size_t index) const
	{
		return *(base + index);
	}

	const Item *data() const
	{
		return base;
	}
};

constexpr size_t DynamicExtent = std::numeric_limits<size_t>::max();

template<size_t Extent>
struct extentStorage
{
	constexpr extentStorage(size_t)
	{}

	constexpr size_t getExtent() const
	{
		return Extent;
	}

	constexpr void setExtent(size_t)
	{}
};

template<>
struct extentStorage<DynamicExtent>
{
	size_t extent;

	constexpr extentStorage(size_t extent):
		extent(extent)
	{}

	constexpr size_t getExtent() const
	{
		return extent;
	}

	constexpr void setExtent(size_t extent)
	{
		this->extent = extent;
	}
};

template<size_t Extent>
struct xExtent: extentStorage<Extent>
{
	using extentStorage<Extent>::extentStorage;
};

template<size_t Extent>
struct yExtent: extentStorage<Extent>
{
	using extentStorage<Extent>::extentStorage;
};

template<typename T>
struct baseStorage
{
	using type = T;
};

template<typename T>
struct baseStorage<T &>
{
	using type = std::reference_wrapper<T>;
};

template<typename T>
struct baseStorage<T &&>
{
	using type = std::reference_wrapper<T>;
};

// A class that contains some container T and lets you index into it as if it
// were a 2D array of size Width x Height, in row-major order.
template<typename T, size_t Width = DynamicExtent, size_t Height = DynamicExtent>
class PlaneAdapter: xExtent<Width>, yExtent<Height>
{
	using value_type = std::remove_reference_t<decltype(std::declval<T>()[0])>;
	using iterator = decltype(std::begin(std::declval<T &>()));
	using const_iterator = decltype(std::begin(std::declval<T const &>()));

	size_t getWidth() const
	{
		return xExtent<Width>::getExtent();
	}

	size_t getHeight() const
	{
		return yExtent<Height>::getExtent();
	}

	std::remove_reference_t<T> &getBase()
	{
		return Base;
	}

	std::remove_reference_t<T> const &getBase() const
	{
		return Base;
	}

public:
	typename baseStorage<T>::type Base;

	PlaneAdapter():
		xExtent<Width>(0),
		yExtent<Height>(0),
		Base()
	{}

	template<typename... Args>
	PlaneAdapter(Vec2<int> size, Args&&... args):
		xExtent<Width>(size.X),
		yExtent<Height>(size.Y),
		Base(getWidth() * getHeight(), std::forward<Args>(args)...)
	{}

	template<typename... Args>
	PlaneAdapter(Vec2<int> size, std::in_place_t, Args&&... args):
		xExtent<Width>(size.X),
		yExtent<Height>(size.Y),
		Base(std::forward<Args>(args)...)
	{}

	Vec2<int> Size() const
	{
		return Vec2<int>(getWidth(), getHeight());
	}

	void SetSize(Vec2<int> size)
	{
		xExtent<Width>::setExtent(size.X);
		yExtent<Height>::setExtent(size.Y);
	}

	iterator RowIterator(Vec2<int> p)
	{
		return std::begin(getBase()) + (p.X + p.Y * getWidth());
	}

	const_iterator RowIterator(Vec2<int> p) const
	{
		return std::begin(getBase()) + (p.X + p.Y * getWidth());
	}

	value_type *data()
	{
		return std::data(getBase());
	}

	value_type const *data() const
	{
		return std::data(getBase());
	}

	value_type &operator[](Vec2<int> p)
	{
		return getBase()[p.X + p.Y * getWidth()];
	}

	value_type const &operator[](Vec2<int> p) const
	{
		return getBase()[p.X + p.Y * getWidth()];
	}
};


=== src\common\RasterGeometry.h ===

#include "common/Vec2.h"

// Draw a line from the origin on the ZW plane, assuming abs(dw) <= dz
template<bool Ortho, typename F>
void rasterizeLineZW(int dz, int dw, F f)
{
	const int incW = dw >= 0 ? 1 : -1;
	int w = 0, err = 0;
	for (int z = 0; z <= dz; z++)
	{
		f(z, w);

		// err / (2 * dz) is the difference between the integer w and the
		// (potentially non-integer) value z * dw / dz that would like w to be.
		// When the difference becomes too large, we can increment w.
		err += 2 * dw * incW;
		if (err >= dz)
		{
			w += incW;
			err -= 2 * dz;
			if (Ortho && z < dz)
				f(z, w);
		}
	}
}

// Call f for every point on the rasterization of a line between p1 and p2.
// Ortho makes the resulting line orthogonally connected.
template<bool Ortho, typename F>
void RasterizeLine(Vec2<int> p1, Vec2<int> p2, F f)
{
	if(std::abs(p1.X - p2.X) >= std::abs(p1.Y - p2.Y))
	{
		// If it's more wide than tall, map Z to X and W to Y
		auto source = p1.X < p2.X ? p1 : p2;
		auto delta = p1.X < p2.X ? p2 - p1 : p1 - p2;
		rasterizeLineZW<Ortho>(delta.X, delta.Y, [source, f](int z, int w) { f(source + Vec2(z, w)); });
	}
	else
	{
		// If it's more tall than wide, map Z to Y and W to X
		auto source = p1.Y < p2.Y ? p1 : p2;
		auto delta = p1.Y < p2.Y ? p2 - p1 : p1 - p2;
		rasterizeLineZW<Ortho>(delta.Y, delta.X, [source, f](int z, int w) { f(source + Vec2(w, z)); });
	}
}

template<typename F>
void rasterizeEllipseQuadrant(Vec2<float> radiusSquared, F f)
{
	// An ellipse is a region of points (x, y) such that
	// (x / rx)^2 + (y / ry)^2 <= 1, which can be rewritten as
	// x^2 * ry^2 + y^2 * rx^2 <= ry^2 * rx^2,
	// except, if rx == 0, then an additional constraint abs(y) <= ry must be
	// added, and same for ry.
	// The code below ensures 0 <= x <= rx and 0 <= y <= ry + 1.
	// A false positive for y > ry can only happen if rx == 0 and does not
	// affect the outcome
	auto inEllipse = [=](int x, int y)
	{
		return y * y * radiusSquared.X + x * x * radiusSquared.Y <= radiusSquared.X * radiusSquared.Y;
	};
	// Focusing on the bottom right quadrant, in every row we find the range of
	// points inside the ellipse, and within those, the range of points on the
	// boundary.
	int x = int(std::floor(std::sqrt(radiusSquared.X)));
	int maxY = int(std::floor(std::sqrt(radiusSquared.Y)));
	for (int y = 0; y <= maxY; y++)
	{
		// At the start of each iteration, (x, y) is on the boundary,
		// i.e. the range of points inside the ellipse is [0, x]
		if (inEllipse(x, y + 1))
		{
			// If the point below is inside, x is the only boundary point
			f(x, x, y);
		}
		else
		{
			// Otherwise, all points whose below point is outside -- are on the boundary
			int xStart = x;
			do
			{
				x--;
			} while (x >= 0 && !inEllipse(x, y + 1));
			f(x + 1, xStart, y);
		}
	}
}

// Call f for every point on the rasterized boundary of the ellipse with the
// indicated radius.
// In some situations we may want the radius to be the square root of an
// integer, so passing the radius squared allows for exact calculation.
// In some situations we may want the radius to be a half-integer, and floating
// point arithmetic is still exact for half-integers (really, 1/16ths), which is
// why we pass this as a float.
template<typename F>
void RasterizeEllipsePoints(Vec2<float> radiusSquared, F f)
{
	rasterizeEllipseQuadrant(radiusSquared, [f](int x1, int x2, int y)
		{
			for (int x = x1; x <= x2; x++)
			{
				f(Vec2(x, y));
				if (x) f(Vec2(-x, y));
				if (y) f(Vec2(x, -y));
				if (x && y) f(Vec2(-x, -y));
			}
		});
}

// Call f for every point inside the ellipse with the indicated radius.
template<typename F>
void RasterizeEllipseRows(Vec2<float> radiusSquared, F f)
{
	rasterizeEllipseQuadrant(radiusSquared, [f](int _, int xLim, int y)
		{
			f(xLim, y);
			if (y) f(xLim, -y);
		});
}

// Call f for every point on the boundary of the indicated rectangle (so that
// pos and BottomRight are both corners).
template<typename F>
void RasterizeRect(Rect<int> rect, F f)
{
	for (int x = rect.pos.X; x < rect.pos.X + rect.size.X; x++)
		f(Vec2(x, rect.pos.Y));

	if (rect.pos.Y != rect.pos.Y + rect.size.Y - 1)
		for (int x = rect.pos.X; x < rect.pos.X + rect.size.X; x++)
			f(Vec2(x, rect.pos.Y + rect.size.Y - 1));

	// corners already drawn
	for (int y = rect.pos.Y + 1; y < rect.pos.Y + rect.size.Y - 1; y++)
		f(Vec2(rect.pos.X, y));

	if (rect.pos.X != rect.pos.X + rect.size.X - 1)
		for (int y = rect.pos.Y + 1; y < rect.pos.Y + rect.size.Y - 1; y++)
			f(Vec2(rect.pos.X + rect.size.X - 1, y));
}

// Call f for every point on the dotted boundary of the indicated rectangle.
template<typename F>
void RasterizeDottedRect(Rect<int> rect, F f)
{
	for (int x = rect.pos.X; x < rect.pos.X + rect.size.X; x += 2)
		f(Vec2(x, rect.pos.Y));

	int bottomOff = (rect.pos.Y + rect.size.Y - 1 - rect.pos.Y) % 2;
	if (rect.pos.Y != rect.pos.Y + rect.size.Y - 1)
		for (int x = rect.pos.X + bottomOff; x < rect.pos.X + rect.size.X; x += 2)
			f(Vec2(x, rect.pos.Y + rect.size.Y - 1));

	// corners already drawn
	for (int y = rect.pos.Y + 1 + 1; y < rect.pos.Y + rect.size.Y - 1; y += 2)
		f(Vec2(rect.pos.X, y));

	int leftOff = (rect.pos.X + rect.size.X - 1 - rect.pos.X + 1) % 2;
	if (rect.pos.X != rect.pos.X + rect.size.X - 1)
		for (int y = rect.pos.Y + 1 + leftOff; y < rect.pos.Y + rect.size.Y - 1; y += 2)
			f(Vec2(rect.pos.X + rect.size.X - 1, y));
}


=== src\common\String.cpp ===

#include <sstream>
#include <vector>
#include <locale>
#include <limits>
#include <stdexcept>

#include "String.h"

ByteString ConversionError::formatError(ByteString::value_type const *at, ByteString::value_type const *upto)
{
	std::stringstream ss;
	ss << "Could not convert sequence to UTF-8:";
	for(int i = 0; i < 4 && at + i < upto; i++)
		ss << " " << std::hex << (unsigned int)std::make_unsigned<ByteString::value_type>::type(at[i]);
	return ss.str();
}

std::vector<ByteString> ByteString::PartitionBy(value_type ch, bool includeEmpty) const
{
	std::vector<ByteString> result;
	size_t at = 0;
	while(true)
	{
		Split split = SplitBy(ch, at);
		ByteString part = split.Before();
		if(includeEmpty || part.size())
			result.push_back(part);
		at = split.PositionAfter();
		if(!split)
			break;
	}
	return result;
}

std::vector<ByteString> ByteString::PartitionBy(ByteString const &str, bool includeEmpty) const
{
	std::vector<ByteString> result;
	size_t at = 0;
	while(true)
	{
		Split split = SplitBy(str, at);
		ByteString part = split.Before();
		if(includeEmpty || part.size())
			result.push_back(part);
		at = split.PositionAfter();
		if(!split)
			break;
	}
	return result;
}

std::vector<ByteString> ByteString::PartitionByAny(ByteString const &str, bool includeEmpty) const
{
	std::vector<ByteString> result;
	size_t at = 0;
	while(true)
	{
		Split split = SplitByAny(str, at);
		ByteString part = split.Before();
		if(includeEmpty || part.size())
			result.push_back(part);
		at = split.PositionAfter();
		if(!split)
			break;
	}
	return result;
}

ByteString &ByteString::Substitute(ByteString const &needle, ByteString const &replacement)
{
	size_t needleSize = needle.size();
	size_t replacementSize = replacement.size();
	size_t at = super::find(needle);
	while(at != npos)
	{
		super::replace(at, needleSize, replacement);
		at += replacementSize + !needleSize;
		at = super::find(needle, at);
	}
	return *this;
}

// The STL codecvt interfaces aren't very portable and behave wildly
// differntly on edge cases.
// Refer to Table 3.1 of the Unicode Standard version 3.1.0+

String ByteString::FromUtf8(bool ignoreError) const
{
	std::vector<String::value_type> destination;
	destination.reserve(size());
	std::make_unsigned<value_type>::type const *from = reinterpret_cast<std::make_unsigned<value_type>::type const *>(data());
	for(size_t i = 0; i < size(); )
	{
		if(from[i] < 0x80)
		{
			destination.push_back(from[i]);
			i += 1;
			continue;
		}
		else if(from[i] >= 0xC2 && from[i] < 0xE0)
		{
			if(i + 1 < size() && from[i + 1] >= 0x80 && from[i + 1] < 0xC0)
			{
				destination.push_back((from[i] & 0x1F) << 6 | (from[i + 1] & 0x3F));
				i += 2;
				continue;
			}
		}
		else if(from[i] >= 0xE0 && from[i] < 0xF0)
		{
			if(i + 1 < size() && from[i + 1] >= (from[i] == 0xE0 ? 0xA0 : 0x80) && from[i + 1] < 0xC0)
				if(i + 2 < size() && from[i + 2] >= 0x80 && from[i + 2] < 0xC0)
				{
					destination.push_back((from[i] & 0x0F) << 12 | (from[i + 1] & 0x3F) << 6 | (from[i + 2] & 0x3F));
					i += 3;
					continue;
				}
		}
		else if(from[i] >= 0xF0 && from[i] < 0xF5)
		{
			if(i + 1 < size() && from[i + 1] >= (from[i] == 0xF0 ? 0x90 : 0x80) && from[i + 1] < (from[i] == 0xF4 ? 0x90 : 0xC0))
				if(i + 2 < size() && from[i + 2] >= 0x80 && from[i + 2] < 0xC0)
					if(i + 3 < size() && from[i + 3] >= 0x80 && from[i + 3] < 0xC0)
					{
						destination.push_back((from[i] & 0x07) << 18 | (from[i + 1] & 0x3F) << 12 | (from[i + 2] & 0x3F) | (from[i + 3] & 0x3F));
						i += 4;
						continue;
					}
		}
		if(ignoreError)
			destination.push_back(from[i++]);
		else
			throw ConversionError(data() + i, data() + size());
	}
	return String(destination.data(), destination.size());
}

std::vector<String> String::PartitionBy(value_type ch, bool includeEmpty) const
{
	std::vector<String> result;
	size_t at = 0;
	while(true)
	{
		Split split = SplitBy(ch, at);
		String part = split.Before();
		if(includeEmpty || part.size())
			result.push_back(part);
		at = split.PositionAfter();
		if(!split)
			break;
	}
	return result;
}

std::vector<String> String::PartitionBy(String const &str, bool includeEmpty) const
{
	std::vector<String> result;
	size_t at = 0;
	while(true)
	{
		Split split = SplitBy(str, at);
		String part = split.Before();
		if(includeEmpty || part.size())
			result.push_back(part);
		at = split.PositionAfter();
		if(!split)
			break;
	}
	return result;
}

std::vector<String> String::PartitionByAny(String const &str, bool includeEmpty) const
{
	std::vector<String> result;
	size_t at = 0;
	while(true)
	{
		Split split = SplitByAny(str, at);
		String part = split.Before();
		if(includeEmpty || part.size())
			result.push_back(part);
		at = split.PositionAfter();
		if(!split)
			break;
	}
	return result;
}

String &String::Substitute(String const &needle, String const &replacement)
{
	size_t needleSize = needle.size();
	size_t replacementSize = replacement.size();
	size_t at = super::find(needle);
	while(at != npos)
	{
		super::replace(at, needleSize, replacement);
		at += replacementSize + !needleSize;
		at = super::find(needle, at);
	}
	return *this;
}

ByteString String::ToUtf8() const
{
	std::vector<std::make_unsigned<ByteString::value_type>::type> destination;
	destination.reserve(size() * 2);
	value_type const *from = data();
	for(size_t i = 0; i < size(); i++)
	{
		if(from[i] >= 0 && from[i] < 0x80)
		{
			destination.push_back(from[i]);
		}
		else if(from[i] < 0x800)
		{
			destination.push_back(0xC0 | (from[i] >> 6));
			destination.push_back(0x80 | (from[i] & 0x3F));
		}
		else if(from[i] < 0x10000)
		{
			destination.push_back(0xE0 | (from[i] >> 12));
			destination.push_back(0x80 | ((from[i] >> 6) & 0x3F));
			destination.push_back(0x80 | (from[i] & 0x3F));
		}
		else if(from[i] <= 0x10FFFF)
		{
			destination.push_back(0xF0 | (from[i] >> 18));
			destination.push_back(0x80 | ((from[i] >> 12) & 0x3F));
			destination.push_back(0x80 | ((from[i] >> 6) & 0x3F));
			destination.push_back(0x80 | (from[i] & 0x3F));
		}
		else
			throw ConversionError(true);
	}
	return ByteString(reinterpret_cast<ByteString::value_type const *>(destination.data()), destination.size());
}

/*
	Due to unknown reasons, the STL basically doesn't support string-number
	conversions for char32_t strings. Under the hood all stream objects use
	the so-called locale facets to do number formatting and parsing. As the
	name implies the facets can depend on the currently chosen locale, but
	they are also specialized by the type of characters that are used in
	the strings that are written/read.

	Of particular interest are the std::num_put<T> and std::num_get<T>
	facets. In accordance with the standard the two class templates are
	defined, and then specialized to char and wchar_t types. But the
	generic class template does not implement all the necessary methods,
	leaving you with undefined reference errors. Manually providing
	implementations for such methods is a not a portable solution.
	Therefore we provide our own number reading/writing interface, detached
	from std::basic_stringstream.

	We would nevertheless like to avoid writing all the conversion code
	ourselves and use STL as much as possible. As it turns out std::num_put
	and std::num_get are too wired into std::ios_base and thus are unusable
	in separation from an STL stream object.

	A hacky but simple solution is to create a static thread-local
	std::wstringstream initialized to the C locale (setting the locale of a
	temporarily created stream every time might be too expensive). Number
	serialization then simply uses operator<< and then manually widens the
	produced wchar_t's into char32_t's. Number parsing is more tricky and
	narrows only a prefix of the parsed string: it selects only characters
	that could be a part of a number as in "Stage 2" in
	[facet.num.get.virtuals], narrows them and uses operator>>. The number
	of characters consumed is used to take an offset into the original
	string.

	A std::stringstream is added in the same way for symmetry with
	ByteStringStream and follows the same protocol except it doesn't
	perform and narrowing or widening.

	The nice thing above the *_wchar functions immediately below is that on
	platforms where wchar_t has 32 bits these should be a no-op.
*/

inline String::value_type widen_wchar(wchar_t ch)
{
	return std::make_unsigned<wchar_t>::type(ch);
}

inline bool representable_wchar(String::value_type ch)
{
	return ch < String::value_type(std::make_unsigned<wchar_t>::type(std::numeric_limits<wchar_t>::max()));
}

inline wchar_t narrow_wchar(String::value_type ch)
{
	return wchar_t(ch);
}

char const numberChars[] = "-.+0123456789ABCDEFXabcdefx";
ByteString numberByteString(numberChars);
String numberString(numberChars);

struct LocaleImpl
{
	std::basic_stringstream<char> stream;
	std::basic_stringstream<wchar_t> wstream;

	LocaleImpl()
	{
		stream.imbue(std::locale::classic());
		wstream.imbue(std::locale::classic());
	}

	inline void PrepareStream(ByteStringBuilder &b)
	{
		stream.flags(b.flags);
		stream.width(b.width);
		stream.precision(b.precision);
		stream.fill(b.fill);
		stream.clear();
	}

	inline void PrepareStream(ByteString const &str, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset)
	{
		stream.flags((std::ios_base::dec & ~ reset) | set);
		std::basic_string<char> bstr;
		while(pos < str.size() && numberByteString.Contains(str[pos]))
			bstr.push_back(narrow_wchar(str[pos++]));
		stream.str(bstr);
		stream.clear();
	}

	inline void FlushStream(ByteStringBuilder &b)
	{
		std::basic_string<char> str = stream.str();
		b.AddChars(str.data(), str.size());
		stream.str(std::basic_string<char>());
	}

	inline void FlushStream()
	{
		stream.str(std::basic_string<char>());
	}

	inline void PrepareWStream(StringBuilder &b)
	{
		wstream.flags(b.flags);
		wstream.width(b.width);
		wstream.precision(b.precision);
		wstream.fill(b.fill);
		wstream.clear();
	}

	inline void PrepareWStream(String const &str, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset)
	{
		wstream.flags((std::ios_base::dec & ~ reset) | set);
		std::basic_string<wchar_t> wstr;
		while(pos < str.size() && representable_wchar(str[pos]) && numberString.Contains(str[pos]))
			wstr.push_back(narrow_wchar(str[pos++]));
		wstream.str(wstr);
		wstream.clear();
	}

	inline void FlushWStream(StringBuilder &b)
	{
		std::basic_string<wchar_t> wstr = wstream.str();
		std::vector<String::value_type> chars; // operator new?
		chars.reserve(wstr.size());
		for(wchar_t ch : wstream.str())
			chars.push_back(widen_wchar(ch));
		b.AddChars(chars.data(), chars.size());
		wstream.str(std::basic_string<wchar_t>());
	}

	inline void FlushWStream()
	{
		wstream.str(std::basic_string<wchar_t>());
	}
};

static LocaleImpl *getLocaleImpl()
{
	thread_local LocaleImpl li;
	return &li;
}

ByteString ByteStringBuilder::Build() const
{
	return ByteString(buffer.begin(), buffer.end());
}

void ByteStringBuilder::AddChars(ByteString::value_type const *data, size_t count)
{
	buffer.reserve(buffer.size() + count);
	buffer.insert(buffer.end(), data, data + count);
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, short int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, long int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, long long int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, unsigned short int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, unsigned int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, unsigned long int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, unsigned long long int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, ByteString::value_type data)
{
	b.AddChars(&data, 1);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, ByteString::value_type const *data)
{
	return b << ByteString(data);
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, ByteString const &data)
{
	b.AddChars(data.data(), data.size());
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, float data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteStringBuilder &operator<<(ByteStringBuilder &b, double data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(b);
	impl->stream << data;
	impl->FlushStream(b);
	return b;
}

ByteString::Split ByteString::SplitSigned(long long int &value, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(*this, pos, set, reset);
	impl->stream >> value;
	if(impl->stream.fail())
	{
		impl->FlushStream();
		return Split(*this, pos, npos, 0, false);
	}
	impl->stream.clear();
	Split split(*this, pos, pos + impl->stream.tellg(), 0, false);
	impl->FlushStream();
	return split;
}

ByteString::Split ByteString::SplitUnsigned(unsigned long long int &value, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(*this, pos, set, reset);
	impl->stream >> value;
	if(impl->stream.fail())
	{
		impl->FlushStream();
		return Split(*this, pos, npos, 0, false);
	}
	impl->stream.clear();
	Split split(*this, pos, pos + impl->stream.tellg(), 0, false);
	impl->FlushStream();
	return split;
}

ByteString::Split ByteString::SplitFloat(double &value, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareStream(*this, pos, set, reset);
	impl->stream >> value;
	if(impl->stream.fail())
	{
		impl->FlushStream();
		return Split(*this, pos, npos, 0, false);
	}
	impl->stream.clear();
	Split split(*this, pos, pos + impl->stream.tellg(), 0, false);
	impl->FlushStream();
	return split;
}

String StringBuilder::Build() const
{
	return String(buffer.begin(), buffer.end());
}

void StringBuilder::AddChars(String::value_type const *data, size_t count)
{
	buffer.reserve(buffer.size() + count);
	buffer.insert(buffer.end(), data, data + count);
}

StringBuilder &operator<<(StringBuilder &b, short int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, long int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, long long int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, unsigned short int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, unsigned int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, unsigned long int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, unsigned long long int data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, ByteString::value_type data)
{
	String::value_type ch = data;
	b.AddChars(&ch, 1);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, String::value_type data)
{
	b.AddChars(&data, 1);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, String::value_type const *data)
{
	return b << String(data);
}

StringBuilder &operator<<(StringBuilder &b, String const &data)
{
	b.AddChars(data.data(), data.size());
	return b;
}

StringBuilder &operator<<(StringBuilder &b, float data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

StringBuilder &operator<<(StringBuilder &b, double data)
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(b);
	impl->wstream << data;
	impl->FlushWStream(b);
	return b;
}

String::Split String::SplitSigned(long long int &value, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(*this, pos, set, reset);
	impl->wstream >> value;
	if(impl->wstream.fail())
	{
		impl->FlushWStream();
		return Split(*this, pos, npos, 0, false);
	}
	impl->wstream.clear();
	Split split(*this, pos, pos + impl->wstream.tellg(), 0, false);
	impl->FlushWStream();
	return split;
}

String::Split String::SplitUnsigned(unsigned long long int &value, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(*this, pos, set, reset);
	impl->wstream >> value;
	if(impl->wstream.fail())
	{
		impl->FlushWStream();
		return Split(*this, pos, npos, 0, false);
	}
	impl->wstream.clear();
	Split split(*this, pos, pos + impl->wstream.tellg(), 0, false);
	impl->FlushWStream();
	return split;
}

String::Split String::SplitFloat(double &value, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
{
	LocaleImpl *impl = getLocaleImpl();
	impl->PrepareWStream(*this, pos, set, reset);
	impl->wstream >> value;
	if(impl->wstream.fail())
	{
		impl->FlushWStream();
		return Split(*this, pos, npos, 0, false);
	}
	impl->wstream.clear();
	Split split(*this, pos, pos + impl->wstream.tellg(), 0, false);
	impl->FlushWStream();
	return split;
}


=== src\common\String.h ===

#pragma once
#include <algorithm>
#include <stdexcept>
#include <sstream>
#include <vector>
#include <string>
#include <limits>
#include <locale>
#include <ios>

/*
	There are two "string" classes: ByteString and String. They have nearly
	identical interfaces, except that one stores 8-bit octets (bytes) and
	the other stores Unicode codepoints.

	For ease of use, a String can be constructed from a string literal
	(char const[]) however not char const *. Exercise care when working
	with char arrays.

	Both classes inherit from std::basic_string (std::string is an
	instatiation of that), so all the familiar string interface is there
	however some helper methods have been defined:

	Substr(size_t start = 0, size_t count = npos)
		Returns a substring starting at position <start> and counting
		<count> symbols, or until end of string, whichever is earlier.
		If count == npos, the entire remainder of the string is
		included.

	SubstrFromEnd(size_t rstart = 0, size_t rcount = npos)
		Behaviourally equal to
			reverse(reverse(str).Substr(rstart, rcount))
		but is more efficient. Useful for taking suffixes of given
		length or dropping a fixed number of symbols from the end.

	Between(size_t begin, size_t end)
		Returns a substring starting at <begin> and ending at <end>.
		If end == npos, length of the string is used. If begin > end,
		an empty string is returned.

	Insert(size_t pos, String str)
		Inserts the characters from <str> at position <pos> shifting
		the rest of the string to the right.

	Erase(size_t pos, size_t count)
		Starting at position <pos> erases <count> characters to the
		right or until the end of string. The rest of the string is
		shifted left to fill the gap.

	EraseBetween(size_t from, size_t to)
		Starting at position <pos> erase until position <to> or end of
		string, whichever is earlier. The rest of the string is shifted
		left to fill the gap.

	BeginsWith(String prefix)
	EndsWith(String suffix)
	Contains(String infix)
	Contains(value_type infix)
		Self-explanatory.

	ToLower()
	ToUpper()
		Lowercases/Uppercases characters in the string. Only works on
		characters in the ASCII range.

	ByteString::FromUtf8(bool ignoreError = true)
		Decodes UTF-8 byte sequences into Unicode codepoints.
		If ignoreError is true, then invalid byte sequences are widened
		as-is. Otherwise, a ConversionError is thrown.

	ByteString::FromAscii()
		Interprets byte values as Unicode codepoints.

	String::ToUtf8()
		Encodes Unicode codepoints into UTF-8 byte sequences.

	String::ToAscii()
		Narrows Unicode codepoints into bytes, possibly truncating
		them (!).

	To convert something into a string use ByteStringBuilder and
	StringBuilder respectively. The two use operator<< much like
	std::ostringstream. To convert a builder to a string use the Build()
	method. Alternatively you could use the static ByteString::Build and
	String::Build methods respectively. String::Build(x, y, z) is roughly
	equivalent to:
		StringBuilder tmp;
		tmp << x << y << z;
		return tmp.Build();

	To control formatting of the input/output see "common/Format.h".

	If you simply want to convert a string to a number you can use the
	ToNumber<type>(bool ignoreError = false) method. It can optionally take
	a formatting specifier as an argument:
		str.ToNumber<unsigned>(Format::Hex(), true)

	Otherwise to parse a string into components you can use splits. A Split
	is a temporary object that "remembers" how a string is divided into a
	"prefix", a "separator", and a "suffix". A split can also "fail", if,
	for example the separator was not found in the string. A Split has the
	following methods:

	Before(bool includeSeparator = false)
		Returns the "prefix", optionally with the "separator".

	After(bool includeSeparator = false)
		Returns the "suffix", optionally with the "separator".

	A Split can also be converted to bool (used in the condition of an 'if'
	or a 'while'), in which case it shows whether the split had succeeded
	or failed. The idiomatic code goes like:
		if(String::Split split = str.SplitBy(','))
			// use split.Before() and split.After()
		else
			// str does not contain a ','

	The following methods split a string:

	SplitBy(String sep, size_t from = 0)
	SplitBy(value_type sep, size_t from = 0)
		Split on the first occurence of the <sep> separator since
		position <from>. If no such separator is found the split fails
		and "prefix" contains the whole string starting from <from>.

	SplitByAny(String chars, size_t from = 0)
		Split on the first occurence of any of the characters in
		<chars>.

	SplitByNot(String chars, size_t from = 0)
		Split on the first occurence of any character that is *not* in
		<chars>.

	SplitFromEndBy(String sep, size_t from = npos)
	SplitFromEndBy(value_type sep, size_t from = npos)
	SplitFromEndByAny(String chars, size_t from = npos)
	SplitFromEndByNot(String chars, size_t from = npos)
		These do the same as the functions above except they try to
		find the *last* occurence of the separator. If the split fails
		it is the "suffix" that contains the whole string, and the
		"prefix" is empty instead.

	SplitNumber(number &ref, size_t pos = 0)
		Attempt to read a number (with the type indicated by the type
		of the reference) from position <pos>. In case of success store
		the parsed number in the reference and return a split at the
		end of the parse. The separator in this case is empty. If the
		parse fails, the "prefix" is empty.

	SplitNumber(number &ref, format, size_t pos = 0)
		Parse the number according to the provided formatting
		specifier.

	It is recommented to use ByteString::value_type and String::value_type
	instead of char and char32_t respectively.

	The reason we do not use std::wstring is that on Windows, wchar_t is a
	16-bit type, which forces the usage of a UTF-16 (UCS-2) encoding to
	store the higher parts of the Unicode. The std::wstring implementation
	does not care to handle the UTF-16 encoding. Considering characters
	still occupy a variable amount of space (1 or 2 wchar_t's), finding the
	"n'th character" or "index of character at offset n" becomes a problem.
	(Event if that were not a problem a better solution would be to use the
	more space-efficient UTF-8). Therefore the String class is derived from
	std::basic_string<char32_t>, where char32_t is a type that is
	guaranteed to contain at least 32 bits. The drawback is that we
	basically lose std::stringstream (std::basic_stringstream) support and
	have to implement our own (See "common/String.cpp").
*/

class ByteStringBuilder;
class String;
class StringBuilder;
namespace Format
{
	const std::ios_base::fmtflags EmptyFmtFlags = std::ios_base::dec & ~std::ios_base::dec;
	template<typename T, std::ios_base::fmtflags set, std::ios_base::fmtflags reset> struct FlagsOverride;
}

template<typename T> class SplitBase
{
	T const &parent;
	size_t posFrom;
	size_t posBefore;
	size_t posAfter;
	bool reverse;

	inline SplitBase(T const &_parent, size_t _posFrom, size_t _posBefore, size_t offset, bool _reverse):
		parent(_parent),
		posFrom(_posFrom),
		posBefore(_posBefore),
		posAfter(_posBefore == T::npos ? T::npos : _posBefore + offset),
		reverse(_reverse)
	{}
public:
	inline T Before(bool includeSeparator = false) const
	{
		if(posBefore == T::npos)
			return reverse ? T() : parent.Substr(posFrom);
		return parent.Between(reverse ? 0 : posFrom, includeSeparator ? posAfter : posBefore);
	}
	inline T After(bool includeSeparator = false) const
	{
		if(posBefore == T::npos)
			return reverse ? parent.Substr(0, posFrom) : T();
		return parent.Between(includeSeparator ? posBefore : posAfter, reverse ? posFrom : T::npos);
	}

	inline size_t PositionFrom() const { return posFrom; }
	inline size_t PositionBefore() const { return posBefore; }
	inline size_t PositionAfter() const { return posAfter; }

	inline operator bool() const { return posBefore != T::npos; }

	friend T;
};

class ByteString : public std::basic_string<char>
{
	using super = std::basic_string<char>;
public:
	inline ByteString(): super() {}
	inline ByteString(value_type ch): super(1, ch) {}
	inline ByteString(size_type count, value_type ch): super(count, ch) {}
	inline ByteString(value_type const *ch, size_type count): super(ch, count) {}
	inline ByteString(value_type const *ch): super(ch) {}
	template<class It> inline ByteString(It first, It last): super(first, last) {}
	inline ByteString(super const &other): super(other) {}
	inline ByteString(super &&other): super(std::move(other)) {}
	inline ByteString(ByteString const &other): super(other) {}
	inline ByteString(ByteString &&other): super(std::move(other)) {}

	inline ByteString &operator=(ByteString const &other) { super::operator=(other); return *this; }
	inline ByteString &operator=(ByteString &&other) { super::operator=(other); return *this; }

	inline ByteString &operator+=(ByteString const &other) { super::operator+=(other); return *this; }
	inline ByteString &operator+=(ByteString &&other) { super::operator+=(std::move(other)); return *this; }

	inline ByteString Substr(size_t pos = 0, size_t count = npos) const { return super::substr(pos, count); }
	inline ByteString SubstrFromEnd(size_t rpos = 0, size_t rcount = npos) const { return super::substr(rcount == npos || rcount > rpos ? 0 : rpos - rcount, size() - rpos); }
	inline ByteString Between(size_t from, size_t to) const { return to == npos ? super::substr(from) : from >= to ? ByteString() : super::substr(from, to - from); }

	inline bool Contains(value_type ch) const { return super::find(ch) != npos; }
	inline bool Contains(ByteString const &other) const { return super::find(other) != npos; }

	inline bool BeginsWith(ByteString const &other) const { return !super::compare(0, other.size(), other); }
	inline bool EndsWith(ByteString const &other) const { return size() >= other.size() && !super::compare(size() - other.size(), other.size(), other); }

	using Split = SplitBase<ByteString>;
	inline Split SplitBy(value_type ch, size_t pos = 0) const { return Split(*this, pos, super::find(ch, pos), 1, false); }
	inline Split SplitBy(ByteString const &str, size_t pos = 0) const { return Split(*this, pos, super::find(str, pos), str.size(), false); }
	inline Split SplitByAny(ByteString const &str, size_t pos = 0) const { return Split(*this, pos, super::find_first_of(str, pos), 1, false); }
	inline Split SplitByNot(ByteString const &str, size_t pos = 0) const { return Split(*this, pos, super::find_first_not_of(str, pos), 1, false); }
	inline Split SplitFromEndBy(value_type ch, size_t pos = npos) const { return Split(*this, pos, super::rfind(ch, pos), 1, true); }
	inline Split SplitFromEndBy(ByteString const &str, size_t pos = npos) const { return Split(*this, pos, super::rfind(str, pos), str.size(), true); }
	inline Split SplitFromEndByAny(ByteString const &str, size_t pos = npos) const { return Split(*this, pos, super::find_last_of(str, pos), 1, true); }
	inline Split SplitFromEndByNot(ByteString const &str, size_t pos = npos) const { return Split(*this, pos, super::find_last_not_of(str, pos), 1, true); }
private:
	Split SplitSigned(long long int &, size_t, std::ios_base::fmtflags, std::ios_base::fmtflags) const;
	Split SplitUnsigned(unsigned long long int &, size_t, std::ios_base::fmtflags, std::ios_base::fmtflags) const;
	Split SplitFloat(double &, size_t, std::ios_base::fmtflags, std::ios_base::fmtflags) const;
public:
	template<typename T> inline Split SplitSigned(T &ref, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
	{
		long long int value = 0;
		Split split = SplitSigned(value, pos, set, reset);
		ref = value;
		return split;
	}
	template<typename T> inline Split SplitUnsigned(T &ref, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
	{
		unsigned long long int value = 0;
		Split split = SplitUnsigned(value, pos, set, reset);
		ref = value;
		return split;
	}
	template<typename T> inline Split SplitFloat(T &ref, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
	{
		double value = 0;
		Split split = SplitFloat(value, pos, set, reset);
		ref = value;
		return split;
	}

	inline Split SplitNumber(short int &ref, size_t pos = 0) const { return SplitSigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(int &ref, size_t pos = 0) const { return SplitSigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(long int &ref, size_t pos = 0) const { return SplitSigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(long long int &ref, size_t pos = 0) const { return SplitSigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(unsigned short int &ref, size_t pos = 0) const { return SplitUnsigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(unsigned int &ref, size_t pos = 0) const { return SplitUnsigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(unsigned long int &ref, size_t pos = 0) const { return SplitUnsigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(unsigned long long int &ref, size_t pos = 0) const { return SplitUnsigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(float &ref, size_t pos = 0) const { return SplitFloat(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(double &ref, size_t pos = 0) const { return SplitFloat(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }

	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(short int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitSigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitSigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(long int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitSigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(long long int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitSigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(unsigned short int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitUnsigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(unsigned int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitUnsigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(unsigned long int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitUnsigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(unsigned long long int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitUnsigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(float &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitFloat(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(double &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitFloat(ref, pos, set, reset); }

	template<typename T> T ToNumber(bool noThrow = false) const
	{
		T value = T();
		Split split = SplitNumber(value);
		if(split.PositionBefore() != size())
			return noThrow ? T() : throw std::runtime_error("Not a number");
		return value;
	}
	template<typename T, std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline T ToNumber(Format::FlagsOverride<void, set, reset> fmt, bool noThrow = false) const
	{
		T value = T();
		Split split = SplitNumber(value, fmt);
		if(split.PositionBefore() != size())
			return noThrow ? T() : throw std::runtime_error("Not a number");
		return value;
	}

	std::vector<ByteString> PartitionBy(value_type ch, bool includeEmpty = false) const;
	std::vector<ByteString> PartitionBy(ByteString const &str, bool includeEmpty = false) const;
	std::vector<ByteString> PartitionByAny(ByteString const &str, bool includeEmpty = false) const;

	ByteString &Substitute(ByteString const &needle, ByteString const &replacement);

	inline ByteString &Insert(size_t pos, ByteString const &str) { super::insert(pos, str); return *this; }
	inline ByteString &Erase(size_t pos, size_t count) { super::erase(pos, count); return *this; }
	inline ByteString &EraseBetween(size_t from, size_t to) { if(from < to) super::erase(from, to - from); return *this; }

	inline ByteString ToLower() const
	{
		std::locale const &loc = std::locale::classic();
		ByteString value(*this);
		for(value_type &ch : value)
			ch = std::tolower(ch, loc);
		return value;
	}

	inline ByteString ToUpper() const
	{
		std::locale const &loc = std::locale::classic();
		ByteString value(*this);
		for(value_type &ch : value)
			ch = std::toupper(ch, loc);
		return value;
	}

	String FromUtf8(bool ignoreError = true) const;
	inline String FromAscii() const;
	template<typename... Ts> static ByteString Build(Ts&&... args);
};

inline ByteString operator+(ByteString const &lhs, ByteString const &rhs) { return static_cast<std::basic_string<char> const &>(lhs) + static_cast<std::basic_string<char> const &>(rhs); }
inline ByteString operator+(ByteString const &lhs, ByteString &&rhs) { return static_cast<std::basic_string<char> const &>(lhs) + static_cast<std::basic_string<char> &&>(rhs); }
inline ByteString operator+(ByteString &&lhs, ByteString const &rhs) { return static_cast<std::basic_string<char> &&>(lhs) + static_cast<std::basic_string<char> const &>(rhs); }
inline ByteString operator+(ByteString &&lhs, ByteString &&rhs) { return static_cast<std::basic_string<char> &&>(lhs) + static_cast<std::basic_string<char> &&>(rhs); }
inline ByteString operator+(ByteString const &lhs, std::basic_string<char> const &rhs) { return static_cast<std::basic_string<char> const &>(lhs) + rhs; }
inline ByteString operator+(ByteString const &lhs, std::basic_string<char> &&rhs) { return static_cast<std::basic_string<char> const &>(lhs) + std::move(rhs); }
inline ByteString operator+(ByteString &&lhs, std::basic_string<char> const &rhs) { return static_cast<std::basic_string<char> &&>(lhs) + rhs; }
inline ByteString operator+(ByteString &&lhs, std::basic_string<char> &&rhs) { return static_cast<std::basic_string<char> &&>(lhs) + std::move(rhs); }
inline ByteString operator+(ByteString const &lhs, ByteString::value_type rhs) { return static_cast<std::basic_string<char> const &>(lhs) + rhs; }
inline ByteString operator+(ByteString &&lhs, ByteString::value_type rhs) { return static_cast<std::basic_string<char> &&>(lhs) + rhs; }
inline ByteString operator+(ByteString const &lhs, ByteString::value_type const *rhs) { return static_cast<std::basic_string<char> const &>(lhs) + rhs; }
inline ByteString operator+(ByteString &&lhs, ByteString::value_type const *rhs) { return static_cast<std::basic_string<char> &&>(lhs) + rhs; }
inline ByteString operator+(std::basic_string<char> const &lhs, ByteString const &rhs) { return lhs + static_cast<std::basic_string<char> const &>(rhs); }
inline ByteString operator+(std::basic_string<char> const &lhs, ByteString &&rhs) { return lhs + static_cast<std::basic_string<char> &&>(rhs); }
inline ByteString operator+(std::basic_string<char> &&lhs, ByteString const &rhs) { return std::move(lhs) + static_cast<std::basic_string<char> const &>(rhs); }
inline ByteString operator+(std::basic_string<char> &&lhs, ByteString &&rhs) { return std::move(lhs) + static_cast<std::basic_string<char> &&>(rhs); }
inline ByteString operator+(ByteString::value_type lhs, ByteString const &rhs) { return lhs + static_cast<std::basic_string<char> const &>(rhs); }
inline ByteString operator+(ByteString::value_type lhs, ByteString &&rhs) { return lhs + static_cast<std::basic_string<char> &&>(rhs); }
inline ByteString operator+(ByteString::value_type const *lhs, ByteString const &rhs) { return lhs + static_cast<std::basic_string<char> const &>(rhs); }
inline ByteString operator+(ByteString::value_type const *lhs, ByteString &&rhs) { return lhs + static_cast<std::basic_string<char> &&>(rhs); }

inline bool operator==(ByteString const &lhs, ByteString const &rhs) { return static_cast<std::basic_string<char> const &>(lhs) == static_cast<std::basic_string<char> const &>(rhs); }
inline bool operator==(ByteString const &lhs, std::basic_string<char> const &rhs) { return static_cast<std::basic_string<char> const &>(lhs) == rhs; }
inline bool operator==(ByteString const &lhs, ByteString::value_type const *rhs) { return static_cast<std::basic_string<char> const &>(lhs) == rhs; }
inline bool operator==(std::basic_string<char> const &lhs, ByteString const &rhs) { return lhs == static_cast<std::basic_string<char> const &>(rhs); }
inline bool operator==(ByteString::value_type const *lhs, ByteString const &rhs) { return lhs == static_cast<std::basic_string<char> const &>(rhs); }

inline bool operator!=(ByteString const &lhs, ByteString const &rhs) { return static_cast<std::basic_string<char> const &>(lhs) != static_cast<std::basic_string<char> const &>(rhs); }
inline bool operator!=(ByteString const &lhs, std::basic_string<char> const &rhs) { return static_cast<std::basic_string<char> const &>(lhs) != rhs; }
inline bool operator!=(ByteString const &lhs, ByteString::value_type const *rhs) { return static_cast<std::basic_string<char> const &>(lhs) != rhs; }
inline bool operator!=(std::basic_string<char> const &lhs, ByteString const &rhs) { return lhs != static_cast<std::basic_string<char> const &>(rhs); }
inline bool operator!=(ByteString::value_type const *lhs, ByteString const &rhs) { return lhs != static_cast<std::basic_string<char> const &>(rhs); }

class String : public std::basic_string<char32_t>
{
	using super = std::basic_string<char32_t>;
public:
	inline String(): super() {}
	inline String(value_type ch): super(1, ch) {}
	inline String(size_type count, value_type ch): super(count, ch) {}
	inline String(value_type const *ch, size_type count): super(ch, count) {}
	inline String(value_type const *ch): super(ch) {}
	template<class It> inline String(It first, It last): super(first, last) {}
	inline String(super const &other): super(other) {}
	inline String(super &&other): super(std::move(other)) {}
	inline String(String const &other): super(other) {}
	inline String(String &&other): super(std::move(other)) {}
	template<size_t N> inline String(ByteString::value_type const (&ch)[N]): super(ByteString(ch, N - 1).FromAscii()) {}

	inline String &operator=(String const &other) { super::operator=(other); return *this; }
	inline String &operator=(String &&other) { super::operator=(other); return *this; }

	inline String &operator+=(String const &other) { super::operator+=(other); return *this; }
	inline String &operator+=(String &&other) { super::operator+=(std::move(other)); return *this; }

	inline String Substr(size_t pos = 0, size_t count = npos) const { return super::substr(pos, count); }
	inline String SubstrFromEnd(size_t rpos = 0, size_t rcount = npos) const { return super::substr(rcount == npos || rcount > rpos ? 0 : rpos - rcount, size() - rpos); }
	inline String Between(size_t from, size_t to) const { return to == npos ? super::substr(from) : from >= to ? String() : super::substr(from, to - from); }

	inline bool Contains(value_type ch) const { return super::find(ch) != npos; }
	inline bool Contains(String const &other) const { return super::find(other) != npos; }

	inline bool BeginsWith(String const &other) const { return !super::compare(0, other.size(), other); }
	inline bool EndsWith(String const &other) const { return size() >= other.size() && !super::compare(size() - other.size(), other.size(), other); }

	using Split = SplitBase<String>;
	inline Split SplitBy(value_type ch, size_t pos = 0) const { return Split(*this, pos, super::find(ch, pos), 1, false); }
	inline Split SplitBy(String const &str, size_t pos = 0) const { return Split(*this, pos, super::find(str, pos), str.size(), false); }
	inline Split SplitByAny(String const &str, size_t pos = 0) const { return Split(*this, pos, super::find_first_of(str, pos), 1, false); }
	inline Split SplitByNot(String const &str, size_t pos = 0) const { return Split(*this, pos, super::find_first_not_of(str, pos), 1, false); }
	inline Split SplitFromEndBy(value_type ch, size_t pos = npos) const { return Split(*this, pos, super::rfind(ch, pos), 1, true); }
	inline Split SplitFromEndBy(String const &str, size_t pos = npos) const { return Split(*this, pos, super::rfind(str, pos), str.size(), true); }
	inline Split SplitFromEndByAny(String const &str, size_t pos = npos) const { return Split(*this, pos, super::find_last_of(str, pos), 1, true); }
	inline Split SplitFromEndByNot(String const &str, size_t pos = npos) const { return Split(*this, pos, super::find_last_not_of(str, pos), 1, true); }
private:
	Split SplitSigned(long long int &, size_t, std::ios_base::fmtflags, std::ios_base::fmtflags) const;
	Split SplitUnsigned(unsigned long long int &, size_t, std::ios_base::fmtflags, std::ios_base::fmtflags) const;
	Split SplitFloat(double &, size_t, std::ios_base::fmtflags, std::ios_base::fmtflags) const;
public:
	template<typename T> inline Split SplitSigned(T &ref, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
	{
		long long int value = 0;
		Split split = SplitSigned(value, pos, set, reset);
		ref = value;
		return split;
	}
	template<typename T> inline Split SplitUnsigned(T &ref, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
	{
		unsigned long long int value = 0;
		Split split = SplitUnsigned(value, pos, set, reset);
		ref = value;
		return split;
	}
	template<typename T> inline Split SplitFloat(T &ref, size_t pos, std::ios_base::fmtflags set, std::ios_base::fmtflags reset) const
	{
		double value = 0;
		Split split = SplitFloat(value, pos, set, reset);
		ref = value;
		return split;
	}

	inline Split SplitNumber(short int &ref, size_t pos = 0) const { return SplitSigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(int &ref, size_t pos = 0) const { return SplitSigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(long int &ref, size_t pos = 0) const { return SplitSigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(long long int &ref, size_t pos = 0) const { return SplitSigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(unsigned short int &ref, size_t pos = 0) const { return SplitUnsigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(unsigned int &ref, size_t pos = 0) const { return SplitUnsigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(unsigned long int &ref, size_t pos = 0) const { return SplitUnsigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(unsigned long long int &ref, size_t pos = 0) const { return SplitUnsigned(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(float &ref, size_t pos = 0) const { return SplitFloat(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }
	inline Split SplitNumber(double &ref, size_t pos = 0) const { return SplitFloat(ref, pos, std::ios_base::fmtflags(), std::ios_base::fmtflags()); }

	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(short int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitSigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitSigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(long int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitSigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(long long int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitSigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(unsigned short int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitUnsigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(unsigned int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitUnsigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(unsigned long int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitUnsigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(unsigned long long int &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitUnsigned(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(float &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitFloat(ref, pos, set, reset); }
	template<std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline Split SplitNumber(double &ref, Format::FlagsOverride<void, set, reset>, size_t pos = 0) const { return SplitFloat(ref, pos, set, reset); }

	template<typename T> T ToNumber(bool noThrow = false) const
	{
		T value = T();
		Split split = SplitNumber(value);
		if(split.PositionBefore() != size())
			return noThrow ? T() : throw std::runtime_error("Not a number");
		return value;
	}
	template<typename T, std::ios_base::fmtflags set, std::ios_base::fmtflags reset> inline T ToNumber(Format::FlagsOverride<void, set, reset> fmt, bool noThrow = false) const
	{
		T value = T();
		Split split = SplitNumber(value, fmt);
		if(split.PositionBefore() != size())
			return noThrow ? T() : throw std::runtime_error("Not a number");
		return value;
	}

	std::vector<String> PartitionBy(value_type ch, bool includeEmpty = false) const;
	std::vector<String> PartitionBy(String const &str, bool includeEmpty = false) const;
	std::vector<String> PartitionByAny(String const &str, bool includeEmpty = false) const;

	String &Substitute(String const &needle, String const &replacement);

	inline String &Insert(size_t pos, String const &str) { super::insert(pos, str); return *this; }
	inline String &Erase(size_t pos, size_t count) { super::erase(pos, count); return *this; }
	inline String &EraseBetween(size_t from, size_t to) { if(from < to) super::erase(from, to - from); return *this; }

	inline String ToLower() const
	{
		std::locale const &loc = std::locale::classic();
		String value(*this);
		for(value_type &ch : value)
			if(ch <= static_cast<value_type>(std::numeric_limits<ByteString::value_type>::max()))
				ch = std::tolower(static_cast<ByteString::value_type>(ch), loc);
		return value;
	}

	inline String ToUpper() const
	{
		std::locale const &loc = std::locale::classic();
		String value(*this);
		for(value_type &ch : value)
			if(ch <= static_cast<value_type>(std::numeric_limits<ByteString::value_type>::max()))
				ch = std::toupper(static_cast<ByteString::value_type>(ch), loc);
		return value;
	}

	ByteString ToUtf8() const;
	ByteString ToAscii() const;
	template<typename... Ts> static String Build(Ts&&... args);
};

inline String operator+(String const &lhs, String const &rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) + static_cast<std::basic_string<char32_t> const &>(rhs); }
inline String operator+(String const &lhs, String &&rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) + static_cast<std::basic_string<char32_t> &&>(rhs); }
inline String operator+(String &&lhs, String const &rhs) { return static_cast<std::basic_string<char32_t> &&>(lhs) + static_cast<std::basic_string<char32_t> const &>(rhs); }
inline String operator+(String &&lhs, String &&rhs) { return static_cast<std::basic_string<char32_t> &&>(lhs) + static_cast<std::basic_string<char32_t> &&>(rhs); }
inline String operator+(String const &lhs, std::basic_string<char32_t> const &rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) + rhs; }
inline String operator+(String const &lhs, std::basic_string<char32_t> &&rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) + std::move(rhs); }
inline String operator+(String &&lhs, std::basic_string<char32_t> const &rhs) { return static_cast<std::basic_string<char32_t> &&>(lhs) + rhs; }
inline String operator+(String &&lhs, std::basic_string<char32_t> &&rhs) { return static_cast<std::basic_string<char32_t> &&>(lhs) + std::move(rhs); }
inline String operator+(String const &lhs, String::value_type rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) + rhs; }
inline String operator+(String &&lhs, String::value_type rhs) { return static_cast<std::basic_string<char32_t> &&>(lhs) + rhs; }
inline String operator+(String const &lhs, String::value_type const *rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) + rhs; }
inline String operator+(String &&lhs, String::value_type const *rhs) { return static_cast<std::basic_string<char32_t> &&>(lhs) + rhs; }
inline String operator+(std::basic_string<char32_t> const &lhs, String const &rhs) { return lhs + static_cast<std::basic_string<char32_t> const &>(rhs); }
inline String operator+(std::basic_string<char32_t> const &lhs, String &&rhs) { return lhs + static_cast<std::basic_string<char32_t> &&>(rhs); }
inline String operator+(std::basic_string<char32_t> &&lhs, String const &rhs) { return std::move(lhs) + static_cast<std::basic_string<char32_t> const &>(rhs); }
inline String operator+(std::basic_string<char32_t> &&lhs, String &&rhs) { return std::move(lhs) + static_cast<std::basic_string<char32_t> &&>(rhs); }
inline String operator+(String::value_type lhs, String const &rhs) { return lhs + static_cast<std::basic_string<char32_t> const &>(rhs); }
inline String operator+(String::value_type lhs, String &&rhs) { return lhs + static_cast<std::basic_string<char32_t> &&>(rhs); }
inline String operator+(String::value_type const *lhs, String const &rhs) { return lhs + static_cast<std::basic_string<char32_t> const &>(rhs); }
inline String operator+(String::value_type const *lhs, String &&rhs) { return lhs + static_cast<std::basic_string<char32_t> &&>(rhs); }
template<size_t N> inline String operator+(String const &lhs, ByteString::value_type const (&rhs)[N]) { return static_cast<std::basic_string<char32_t> const &>(lhs) + ByteString(rhs).FromAscii(); }
template<size_t N> inline String operator+(String &&lhs, ByteString::value_type const (&rhs)[N]) { return static_cast<std::basic_string<char32_t> &&>(lhs) + ByteString(rhs).FromAscii(); }
template<size_t N> inline String operator+(ByteString::value_type const (&lhs)[N], String const &rhs) { return ByteString(lhs).FromAscii() + static_cast<std::basic_string<char32_t> const &>(rhs); }
template<size_t N> inline String operator+(ByteString::value_type const (&lhs)[N], String &&rhs) { return ByteString(lhs).FromAscii() + static_cast<std::basic_string<char32_t> &&>(rhs); }

inline bool operator==(String const &lhs, String const &rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) == static_cast<std::basic_string<char32_t> const &>(rhs); }
inline bool operator==(String const &lhs, std::basic_string<char32_t> const &rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) == rhs; }
inline bool operator==(String const &lhs, String::value_type const *rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) == rhs; }
inline bool operator==(std::basic_string<char32_t> const &lhs, String const &rhs) { return lhs == static_cast<std::basic_string<char32_t> const &>(rhs); }
inline bool operator==(String::value_type const *lhs, String const &rhs) { return lhs == static_cast<std::basic_string<char32_t> const &>(rhs); }
template<size_t N> inline bool operator==(String const &lhs, ByteString::value_type const (&rhs)[N]) { return static_cast<std::basic_string<char32_t> const &>(lhs) == ByteString(rhs).FromAscii(); }
template<size_t N> inline bool operator==(ByteString::value_type const (&lhs)[N], String const &rhs) { return ByteString(lhs).FromAscii() == static_cast<std::basic_string<char32_t> const &>(rhs); }

inline bool operator!=(String const &lhs, String const &rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) != static_cast<std::basic_string<char32_t> const &>(rhs); }
inline bool operator!=(String const &lhs, std::basic_string<char32_t> const &rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) != rhs; }
inline bool operator!=(String const &lhs, String::value_type const *rhs) { return static_cast<std::basic_string<char32_t> const &>(lhs) != rhs; }
inline bool operator!=(std::basic_string<char32_t> const &lhs, String const &rhs) { return lhs != static_cast<std::basic_string<char32_t> const &>(rhs); }
inline bool operator!=(String::value_type const *lhs, String const &rhs) { return lhs != static_cast<std::basic_string<char32_t> const &>(rhs); }
template<size_t N> inline bool operator!=(String const &lhs, ByteString::value_type const (&rhs)[N]) { return static_cast<std::basic_string<char32_t> const &>(lhs) != ByteString(rhs).FromAscii(); }
template<size_t N> inline bool operator!=(ByteString::value_type const (&lhs)[N], String const &rhs) { return ByteString(lhs).FromAscii() != static_cast<std::basic_string<char32_t> const &>(rhs); }

inline String ByteString::FromAscii() const
{
	String destination = String(size(), String::value_type());
	for(size_t i = 0; i < size(); i++)
		destination[i] = String::value_type(std::make_unsigned<ByteString::value_type>::type(operator[](i)));
	return destination;
}

inline ByteString String::ToAscii() const
{
	ByteString destination = ByteString(size(), ByteString::value_type());
	for(size_t i = 0; i < size(); i++)
		destination[i] = ByteString::value_type(operator[](i));
	return destination;
}

class ConversionError : public std::runtime_error
{
	static ByteString formatError(ByteString::value_type const *at, ByteString::value_type const *upto);
public:
	inline ConversionError(ByteString::value_type const *at, ByteString::value_type const *upto): std::runtime_error(formatError(at, upto)) {}
	inline ConversionError(bool to): std::runtime_error(to ? "Could not convert to UTF-8" : "Could not convert from UTF-8") {}
};

class ByteStringBuilder
{
	std::vector<ByteString::value_type> buffer;
public:
	std::ios_base::fmtflags flags;
	ByteString::value_type fill;
	size_t width, precision;
	inline ByteStringBuilder(): flags(std::ios_base::skipws | std::ios_base::dec), fill(' '), width(0), precision(6) {}

	void AddChars(ByteString::value_type const *, size_t);
	size_t Size() const { return buffer.size(); }
	ByteString Build() const;

	template<typename T> ByteStringBuilder &operator<<(T) &&= delete;

	template<typename T, typename... Ts> inline ByteStringBuilder &Add(T &&arg, Ts&&... args)
	{
		return (*this << std::forward<T>(arg)).Add(std::forward<Ts>(args)...);
	}
	inline ByteStringBuilder &Add() { return *this; }
};

ByteStringBuilder &operator<<(ByteStringBuilder &, short int);
ByteStringBuilder &operator<<(ByteStringBuilder &, int);
ByteStringBuilder &operator<<(ByteStringBuilder &, long int);
ByteStringBuilder &operator<<(ByteStringBuilder &, long long int);
ByteStringBuilder &operator<<(ByteStringBuilder &, unsigned short int);
ByteStringBuilder &operator<<(ByteStringBuilder &, unsigned int);
ByteStringBuilder &operator<<(ByteStringBuilder &, unsigned long int);
ByteStringBuilder &operator<<(ByteStringBuilder &, unsigned long long int);
ByteStringBuilder &operator<<(ByteStringBuilder &, ByteString::value_type);
ByteStringBuilder &operator<<(ByteStringBuilder &, ByteString::value_type const *);
ByteStringBuilder &operator<<(ByteStringBuilder &, ByteString const &);
ByteStringBuilder &operator<<(ByteStringBuilder &, float);
ByteStringBuilder &operator<<(ByteStringBuilder &, double);

template<typename... Ts> ByteString ByteString::Build(Ts&&... args)
{
	ByteStringBuilder b;
	b.Add(std::forward<Ts>(args)...);
	return b.Build();
}

class StringBuilder
{
	std::vector<String::value_type> buffer;
public:
	std::ios_base::fmtflags flags;
	String::value_type fill;
	size_t width, precision;
	inline StringBuilder(): flags(std::ios_base::skipws | std::ios_base::dec), fill(' '), width(0), precision(6) {}

	void AddChars(String::value_type const *, size_t);
	size_t Size() const { return buffer.size(); }
	String Build() const;

	template<typename T> StringBuilder &operator<<(T) = delete;

	template<typename T, typename... Ts> inline StringBuilder &Add(T &&arg, Ts&&... args)
	{
		return (*this << std::forward<T>(arg)).Add(std::forward<Ts>(args)...);
	}
	inline StringBuilder &Add() { return *this; }
};

StringBuilder &operator<<(StringBuilder &, short int);
StringBuilder &operator<<(StringBuilder &, int);
StringBuilder &operator<<(StringBuilder &, long int);
StringBuilder &operator<<(StringBuilder &, long long int);
StringBuilder &operator<<(StringBuilder &, unsigned short int);
StringBuilder &operator<<(StringBuilder &, unsigned int);
StringBuilder &operator<<(StringBuilder &, unsigned long int);
StringBuilder &operator<<(StringBuilder &, unsigned long long int);
StringBuilder &operator<<(StringBuilder &, ByteString::value_type);
StringBuilder &operator<<(StringBuilder &, String::value_type);
StringBuilder &operator<<(StringBuilder &, String::value_type const *);
StringBuilder &operator<<(StringBuilder &, String const &);
StringBuilder &operator<<(StringBuilder &, float);
StringBuilder &operator<<(StringBuilder &, double);
template<size_t N> StringBuilder &operator<<(StringBuilder &b, ByteString::value_type const (&data)[N]) { return b << ByteString(data).FromUtf8(); }

template<typename... Ts> String String::Build(Ts&&... args)
{
	StringBuilder b;
	b.Add(std::forward<Ts>(args)...);
	return b.Build();
}

#include "common/Format.h"


=== src\common\tpt-compat.h ===

/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
#include <cstddef>
#include <memory>
#include <type_traits>
#include <utility>

#define _USE_MATH_DEFINES
#include <cmath>

#ifdef M_PI
constexpr float  TPT_PI_FLT = float(M_PI);
constexpr double TPT_PI_DBL = double(M_PI);
#else
constexpr float  TPT_PI_FLT = 3.14159265f;
constexpr double TPT_PI_DBL = 3.14159265358979323846;
#endif


=== src\common\tpt-rand.cpp ===

#include "tpt-rand.h"
#include <cstdlib>
#include <ctime>

/* xoroshiro128+ by David Blackman and Sebastiano Vigna */

static inline uint64_t rotl(const uint64_t x, int k)
{
	return (x << k) | (x >> (64 - k));
}

uint64_t RNG::next()
{
	const uint64_t s0 = s[0];
	uint64_t s1 = s[1];
	const uint64_t result = s0 + s1;

	s1 ^= s0;
	s[0] = rotl(s0, 55) ^ s1 ^ (s1 << 14); // a, b
	s[1] = rotl(s1, 36); // c

	return result;
}

unsigned int RNG::gen()
{
	return next() & 0x7FFFFFFF;
}

unsigned int RNG::operator()()
{
	return next()&0xFFFFFFFF;
}

int RNG::between(int lower, int upper)
{
	unsigned int r = next();
	return static_cast<int>(r % ((unsigned int)(upper) - (unsigned int)(lower) + 1U)) + lower;
}

bool RNG::chance(int numerator, unsigned int denominator)
{
	if (numerator < 0)
		return false;
	return next() % denominator < static_cast<unsigned int>(numerator);
}

float RNG::uniform01()
{
	return static_cast<float>(next()&0xFFFFFFFF)/(float)0xFFFFFFFF;
}

RNG::RNG()
{
	s[0] = time(nullptr);
	s[1] = 614;
}

void RNG::seed(unsigned int sd)
{
	s[0] = sd;
	s[1] = sd;
}

RNG interfaceRng;


=== src\common\tpt-rand.h ===

#pragma once
#include "ExplicitSingleton.h"
#include <stdint.h>
#include <array>

class RNG
{
public:
	using State = std::array<uint64_t, 2>;

private:
	State s;
	uint64_t next();
public:
	unsigned int operator()();
	unsigned int gen();
	int between(int lower, int upper);
	bool chance(int numerator, unsigned int denominator);
	float uniform01();

	RNG();
	void seed(unsigned int sd);

	void state(State ns)
	{
		s = ns;
	}

	State state() const
	{
		return s;
	}
};

// Please only use this on the main thread and never for simulation stuff.
// For simulation stuff, use Simulation::rng. For renderer stuff, use Renderer::rng.
// For anything else, prefer a dedicated RNG instance over this one.
extern RNG interfaceRng;


=== src\common\VariantIndex.h ===

#pragma once
#include <variant>
#include <utility>

// https://stackoverflow.com/a/52303671
template<typename VariantType, typename T, std::size_t index = 0>
constexpr std::size_t VariantIndex()
{
	static_assert(std::variant_size_v<VariantType> > index, "Type not found in variant");
	if constexpr (index == std::variant_size_v<VariantType>)
	{
		return index;
	}
	else if constexpr (std::is_same_v<std::variant_alternative_t<index, VariantType>, T>)
	{
		return index;
	}
	else
	{
		return VariantIndex<VariantType, T, index + 1>();
	}
}


=== src\common\Vec2.h ===

#pragma once

#include <algorithm>
#include <cmath>
#include <iterator>
#include <type_traits>
#include <utility>

template<typename T, typename = std::enable_if_t<std::is_arithmetic_v<T>>>
struct Rect;

template<typename T, typename = std::enable_if_t<std::is_arithmetic_v<T>>>
struct Vec2
{
	T X, Y;

	constexpr Vec2(T x, T y):
		X(x),
		Y(y)
	{
	}

	template<typename S, typename = std::enable_if_t<std::is_constructible_v<T, S>>>
	constexpr explicit Vec2(Vec2<S> other):
		X(other.X),
		Y(other.Y)
	{
	}

	constexpr bool operator==(Vec2<T> other) const
	{
		return X == other.X && Y == other.Y;
	}

	constexpr bool operator!=(Vec2<T> other) const
	{
		return X != other.X || Y != other.Y;
	}

	template<typename S>
	constexpr Vec2<decltype(std::declval<T>() + std::declval<S>())> operator+(Vec2<S> other) const
	{
		return Vec2<decltype(std::declval<T>() + std::declval<S>())>(X + other.X, Y + other.Y);
	}

	constexpr Vec2<T> operator-() const
	{
		return Vec2<T>(-X, -Y);
	}

	template<typename S>
	constexpr Vec2<decltype(std::declval<T>() - std::declval<S>())> operator-(Vec2<S> other) const
	{
		return Vec2<decltype(std::declval<T>() - std::declval<S>())>(X - other.X, Y - other.Y);
	}

	template<typename S, typename = std::enable_if_t<std::is_arithmetic_v<S>>>
	constexpr Vec2<decltype(std::declval<T>() * std::declval<S>())> operator*(S other) const
	{
		return Vec2<decltype(std::declval<T>() * std::declval<S>())>(X * other, Y * other);
	}

	template<typename S, typename = std::enable_if_t<std::is_arithmetic_v<S>>>
	constexpr Vec2<decltype(std::declval<T>() / std::declval<S>())> operator/(S other) const
	{
		return Vec2<decltype(std::declval<T>() / std::declval<S>())>(X / other, Y / other);
	}

	template<typename S>
	constexpr Vec2<T> &operator+=(Vec2<S> other)
	{
		return *this = *this + other;
	}

	template<typename S>
	constexpr Vec2<T> &operator-=(Vec2<S> other)
	{
		return *this = *this - other;
	}

	template<typename S>
	constexpr Vec2<T> &operator*=(Vec2<S> other)
	{
		return *this = *this * other;
	}

	template<typename S>
	constexpr Vec2<T> &operator/=(Vec2<S> other)
	{
		return *this = *this / other;
	}

	// Round towards -infinity
	template<typename S = T, typename = std::enable_if_t<std::is_floating_point_v<S>>>
	Vec2<T> Floor() const
	{
		return Vec2<T>(std::floor(X), std::floor(Y));
	}

	// Round towards nearest integer, halfpoints towards -infinity
	template<typename S = T, typename = std::enable_if_t<std::is_floating_point_v<S>>>
	Vec2<T> Round() const
	{
		return (*this + Vec2<T>(0.5, 0.5)).Floor();
	}

	Vec2<T> Clamp(Rect<T> rect) const
	{
		return Vec2<T>(
			std::clamp(X, rect.pos.X, rect.pos.X + rect.size.X - T(1)),
			std::clamp(Y, rect.pos.Y, rect.pos.Y + rect.size.Y - T(1))
		);
	}

	Vec2<T> Min(Vec2<T> other) const
	{
		return Vec2<T>(
			std::min(X, other.X),
			std::min(Y, other.Y)
		);
	}

	// Return a rectangle starting at origin, whose dimensions match this vector
	template<typename S = T, typename = std::enable_if_t<std::is_integral_v<S>>>
	constexpr inline Rect<T> OriginRect() const
	{
		return RectSized(Vec2<T>(0, 0), *this);
	}

	static Vec2<T> const Zero;
};

template<typename T, typename V>
Vec2<T> const Vec2<T, V>::Zero = Vec2<T>(0, 0);

template<typename T, typename = std::enable_if_t<std::is_arithmetic_v<T>>>
struct Mat2
{
	// ⎛A B⎞
	// ⎝C D⎠, acting on column vectors
	T A, B, C, D;

	constexpr Mat2(T a, T b, T c, T d):
		A(a),
		B(b),
		C(c),
		D(d)
	{
	}

	constexpr bool operator==(Mat2<T> other) const
	{
		return A == other.A && B == other.B && C == other.C && D == other.D;
	}

	constexpr bool operator!=(Mat2<T> other) const
	{
		return A != other.A || B != other.B || C != other.C || D != other.D;
	}

	template<typename S>
	constexpr Vec2<decltype(std::declval<T>() * std::declval<S>())> operator*(Vec2<S> vec) const
	{
		return Vec2<decltype(std::declval<T>() * std::declval<S>())>(A * vec.X + B * vec.Y, C * vec.X + D * vec.Y);
	}

	template<typename S>
	constexpr Mat2<decltype(std::declval<T>() * std::declval<S>())> operator*(Mat2<S> mat) const
	{
		return Mat2<decltype(std::declval<T>() * std::declval<S>())>(
			A * mat.A + B * mat.C, A * mat.B + B * mat.D,
			C * mat.A + D * mat.C, C * mat.B + D * mat.D
		);
	}

	static Mat2<T> const Identity, MirrorX, MirrorY, CCW;
};

template<typename T, typename V>
Mat2<T> const Mat2<T, V>::Identity = Mat2<T>(1, 0, 0, 1);
template<typename T, typename V>
Mat2<T> const Mat2<T, V>::MirrorX = Mat2<T>(-1, 0, 0, 1);
template<typename T, typename V>
Mat2<T> const Mat2<T, V>::MirrorY = Mat2<T>(1, 0, 0, -1);
template<typename T, typename V>
Mat2<T> const Mat2<T, V>::CCW = Mat2<T>(0, 1, -1, 0); // reminder: the Y axis points down

template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
constexpr static inline Rect<T> RectSized(Vec2<T>, Vec2<T>);

enum IterationDirection
{
	TOP_TO_BOTTOM,
	BOTTOM_TO_TOP,
	LEFT_TO_RIGHT,
	RIGHT_TO_LEFT,
};

template<typename T, typename>
struct Rect
{
	// Inclusive
	Vec2<T> pos, size;

	constexpr Rect(Vec2<T> newPos, Vec2<T> newSize):
		pos(newPos),
		size(newSize)
	{
	}

private:
	struct end_sentinel
	{};

	template<IterationDirection D1, IterationDirection D2>
	struct range_row_major
	{
		static_assert(D1 == TOP_TO_BOTTOM || D1 == BOTTOM_TO_TOP);
		static_assert(D2 == LEFT_TO_RIGHT || D2 == RIGHT_TO_LEFT);
		T left, top, right, bottom;

		struct iterator
		{
			T x, y;
			T const first_x, last_x, end_y;

			iterator &operator++()
			{
				if (x == last_x)
				{
					x = first_x;
					if constexpr (D1 == TOP_TO_BOTTOM)
						y++;
					else
						y--;
				}
				else
				{
					if constexpr (D2 == LEFT_TO_RIGHT)
						x++;
					else
						x--;
				}
				return *this;
			}

			Vec2<T> operator*() const
			{
				return Vec2<T>(x, y);
			}

			bool operator!=(end_sentinel) const
			{
				if constexpr (D1 == TOP_TO_BOTTOM)
					return y < end_y;
				else
					return y > end_y;
			}

			using difference_type = void;
			using value_type = Vec2<T>;
			using pointer = void;
			using reference = void;
			using iterator_category = std::forward_iterator_tag;
		};

		iterator begin() const
		{
			T first_x = D2 == LEFT_TO_RIGHT ? left : right;
			T last_x = D2 == LEFT_TO_RIGHT ? right : left;
			T first_y = D1 == TOP_TO_BOTTOM ? top : bottom;
			T end_y = D1 == TOP_TO_BOTTOM ? bottom + 1 : top - 1;
			return iterator{first_x, right >= left ? first_y : end_y, first_x, last_x, end_y};
		}

		end_sentinel end() const
		{
			return end_sentinel();
		}
	};

	template<IterationDirection D1, IterationDirection D2>
	struct range_column_major
	{
		static_assert(D1 == LEFT_TO_RIGHT || D1 == RIGHT_TO_LEFT);
		static_assert(D2 == TOP_TO_BOTTOM || D2 == BOTTOM_TO_TOP);
		T left, top, right, bottom;

		struct iterator
		{
			T x, y;
			T const first_y, last_y, end_x;

			iterator &operator++()
			{
				if (y == last_y)
				{
					y = first_y;
					if constexpr (D1 == LEFT_TO_RIGHT)
						x++;
					else
						x--;
				}
				else
				{
					if constexpr (D2 == TOP_TO_BOTTOM)
						y++;
					else
						y--;
				}
				return *this;
			}

			Vec2<T> operator*() const
			{
				return Vec2<T>(x, y);
			}

			bool operator!=(end_sentinel) const
			{
				if constexpr (D1 == LEFT_TO_RIGHT)
					return x < end_x;
				else
					return x > end_x;
			}

			using difference_type = void;
			using value_type = Vec2<T>;
			using pointer = void;
			using reference = void;
			using iterator_category = std::forward_iterator_tag;
		};

		iterator begin() const
		{
			T first_y = D2 == TOP_TO_BOTTOM ? top : bottom;
			T last_y = D2 == TOP_TO_BOTTOM ? bottom : top;
			T first_x = D1 == LEFT_TO_RIGHT ? left : right;
			T end_x = D1 == LEFT_TO_RIGHT ? right + 1 : left - 1;
			return iterator{bottom >= top ? first_x : end_x, first_y, first_y, last_y, end_x};
		}

		end_sentinel end() const
		{
			return end_sentinel();
		}
	};

public:
	constexpr bool operator==(Rect other) const
	{
		return pos == other.pos && size == other.size;
	}

	constexpr bool operator!=(Rect other) const
	{
		return pos != other.pos || size != other.size;
	}

	constexpr explicit operator bool() const
	{
		return size.X > 0 && size.Y > 0;
	}

	// Return the intersection of two rectangles (possibly empty)
	Rect<T> operator&(Rect<T> other) const
	{
		auto tl  = Vec2<T>(std::max(pos.X         , other.pos.X               ), std::max(pos.Y         , other.pos.Y               ));
		auto br1 = Vec2<T>(std::min(pos.X + size.X, other.pos.X + other.size.X), std::min(pos.Y + size.Y, other.pos.Y + other.size.Y));
		auto size = br1 - tl;
		return Rect<T>(tl, Vec2<T>(std::max(size.X, T(0)), std::max(size.Y, T(0))));
	}

	inline Rect<T> &operator&=(Rect<T> other)
	{
		return *this = *this & other;
	}

	constexpr bool Contains(Vec2<T> point) const
	{
		return point.X >= pos.X && point.X < pos.X + size.X && point.Y >= pos.Y && point.Y < pos.Y + size.Y;
	}

	template<typename S = T, typename = std::enable_if_t<std::is_integral_v<S>>>
	inline Vec2<T> TopLeft() const
	{
		return pos;
	}

	template<typename S = T, typename = std::enable_if_t<std::is_integral_v<S>>>
	inline Vec2<T> BottomRight() const
	{
		return pos + size - Vec2<T>(1, 1);
	}

	template<typename S>
	Rect<decltype(std::declval<T>() + std::declval<S>())> Inset(S delta) const
	{
		return Rect<decltype(std::declval<T>() + std::declval<S>())>(pos + Vec2(delta, delta), size - Vec2(delta, delta) * S(2));
	}

	template<IterationDirection D1, IterationDirection D2, typename S = T, typename = std::enable_if_t<std::is_integral_v<T>>>
	constexpr auto Range() const
	{
		static_assert(
			((D1 == TOP_TO_BOTTOM || D1 == BOTTOM_TO_TOP) && (D2 == LEFT_TO_RIGHT || D2 == RIGHT_TO_LEFT)) ||
			((D1 == LEFT_TO_RIGHT || D1 == RIGHT_TO_LEFT) && (D2 == TOP_TO_BOTTOM || D2 == BOTTOM_TO_TOP)),
			"Must include exactly 1 of TOP_TO_BOTTOM/BOTTOM_TO_TOP and exactly 1 of LEFT_TO_RIGHT/RIGHT_TO_LEFT"
		);
		if constexpr (D1 == TOP_TO_BOTTOM || D1 == BOTTOM_TO_TOP)
		{
			return range_row_major<D1, D2>{pos.X, pos.Y, pos.X + size.X - T(1), pos.Y + size.Y - T(1)};
		}
		else
			return range_column_major<D1, D2>{pos.X, pos.Y, pos.X + size.X - T(1), pos.Y + size.Y - T(1)};
	}

	// Use when the order isn't important
	constexpr typename range_row_major<TOP_TO_BOTTOM, LEFT_TO_RIGHT>::iterator begin() const
	{
		return Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>().begin();
	}

	constexpr end_sentinel end() const
	{
		return end_sentinel();
	}
};

template<typename T, typename>
constexpr inline Rect<T> RectSized(Vec2<T> pos, Vec2<T> size)
{
	return Rect<T>(pos, size);
}

template<typename T, typename = std::enable_if_t<std::is_arithmetic_v<T>>>
constexpr inline Rect<T> RectBetween(Vec2<T> topLeft, Vec2<T> bottomRight)
{
	return RectSized(topLeft, bottomRight - topLeft + Vec2<T>(1, 1));
}

template<typename T, typename = std::enable_if_t<std::is_arithmetic_v<T>>>
constexpr inline Rect<T> RectAt(Vec2<T> pos)
{
	return RectSized(pos, Vec2<T>(1, 1));
}


=== src\common\Version.h ===

#pragma once
#include <array>
#include <algorithm>

template<size_t ComponentCount>
struct Version
{
	std::array<size_t, ComponentCount> components;

	template<class ...Args>
	constexpr Version(Args ...args) : components{ size_t(args)... }
	{
	}

	constexpr bool operator <(const Version &other) const
	{
		return std::lexicographical_compare(components.begin(), components.end(), other.components.begin(), other.components.end());
	}

	constexpr bool operator ==(const Version &other) const
	{
		return std::equal(components.begin(), components.end(), other.components.begin(), other.components.end());
	}

	constexpr bool operator <=(const Version &other) const
	{
		return *this < other || *this == other;
	}

	constexpr bool operator >=(const Version &other) const
	{
		return !(*this < other);
	}

	constexpr bool operator >(const Version &other) const
	{
		return !(*this <= other);
	}

	constexpr bool operator !=(const Version &other) const
	{
		return !(*this == other);
	}

	constexpr size_t operator [](size_t index) const
	{
		return components[index];
	}

	size_t &operator [](size_t index)
	{
		return components[index];
	}
};

template<class ...Args>
Version(Args ...args) -> Version<sizeof...(Args)>;


=== src\common\clipboard\Clipboard.h ===

#pragma once
#include <memory>
#include <optional>
#include "common/String.h"

class GameSave;

namespace Clipboard
{
	const ByteString clipboardFormatName = "application/vnd.powdertoy.save";
	void SetClipboardData(std::unique_ptr<GameSave> data);
	const GameSave *GetClipboardData();
	void Init();
	bool GetEnabled();
	void SetEnabled(bool newEnabled);
	void RecreateWindow();
	std::optional<String> Explanation();
}


=== src\common\clipboard\ClipboardImpls.template.h ===

#ifdef CLIPBOARD_IMPLS_DECLARE
# define IMPL_DEFINE(subsystem, factory) std::unique_ptr<ClipboardImpl> factory();
#endif
#ifdef CLIPBOARD_IMPLS_DEFINE
# define IMPL_DEFINE(subsystem, factory) { subsystem, factory },
#endif

@impl_defs@

#undef IMPL_DEFINE


=== src\common\clipboard\Cocoa.mm ===

#include "Dynamic.h"
#include "Clipboard.h"
#include <Cocoa/Cocoa.h>
#include <iostream>

namespace Clipboard
{
	static int changeCount = -1;

	class CocoaClipboardImpl : public ClipboardImpl
	{
	public:
		void SetClipboardData() final override
		{
			@autoreleasepool
			{
				NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
				NSString *format = [NSString stringWithUTF8String:clipboardFormatName.c_str()];
				changeCount = [pasteboard declareTypes:[NSArray arrayWithObject:format] owner:nil];
				std::vector<char> saveData;
				SerializeClipboard(saveData);
				const auto *base = saveData.data();
				auto size = saveData.size();
				NSData *data = [NSData dataWithBytes:base length:size];
				if (![pasteboard setData:data forType:format])
				{
					std::cerr << "cannot put save on clipboard: [pasteboard setData] failed" << std::endl;
					return;
				}
			}
			std::cerr << "put save on clipboard" << std::endl;
		}

		GetClipboardDataResult GetClipboardData() final override
		{
			GetClipboardDataChanged gdc;
			@autoreleasepool
			{
				NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
				int newChangeCount = [pasteboard changeCount];
				if (changeCount == newChangeCount)
				{
					return GetClipboardDataUnchanged{};
				}
				changeCount = newChangeCount;
				NSString *format = [NSString stringWithUTF8String:clipboardFormatName.c_str()];
				NSString *available = [pasteboard availableTypeFromArray:[NSArray arrayWithObject:format]];
				if (![available isEqualToString:format])
				{
					std::cerr << "not getting save from clipboard: no data" << std::endl;
					return GetClipboardDataFailed{};
				}
				NSData *data = [pasteboard dataForType:format];
				if (data == nil)
				{
					std::cerr << "not getting save from clipboard: [pasteboard dataForType] failed" << std::endl;
					return GetClipboardDataFailed{};
				}
				auto *base = reinterpret_cast<const char *>([data bytes]);
				auto size = [data length];
				gdc.data = std::vector<char>(base, base + size);
			}
			return gdc;
		}

		std::optional<String> Explanation() final override
		{
			return std::nullopt;
		}
	};

	std::unique_ptr<ClipboardImpl> CocoaClipboardFactory()
	{
		return std::make_unique<CocoaClipboardImpl>();
	}
}


=== src\common\clipboard\Dynamic.cpp ===

#include "Dynamic.h"
#include "Clipboard.h"
#include "client/GameSave.h"
#include "prefs/GlobalPrefs.h"
#include "PowderToySDL.h"
#include <SDL_syswm.h>
#include <iostream>

namespace Clipboard
{
#define CLIPBOARD_IMPLS_DECLARE
#include "ClipboardImpls.h"
#undef CLIPBOARD_IMPLS_DECLARE

	struct ClipboardImplEntry
	{
		SDL_SYSWM_TYPE subsystem;
		std::unique_ptr<ClipboardImpl> (*factory)();
	} clipboardImpls[] = {
#define CLIPBOARD_IMPLS_DEFINE
#include "ClipboardImpls.h"
#undef CLIPBOARD_IMPLS_DEFINE
		{ SDL_SYSWM_UNKNOWN, nullptr },
	};

	std::unique_ptr<GameSave> clipboardData;
	static std::unique_ptr<ClipboardImpl> clipboard;

	void InvokeClipboardSetClipboardData()
	{
		if (clipboard)
		{
			if (clipboardData)
			{
				clipboard->SetClipboardData(); // this either works or it doesn't, we don't care
			}
			else
			{
				std::cerr << "cannot put save on clipboard: no data to transfer" << std::endl;
			}
		}
	}

	void SerializeClipboard(std::vector<char> &saveData)
	{
		std::tie(std::ignore, saveData) = clipboardData->Serialise();
	}

	void SetClipboardData(std::unique_ptr<GameSave> data)
	{
		clipboardData = std::move(data);
		InvokeClipboardSetClipboardData();
	}

	void InvokeClipboardGetClipboardData()
	{
		if (clipboard)
		{
			auto result = clipboard->GetClipboardData();
			if (std::holds_alternative<ClipboardImpl::GetClipboardDataUnchanged>(result))
			{
				std::cerr << "not getting save from clipboard, data unchanged" << std::endl;
				return;
			}
			if (std::holds_alternative<ClipboardImpl::GetClipboardDataUnknown>(result))
			{
				return;
			}
			clipboardData.reset();
			auto *data = std::get_if<ClipboardImpl::GetClipboardDataChanged>(&result);
			if (!data)
			{
				return;
			}
			try
			{
				clipboardData = std::make_unique<GameSave>(data->data);
			}
			catch (const ParseException &e)
			{
				std::cerr << "got bad save from clipboard: " << e.what() << std::endl;
				return;
			}
			std::cerr << "got save from clipboard" << std::endl;
		}
	}

	const GameSave *GetClipboardData()
	{
		InvokeClipboardGetClipboardData();
		return clipboardData.get();
	}

	static bool enabled = false;
	void Init()
	{
		enabled = GlobalPrefs::Ref().Get("NativeClipboard.Enabled", false);
	}

	bool GetEnabled()
	{
		return enabled;
	}

	void SetEnabled(bool newEnabled)
	{
		enabled = newEnabled;
		RecreateWindow();
	}

	int currentSubsystem;

	void RecreateWindow()
	{
		// old window is gone (or doesn't exist), associate clipboard data with the new one
		SDL_SysWMinfo info;
		SDL_VERSION(&info.version);
		SDL_GetWindowWMInfo(sdl_window, &info);
		clipboard.reset();
		currentSubsystem = info.subsystem;
		if (enabled)
		{
			for (auto *impl = clipboardImpls; impl->factory; ++impl)
			{
				if (impl->subsystem == currentSubsystem)
				{
					clipboard = impl->factory();
					break;
				}
			}
		}
		InvokeClipboardSetClipboardData();
	}

	std::optional<String> Explanation()
	{
		return clipboard ? clipboard->Explanation() : std::nullopt;
	}
}


=== src\common\clipboard\Dynamic.h ===

#pragma once
#include "common/String.h"
#include <vector>
#include <variant>
#include <memory>
#include <optional>

class GameSave;

namespace Clipboard
{
	class ClipboardImpl
	{
	public:
		virtual ~ClipboardImpl() = default;

		virtual void SetClipboardData() = 0;

		struct GetClipboardDataUnchanged
		{
		};
		struct GetClipboardDataChanged
		{
			std::vector<char> data;
		};
		struct GetClipboardDataFailed
		{
		};
		struct GetClipboardDataUnknown
		{
		};
		using GetClipboardDataResult = std::variant<
			GetClipboardDataUnchanged,
			GetClipboardDataChanged,
			GetClipboardDataFailed,
			GetClipboardDataUnknown
		>;
		virtual GetClipboardDataResult GetClipboardData() = 0;

		virtual std::optional<String> Explanation() = 0;
	};

	extern std::unique_ptr<GameSave> clipboardData;

	void SerializeClipboard(std::vector<char> &saveData);

	extern int currentSubsystem;
}


=== src\common\clipboard\External.cpp ===

#include "Dynamic.h"
#include "Clipboard.h"
#include "client/GameSave.h"
#include "prefs/GlobalPrefs.h"
#include "PowderToySDL.h"
#include <iostream>
#include <stdio.h>
#include <optional>
#include <algorithm>
#include <signal.h>
#include <map>
#include <SDL_syswm.h>

namespace Clipboard
{
	struct Preset
	{
		ByteString inCommand;
		ByteString formatsCommand;
		ByteString outCommand;
		std::optional<String> explanation;
		std::optional<int> defaultForSubsystem;
	};
	std::map<ByteString, Preset> builtInPresets = {
		{ "xclip", {
			"xclip -selection clipboard -target %s",
			"xclip -out -selection clipboard -target TARGETS",
			"xclip -out -selection clipboard -target %s",
			"Requires the xclip utility to be installed",
			SDL_SYSWM_X11,
		} },
		{ "wl-clipboard", {
			"wl-copy --type %s",
			"wl-paste --list-types",
			"wl-paste --type %s",
			"Requires the wl-clipboard utility to be installed",
			SDL_SYSWM_WAYLAND,
		} },
	};

	static ByteString SubstFormat(ByteString str)
	{
		if (auto split = str.SplitBy("%s"))
		{
			str = split.Before() + clipboardFormatName + split.After();
		}
		return str;
	}

	static std::optional<Preset> GetPreset()
	{
		std::optional<ByteString> name = GlobalPrefs::Ref().Get("NativeClipboard.External.Type", ByteString("auto"));
		if (name == "custom")
		{
			auto getCommand = [](ByteString key) -> std::optional<ByteString> {
				auto fullKey = "NativeClipboard.External." + key;
				auto value = GlobalPrefs::Ref().Get<ByteString>(fullKey);
				if (!value)
				{
					std::cerr << "custom external clipboard command preset: missing " << fullKey << std::endl;
					return std::nullopt;
				}
				return *value;
			};
			auto inCommand      = getCommand("In");
			auto formatsCommand = getCommand("Formats");
			auto outCommand     = getCommand("Out");
			if (!inCommand || !formatsCommand || !outCommand)
			{
				return std::nullopt;
			}
			return Preset{
				SubstFormat(*inCommand),
				SubstFormat(*formatsCommand),
				SubstFormat(*outCommand),
			};
		}
		if (name == "auto")
		{
			name.reset();
			for (auto &[ presetName, preset ] : builtInPresets)
			{
				if (preset.defaultForSubsystem && *preset.defaultForSubsystem == currentSubsystem)
				{
					name = presetName;
				}
			}
			if (!name)
			{
				std::cerr << "no built-in external clipboard command preset for SDL window subsystem " << currentSubsystem << std::endl;
				return std::nullopt;
			}
		}
		auto it = builtInPresets.find(*name);
		if (it == builtInPresets.end())
		{
			std::cerr << "no built-in external clipboard command preset with name " << *name << std::endl;
			return std::nullopt;
		}
		return Preset{
			SubstFormat(it->second.inCommand),
			SubstFormat(it->second.formatsCommand),
			SubstFormat(it->second.outCommand),
			it->second.explanation,
		};
	}

	class ExternalClipboardImpl : public ClipboardImpl
	{
		bool initialized = false;

	public:
		ExternalClipboardImpl()
		{
			if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) // avoids problems with popen
			{
				std::cerr << "failed to initialize clipboard driver: signal: " << strerror(errno) << std::endl;
				return;
			}
			initialized = true;
		}

		void SetClipboardData() final override
		{
			if (!initialized)
			{
				std::cerr << "failed to set clipboard data: clipboard driver not initialized" << std::endl;
				return;
			}
			auto preset = GetPreset();
			if (!preset)
			{
				return;
			}
			auto handle = popen(preset->inCommand.c_str(), "we");
			if (!handle)
			{
				std::cerr << "failed to set clipboard data: popen: " << strerror(errno) << std::endl;
				return;
			}
			auto bail = false;
			std::vector<char> saveData;
			SerializeClipboard(saveData);
			if (fwrite(saveData.data(), 1, saveData.size(), handle) != saveData.size())
			{
				std::cerr << "failed to set clipboard data: fwrite: " << strerror(errno) << std::endl;
				bail = true;
			}
			auto status = pclose(handle);
			if (bail)
			{
				return;
			}
			if (status == -1)
			{
				std::cerr << "failed to set clipboard data: pclose: " << strerror(errno) << std::endl;
				return;
			}
			if (status)
			{
				std::cerr << "failed to set clipboard data: " << preset->inCommand << ": wait4 status code " << status << std::endl;
				return;
			}
		}

		GetClipboardDataResult GetClipboardData() final override
		{
			if (!initialized)
			{
				std::cerr << "cannot get save from clipboard: clipboard driver not initialized" << std::endl;
				return GetClipboardDataUnknown{};
			}
			auto getTarget = [](ByteString command) -> std::optional<std::vector<char>> {
				if (!command.size())
				{
					return std::nullopt;
				}
				auto handle = popen(command.c_str(), "re");
				if (!handle)
				{
					std::cerr << "cannot get save from clipboard: popen: " << strerror(errno) << std::endl;
					return std::nullopt;
				}
				constexpr auto blockSize = 0x10000;
				std::vector<char> data;
				auto bail = false;
				while (true)
				{
					auto pos = data.size();
					data.resize(pos + blockSize);
					auto got = fread(&data[pos], 1, blockSize, handle);
					if (got != blockSize)
					{
						if (ferror(handle))
						{
							std::cerr << "cannot get save from clipboard: fread: " << strerror(errno) << std::endl;
							bail = true;
							break;
						}
						if (feof(handle))
						{
							data.resize(data.size() - blockSize + got);
							break;
						}
					}
				}
				auto status = pclose(handle);
				if (bail)
				{
					return std::nullopt;
				}
				if (status == -1)
				{
					std::cerr << "cannot get save from clipboard: pclose: " << strerror(errno) << std::endl;
					return std::nullopt;
				}
				if (status)
				{
					std::cerr << "cannot get save from clipboard: " << command << ": wait4 status code " << status << std::endl;
					return std::nullopt;
				}
				return data;
			};
			auto preset = GetPreset();
			if (!preset)
			{
				return GetClipboardDataUnknown{};
			}
			auto formatsOpt = getTarget(preset->formatsCommand);
			if (!formatsOpt)
			{
				return GetClipboardDataUnknown{};
			}
			auto formats = ByteString(formatsOpt->begin(), formatsOpt->end()).PartitionBy('\n');
			if (std::find(formats.begin(), formats.end(), clipboardFormatName) == formats.end())
			{
				std::cerr << "not getting save from clipboard: no data" << std::endl;
				return GetClipboardDataFailed{};
			}
			auto saveDataOpt = getTarget(preset->outCommand);
			if (!saveDataOpt)
			{
				return GetClipboardDataFailed{};
			}
			return GetClipboardDataChanged{ std::move(*saveDataOpt) };
		}

		std::optional<String> Explanation() final override
		{
			auto preset = GetPreset();
			return preset ? preset->explanation : std::nullopt;
		}
	};

	std::unique_ptr<ClipboardImpl> ExternalClipboardFactory()
	{
		return std::make_unique<ExternalClipboardImpl>();
	}
}


=== src\common\clipboard\Local.cpp ===

#include "Clipboard.h"
#include "client/GameSave.h"

namespace Clipboard
{
	void SetClipboardData(std::unique_ptr<GameSave> data)
	{
	}

	const GameSave *GetClipboardData()
	{
		return nullptr;
	}

	void Init()
	{
	}

	bool GetEnabled()
	{
		return false;
	}

	void SetEnabled(bool)
	{
	}

	void RecreateWindow()
	{
	}

	std::optional<String> Explanation()
	{
		return std::nullopt;
	}
}


=== src\common\clipboard\meson.build ===

if platform_clipboard
	clipboard_impl_factories = []
	if host_platform == 'windows'
		powder_files += files('Windows.cpp')
		clipboard_impl_factories += [
			[ 'SDL_SYSWM_WINDOWS', 'WindowsClipboardFactory' ],
		]
	elif host_platform == 'darwin'
		if get_option('build_powder')
			add_languages('objcpp', native: false)
			powder_deps += [
				dependency('Cocoa'),
			]
		endif
		powder_files += files([
			'Cocoa.mm',
		])
		clipboard_impl_factories += [
			[ 'SDL_SYSWM_COCOA', 'CocoaClipboardFactory' ],
		]
	elif host_platform == 'android'
		# TODO
	elif host_platform == 'emscripten'
		# TODO
	else
		powder_files += files([
			'External.cpp',
		])
		clipboard_impl_factories += [
			[ 'SDL_SYSWM_X11', 'ExternalClipboardFactory' ],
			[ 'SDL_SYSWM_WAYLAND', 'ExternalClipboardFactory' ],
		]
	endif
	powder_files += files('Dynamic.cpp')
else
	powder_files += files('Local.cpp')
endif
render_files += files('Null.cpp')
font_files += files('Null.cpp')


=== src\common\clipboard\Null.cpp ===

#include "Clipboard.h"

namespace Clipboard
{
	void Init()
	{
	}

	void RecreateWindow()
	{
	}
}


=== src\common\clipboard\Windows.cpp ===

#include "Dynamic.h"
#include "Clipboard.h"
#include "client/GameSave.h"
#include "common/platform/Platform.h"
#include "PowderToySDL.h"
#include <SDL.h>
#include <SDL_syswm.h>
#include <iostream>
#include <windows.h>

namespace Clipboard
{
	class WindowsClipboardImpl : public ClipboardImpl
	{
		UINT saveClipboardFormat = 0;
		HWND ourHwnd = nullptr;
		DWORD seqNumber = 0; // 0 is invalid

		class ClipboardSession
		{
			bool open = false;

		public:
			ClipboardSession(HWND ourHwnd)
			{
				if (ourHwnd)
				{
					open = ::OpenClipboard(ourHwnd);
				}
			}

			~ClipboardSession()
			{
				if (open)
				{
					::CloseClipboard();
				}
			}

			explicit operator bool() const
			{
				return open;
			}
		};

		void Transfer()
		{
			if (!saveClipboardFormat)
			{
				std::cerr << "cannot transfer save data: save clipboard format not registered" << std::endl;
				return;
			}
			if (!clipboardData)
			{
				std::cerr << "cannot transfer save data: no data to transfer" << std::endl;
				return;
			}
			std::vector<char> saveData;
			SerializeClipboard(saveData);
			auto handle = std::unique_ptr<void, decltype(&::GlobalFree)>(::GlobalAlloc(GMEM_MOVEABLE, saveData.size()), GlobalFree);
			if (!handle)
			{
				std::cerr << "cannot transfer save data: GlobalAlloc failed: " << ::GetLastError() << std::endl;
				return;
			}
			{
				auto data = std::unique_ptr<void, decltype(&::GlobalUnlock)>(::GlobalLock(handle.get()), ::GlobalUnlock);
				auto base = reinterpret_cast<char *>(data.get());
				std::copy(saveData.begin(), saveData.end(), base);
			}
			if (!::SetClipboardData(saveClipboardFormat, handle.get()))
			{
				std::cerr << "cannot transfer save data: SetClipboardData failed: " << ::GetLastError() << std::endl;
				return;
			}
			handle.release(); // windows owns it now
			auto newSeqNumber = ::GetClipboardSequenceNumber();
			if (newSeqNumber)
			{
				seqNumber = newSeqNumber;
			}
			std::cerr << "transferred save data" << std::endl;
		}

		static int TransferWatchWrapper(void *userdata, SDL_Event *event)
		{
			return reinterpret_cast<WindowsClipboardImpl *>(userdata)->TransferWatch(event);
		}

		int TransferWatch(SDL_Event *event)
		{
			// SDL documentation says we have to be very careful with what we do here because
			// the callback can come from any random thread, and we indeed are: WM_RENDERFORMAT
			// and WM_RENDERALLFORMATS are only posted to windows that have announced data on
			// the clipboard, and only our main thread ever owns a window, so we don't touch
			// the WindowsClipboardImpl outside of these events.
			switch (event->type)
			{
			case SDL_SYSWMEVENT:
				switch (event->syswm.msg->msg.win.msg)
				{
				case WM_RENDERFORMAT:
					if (event->syswm.msg->msg.win.wParam == saveClipboardFormat)
					{
						Transfer(); 
					}
					break; 

				case WM_RENDERALLFORMATS:
					{
						ClipboardSession cs(ourHwnd);
						if (cs)
						{
							if (ourHwnd && ::GetClipboardOwner() == ourHwnd)
							{
								Transfer();
							}
						}
						else
						{
							std::cerr << "cannot place save on clipboard: OpenClipboard failed: " << ::GetLastError() << std::endl;
						}
					}
					break;
				}
				break;
			}
			return 0;
		}

	public:
		WindowsClipboardImpl()
		{
			SDL_SysWMinfo info;
			SDL_VERSION(&info.version);
			SDL_GetWindowWMInfo(sdl_window, &info);
			ourHwnd = info.info.win.window;
			saveClipboardFormat = ::RegisterClipboardFormatW(Platform::WinWiden(clipboardFormatName).c_str());
			if (!saveClipboardFormat)
			{
				std::cerr << "cannot register save clipboard format: RegisterClipboardFormatW failed: " << ::GetLastError() << std::endl;
				return;
			}
			std::cerr << "save clipboard format registered" << std::endl;
			SDL_EventState(SDL_SYSWMEVENT, SDL_ENABLE);
			SDL_AddEventWatch(&WindowsClipboardImpl::TransferWatchWrapper, this);
		}

		~WindowsClipboardImpl()
		{
			SDL_DelEventWatch(&WindowsClipboardImpl::TransferWatchWrapper, this);
			SDL_EventState(SDL_SYSWMEVENT, SDL_DISABLE);
		}

		void SetClipboardData() final override
		{
			if (!saveClipboardFormat)
			{
				std::cerr << "cannot announce save on clipboard: save clipboard format not registered" << std::endl;
				return;
			}
			ClipboardSession cs(ourHwnd);
			if (!cs)
			{
				std::cerr << "cannot announce save on clipboard: OpenClipboard failed: " << ::GetLastError() << std::endl;
				return;
			}
			if (!::EmptyClipboard())
			{
				std::cerr << "cannot announce save on clipboard: EmptyClipboard failed: " << ::GetLastError() << std::endl;
				return;
			}
			::SetClipboardData(saveClipboardFormat, nullptr);
			std::cerr << "announced save on clipboard" << std::endl;
		}

		GetClipboardDataResult GetClipboardData() final override
		{
			// Note that the data from the local clipboard is left alone if any error occurs so
			// the local clipboard keeps working even in the worst case.
			if (!saveClipboardFormat)
			{
				std::cerr << "cannot get save from clipboard: save clipboard format not registered" << std::endl;
				return GetClipboardDataUnknown{};
			}
			ClipboardSession cs(ourHwnd);
			if (!cs)
			{
				std::cerr << "cannot get save from clipboard: OpenClipboard failed: " << ::GetLastError() << std::endl;
				return GetClipboardDataUnknown{};
			}
			auto newSeqNumber = ::GetClipboardSequenceNumber();
			if (seqNumber && newSeqNumber && seqNumber == newSeqNumber)
			{
				std::cerr << "not getting save from clipboard, data unchanged" << std::endl;
				return GetClipboardDataUnchanged{};
			}
			seqNumber = newSeqNumber;
			if (!::IsClipboardFormatAvailable(saveClipboardFormat))
			{
				std::cerr << "not getting save from clipboard: no data" << std::endl;
				return GetClipboardDataFailed{};
			}
			auto handle = ::GetClipboardData(saveClipboardFormat);
			if (!handle)
			{
				std::cerr << "cannot get save from clipboard: GetClipboardData failed: " << ::GetLastError() << std::endl;
				return GetClipboardDataFailed{};
			}
			auto size = ::GlobalSize(handle);
			auto data = std::unique_ptr<void, decltype(&::GlobalUnlock)>(::GlobalLock(handle), ::GlobalUnlock);
			if (!data)
			{
				std::cerr << "cannot get save from clipboard: GlobalLock failed: " << ::GetLastError() << std::endl;
				return GetClipboardDataFailed{};
			}
			auto base = reinterpret_cast<const char *>(data.get());
			return GetClipboardDataChanged{ std::vector<char>(base, base + size) };
		}

		std::optional<String> Explanation() final override
		{
			return std::nullopt;
		}
	};

	std::unique_ptr<ClipboardImpl> WindowsClipboardFactory()
	{
		return std::make_unique<WindowsClipboardImpl>();
	}
}


=== src\common\platform\Android.cpp ===

#include "Platform.h"
#include "Android.h"
#include "common/Defer.h"
#include "Config.h"
#include <ctime>
#include <SDL.h>
#include <jni.h>
#include <android/log.h>

namespace Platform
{
void OpenURI(ByteString uri)
{
	fprintf(stderr, "cannot open URI: not implemented\n");
}

long unsigned int GetTime()
{
	struct timespec s;
	clock_gettime(CLOCK_MONOTONIC, &s);
	return s.tv_sec * 1000 + s.tv_nsec / 1000000;
}

ByteString ExecutableNameFirstApprox()
{
	return "/proc/self/exe";
}

bool CanUpdate()
{
	return false;
}

void SetupCrt()
{
}

std::optional<ByteString> CallActivityStringFunc(const char *funcName)
{
	ByteString result;
	struct CheckFailed : public std::runtime_error
	{
		using runtime_error::runtime_error;
	};
	try
	{
		auto CHECK = [](auto thing, const char *what) {
			if (!thing)
			{
				throw CheckFailed(what);
			}
			return thing;
		};
#define CHECK(a) CHECK(a, #a)
		auto *env              = CHECK((JNIEnv *)SDL_AndroidGetJNIEnv());
		auto activityInst      = CHECK((jobject)SDL_AndroidGetActivity());
		auto activityCls       = CHECK(env->GetObjectClass(activityInst));
		auto getClassLoaderMth = CHECK(env->GetMethodID(activityCls, "getClassLoader", "()Ljava/lang/ClassLoader;"));
		auto classLoaderInst   = CHECK(env->CallObjectMethod(activityInst, getClassLoaderMth));
		auto classLoaderCls    = CHECK(env->FindClass("java/lang/ClassLoader"));
		auto findClassMth      = CHECK(env->GetMethodID(classLoaderCls, "loadClass", "(Ljava/lang/String;)Ljava/lang/Class;"));
		auto strClassName      = CHECK(env->NewStringUTF(ByteString::Build(APPID, ".PowderActivity").c_str()));
		Defer deleteStrClassName([env, strClassName]() { env->DeleteLocalRef(strClassName); });
		auto mPowderActivity   = CHECK((jclass)(env->CallObjectMethod(classLoaderInst, findClassMth, strClassName)));
		auto funcMth           = CHECK(env->GetMethodID(mPowderActivity, funcName, "()Ljava/lang/String;"));
		auto resultRef         = CHECK((jstring)env->CallObjectMethod(activityInst, funcMth));
		Defer deleteStr([env, resultRef]() { env->DeleteLocalRef(resultRef); });
		auto *resultBytes      = CHECK(env->GetStringUTFChars(resultRef, nullptr));
		Defer deleteUtf([env, resultRef, resultBytes]() { env->ReleaseStringUTFChars(resultRef, resultBytes); });
		result = resultBytes;
	}
	catch (const CheckFailed &ex)
	{
		__android_log_print(ANDROID_LOG_ERROR, APPID, "CallActivityStringFunc/%s failed: %s", funcName, ex.what());
		return std::nullopt;
	}
#undef CHECK
	return result;
}

ByteString DefaultDdir()
{
	auto result = CallActivityStringFunc("getDefaultDdir");
	if (result)
	{
		__android_log_print(ANDROID_LOG_ERROR, APPID, "DefaultDdir succeeded, data dir is %s", result->c_str());
		return *result;
	}
	return "";
}
}


=== src\common\platform\Android.h ===

#pragma once
#include "common/String.h"
#include <optional>

namespace Platform
{
	std::optional<ByteString> CallActivityStringFunc(const char *funcName);
}


=== src\common\platform\Common.cpp ===

#include "Platform.h"
#include "resource.h"
#include "common/tpt-rand.h"
#include "Config.h"
#include <memory>
#include <cstring>
#include <fstream>
#include <iostream>
#include <sys/stat.h>

namespace Platform
{

std::string originalCwd;
std::string sharedCwd;

// Returns a list of all files in a directory matching a search
// search - list of search terms. extensions - list of extensions to also match
std::vector<ByteString> DirectorySearch(ByteString directory, ByteString search, std::vector<ByteString> extensions)
{
	//Get full file listing
	//Normalise directory string, ensure / or \ is present
	if (!directory.size() || (directory.back() != '/' && directory.back() != '\\'))
		directory.append(1, PATH_SEP_CHAR);
	auto directoryList = DirectoryList(directory);

	search = search.ToLower();

	std::vector<ByteString> searchResults;
	for (std::vector<ByteString>::iterator iter = directoryList.begin(), end = directoryList.end(); iter != end; ++iter)
	{
		ByteString filename = *iter, tempfilename = *iter;
		bool extensionMatch = !extensions.size();
		for (auto &extension : extensions)
		{
			if (filename.size() >= extension.size() && filename.EndsWith(extension))
			{
				extensionMatch = true;
				tempfilename = filename.SubstrFromEnd(0, extension.size()).ToLower();
				break;
			}
		}
		bool searchMatch = !search.size();
		if (search.size() && tempfilename.Contains(search))
			searchMatch = true;

		if (searchMatch && extensionMatch)
			searchResults.push_back(filename);
	}

	//Filter results
	return searchResults;
}

bool ReadFile(std::vector<char> &fileData, ByteString filename)
{
	std::ifstream f(filename, std::ios::binary);
	if (f) f.seekg(0, std::ios::end);
	if (f) fileData.resize(f.tellg());
	if (f) f.seekg(0);
	if (f && fileData.size()) f.read(fileData.data(), fileData.size());
	if (!f)
	{
		std::cerr << "ReadFile: " << filename << ": " << strerror(errno) << std::endl;
		return false;
	}
	return true;
}

bool WriteFile(std::span<const char> fileData, ByteString filename)
{
	auto replace = FileExists(filename);
	auto writeFileName = filename;
	if (replace)
	{
		while (true)
		{
			writeFileName = ByteString::Build(filename, ".temp.", Format::Width(5), Format::Fill('0'), interfaceRng() % 100000);
			if (!FileExists(writeFileName))
			{
				break;
			}
		}
	}
	bool ok = false;
	{
		std::ofstream f(writeFileName, std::ios::binary);
		if (f) f.write(fileData.data(), fileData.size());
		ok = bool(f);
	}
	if (!ok)
	{
		std::cerr << "WriteFile: " << filename << ": " << strerror(errno) << std::endl;
		if (replace)
		{
			RemoveFile(writeFileName);
		}
		return false;
	}
	if (replace)
	{
		if (!RenameFile(writeFileName, filename, true))
		{
			RemoveFile(writeFileName);
			return false;
		}
	}
	return true;
}
}


=== src\common\platform\Darwin.cpp ===

#include "Platform.h"
#include <iostream>
#include <sys/time.h>
#include <cstdint>
#include <mach-o/dyld.h>

namespace Platform
{

void OpenURI(ByteString uri)
{
	if (system(("open \"" + uri + "\"").c_str()))
	{
		fprintf(stderr, "cannot open URI: system(...) failed\n");
	}
}

long unsigned int GetTime()
{
	struct timeval s;
	gettimeofday(&s, NULL);
	return (unsigned int)(s.tv_sec * 1000 + s.tv_usec / 1000);
}

ByteString ExecutableNameFirstApprox()
{
	ByteString firstApproximation("?");
	{
		auto bufSize = uint32_t(firstApproximation.size());
		auto ret = _NSGetExecutablePath(firstApproximation.data(), &bufSize);
		if (ret == -1)
		{
			// Buffer not large enough; likely to happen since it's initially a single byte.
			firstApproximation.resize(bufSize);
			ret = _NSGetExecutablePath(firstApproximation.data(), &bufSize);
		}
		if (ret != 0)
		{
			// Can't even get a first approximation.
			std::cerr << "_NSGetExecutablePath: " << ret << std::endl;
			return "";
		}
	}
	return firstApproximation;
}

bool CanUpdate()
{
	return false;
}

void SetupCrt()
{
}
}


=== src\common\platform\DdirCommon.cpp ===

#include "Platform.h"
#include "common/String.h"
#include "Config.h"
#include <SDL.h>
#include <memory>

namespace Platform
{
ByteString DefaultDdir()
{
	auto ddir = std::unique_ptr<char, decltype(&SDL_free)>(SDL_GetPrefPath(nullptr, APPDATA), SDL_free);
	return ddir.get();
}
}


=== src\common\platform\Emscripten.cpp ===

#include "Platform.h"
#include <ctime>
#include <emscripten.h>
#include <emscripten/threading.h>
#include <atomic>
#include <iostream>

static std::atomic<bool> shouldSyncFs = false;
static bool syncFsInFlight = false;

EMSCRIPTEN_KEEPALIVE extern "C" void Platform_SyncFsDone()
{
	syncFsInFlight = false;
}

namespace Platform
{
void OpenURI(ByteString uri)
{
	EM_ASM({
		open(UTF8ToString($0));
	}, uri.c_str());
}

void DoRestart()
{
	EM_ASM({
		location.reload();
	});
}

long unsigned int GetTime()
{
	struct timespec s;
	clock_gettime(CLOCK_MONOTONIC, &s);
	return s.tv_sec * 1000 + s.tv_nsec / 1000000;
}

ByteString ExecutableNameFirstApprox()
{
	return "powder.wasm"; // bogus
}

bool CanUpdate()
{
	return false;
}

bool Install()
{
	return false;
}

void Atexit(ExitFunc exitFunc)
{
}

void Exit(int code)
{
}

ByteString DefaultDdir()
{
	return "/powder";
}

int InvokeMain(int argc, char *argv[])
{
	EM_ASM({
		FS.syncfs(true, () => {
			Module.ccall('MainJs', 'number', [ 'number', 'number' ], [ $0, $1 ]);
		});
	}, argc, argv);
	return 0;
}

void MarkPresentable()
{
	EM_ASM({
		try {
			window.mark_presentable();
		} catch (e) {
		}
	});
}

void MaybeTriggerSyncFs()
{
	if (!syncFsInFlight && shouldSyncFs.exchange(false, std::memory_order_relaxed))
	{
		std::cerr << "invoking FS.syncfs" << std::endl;
		syncFsInFlight = true;
		EM_ASM({
			FS.syncfs(false, err => {
				if (err) {
					console.error(err);
				}
				Module.ccall('Platform_SyncFsDone', null, [], []);
			});
		});
	}
}

ByteString ExecutableName()
{
	return DefaultDdir() + "/" + ExecutableNameFirstApprox(); // bogus
}

bool UpdateStart(std::span<const char> data)
{
	return false;
}

bool UpdateFinish()
{
	return false;
}

void UpdateCleanup()
{
}
}

EMSCRIPTEN_KEEPALIVE extern "C" int MainJs(int argc, char *argv[])
{
	return Main(argc, argv);
}

EMSCRIPTEN_KEEPALIVE extern "C" void Platform_ShouldSyncFs()
{
	shouldSyncFs.store(true, std::memory_order_relaxed);
}

namespace Platform
{
	void SetupCrt()
	{
		EM_ASM({
			// If we don't castrate assert here, we get a crash from within the emscripten port of
			// SDL2 having to do with registering a callback that reports to the main thread, ever
			// since this "fix" https://github.com/emscripten-core/emscripten/pull/19691/files
			// TODO: Review later.
			assert = () => {};

			let ddir = UTF8ToString($0);
			let prefix = ddir + '/';
			let shouldSyncFs = Module.cwrap(
				'Platform_ShouldSyncFs',
				null,
				[]
			);
			FS.trackingDelegate['onMovePath'] = function(oldpath, newpath) {
				if (oldpath.startsWith(prefix) || newpath.startsWith(prefix)) {
					shouldSyncFs();
				}
			};
			FS.trackingDelegate['onDeletePath'] = function(path) {
				if (path.startsWith(prefix)) {
					shouldSyncFs();
				}
			};
			FS.trackingDelegate['onWriteToFile'] = function(path, bytesWritten) {
				if (path.startsWith(prefix)) {
					shouldSyncFs();
				}
			};
			FS.trackingDelegate['onMakeDirectory'] = function(path, mode) {
				if (path.startsWith(prefix)) {
					shouldSyncFs();
				}
			};
			FS.mkdir(ddir);
			FS.mount(IDBFS, {}, ddir);
		}, DefaultDdir().c_str());
	}
}


=== src\common\platform\ExitCommon.cpp ===

#include "Platform.h"
#include <cstdlib>
#include <list>

namespace Platform
{
std::list<ExitFunc> exitFuncs;

void Atexit(ExitFunc exitFunc)
{
	exitFuncs.push_front(exitFunc);
}

void Exit(int code)
{
	for (auto exitFunc : exitFuncs)
	{
		exitFunc();
	}
	exit(code);
}
}


=== src\common\platform\Linux.cpp ===

#include "Platform.h"
#include "icon_cps_png.h"
#include "icon_exe_png.h"
#include "save_xml.h"
#include "powder_desktop.h"
#include "Config.h"
#include <cstring>
#include <ctime>
#ifdef __FreeBSD__
# include <sys/sysctl.h>
#endif

namespace Platform
{
void OpenURI(ByteString uri)
{
	if (system(("xdg-open \"" + uri + "\"").c_str()))
	{
		fprintf(stderr, "cannot open URI: system(...) failed\n");
	}
}

long unsigned int GetTime()
{
	struct timespec s;
	clock_gettime(CLOCK_MONOTONIC, &s);
	return s.tv_sec * 1000 + s.tv_nsec / 1000000;
}

ByteString ExecutableNameFirstApprox()
{
	if (Stat("/proc/self/exe"))
	{
		return "/proc/self/exe";
	}
#ifdef __FreeBSD__
	{
		int mib[4];
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC;
		mib[2] = KERN_PROC_PATHNAME;
		mib[3] = -1;
		std::array<char, 1000> buf;
		size_t cb = buf.size();
		if (!sysctl(mib, 4, buf.data(), &cb, NULL, 0))
		{
			return ByteString(buf.data(), buf.data() + cb);
		}
	}
#endif
	return "";
}

bool CanUpdate()
{
	return true;
}

bool Install()
{
	bool ok = true;
	auto desktopEscapeString = [](ByteString str) {
		ByteString escaped;
		for (auto ch : str)
		{
			auto from = " " "\n" "\t" "\r" "\\";
			auto to   = "s"  "n"  "t"  "r" "\\";
			if (auto off = strchr(from, ch))
			{
				escaped.append(1, '\\');
				escaped.append(1, to[off - from]);
			}
			else
			{
				escaped.append(1, ch);
			}
		}
		return escaped;
	};
	auto desktopEscapeExec = [](ByteString str) {
		ByteString escaped;
		for (auto ch : str)
		{
			if (strchr(" \t\n\"\'\\><~|&;$*?#()`", ch))
			{
				escaped.append(1, '\\');
			}
			escaped.append(1, ch);
		}
		return escaped;
	};

	if (ok)
	{
		auto data = powder_desktop.AsCharSpan();
		ByteString desktopData(data.begin(), data.end());
		auto exe = Platform::ExecutableName();
		auto path = exe.SplitFromEndBy('/').Before();
		desktopData = desktopData.Substitute("Exec=" + ByteString(APPEXE), "Exec=" + desktopEscapeString(desktopEscapeExec(exe)));
		desktopData += ByteString::Build("Path=", desktopEscapeString(path), "\n");
		ByteString file = ByteString::Build(APPVENDOR, "-", APPID, ".desktop");
		ok = ok && Platform::WriteFile(desktopData, file);
		ok = ok && !system(ByteString::Build("xdg-desktop-menu install ", file).c_str());
		ok = ok && !system(ByteString::Build("xdg-mime default ", file, " application/vnd.powdertoy.save").c_str());
		ok = ok && !system(ByteString::Build("xdg-mime default ", file, " x-scheme-handler/ptsave").c_str());
		Platform::RemoveFile(file);
	}
	if (ok)
	{
		ByteString file = ByteString(APPVENDOR) + "-save.xml";
		ok = ok && Platform::WriteFile(save_xml.AsCharSpan(), file);
		ok = ok && !system(ByteString::Build("xdg-mime install ", file).c_str());
		Platform::RemoveFile(file);
	}
	if (ok)
	{
		ByteString file = ByteString(APPVENDOR) + "-cps.png";
		ok = ok && Platform::WriteFile(icon_cps_png.AsCharSpan(), file);
		ok = ok && !system(ByteString::Build("xdg-icon-resource install --noupdate --context mimetypes --size 64 ", file, " application-vnd.powdertoy.save").c_str());
		Platform::RemoveFile(file);
	}
	if (ok)
	{
		ByteString file = ByteString(APPVENDOR) + "-exe.png";
		ok = ok && Platform::WriteFile(icon_exe_png.AsCharSpan(), file);
		ok = ok && !system(ByteString::Build("xdg-icon-resource install --noupdate --size 64 ", file, " ", APPVENDOR, "-", APPEXE).c_str());
		Platform::RemoveFile(file);
	}
	if (ok)
	{
		ok = ok && !system("xdg-icon-resource forceupdate");
	}
	return ok;
}

void SetupCrt()
{
}
}


=== src\common\platform\MainCommon.cpp ===

#include "Platform.h"

namespace Platform
{
int InvokeMain(int argc, char *argv[])
{
	return Main(argc, argv);
}

void MarkPresentable()
{
}
}


=== src\common\platform\meson.build ===

common_files += files(
	'Common.cpp',
)

if get_option('use_bluescreen') == 'auto'
	use_bluescreen = not is_debug
else
	use_bluescreen = get_option('use_bluescreen') == 'yes'
endif
can_install_enforce_no = false
set_window_icon = false
path_sep_char = '/'
if host_platform == 'windows'
	path_sep_char = '\\\\'
	common_files += files(
		'Windows.cpp',
		'ExitCommon.cpp',
	)
	powder_files += files(
		'MainCommon.cpp',
		'DdirCommon.cpp',
	)
elif host_platform == 'darwin'
	can_install_enforce_no = true
	common_files += files(
		'Darwin.cpp',
		'Posix.cpp',
		'PosixProc.cpp',
		'ExitCommon.cpp',
	)
	powder_files += files(
		'MainCommon.cpp',
		'DdirCommon.cpp',
	)
elif host_platform == 'android'
	can_install_enforce_no = true
	common_files += files(
		'Android.cpp',
		'Posix.cpp',
		'PosixProc.cpp',
		'ExitCommon.cpp',
	)
	powder_files += files(
		'MainCommon.cpp',
	)
elif host_platform == 'emscripten'
	use_bluescreen = false
	can_install_enforce_no = true
	common_files += files(
		'Emscripten.cpp',
		'Posix.cpp',
	)
elif host_platform == 'linux'
	# TODO: again, this is more like "posix" than "linux"
	set_window_icon = true
	common_files += files(
		'Linux.cpp',
		'Posix.cpp',
		'PosixProc.cpp',
		'ExitCommon.cpp',
	)
	powder_files += files(
		'MainCommon.cpp',
		'DdirCommon.cpp',
	)
else
	can_install_enforce_no = true
	common_files += files(
		'Null.cpp',
		'Posix.cpp',
		'PosixProc.cpp',
		'ExitCommon.cpp',
	)
	powder_files += files(
		'MainCommon.cpp',
		'DdirCommon.cpp',
	)
endif

bluescreen_export_symbols = false

subdir('stacktrace')

if use_bluescreen
	common_files += stacktrace_files
	if bluescreen_export_symbols and is_debug
		project_export_dynamic = true
	endif
else
	common_files += files('stacktrace/Null.cpp')
endif
conf_data.set('SET_WINDOW_ICON', set_window_icon.to_string())
conf_data.set('PATH_SEP_CHAR', path_sep_char)
conf_data.set('USE_BLUESCREEN', use_bluescreen.to_string())

can_install = get_option('can_install')
if can_install == 'auto'
	can_install = 'yes_check'
	if is_debug
		can_install = 'yes'
	endif
	if can_install_enforce_no
		can_install = 'no'
	endif
endif
if can_install != 'no' and can_install_enforce_no
	error('cannot provide install support, configure with -Dcan_install=no to fix this error')
endif
conf_data.set('CAN_INSTALL', (can_install != 'no').to_string())
conf_data.set('SHARED_DATA_FOLDER', get_option('shared_data_folder').to_string())
conf_data.set('INSTALL_CHECK', (can_install == 'yes_check').to_string())


=== src\common\platform\Null.cpp ===

#include "Platform.h"

namespace Platform
{
void OpenURI(ByteString uri)
{
	fprintf(stderr, "cannot open URI: not implemented\n");
}

bool CanUpdate()
{
	return false;
}

void SetupCrt()
{
}
}


=== src\common\platform\Platform.h ===

#pragma once
#include "common/String.h"
#include <cstdint>
#include <span>
#include <string>
#include <vector>
#include <optional>

namespace Platform
{
	ByteString GetCwd();
	ByteString ExecutableNameFirstApprox();
	ByteString ExecutableName();
	void DoRestart();

	void OpenURI(ByteString uri);

	void Millisleep(long int t);
	long unsigned int GetTime();

	bool Stat(ByteString filename);
	bool FileExists(ByteString filename);
	bool DirectoryExists(ByteString directory);
	bool IsLink(ByteString path);
	/**
	 * @return true on success
	 */
	bool RemoveFile(ByteString filename);
	bool RenameFile(ByteString filename, ByteString newFilename, bool replace);

	/**
	 * @return true on success
	 */
	bool DeleteDirectory(ByteString folder);

	/**
	 * @return true on success
	 */
	bool MakeDirectory(ByteString dir);
	std::vector<ByteString> DirectoryList(ByteString directory);
	std::vector<ByteString> DirectorySearch(ByteString directory, ByteString search, std::vector<ByteString> extensions);

	bool ReadFile(std::vector<char> &fileData, ByteString filename);
	bool WriteFile(std::span<const char> fileData, ByteString filename);

	// TODO: Remove these and switch to *A Win32 API variants when we stop fully supporting windows
	//       versions older than win10 1903, for example when win10 reaches EOL, see 18084d5aa0e5.
	ByteString WinNarrow(const std::wstring &source);
	std::wstring WinWiden(const ByteString &source);

	extern std::string originalCwd;
	extern std::string sharedCwd;

	bool CanUpdate();

	bool Install();

	bool ChangeDir(ByteString toDir);

	bool UpdateStart(std::span<const char> data);
	bool UpdateFinish();
	void UpdateCleanup();

	void SetupCrt();

	using ExitFunc = void (*)();
	void Atexit(ExitFunc exitFunc);
	void Exit(int code);

	ByteString DefaultDdir();

	int InvokeMain(int argc, char *argv[]);

	std::optional<std::vector<String>> StackTrace();

	void MarkPresentable();
	void AllocConsole();
}

extern "C" int Main(int argc, char *argv[]);


=== src\common\platform\Posix.cpp ===

#include "Platform.h"
#include <iostream>
#include <memory>
#include <sys/stat.h>
#include <unistd.h>
#include <ctime>
#include <sys/time.h>
#include <dirent.h>

namespace Platform
{
ByteString GetCwd()
{
	ByteString cwd;
	char *cwdPtr = getcwd(nullptr, 0);
	if (cwdPtr)
	{
		cwd = cwdPtr;
	}
	free(cwdPtr);
	return cwd;
}

void Millisleep(long int t)
{
	struct timespec s;
	s.tv_sec = t / 1000;
	s.tv_nsec = (t % 1000) * 10000000;
	nanosleep(&s, nullptr);
}

bool Stat(ByteString filename)
{
	struct stat s;
	if (stat(filename.c_str(), &s) == 0)
	{
		return true; // Something exists, be it a file, directory, link, etc.
	}
	else
	{
		return false; // Doesn't exist
	}
}

bool FileExists(ByteString filename)
{
	struct stat s;
	if (stat(filename.c_str(), &s) == 0)
	{
		if(s.st_mode & S_IFREG)
		{
			return true; // Is file
		}
		else
		{
			return false; // Is directory or something else
		}
	}
	else
	{
		return false; // Doesn't exist
	}
}

bool DirectoryExists(ByteString directory)
{
	struct stat s;
	if (stat(directory.c_str(), &s) == 0)
	{
		if(s.st_mode & S_IFDIR)
		{
			return true; // Is directory
		}
		else
		{
			return false; // Is file or something else
		}
	}
	else
	{
		return false; // Doesn't exist
	}
}

bool IsLink(ByteString path)
{
	struct stat s;
	if (stat(path.c_str(), &s) == 0)
	{
		if (s.st_mode & S_IFLNK)
		{
			return true; // Is path
		}
		else
		{
			return false; // Is file or something else
		}
	}
	else
	{
		return false; // Doesn't exist
	}
}

bool RemoveFile(ByteString filename)
{
	return remove(filename.c_str()) == 0;
}

bool RenameFile(ByteString filename, ByteString newFilename, bool replace)
{
	// TODO: Make atomic :( Could use renameat2 with RENAME_NOREPLACE on linux and
	// renamex_np with RENAME_EXCL on darwin, but both require filesystem support;
	// I don't think it's worth it for now. -- LBPHacker
	if (!replace && FileExists(newFilename))
	{
		return false;
	}
	return rename(filename.c_str(), newFilename.c_str()) == 0;
}

bool DeleteDirectory(ByteString folder)
{
	return rmdir(folder.c_str()) == 0;
}

bool MakeDirectory(ByteString dir)
{
	return mkdir(dir.c_str(), 0755) == 0;
}

bool ChangeDir(ByteString toDir)
{
	return chdir(toDir.c_str()) == 0;
}

std::vector<ByteString> DirectoryList(ByteString directory)
{
	std::vector<ByteString> directoryList;
	struct dirent * directoryEntry;
	DIR *directoryHandle = opendir(directory.c_str());
	if (!directoryHandle)
	{
		return std::vector<ByteString>();
	}
	while ((directoryEntry = readdir(directoryHandle)))
	{
		directoryList.push_back(ByteString(directoryEntry->d_name));
	}
	closedir(directoryHandle);
	return directoryList;
}

void AllocConsole()
{
}
}


=== src\common\platform\PosixProc.cpp ===

#include "Platform.h"
#include <iostream>
#include <memory>
#include <sys/stat.h>
#include <unistd.h>
#include <ctime>
#include <sys/time.h>
#include <dirent.h>

namespace Platform
{
void DoRestart()
{
	ByteString exename = ExecutableName();
	if (exename.length())
	{
		execl(exename.c_str(), exename.c_str(), NULL);
		int ret = errno;
		fprintf(stderr, "cannot restart: execl(...) failed: code %i\n", ret);
	}
	else
	{
		fprintf(stderr, "cannot restart: no executable name???\n");
	}
	Exit(-1);
}

ByteString ExecutableName()
{
	auto firstApproximation = ExecutableNameFirstApprox();
	auto rp = std::unique_ptr<char, decltype(std::free) *>(realpath(firstApproximation.data(), nullptr), std::free);
	if (!rp)
	{
		std::cerr << "realpath: " << errno << std::endl;
		return "";
	}
	return rp.get();
}

bool UpdateStart(std::span<const char> data)
{
	ByteString exeName = Platform::ExecutableName();

	if (!exeName.length())
		return false;

	auto updName = exeName + "-update";

	if (!WriteFile(data, updName))
	{
		RemoveFile(updName);
		return false;
	}

	if (chmod(updName.c_str(), 0755))
	{
		RemoveFile(updName);
		return false;
	}

	if (!RenameFile(updName, exeName, true))
	{
		RemoveFile(updName);
		return false;
	}

	execl(exeName.c_str(), "powder-update", NULL);
	return false; // execl returned, we failed
}

bool UpdateFinish()
{
	return true;
}

void UpdateCleanup()
{
}
}


=== src\common\platform\Windows.cpp ===

#include "Platform.h"
#include "resource.h"
#include "Config.h"
#include <iostream>
#include <sys/stat.h>
#include <io.h>
#include <fcntl.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <windows.h>
#include <crtdbg.h>
#include <memory>
#include <cstdlib>

namespace Platform
{
ByteString GetCwd()
{
	ByteString cwd;
	auto cwdPtr = std::unique_ptr<wchar_t, decltype(&free)>(_wgetcwd(nullptr, 0), free);
	if (cwdPtr)
	{
		cwd = WinNarrow(cwdPtr.get());
	}
	return cwd;
}

void OpenURI(ByteString uri)
{
	if (int(INT_PTR(ShellExecuteW(nullptr, nullptr, WinWiden(uri).c_str(), nullptr, nullptr, SW_SHOWNORMAL))) <= 32)
	{
		fprintf(stderr, "cannot open URI: ShellExecute(...) failed\n");
	}
}

void Millisleep(long int t)
{
	Sleep(t);
}

long unsigned int GetTime()
{
	return GetTickCount();
}

bool Stat(ByteString filename)
{
	struct _stat s;
	if (_wstat(WinWiden(filename).c_str(), &s) == 0)
	{
		return true; // Something exists, be it a file, directory, link, etc.
	}
	else
	{
		return false; // Doesn't exist
	}
}

bool FileExists(ByteString filename)
{
	struct _stat s;
	if (_wstat(WinWiden(filename).c_str(), &s) == 0)
	{
		if(s.st_mode & S_IFREG)
		{
			return true; // Is file
		}
		else
		{
			return false; // Is directory or something else
		}
	}
	else
	{
		return false; // Doesn't exist
	}
}

bool DirectoryExists(ByteString directory)
{
	struct _stat s;
	if (_wstat(WinWiden(directory).c_str(), &s) == 0)
	{
		if(s.st_mode & S_IFDIR)
		{
			return true; // Is directory
		}
		else
		{
			return false; // Is file or something else
		}
	}
	else
	{
		return false; // Doesn't exist
	}
}

bool IsLink(ByteString path)
{
	struct _stat s;
	if (_wstat(WinWiden(path).c_str(), &s) == 0)
	{
		if (GetFileAttributesW(WinWiden(path).c_str()) & FILE_ATTRIBUTE_REPARSE_POINT)
		{
			return true; // Is directory
		}
		else
		{
			return false; // Is file or something else
		}
	}
	else
	{
		return false; // Doesn't exist
	}
}

bool RemoveFile(ByteString filename)
{
	return _wremove(WinWiden(filename).c_str()) == 0;
}

bool RenameFile(ByteString filename, ByteString newFilename, bool replace)
{
	if (replace)
	{
		// TODO: we rely on errno but errors from this are available through GetLastError(); fix
		return MoveFileExW(WinWiden(filename).c_str(), WinWiden(newFilename).c_str(), MOVEFILE_REPLACE_EXISTING);
	}
	return _wrename(WinWiden(filename).c_str(), WinWiden(newFilename).c_str()) == 0;
}

bool DeleteDirectory(ByteString folder)
{
	return _wrmdir(WinWiden(folder).c_str()) == 0;
}

bool MakeDirectory(ByteString dir)
{
	return _wmkdir(WinWiden(dir).c_str()) == 0;
}

bool ChangeDir(ByteString toDir)
{
	return _wchdir(WinWiden(toDir).c_str()) == 0;
}

std::vector<ByteString> DirectoryList(ByteString directory)
{
	std::vector<ByteString> directoryList;
	struct _wfinddata_t currentFile;
	intptr_t findFileHandle;
	ByteString fileMatch = directory + "*.*";
	findFileHandle = _wfindfirst(Platform::WinWiden(fileMatch).c_str(), &currentFile);
	if (findFileHandle == -1L)
	{
		return std::vector<ByteString>();
	}
	do
	{
		directoryList.push_back(Platform::WinNarrow(currentFile.name));
	}
	while (_wfindnext(findFileHandle, &currentFile) == 0);
	_findclose(findFileHandle);
	return directoryList;
}

ByteString WinNarrow(const std::wstring &source)
{
	int buffer_size = WideCharToMultiByte(CP_UTF8, 0, source.c_str(), source.size(), nullptr, 0, nullptr, nullptr);
	if (!buffer_size)
	{
		return "";
	}
	std::string output(buffer_size, 0);
	if (!WideCharToMultiByte(CP_UTF8, 0, source.c_str(), source.size(), output.data(), buffer_size, nullptr, nullptr))
	{
		return "";
	}
	return output;
}

std::wstring WinWiden(const ByteString &source)
{
	int buffer_size = MultiByteToWideChar(CP_UTF8, 0, source.c_str(), source.size(), nullptr, 0);
	if (!buffer_size)
	{
		return L"";
	}
	std::wstring output(buffer_size, 0);
	if (!MultiByteToWideChar(CP_UTF8, 0, source.c_str(), source.size(), output.data(), buffer_size))
	{
		return L"";
	}
	return output;
}

ByteString ExecutableName()
{
	std::wstring buf(L"?");
	while (true)
	{
		SetLastError(ERROR_SUCCESS);
		if (!GetModuleFileNameW(nullptr, buf.data(), DWORD(buf.size())))
		{
			std::cerr << "GetModuleFileNameW: " << GetLastError() << std::endl;
			return "";
		}
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		{
			break;
		}
		buf.resize(buf.size() * 2);
	}
	return WinNarrow(buf.data()); // Pass pointer to copy only up to the zero terminator.
}

void DoRestart()
{
	ByteString exename = ExecutableName();
	if (exename.length())
	{
		int ret = int(INT_PTR(ShellExecuteW(nullptr, nullptr, WinWiden(exename).c_str(), nullptr, nullptr, SW_SHOWNORMAL)));
		if (ret <= 32)
		{
			fprintf(stderr, "cannot restart: ShellExecute(...) failed: code %i\n", ret);
		}
		else
		{
			Exit(0);
		}
	}
	else
	{
		fprintf(stderr, "cannot restart: no executable name???\n");
	}
	Exit(-1);
}

bool CanUpdate()
{
	return true;
}

bool Install()
{
	bool ok = true;
	auto deleteKey = [](ByteString path) {
		RegDeleteKeyW(HKEY_CURRENT_USER, Platform::WinWiden(path).c_str());
	};
	auto createKey = [](ByteString path, ByteString value, ByteString extraKey = {}, ByteString extraValue = {}) {
		auto ok = true;
		auto wPath = Platform::WinWiden(path);
		auto wValue = Platform::WinWiden(value);
		auto wExtraKey = Platform::WinWiden(extraKey);
		auto wExtraValue = Platform::WinWiden(extraValue);
		HKEY k;
		ok = ok && RegCreateKeyExW(HKEY_CURRENT_USER, wPath.c_str(), 0, nullptr, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, nullptr, &k, nullptr) == ERROR_SUCCESS;
		ok = ok && RegSetValueExW(k, nullptr, 0, REG_SZ, reinterpret_cast<const BYTE *>(wValue.c_str()), (wValue.size() + 1) * 2) == ERROR_SUCCESS;
		if (wExtraKey.size())
		{
			ok = ok && RegSetValueExW(k, wExtraKey.c_str(), 0, REG_SZ, reinterpret_cast<const BYTE *>(wExtraValue.c_str()), (wExtraValue.size() + 1) * 2) == ERROR_SUCCESS;
		}
		RegCloseKey(k);
		return ok;
	};

	CoInitializeEx(nullptr, COINIT_MULTITHREADED);
	auto exe = Platform::ExecutableName();
#ifndef IDI_DOC_ICON
	// make this fail so I don't remove #include "resource.h" again and get away with it
# error where muh IDI_DOC_ICON D:
#endif
	auto icon = ByteString::Build(exe, ",-", IDI_DOC_ICON);
	auto path = Platform::GetCwd();
	auto open = ByteString::Build("\"", exe, "\" ddir \"", path, "\" \"file://%1\"");
	auto ptsave = ByteString::Build("\"", exe, "\" ddir \"", path, "\" \"%1\"");
	deleteKey("Software\\Classes\\ptsave");
	deleteKey("Software\\Classes\\.cps");
	deleteKey("Software\\Classes\\.stm");
	deleteKey("Software\\Classes\\PowderToySave");
	ok = ok && createKey("Software\\Classes\\ptsave", "Powder Toy Save", "URL Protocol", "");
	ok = ok && createKey("Software\\Classes\\ptsave\\DefaultIcon", icon);
	ok = ok && createKey("Software\\Classes\\ptsave\\shell\\open\\command", ptsave);
	ok = ok && createKey("Software\\Classes\\.cps", "PowderToySave");
	ok = ok && createKey("Software\\Classes\\.stm", "PowderToySave");
	ok = ok && createKey("Software\\Classes\\PowderToySave", "Powder Toy Save");
	ok = ok && createKey("Software\\Classes\\PowderToySave\\DefaultIcon", icon);
	ok = ok && createKey("Software\\Classes\\PowderToySave\\shell\\open\\command", open);
	IShellLinkW *shellLink = nullptr;
	IPersistFile *shellLinkPersist = nullptr;
	wchar_t programsPath[MAX_PATH];
	ok = ok && SHGetFolderPathW(nullptr, CSIDL_PROGRAMS, nullptr, SHGFP_TYPE_CURRENT, programsPath) == S_OK;
	ok = ok && CoCreateInstance(CLSID_ShellLink, nullptr, CLSCTX_INPROC_SERVER, IID_IShellLinkW, (LPVOID *)&shellLink) == S_OK;
	ok = ok && shellLink->SetPath(Platform::WinWiden(exe).c_str()) == S_OK;
	ok = ok && shellLink->SetWorkingDirectory(Platform::WinWiden(path).c_str()) == S_OK;
	ok = ok && shellLink->SetDescription(Platform::WinWiden(APPNAME).c_str()) == S_OK;
	ok = ok && shellLink->QueryInterface(IID_IPersistFile, (LPVOID *)&shellLinkPersist) == S_OK;
	ok = ok && shellLinkPersist->Save(Platform::WinWiden(ByteString::Build(Platform::WinNarrow(programsPath), "\\", APPNAME, ".lnk")).c_str(), TRUE) == S_OK;
	if (shellLinkPersist)
	{
		shellLinkPersist->Release();
	}
	if (shellLink)
	{
		shellLink->Release();
	}
	CoUninitialize();
	return ok;
}

bool UpdateStart(std::span<const char> data)
{
	ByteString exeName = Platform::ExecutableName(), updName;

	if (!exeName.length())
		return false;

	updName = exeName;
	ByteString extension = exeName.substr(exeName.length() - 4);
	if (extension == ".exe")
		updName = exeName.substr(0, exeName.length() - 4);
	updName = updName + "_upd.exe";

	if (!RenameFile(exeName, updName, false))
		return false;

	if (!WriteFile(data, exeName))
	{
		Platform::RemoveFile(exeName);
		return false;
	}

	if ((uintptr_t)ShellExecute(nullptr, L"open", Platform::WinWiden(exeName).c_str(), nullptr, nullptr, SW_SHOWNORMAL) <= 32)
	{
		Platform::RemoveFile(exeName);
		return false;
	}

	return true;
}

bool UpdateFinish()
{
	ByteString exeName = Platform::ExecutableName(), updName;
	int timeout = 5, err;
	if constexpr (DEBUG)
	{
		printf("Update: Current EXE name: %s\n", exeName.c_str());
	}
	updName = exeName;
	ByteString extension = exeName.substr(exeName.length() - 4);
	if (extension == ".exe")
		updName = exeName.substr(0, exeName.length() - 4);
	updName = updName + "_upd.exe";
	if constexpr (DEBUG)
	{
		printf("Update: Temp EXE name: %s\n", updName.c_str());
	}
	while (!Platform::RemoveFile(updName))
	{
		err = GetLastError();
		if (err == ERROR_FILE_NOT_FOUND)
		{
			if constexpr (DEBUG)
			{
				printf("Update: Temp file not deleted\n");
			}
			// Old versions of powder toy name their update files with _update.exe, delete that upgrade file here
			updName = exeName;
			ByteString extension = exeName.substr(exeName.length() - 4);
			if (extension == ".exe")
				updName = exeName.substr(0, exeName.length() - 4);
			updName = updName + "_update.exe";
			Platform::RemoveFile(updName);
			return true;
		}
		Sleep(500);
		timeout--;
		if (timeout <= 0)
		{
			if constexpr (DEBUG)
			{
				printf("Update: Delete timeout\n");
			}
			return false;
		}
	}
	return true;
}

void UpdateCleanup()
{
	UpdateFinish();
}

void SetupCrt()
{
	_setmode(0, _O_BINARY);
	_setmode(1, _O_BINARY);
	SetConsoleCP(CP_UTF8);
	SetConsoleOutputCP(CP_UTF8);
	if constexpr (DEBUG)
	{
		_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
	}
	if (GetACP() != CP_UTF8)
	{
		std::cerr << "failed to set codepage to utf-8, expect breakage" << std::endl;
	}
}

void AllocConsole()
{
	if (!::AllocConsole())
	{
		return;
	}
	freopen("CONOUT$", "w", stdout);
	freopen("CONOUT$", "w", stderr);
}
}


=== src\common\platform\stacktrace\Execinfo.cpp ===

#include "common/platform/Platform.h"
#include "common/Defer.h"
#include <execinfo.h>
#include <cstdint>
#include <array>
#include <cxxabi.h>
#include <iostream>

namespace Platform
{
std::optional<std::vector<String>> StackTrace()
{
	std::array<void *, 100> buf;
	auto used = backtrace(buf.data(), buf.size());
	auto *strs = backtrace_symbols(buf.data(), used);
	Defer freeStrs([strs]() {
		free(strs);
	});
	std::vector<String> res;
	for (auto i = 0; i < used; ++i)
	{
		if (strs)
		{
			auto line = ByteString(strs[i]);
			if (auto beginSymbolName = line.SplitBy('('))
			{
				auto afterBeginSymbolName = beginSymbolName.After();
				if (auto endSymbolName = afterBeginSymbolName.SplitBy('+'))
				{
					auto beforeSymbolName = beginSymbolName.Before();
					auto symbolName = endSymbolName.Before();
					auto afterSymbolName = endSymbolName.After();
					int status;
					char *demangled = abi::__cxa_demangle(symbolName.c_str(), NULL, NULL, &status);
					Defer freeDemangled([demangled]() {
						free(demangled);
					});
					if (!status)
					{
						line = ByteString::Build(beforeSymbolName, "(", demangled, "+", afterSymbolName);
					}
				}
			}
			res.push_back(line.FromUtf8());
		}
		else
		{
			res.push_back(String::Build("0x", Format::Hex(), uintptr_t(buf[i])));
		}
	}
	return res;
}
}


=== src\common\platform\stacktrace\meson.build ===

if host_platform == 'windows'
	if use_bluescreen
		project_deps += [
			cpp_compiler.find_library('dbghelp'),
			cpp_compiler.find_library('psapi'),
		]
	endif
	stacktrace_files = files('Windows.cpp')
elif host_platform == 'darwin'
	# TODO: good impl; current one is only slightly better than nothing
	stacktrace_files = files('Execinfo.cpp')
	# export symbols so backtrace_symbols works, see https://www.gnu.org/software/libc/manual/html_node/Backtraces.html
	bluescreen_export_symbols = true
elif host_platform == 'linux'
	# TODO: again, this is more like "posix" than "linux"
	stacktrace_files = files('Execinfo.cpp')
	# export symbols so backtrace_symbols works, see above
	bluescreen_export_symbols = true
	if host_machine.system() in [ 'freebsd' ]
		project_deps += [
			cpp_compiler.find_library('execinfo'),
		]
	endif
else
	stacktrace_files = files('Null.cpp')
endif


=== src\common\platform\stacktrace\Null.cpp ===

#include "common/platform/Platform.h"

namespace Platform
{
std::optional<std::vector<String>> StackTrace()
{
	return std::nullopt;
}
}


=== src\common\platform\stacktrace\Windows.cpp ===

#include "common/platform/Platform.h"
#include "common/Defer.h"
#include <windows.h>
#pragma pack(push, 8)
#include <dbghelp.h>
#pragma pack(pop)
#include <psapi.h>
#include <array>
#include <mutex>
#include <cstdint>

namespace Platform
{
struct SymbolInfo
{
	String name;
	uintptr_t displacement;
};
static std::optional<SymbolInfo> GetSymbolInfo(HANDLE process, uintptr_t offset)
{
	DWORD64 displacement;
	std::array<char, sizeof(SYMBOL_INFOW) + 1000> symbolData{};
	auto &symbol = *reinterpret_cast<SYMBOL_INFOW *>(symbolData.data());
	symbol.SizeOfStruct = sizeof(symbol);
	symbol.MaxNameLen = symbolData.size() - sizeof(symbol);
	if (SymFromAddrW(process, offset, &displacement, &symbol))
	{
		return SymbolInfo{ WinNarrow(&symbol.Name[0]).FromUtf8(), uintptr_t(displacement) };
	}
	return std::nullopt;
}

struct ModuleInfo
{
	String name;
	uintptr_t displacement;
};
static std::optional<ModuleInfo> GetModuleInfo(HANDLE process, uintptr_t offset)
{
	IMAGEHLP_MODULEW64 module{};
	module.SizeOfStruct = sizeof(module);
	if (SymGetModuleInfoW64(process, offset, &module))
	{
		auto displacement = offset - uintptr_t(module.BaseOfImage);
		return ModuleInfo{ WinNarrow(&module.LoadedImageName[0]).FromUtf8(), displacement };
	}
	return std::nullopt;
}

std::optional<std::vector<String>> StackTrace()
{
	static std::mutex mx;
	std::unique_lock lk(mx);
	auto process = GetCurrentProcess();
	auto thread = GetCurrentThread();

	Defer symCleanup([process]() {
		SymCleanup(process);
	});
	SymInitialize(process, nullptr, TRUE);

	CONTEXT context{};
	context.ContextFlags = CONTEXT_FULL;
	RtlCaptureContext(&context);

	STACKFRAME64 frame{};
	DWORD machine;
#if defined(_M_IX86)
	machine                 = IMAGE_FILE_MACHINE_I386;
	frame.AddrPC.Offset     = context.Eip;
	frame.AddrPC.Mode       = AddrModeFlat;
	frame.AddrFrame.Offset  = context.Ebp;
	frame.AddrFrame.Mode    = AddrModeFlat;
	frame.AddrStack.Offset  = context.Esp;
	frame.AddrStack.Mode    = AddrModeFlat;
#elif defined(_M_X64)
	machine                 = IMAGE_FILE_MACHINE_AMD64;
	frame.AddrPC.Offset     = context.Rip;
	frame.AddrPC.Mode       = AddrModeFlat;
	frame.AddrFrame.Offset  = context.Rsp;
	frame.AddrFrame.Mode    = AddrModeFlat;
	frame.AddrStack.Offset  = context.Rsp;
	frame.AddrStack.Mode    = AddrModeFlat;
#elif defined(_M_IA64)
	machine                 = IMAGE_FILE_MACHINE_IA64;
	frame.AddrPC.Offset     = context.StIIP;
	frame.AddrPC.Mode       = AddrModeFlat;
	frame.AddrFrame.Offset  = context.IntSp;
	frame.AddrFrame.Mode    = AddrModeFlat;
	frame.AddrBStore.Offset = context.RsBSP;
	frame.AddrBStore.Mode   = AddrModeFlat;
	frame.AddrStack.Offset  = context.IntSp;
	frame.AddrStack.Mode    = AddrModeFlat;
#elif defined(_M_ARM64)
	machine                 = IMAGE_FILE_MACHINE_ARM64;
	frame.AddrPC.Offset     = context.Pc;
	frame.AddrPC.Mode       = AddrModeFlat;
	frame.AddrFrame.Offset  = context.Fp;
	frame.AddrFrame.Mode    = AddrModeFlat;
	frame.AddrStack.Offset  = context.Sp;
	frame.AddrStack.Mode    = AddrModeFlat;
#else
	return std::nullopt;
#endif

	std::vector<String> res;
	for (auto i = 0; i < 100; ++i)
	{
		if (!StackWalk64(machine, process, thread, &frame, &context, nullptr, SymFunctionTableAccess64, SymGetModuleBase64, nullptr))
		{
			break;
		}
		auto offset = uintptr_t(frame.AddrPC.Offset);
		StringBuilder addr;
		addr << Format::Hex();
		if (auto moduleInfo = GetModuleInfo(process, offset))
		{
			addr << moduleInfo->name << "(";
			if (auto symbolInfo = GetSymbolInfo(process, offset))
			{
				addr << symbolInfo->name << "+0x" << symbolInfo->displacement;
			}
			else
			{
				addr << "+0x" << moduleInfo->displacement;
			}
			addr << ") [0x" << offset << "]";
		}
		else
		{
			addr << "0x" << offset;
		}
		res.push_back(addr.Build());
	}
	return res;
}
}


=== src\debug\AirVelocity.cpp ===

#include "AirVelocity.h"
#include "gui/game/GameView.h"
#include "gui/game/GameController.h"
#include "gui/interface/Engine.h"
#include "simulation/Simulation.h"
#include "simulation/ElementClasses.h"
#include "graphics/Graphics.h"

AirVelocity::AirVelocity(unsigned int id, const Simulation *newSim, GameView *newView, GameController *newController) :
	DebugInfo(id), sim(newSim), view(newView), controller(newController)
{
}

void AirVelocity::Draw()
{
	auto *g = ui::Engine::Ref().g;
	ui::Point pos = controller->PointTranslate(view->GetCurrentMouse());

	float velx = sim->vx[pos.Y/CELL][pos.X/CELL];
	float vely = sim->vy[pos.Y/CELL][pos.X/CELL];
	int endx = pos.X + (int)(10.0f*velx);
	int endy = pos.Y + (int)(10.0f*vely);
	
	//Air velocity line near cursor
	g->XorLine({pos.X, pos.Y}, {endx, endy});

	//Air velocity magnitude
	float vlen = std::sqrt(velx*velx + vely*vely);
	if (vlen > 0.001f)
	{
		StringBuilder velocity;
		velocity << Format::Precision(2) << vlen;

		int width = Graphics::TextSize(velocity.Build()).X;
		int height = Graphics::TextSize(velocity.Build()).Y;

		//Rectangle in polar coordinates, here diff is radius
		int dx = endx - pos.X;
		int dy = endy - pos.Y;
		float diff = 0;
		if (width*std::abs(dy) < height*std::abs(dx))
			diff = ((float)width)/((float)std::abs(dx));
		else
			diff = (dy == 0) ? 0 : (((float)height)/((float)std::abs(dy)));

		float circx = (diff/1.5f) * (endx - pos.X) + endx;
		float circy = (diff/1.5f) * (endy - pos.Y) + endy;

		g->BlendText({(int)circx - width/2, (int)circy - height/2 + 2}, velocity.Build(), 0xFFFFFF_rgb .WithAlpha(255));
	}
}


=== src\debug\AirVelocity.h ===

#pragma once
#include "DebugInfo.h"

class Simulation;
class GameView;
class GameController;
class AirVelocity : public DebugInfo
{
	const Simulation *sim;
	GameView *view;
	GameController *controller;

public:
	AirVelocity(unsigned int id, const Simulation *newSim, GameView *newView, GameController *newController);

	void Draw() override;
};


=== src\debug\DebugInfo.h ===

#pragma once
#include "gui/interface/Point.h"

class DebugInfo
{
public:
	DebugInfo(unsigned int id):debugID(id) { }
	virtual ~DebugInfo() { }
	unsigned int debugID;
	virtual void Draw() {}
	// currentMouse doesn't belong but I don't want to create more hooks at the moment
	virtual bool KeyPress(int key, int scan, bool shift, bool ctrl, bool alt, ui::Point currentMouse) { return true; }
};


=== src\debug\DebugLines.cpp ===

#include "DebugLines.h"
#include "gui/game/GameView.h"
#include "gui/game/GameController.h"
#include "graphics/Graphics.h"
#include "SimulationConfig.h"

DebugLines::DebugLines(unsigned int id, GameView * view, GameController * controller):
	DebugInfo(id),
	view(view),
	controller(controller)
{

}

void DebugLines::Draw()
{
	Graphics * g = view->GetGraphics();

	if (view->GetDrawingLine())
	{
		ui::Point drawPoint1 = controller->PointTranslate(view->GetLineStartCoords()), drawPoint2 = controller->PointTranslate(view->GetLineFinishCoords());
		if (view->GetDrawSnap())
			drawPoint2 = view->lineSnapCoords(drawPoint1, drawPoint2);

		g->BlendLine({ 0, drawPoint1.Y }, { XRES, drawPoint1.Y }, 0xFFFFFF_rgb .WithAlpha(120));
		g->BlendLine({ drawPoint1.X, 0 }, { drawPoint1.X, YRES }, 0xFFFFFF_rgb .WithAlpha(120));

		g->BlendLine({ 0, drawPoint2.Y }, { XRES, drawPoint2.Y }, 0xFFFFFF_rgb .WithAlpha(120));
		g->BlendLine({ drawPoint2.X, 0 }, { drawPoint2.X, YRES }, 0xFFFFFF_rgb .WithAlpha(120));

		String info;
		info = String::Build(drawPoint2.X, " x ", drawPoint2.Y);
		g->BlendTextOutline({ drawPoint2.X+(drawPoint2.X>drawPoint1.X?3:-(g->TextSize(info).X-1)-3), drawPoint2.Y+(drawPoint2.Y<drawPoint1.Y?-10:3) }, info, 0xFFFFFF_rgb .WithAlpha(200));

		info = String::Build(drawPoint1.X, " x ", drawPoint1.Y);
		g->BlendTextOutline({ drawPoint1.X+(drawPoint2.X<drawPoint1.X?3:-(g->TextSize(info).X-1)-2), drawPoint1.Y+(drawPoint2.Y>drawPoint1.Y?-10:3) }, info, 0xFFFFFF_rgb .WithAlpha(200));

		info = String::Build(std::abs(drawPoint2.X-drawPoint1.X));
		g->BlendTextOutline({ (drawPoint1.X+drawPoint2.X)/2-(g->TextSize(info).X-1)/2, drawPoint1.Y+(drawPoint2.Y>drawPoint1.Y?-10:3) }, info, 0xFFFFFF_rgb .WithAlpha(200));

		info = String::Build(std::abs(drawPoint2.Y-drawPoint1.Y));
		g->BlendTextOutline({ drawPoint1.X+(drawPoint2.X<drawPoint1.X?3:-(g->TextSize(info).X-1)-2), (drawPoint1.Y+drawPoint2.Y)/2-3 }, info, 0xFFFFFF_rgb .WithAlpha(200));
	}
}

DebugLines::~DebugLines()
{

}


=== src\debug\DebugLines.h ===

#pragma once

#include "DebugInfo.h"

class GameView;
class GameController;
class DebugLines : public DebugInfo
{
	GameView * view;
	GameController * controller;
public:
	DebugLines(unsigned int id, GameView * view, GameController * controller);
	void Draw() override;
	virtual ~DebugLines();
};


=== src\debug\DebugParts.cpp ===

#include "DebugParts.h"

#include "gui/interface/Engine.h"

#include "simulation/Simulation.h"

#include "graphics/Graphics.h"

DebugParts::DebugParts(unsigned int id, Simulation * sim):
	DebugInfo(id),
	sim(sim)
{

}

void DebugParts::Draw()
{
	Graphics * g = ui::Engine::Ref().g;

	int x = 0, y = 0, lpx = 0, lpy = 0;
	String info = String::Build(sim->parts.lastActiveIndex, "/", NPART, " (", Format::Precision((float)sim->parts.lastActiveIndex/(NPART)*100.0f, 2), "%)");
	for (int i = 0; i < NPART; i++)
	{
		if (sim->parts[i].type)
			g->AddPixel({ x, y }, 0xFFFFFF_rgb .WithAlpha(180));
		else
			g->AddPixel({ x, y }, 0x000000_rgb .WithAlpha(180));

		if (i == sim->parts.lastActiveIndex)
		{
			lpx = x;
			lpy = y;
		}
		x++;
		if(x >= XRES)
		{
			y++;
			x = 0;
		}
	}
	g->DrawLine({ 0, lpy }, { XRES, lpy }, 0x00FF78_rgb);
	g->DrawLine({ lpx, 0 }, { lpx, YRES }, 0x00FF78_rgb);
	g->AddPixel({ lpx, lpy }, 0xFF3232_rgb .WithAlpha(220));

	g->AddPixel({ lpx+1, lpy }, 0xFF3232_rgb .WithAlpha(120));
	g->AddPixel({ lpx-1, lpy }, 0xFF3232_rgb .WithAlpha(120));
	g->AddPixel({ lpx, lpy+1 }, 0xFF3232_rgb .WithAlpha(120));
	g->AddPixel({ lpx, lpy-1 }, 0xFF3232_rgb .WithAlpha(120));

	g->BlendFilledRect(RectSized(Vec2{ 7, YRES-26}, Vec2{ g->TextSize(info).X + 4, 14}), 0x000000_rgb .WithAlpha(180));
	g->BlendText({ 10, YRES-22 }, info, 0xFFFFFF_rgb .WithAlpha(255));
}

DebugParts::~DebugParts()
{

}


=== src\debug\DebugParts.h ===

#pragma once

#include "DebugInfo.h"

class Simulation;
class DebugParts : public DebugInfo
{
	Simulation * sim;
public:
	DebugParts(unsigned int id, Simulation * sim);
	void Draw() override;
	virtual ~DebugParts();
};


=== src\debug\ElementPopulation.cpp ===

#include "ElementPopulation.h"
#include "gui/interface/Engine.h"
#include "simulation/Simulation.h"
#include "simulation/SimulationData.h"
#include "graphics/Graphics.h"

ElementPopulationDebug::ElementPopulationDebug(unsigned int id, Simulation * sim):
	DebugInfo(id),
	sim(sim),
	maxAverage(255.0f)
{

}

void ElementPopulationDebug::Draw()
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	Graphics * g = ui::Engine::Ref().g;

	int yBottom = YRES-10;
	int xStart = 10;

	String maxValString;
	String halfValString;


	float maxVal = 255;
	float scale = 1.0f;
	int bars = 0;
	for(int i = 0; i < PT_NUM; i++)
	{
		if(elements[i].Enabled)
		{
			if(maxVal < sim->elementCount[i])
				maxVal = float(sim->elementCount[i]);
			bars++;
		}
	}
	maxAverage = (maxAverage*(1.0f-0.015f)) + (0.015f*maxVal);
	scale = 255.0f/maxAverage;

	maxValString = String::Build(maxAverage);
	halfValString = String::Build(maxAverage/2);


	g->BlendFilledRect(RectSized(Vec2{ xStart-5, yBottom - 263 }, Vec2{ bars+10+Graphics::TextSize(maxValString).X+9, 255 + 13 }), 0x000000_rgb .WithAlpha(180));

	bars = 0;
	for(int i = 0; i < PT_NUM; i++)
	{
		if(elements[i].Enabled)
		{
			auto count = sim->elementCount[i];
			auto barSize = int(count * scale - 0.5f);
			int barX = bars;//*2;

			RGB colour = elements[i].Colour;

			g->DrawLine({ xStart+barX, yBottom+3 }, { xStart+barX, yBottom+2 }, colour);
			if(sim->elementCount[i])
			{
				if(barSize > 256)
				{
					barSize = 256;
					g->DrawPixel({ xStart+barX, yBottom-barSize-3 }, colour);
					g->DrawPixel({ xStart+barX, yBottom-barSize-5 }, colour);
					g->DrawPixel({ xStart+barX, yBottom-barSize-7 }, colour);
				} else {

					g->BlendLine({ xStart+barX, yBottom-barSize-3 }, { xStart+barX, yBottom-barSize-2 }, 0xFFFFFF_rgb .WithAlpha(180));
				}
				g->DrawLine({ xStart+barX, yBottom-barSize }, { xStart+barX, yBottom }, colour);
			}
			bars++;
		}
	}

	g->BlendText({ xStart + bars + 5, yBottom-5 }, "0", 0xFFFFFF_rgb .WithAlpha(255));
	g->BlendText({ xStart + bars + 5, yBottom-132 }, halfValString, 0xFFFFFF_rgb .WithAlpha(255));
	g->BlendText({ xStart + bars + 5, yBottom-260 }, maxValString, 0xFFFFFF_rgb .WithAlpha(255));
}

ElementPopulationDebug::~ElementPopulationDebug()
{

}


=== src\debug\ElementPopulation.h ===

#pragma once

#include "DebugInfo.h"

class Simulation;
class ElementPopulationDebug : public DebugInfo
{
	Simulation * sim;
	float maxAverage;
public:
	ElementPopulationDebug(unsigned int id, Simulation * sim);
	void Draw() override;
	virtual ~ElementPopulationDebug();
};


=== src\debug\meson.build ===

powder_files += files(
	'DebugLines.cpp',
	'DebugParts.cpp',
	'ElementPopulation.cpp',
	'ParticleDebug.cpp',
	'SurfaceNormals.cpp',
	'AirVelocity.cpp',
)


=== src\debug\ParticleDebug.cpp ===

#include "ParticleDebug.h"

#include "gui/game/GameModel.h"

#include "simulation/Simulation.h"

ParticleDebug::ParticleDebug(unsigned int id, Simulation * sim, GameModel * model):
	DebugInfo(id),
	sim(sim),
	model(model)
{

}

void ParticleDebug::Debug(int mode, int x, int y)
{
	int i = 0;
	String logmessage;

	if (mode == 0)
	{
		if (!sim->NUM_PARTS)
			return;
		i = sim->debug_nextToUpdate;
		while (i < NPART - 1 && !sim->parts[i].type)
			i++;
		if (i == NPART - 1)
			logmessage = "End of particles reached, updated sim";
		else
			logmessage = String::Build("Updated particle #", i);
	}
	else if (mode == 1)
	{
		i = NPART - 1;
		if (x >= 0 && x < XRES && y >= 0 && y < YRES)
		{
			if (sim->pmap[y][x] && ID(sim->pmap[y][x]) >= sim->debug_nextToUpdate)
			{
				i = ID(sim->pmap[y][x]);
			}
			else if (sim->photons[y][x] && ID(sim->photons[y][x]) >= sim->debug_nextToUpdate)
			{
				i = ID(sim->photons[y][x]);
			}
		}
	}
	sim->framerender = 1;
	auto prevToUpdate = sim->debug_nextToUpdate;
	model->UpdateUpTo(i + 1);
	if (sim->debug_nextToUpdate)
	{
		logmessage = String::Build("Updated particles from #", prevToUpdate, " through #", i);
	}
	else
	{
		logmessage = String::Build("Updated particles from #", prevToUpdate, " to end");
	}
	model->Log(logmessage, false);
}

bool ParticleDebug::KeyPress(int key, int scan, bool shift, bool ctrl, bool alt, ui::Point currentMouse)
{
	if (key == 'f' && !ctrl)
	{
		model->SetPaused(1);
		if (alt)
		{
			Debug(0, 0, 0);
		}
		else if (shift)
		{
			ui::Point mouse = currentMouse;
			if (mouse.X >= XRES)
				mouse.X = XRES-1;
			else if (mouse.X < 0)
				mouse.X = 0;
			if (mouse.Y >= YRES)
				mouse.Y = YRES-1;
			else if (mouse.Y < 0)
				mouse.Y = 0;

			mouse = model->AdjustZoomCoords(mouse);
			Debug(1, mouse.X, mouse.Y);
		}
		else
		{
			if (ctrl)
				return true;
			if (sim->debug_nextToUpdate > 0)
			{
				String logmessage = String::Build("Updated particles from #", sim->debug_nextToUpdate, " to end due to frame step");
				model->UpdateUpTo(NPART);
				model->Log(logmessage, false);
			}
			else
			{
				model->FrameStep(1);
			}
		}
		return false;
	}
	return true;
}


=== src\debug\ParticleDebug.h ===

#pragma once
#include "DebugInfo.h"

class Simulation;
class GameModel;
class ParticleDebug : public DebugInfo
{
	Simulation * sim;
	GameModel * model;
public:
	ParticleDebug(unsigned int id, Simulation * sim, GameModel * model);
	void Debug(int mode, int x, int y);
	bool KeyPress(int key, int scan, bool shift, bool ctrl, bool alt, ui::Point currentMouse) override;
};


=== src\debug\SurfaceNormals.cpp ===

#include "SurfaceNormals.h"
#include "gui/game/GameView.h"
#include "gui/game/GameController.h"
#include "gui/interface/Engine.h"
#include "simulation/Simulation.h"
#include "simulation/ElementClasses.h"
#include "graphics/Graphics.h"

SurfaceNormals::SurfaceNormals(unsigned int id, const Simulation *newSim, GameView *newView, GameController *newController) :
	DebugInfo(id), sim(newSim), view(newView), controller(newController)
{
}

void SurfaceNormals::Draw()
{
	auto *g = ui::Engine::Ref().g;
	ui::Point pos = controller->PointTranslate(view->GetCurrentMouse());
	auto p = sim->photons[pos.Y][pos.X];
	if (!p)
	{
		p = sim->pmap[pos.Y][pos.X];
	}
	if (!p)
	{
		return;
	}
	auto i = ID(p);
	auto t = TYP(p);
	auto &parts = sim->parts;
	auto x = int(parts[i].x + 0.5f);
	auto y = int(parts[i].y + 0.5f);
	auto mr = Simulation::PlanMove<false>(*sim, i, x, y);
	if (t == PT_PHOT)
	{
		if (parts[i].flags & FLAG_SKIPMOVE)
		{
			return;
		}
		if (sim->eval_move(PT_PHOT, mr.fin_x, mr.fin_y, nullptr))
		{
			int rt = TYP(sim->pmap[mr.fin_y][mr.fin_x]);
			int lt = TYP(sim->pmap[y][x]);
			int rt_glas = (rt == PT_GLAS) || (rt == PT_BGLA);
			int lt_glas = (lt == PT_GLAS) || (lt == PT_BGLA);
			if ((rt_glas && !lt_glas) || (lt_glas && !rt_glas))
			{
				t |= REFRACT;
			}
		}
	}
	auto gn = sim->get_normal_interp<false>(*sim, t, parts[i].x, parts[i].y, mr.vx, mr.vy);
	if (!gn.success)
	{
		return;
	}
	g->XorLine({ x, y }, { mr.fin_x, mr.fin_y });
	g->XorLine({ mr.fin_x, mr.fin_y }, { int((mr.fin_x + gn.nx * SURF_RANGE) + 0.5f), int((mr.fin_y + gn.ny * SURF_RANGE) + 0.5f) });
	g->XorLine({ mr.fin_x, mr.fin_y }, { gn.lx, gn.ly });
	g->XorLine({ mr.fin_x, mr.fin_y }, { gn.rx, gn.ry });
}


=== src\debug\SurfaceNormals.h ===

#pragma once
#include "DebugInfo.h"

class Simulation;
class GameView;
class GameController;
class SurfaceNormals : public DebugInfo
{
	const Simulation *sim;
	GameView *view;
	GameController *controller;

public:
	SurfaceNormals(unsigned int id, const Simulation *newSim, GameView *newView, GameController *newController);

	void Draw() override;
};


=== src\graphics\FindingElement.h ===

#pragma once
#include "simulation/StructProperty.h"

struct FindingElement
{
	StructProperty property;
	PropertyValue value;

	bool operator ==(const FindingElement &other) const
	{
		return property == other.property &&
		       value == other.value;
	}
};


=== src\graphics\FontReader.cpp ===

#include "FontReader.h"

#include "bzip2/bz2wrap.h"
#include "font_bz2.h"

#include <array>
#include <cstdint>

unsigned char *font_data = nullptr;
unsigned int *font_ptrs = nullptr;
unsigned int (*font_ranges)[2] = nullptr;

FontReader::FontReader(unsigned char const *_pointer):
	pointer(_pointer + 1),
	width(*_pointer),
	pixels(0),
	data(0)
{
}

static bool InitFontData()
{
	static std::vector<char> fontDataBuf;
	static std::vector<int> fontPtrsBuf;
	static std::vector< std::array<int, 2> > fontRangesBuf;
	if (BZ2WDecompress(fontDataBuf, font_bz2.AsCharSpan()) != BZ2WDecompressOk)
	{
		return false;
	}
	int first = -1;
	int last = -1;
	char *begin = fontDataBuf.data();
	char *ptr = fontDataBuf.data();
	char *end = fontDataBuf.data() + fontDataBuf.size();
	while (ptr != end)
	{
		if (ptr + 4 > end)
		{
			return false;
		}
		auto codePoint = *reinterpret_cast<uint32_t *>(ptr) & 0xFFFFFFU;
		if (codePoint >= 0x110000U)
		{
			return false;
		}
		auto width = *reinterpret_cast<uint8_t *>(ptr + 3);
		if (width > 64)
		{
			return false;
		}
		if (ptr + 4 + width * 3 > end)
		{
			return false;
		}
		auto cp = (int)codePoint;
		if (last >= cp)
		{
			return false;
		}
		if (first != -1 && last + 1 < cp)
		{
			fontRangesBuf.push_back({ { first, last } });
			first = -1;
		}
		if (first == -1)
		{
			first = cp;
		}
		last = cp;
		fontPtrsBuf.push_back(ptr + 3 - begin);
		ptr += width * 3 + 4;
	}
	if (first != -1)
	{
		fontRangesBuf.push_back({ { first, last } });
	}
	fontRangesBuf.push_back({ { 0, 0 } });
	font_data = reinterpret_cast<unsigned char *>(fontDataBuf.data());
	font_ptrs = reinterpret_cast<unsigned int *>(fontPtrsBuf.data());
	font_ranges = reinterpret_cast<unsigned int (*)[2]>(fontRangesBuf.data());
	return true;
}

unsigned char const *FontReader::lookupChar(String::value_type ch)
{
	if (!font_data)
	{
		if (!InitFontData())
		{
			throw std::runtime_error("font data corrupt");
		}
	}
	size_t offset = 0;
	for(int i = 0; font_ranges[i][1]; i++)
		if(font_ranges[i][0] > ch)
			break;
		else if(font_ranges[i][1] >= ch)
			return &font_data[font_ptrs[offset + (ch - font_ranges[i][0])]];
		else
			offset += font_ranges[i][1] - font_ranges[i][0] + 1;
	if(ch == 0xFFFD)
		return &font_data[0];
	else
		return lookupChar(0xFFFD);
}

FontReader::FontReader(String::value_type ch):
	FontReader(lookupChar(ch))
{
}

int FontReader::GetWidth() const
{
	return width;
}

int FontReader::NextPixel()
{
	if(!pixels)
	{
		data = *(pointer++);
		pixels = 4;
	}
	int old = data;
	pixels--;
	data >>= 2;
	return old & 0x3;
}


=== src\graphics\FontReader.h ===

#pragma once
#include <cstddef>

#include "common/String.h"

constexpr auto FONT_H = 12;

class FontReader
{
	unsigned char const *pointer;
	int width;
	int pixels;
	int data;

	FontReader(unsigned char const *_pointer);
	static unsigned char const *lookupChar(String::value_type ch);

public:
	FontReader(String::value_type ch);
	int GetWidth() const;
	int NextPixel();
};


=== src\graphics\gcache_item.h ===

#pragma once

struct gcache_item
{
	int isready = 0;
	int pixel_mode = 0;
	int cola = 0;
	int colr = 0;
	int colg = 0;
	int colb = 0;
	int firea = 0;
	int firer = 0;
	int fireg = 0;
	int fireb = 0;
};


=== src\graphics\Gradient.cpp ===

#include "Gradient.h"

std::vector<RGB> Gradient(std::vector<GradientStop> stops, int resolution)
{
	std::vector<RGB> table(resolution, 0x000000_rgb);
	if (stops.size() >= 2)
	{
		std::sort(stops.begin(), stops.end());
		auto stop = -1;
		for (auto i = 0; i < resolution; ++i)
		{
			auto point = i / (float)resolution;
			while (stop < (int)stops.size() - 1 && stops[stop + 1].point <= point)
			{
				++stop;
			}
			if (stop < 0 || stop >= (int)stops.size() - 1)
			{
				continue;
			}
			auto &left = stops[stop];
			auto &right = stops[stop + 1];
			auto f = (point - left.point) / (right.point - left.point);
			table[i] = left.color.Blend(right.color.WithAlpha(uint8_t(f * 0xFF)));
		}
	}
	return table;
}


=== src\graphics\Gradient.h ===

#pragma once
#include "Pixel.h"
#include <vector>

struct GradientStop
{
	RGB color;
	float point;

	bool operator <(const GradientStop &other) const
	{
		return point < other.point;
	}
};
std::vector<RGB> Gradient(std::vector<GradientStop> stops, int resolution);


=== src\graphics\Graphics.cpp ===

#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <memory>
#include <png.h>
#include "common/platform/Platform.h"
#include "FontReader.h"
#include "Format.h"
#include "Graphics.h"
#include "resampler/resampler.h"
#include "SimulationConfig.h"
#include "RasterDrawMethodsImpl.h"

VideoBuffer::VideoBuffer(Vec2<int> size):
	video(size)
{}

VideoBuffer::VideoBuffer(pixel const *data, Vec2<int> size):
	VideoBuffer(size)
{
	std::copy_n(data, size.X * size.Y, video.data());
}

VideoBuffer::VideoBuffer(pixel const *data, Vec2<int> size, size_t rowStride):
	VideoBuffer(size)
{
	for(int y = 0; y < size.Y; y++)
		std::copy_n(data + rowStride * y, size.X, video.RowIterator(Vec2(0, y)));
}

void VideoBuffer::Crop(Rect<int> rect)
{
	rect &= Size().OriginRect();
	if (rect == Size().OriginRect())
		return;

	PlaneAdapter<std::vector<pixel> &> newVideo(rect.size, std::in_place, video.Base);
	for (auto y = 0; y < newVideo.Size().Y; y++)
		std::copy_n(
			video.RowIterator(rect.pos + Vec2(0, y)),
			newVideo.Size().X,
			newVideo.RowIterator(Vec2(0, y))
		);
	video.Base.resize(newVideo.Size().X * newVideo.Size().Y);
	video.Base.shrink_to_fit();
	video.SetSize(newVideo.Size());
}

void VideoBuffer::Resize(Vec2<int> size, bool resample)
{
	if (size == Size())
		return;

	if (resample)
	{
		std::array<std::unique_ptr<Resampler>, PIXELCHANNELS> resamplers;
		Resampler::Contrib_List *clist_x = nullptr, *clist_y = nullptr;
		for (auto &ptr : resamplers)
		{
			ptr = std::make_unique<Resampler>(
				Size().X, Size().Y, // source size
				size.X, size.Y, // destination size
				Resampler::BOUNDARY_CLAMP,
				0.0f, 255.0f, // upper and lower bounds for channel values
				"lanczos12",
				clist_x, clist_y,
				0.75f, 0.75f // X and Y filter scales, values < 1.0 cause aliasing, but create sharper looking mips.
			);
			clist_x = ptr->get_clist_x();
			clist_y = ptr->get_clist_y();
		}

		std::array<std::unique_ptr<float []>, PIXELCHANNELS> samples;
		for (auto &ptr : samples)
			ptr = std::make_unique<float []>(Size().X);

		PlaneAdapter<std::vector<pixel>> newVideo(size);

		pixel const *inIter = video.data();
		std::array<pixel *, PIXELCHANNELS> outIter;
		for (pixel *&it : outIter)
			it = newVideo.data();

		for (int sourceY = 0; sourceY < Size().Y; sourceY++)
		{
			for (int sourceX = 0; sourceX < Size().X; sourceX++)
			{
				pixel px = *inIter++;
				for (int c = 0; c < PIXELCHANNELS; c++)
					samples[c][sourceX] = uint8_t(px >> (8 * c));
			}

			for (int c = 0; c < PIXELCHANNELS; c++)
			{
				if (!resamplers[c]->put_line(samples[c].get()))
				{
					fprintf(stderr, "Out of memory when resampling\n");
					Crop(size.OriginRect()); // Better than leaving the image at original size I guess
					return;
				}

				while (float const *output = resamplers[c]->get_line())
					for (int destX = 0; destX < size.X; destX++)
						*outIter[c]++ |= pixel(uint8_t(output[destX])) << (8 * c);
			}
		}

		video = std::move(newVideo);
	}
	else
	{
		PlaneAdapter<std::vector<pixel>> newVideo(size);
		for (auto pos : size.OriginRect())
		{
			auto oldPos = Vec2(pos.X * Size().X / size.X, pos.Y * Size().Y / size.Y);
			newVideo[pos] = video[oldPos];
		}
		video = std::move(newVideo);
	}
}

void VideoBuffer::Resize(float factor, bool resample)
{
	Resize(Vec2{ int(Size().X * factor), int(Size().Y * factor) }, resample);
}

void VideoBuffer::ResizeToFit(Vec2<int> bound, bool resample)
{
	Vec2<int> size = Size();
	if (size.X > bound.X || size.Y > bound.Y)
	{
		auto ceilDiv = [](int a, int b) {
			return a / b + ((a % b) ? 1 : 0);
		};
		if (bound.X * size.Y < bound.Y * size.X)
			size = { bound.X, ceilDiv(size.Y * bound.X, size.X) };
		else
			size = { ceilDiv(size.X * bound.Y, size.Y), bound.Y };
	}
	Resize(size, resample);
}

std::unique_ptr<VideoBuffer> VideoBuffer::FromPNG(std::span<const char> data)
{
	auto video = format::PixelsFromPNG(data, 0x000000_rgb);
	if (video)
	{
		auto buf = std::make_unique<VideoBuffer>(Vec2<int>::Zero);
		buf->video = std::move(*video);
		return buf;
	}
	else
		return nullptr;
}

std::unique_ptr<std::vector<char>> VideoBuffer::ToPNG() const
{
	return format::PixelsToPNG(video);
}

std::vector<char> VideoBuffer::ToPPM() const
{
	return format::PixelsToPPM(video);
}

template struct RasterDrawMethods<VideoBuffer>;

Graphics::Graphics()
{}

void Graphics::draw_icon(int x, int y, Icon icon, unsigned char alpha, bool invert)
{
	y--;
	switch(icon)
	{
	case IconOpen:
		if(invert)
			BlendChar({ x, y }, 0xE001, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE001, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconReload:
		if(invert)
			BlendChar({ x, y }, 0xE011, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE011, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconSave:
		if(invert)
			BlendChar({ x, y }, 0xE002, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE002, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconVoteUp:
		if(invert)
		{
			BlendChar({ x-11, y+1 }, 0xE04B, 0x006400_rgb .WithAlpha(alpha));
			BlendText({ x+2, y+1 }, "Vote", 0x006400_rgb .WithAlpha(alpha));
		}
		else
		{
			BlendChar({ x-11, y+1 }, 0xE04B, 0x00BB12_rgb .WithAlpha(alpha));
			BlendText({ x+2, y+1 }, "Vote", 0x00BB12_rgb .WithAlpha(alpha));
		}
		break;
	case IconVoteDown:
		if(invert)
			BlendChar({ x, y }, 0xE04A, 0x640A00_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE04A, 0xBB2800_rgb .WithAlpha(alpha));
		break;
	case IconTag:
		if(invert)
			BlendChar({ x, y }, 0xE003, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE003, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconNew:
		if(invert)
			BlendChar({ x, y }, 0xE012, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE012, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconLogin:
		if(invert)
			BlendChar({ x, y + 1 }, 0xE004, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y + 1 }, 0xE004, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconSimulationSettings:
		if(invert)
			BlendChar({ x, y + 1 }, 0xE04F, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y + 1 }, 0xE04F, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconRenderSettings:
		if(invert)
		{
			BlendChar({ x, y + 1 }, 0xE058, 0xFF0000_rgb .WithAlpha(alpha));
			BlendChar({ x, y + 1 }, 0xE059, 0x00FF00_rgb .WithAlpha(alpha));
			BlendChar({ x, y + 1 }, 0xE05A, 0x0000FF_rgb .WithAlpha(alpha));
		}
		else
		{
			AddChar({ x, y + 1 }, 0xE058, 0xFF0000_rgb .WithAlpha(alpha));
			AddChar({ x, y + 1 }, 0xE059, 0x00FF00_rgb .WithAlpha(alpha));
			AddChar({ x, y + 1 }, 0xE05A, 0x0000FF_rgb .WithAlpha(alpha));
		}
		break;
	case IconPause:
		if(invert)
			BlendChar({ x, y }, 0xE010, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE010, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconFavourite:
		if(invert)
			BlendChar({ x, y }, 0xE04C, 0x645020_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE04C, 0xC0A040_rgb .WithAlpha(alpha));
		break;
	case IconReport:
		if(invert)
			BlendChar({ x, y }, 0xE063, 0x8C8C00_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE063, 0xFFFF00_rgb .WithAlpha(alpha));
		break;
	case IconUsername:
		if(invert)
		{
			BlendChar({ x, y }, 0xE00B, 0x204080_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE00A, 0x000000_rgb .WithAlpha(alpha));
		}
		else
		{
			BlendChar({ x, y }, 0xE00B, 0x204080_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE00A, 0xFFFFFF_rgb .WithAlpha(alpha));
		}
		break;
	case IconPassword:
		if(invert)
		{
			BlendChar({ x, y }, 0xE00C, 0xA09020_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE004, 0x000000_rgb .WithAlpha(alpha));
		}
		else
		{
			BlendChar({ x, y }, 0xE00C, 0xA09020_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE004, 0xFFFFFF_rgb .WithAlpha(alpha));
		}
		break;
	case IconClose:
		if(invert)
			BlendChar({ x, y }, 0xE02A, 0x141414_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 0xE02A, 0xE6E6E6_rgb .WithAlpha(alpha));
		break;
	case IconVoteSort:
		if (invert)
		{
			BlendChar({ x, y }, 0xE029, 0x2C3020_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE028, 0x202C20_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE027, 0x808080_rgb .WithAlpha(alpha));
		}
		else
		{
			BlendChar({ x, y }, 0xE029, 0x903020_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE028, 0x209020_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE027, 0xFFFFFF_rgb .WithAlpha(alpha));
		}
		break;
	case IconDateSort:
		if (invert)
		{
			BlendChar({ x, y }, 0xE026, 0x202020_rgb .WithAlpha(alpha));
		}
		else
		{
			BlendChar({ x, y }, 0xE026, 0xFFFFFF_rgb .WithAlpha(alpha));
		}
		break;
	case IconMyOwn:
		if (invert)
		{
			BlendChar({ x, y }, 0xE014, 0xC0A040_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE013, 0x202020_rgb .WithAlpha(alpha));
		}
		else
		{
			BlendChar({ x, y }, 0xE014, 0xC0A040_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE013, 0xFFFFFF_rgb .WithAlpha(alpha));
		}
		break;
	case IconSearch:
		BlendChar({ x, y }, 0xE00E, 0x1E1EB4_rgb .WithAlpha(alpha));
		BlendChar({ x, y }, 0xE00F, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconDelete:
		if(invert)
		{
			BlendChar({ x, y }, 0xE006, 0x9F2F1F_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE005, 0x000000_rgb .WithAlpha(alpha));
		}
		else
		{
			BlendChar({ x, y }, 0xE006, 0x9F2F1F_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE005, 0xFFFFFF_rgb .WithAlpha(alpha));
		}
		break;
	case IconAdd:
		if(invert)
		{
			BlendChar({ x, y }, 0xE006, 0x209020_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE009, 0x000000_rgb .WithAlpha(alpha));
		}
		else
		{
			BlendChar({ x, y }, 0xE006, 0x209020_rgb .WithAlpha(alpha));
			BlendChar({ x, y }, 0xE009, 0xFFFFFF_rgb .WithAlpha(alpha));
		}
		break;
	case IconVelocity:
		BlendChar({ x + 1, y }, 0xE018, 0x80A0FF_rgb .WithAlpha(alpha));
		break;
	case IconPressure:
		if(invert)
			BlendChar({ x + 1, y + 1 }, 0xE019, 0xB4A010_rgb .WithAlpha(alpha));
		else
			BlendChar({ x + 1, y + 1 }, 0xE019, 0xFFD420_rgb .WithAlpha(alpha));
		break;
	case IconPersistant:
		if(invert)
			BlendChar({ x + 1, y + 1 }, 0xE01A, 0x141414_rgb .WithAlpha(alpha));
		else
			BlendChar({ x + 1, y + 1 }, 0xE01A, 0xD4D4D4_rgb .WithAlpha(alpha));
		break;
	case IconFire:
		BlendChar({ x + 1, y + 1 }, 0xE01B, 0xFF0000_rgb .WithAlpha(alpha));
		BlendChar({ x + 1, y + 1 }, 0xE01C, 0xFFFF40_rgb .WithAlpha(alpha));
		break;
	case IconBlob:
		if(invert)
			BlendChar({ x + 1, y }, 0xE03F, 0x37B437_rgb .WithAlpha(alpha));
		else
			BlendChar({ x + 1, y }, 0xE03F, 0x37FF37_rgb .WithAlpha(alpha));
		break;
	case IconHeat:
		BlendChar({ x + 3, y }, 0xE03E, 0xFF0000_rgb .WithAlpha(alpha));
		if(invert)
			BlendChar({ x + 3, y }, 0xE03D, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x + 3, y }, 0xE03D, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconBlur:
		if(invert)
			BlendChar({ x + 1, y }, 0xE044, 0x3246B4_rgb .WithAlpha(alpha));
		else
			BlendChar({ x + 1, y }, 0xE044, 0x6496FF_rgb .WithAlpha(alpha));
		break;
	case IconGradient:
		if(invert)
			BlendChar({ x + 1, y + 1 }, 0xE053, 0xFF32FF_rgb .WithAlpha(alpha));
		else
			BlendChar({ x + 1, y + 1 }, 0xE053, 0xCD32CD_rgb .WithAlpha(alpha));
		break;
	case IconLife:
		if(invert)
			BlendChar({ x, y + 1 }, 0xE060, 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y + 1 }, 0xE060, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconEffect:
		BlendChar({ x + 1, y }, 0xE061, 0xFFFFA0_rgb .WithAlpha(alpha));
		break;
	case IconGlow:
		BlendChar({ x + 1, y }, 0xE05F, 0xC8FFFF_rgb .WithAlpha(alpha));
		break;
	case IconWarp:
		BlendChar({ x + 1, y }, 0xE05E, 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	case IconBasic:
		if(invert)
			BlendChar({ x + 1, y + 1 }, 0xE05B, 0x323200_rgb .WithAlpha(alpha));
		else
			BlendChar({ x + 1, y + 1 }, 0xE05B, 0xFFFFC8_rgb .WithAlpha(alpha));
		break;
	case IconAltAir:
		if(invert) {
			BlendChar({ x + 1, y + 1 }, 0xE054, 0xB43737_rgb .WithAlpha(alpha));
			BlendChar({ x + 1, y + 1 }, 0xE055, 0x37B437_rgb .WithAlpha(alpha));
		} else {
			BlendChar({ x + 1, y + 1 }, 0xE054, 0xFF3737_rgb .WithAlpha(alpha));
			BlendChar({ x + 1, y + 1 }, 0xE055, 0x37FF37_rgb .WithAlpha(alpha));
		}
		break;
	default:
		if(invert)
			BlendChar({ x, y }, 't', 0x000000_rgb .WithAlpha(alpha));
		else
			BlendChar({ x, y }, 't', 0xFFFFFF_rgb .WithAlpha(alpha));
		break;
	}
}

VideoBuffer Graphics::DumpFrame()
{
	VideoBuffer newBuffer(video.Size());
	std::copy_n(video.data(), video.Size().X * video.Size().Y, newBuffer.Data());
	return newBuffer;
}

void Graphics::SwapClipRect(Rect<int> &rect)
{
	std::swap(clipRect, rect);
	clipRect &= video.Size().OriginRect();
}

void Graphics::RenderZoom()
{
	if(!zoomEnabled)
		return;
	{
		int x, y, i, j;
		pixel pix;

		DrawFilledRect(RectSized(zoomWindowPosition, { zoomScopeSize * ZFACTOR, zoomScopeSize * ZFACTOR }), 0x000000_rgb);
		DrawRect(RectSized(zoomWindowPosition - Vec2{ 2, 2 }, Vec2{ zoomScopeSize*ZFACTOR+3, zoomScopeSize*ZFACTOR+3 }), 0xC0C0C0_rgb);
		DrawRect(RectSized(zoomWindowPosition - Vec2{ 1, 1 }, Vec2{ zoomScopeSize*ZFACTOR+1, zoomScopeSize*ZFACTOR+1 }), 0x000000_rgb);
		for (j=0; j<zoomScopeSize; j++)
			for (i=0; i<zoomScopeSize; i++)
			{
				pix = video[{ i + zoomScopePosition.X, j + zoomScopePosition.Y }];
				for (y=0; y<ZFACTOR-1; y++)
					for (x=0; x<ZFACTOR-1; x++)
						video[{ i * ZFACTOR + x + zoomWindowPosition.X, j * ZFACTOR + y + zoomWindowPosition.Y }] = pix;
			}
		if (zoomEnabled)
		{
			for (j=-1; j<=zoomScopeSize; j++)
			{
				XorPixel(zoomScopePosition + Vec2{ j, -1 });
				XorPixel(zoomScopePosition + Vec2{ j, zoomScopeSize });
			}
			for (j=0; j<zoomScopeSize; j++)
			{
				XorPixel(zoomScopePosition + Vec2{ -1, j });
				XorPixel(zoomScopePosition + Vec2{ zoomScopeSize, j });
			}
		}
	}
}


=== src\graphics\Graphics.h ===

#pragma once
#include "Icons.h"
#include "gui/interface/Point.h"
#include "common/Plane.h"
#include "SimulationConfig.h"
#include "RasterDrawMethods.h"
#include <array>

class Graphics: public RasterDrawMethods<Graphics>
{
	PlaneAdapter<std::array<pixel, WINDOW.X * WINDOW.Y>, WINDOW.X, WINDOW.Y> video;
	Rect<int> clipRect = video.Size().OriginRect();

	friend struct RasterDrawMethods<Graphics>;

public:
	Vec2<int> Size() const
	{
		return video.Size();
	}

	pixel const *Data() const
	{
		return video.data();
	}

	pixel *Data()
	{
		return video.data();
	}

	VideoBuffer DumpFrame();

	void draw_icon(int x, int y, Icon icon, unsigned char alpha = 255, bool invert = false);

	void Finalise();

	Graphics();

	void SwapClipRect(Rect<int> &);

	Rect<int> GetClipRect() const
	{
		return clipRect;
	}

	ui::Point zoomWindowPosition = { 0, 0 };
	ui::Point zoomScopePosition = { 0, 0 };
	int zoomScopeSize = 32;
	bool zoomEnabled = false;
	int ZFACTOR = 8;
	void RenderZoom();
};


=== src\graphics\Icons.h ===

#pragma once
//Icon names, see Graphics::draw_icon
enum Icon
{
	NoIcon = 0,
	IconOpen,
	IconReload,
	IconSave,
	IconVoteUp,
	IconVoteDown,
	IconTag,
	IconNew,
	IconLogin,
	IconRenderSettings,
	IconSimulationSettings,
	IconPause,
	IconVoteSort,
	IconDateSort,
	IconMyOwn,
	IconFavourite,
	IconSearch,
	IconDelete,
	IconAdd,
	IconReport,
	IconUsername,
	IconPassword,
	IconClose,
	IconEffect,
	IconFire,
	IconGlow,
	IconBlur,
	IconBlob,
	IconBasic,
	IconAltAir,
	IconPressure,
	IconVelocity,
	IconWarp,
	IconPersistant,
	IconHeat,
	IconLife,
	IconGradient
};


=== src\graphics\meson.build ===

graphics_files = files(
	'Gradient.cpp',
	'Graphics.cpp',
	'RasterGraphics.cpp',
	'FontReader.cpp',
)
powder_graphics_files = files(
	'Renderer.cpp',
)

common_files += graphics_files
powder_files += powder_graphics_files
render_files += powder_graphics_files


=== src\graphics\Pixel.h ===

#pragma once

#include <algorithm>
#include <cstdint>
#include <initializer_list>
#include <limits>
#include <type_traits>
#include <utility>

// This is always packed with the least significant byte being blue,
// then green, then red, then 0.
typedef uint32_t pixel;

constexpr int PIXELCHANNELS = 3;

// Least significant byte is blue, then green, then red, then alpha.
// Use sparingly, e.g. when passing packed data to a third party library.
typedef uint32_t pixel_rgba;

struct RGBA;

struct alignas(alignof(uint32_t)) RGB
{
	uint8_t Blue, Green, Red;

	constexpr RGB() = default;

	constexpr RGB(uint8_t r, uint8_t g, uint8_t b):
		Blue(b),
		Green(g),
		Red(r)
	{
	}

	template<typename S> // Disallow brace initialization
	RGB(std::initializer_list<S>) = delete;

	// Blend and Add get called in tight loops so it's important that they
	// vectorize well.
	constexpr RGB Blend(RGBA other) const;
	constexpr RGB Add(RGBA other) const;

	constexpr RGB AddFire(RGB other, int fireAlpha) const
	{
		return RGB(
			std::min(0xFF, Red + (fireAlpha * other.Red) / 0xFF),
			std::min(0xFF, Green + (fireAlpha * other.Green) / 0xFF),
			std::min(0xFF, Blue + (fireAlpha * other.Blue) / 0xFF)
		);
	}

	// Decrement each component that is nonzero.
	constexpr RGB Decay() const
	{
		// This vectorizes really well.
		pixel colour = Pack(), mask = colour;
		mask |= mask >> 4;
		mask |= mask >> 2;
		mask |= mask >> 1;
		mask &= 0x00010101;
		return Unpack(colour - mask);
	}

	constexpr RGB Inverse() const
	{
		return RGB(0xFF - Red, 0xFF - Green, 0xFF - Blue);
	}

	constexpr RGBA WithAlpha(uint8_t a) const;

	constexpr pixel Pack() const
	{
		return Red << 16 | Green << 8 | Blue;
	}

	constexpr static RGB Unpack(pixel px)
	{
		return RGB(px >> 16, px >> 8, px);
	}
};

constexpr inline RGB operator ""_rgb(unsigned long long value)
{
	return RGB::Unpack(value);
}

struct alignas(alignof(uint32_t)) RGBA
{
	uint8_t Blue, Green, Red, Alpha;

	constexpr RGBA() = default;

	constexpr RGBA(uint8_t r, uint8_t g, uint8_t b, uint8_t a):
		Blue(b),
		Green(g),
		Red(r),
		Alpha(a)
	{
	}

	RGBA(uint8_t r, uint8_t g, uint8_t b):
		Blue(b),
		Green(g),
		Red(r),
		Alpha(0xFF)
	{
	}

	template<typename S> // Disallow brace initialization
	RGBA(std::initializer_list<S>) = delete;

	constexpr RGB NoAlpha() const
	{
		return RGB(Red, Green, Blue);
	}

	constexpr pixel Pack() const
	{
		return Red << 16 | Green << 8 | Blue | Alpha << 24;
	}

	constexpr static RGBA Unpack(pixel_rgba px)
	{
		return RGBA(px >> 16, px >> 8, px, px >> 24);
	}
};

// Blend and Add get called in tight loops so it's important that they
// vectorize well.
constexpr RGB RGB::Blend(RGBA other) const
{
	if (other.Alpha == 0xFF)
		return other.NoAlpha();
	// Dividing by 0xFF means the two branches return the same value in the
	// case that other.Alpha == 0xFF, and the division happens via
	// multiplication and bitshift anyway, so it vectorizes better than code
	// that branches in a meaningful way.
	return RGB(
		// the intermediate is guaranteed to fit in 16 bits, and a 16 bit
		// multiplication vectorizes better than a longer one.
		uint16_t(other.Alpha * other.Red   + (0xFF - other.Alpha) * Red  ) / 0xFF,
		uint16_t(other.Alpha * other.Green + (0xFF - other.Alpha) * Green) / 0xFF,
		uint16_t(other.Alpha * other.Blue  + (0xFF - other.Alpha) * Blue ) / 0xFF
	);
}

constexpr RGB RGB::Add(RGBA other) const
{
	return RGB(
		std::min(0xFF, Red + uint16_t(other.Alpha * other.Red) / 0xFF),
		std::min(0xFF, Green + uint16_t(other.Alpha * other.Green) / 0xFF),
		std::min(0xFF, Blue + uint16_t(other.Alpha * other.Blue) / 0xFF)
	);
}

constexpr RGBA RGB::WithAlpha(uint8_t a) const
{
	return RGBA(Red, Green, Blue, a);
}


=== src\graphics\RasterDrawMethods.h ===

#pragma once
#include "common/String.h"
#include "common/Vec2.h"
#include "graphics/Pixel.h"

class VideoBuffer;

// This is a mixin that adds methods to the Derived class, using the "Curiously
// Recurring Template Pattern" trick.
template<typename Derived>
struct RasterDrawMethods
{
	void DrawPixel(Vec2<int>, RGB);
	void BlendPixel(Vec2<int>, RGBA);
	void AddPixel(Vec2<int>, RGBA);
	void AddFirePixel(Vec2<int>, RGB, int fireAlpha);
	void XorPixel(Vec2<int>);

	void DrawLine(Vec2<int>, Vec2<int>, RGB);
	void BlendLine(Vec2<int>, Vec2<int>, RGBA);
	void AddLine(Vec2<int>, Vec2<int>, RGBA);
	void XorLine(Vec2<int>, Vec2<int>);

	void DrawRect(Rect<int>, RGB);
	void BlendRect(Rect<int>, RGBA);

	void XorDottedRect(Rect<int>);

	void DrawFilledRect(Rect<int>, RGB);
	void BlendFilledRect(Rect<int>, RGBA);

	void BlendEllipse(Vec2<int> center, Vec2<int> size, RGBA);

	void BlendFilledEllipse(Vec2<int> center, Vec2<int> size, RGBA);

	void BlendImage(pixel const *, uint8_t alpha, Rect<int>);
	void BlendImage(pixel const *, uint8_t alpha, Rect<int>, size_t rowStride);
	void XorImage(unsigned char const *, Rect<int>);
	void XorImage(unsigned char const *, Rect<int>, size_t rowStride);

	void BlendRGBAImage(pixel_rgba const *, Rect<int>);
	void BlendRGBAImage(pixel_rgba const *, Rect<int>, size_t rowStride);

	// Returns width of character
	int BlendChar(Vec2<int>, String::value_type, RGBA);
	int AddChar(Vec2<int>, String::value_type, RGBA);

	// Returns the offset between the first character and the
	// would-be-next character
	Vec2<int> BlendText(Vec2<int>, String const &, RGBA);

	Vec2<int> BlendTextOutline(Vec2<int>, String const &, RGBA);

	static int CharWidth(String::value_type);
	// Considers the first line to be FONT_H-2 tall with successive lines adding
	// FONT_H each
	static Vec2<int> TextSize(String const &);
	// Return iterator to the end of an initial portion of text that fits in
	// the given width
	static String::const_iterator TextFit(String const &, int width);

	void Clear();
};


=== src\graphics\RasterDrawMethodsImpl.h ===

#include <cmath>
#include <cstring>
#include "common/RasterGeometry.h"
#include "FontReader.h"
#include "VideoBuffer.h"
#include "RasterDrawMethods.h"

#define clipRect() (static_cast<Derived const &>(*this).GetClipRect())

template<typename Derived, typename V>
static inline void drawPixelUnchecked(RasterDrawMethods<Derived> &self, V Derived::*video, Vec2<int> pos, RGB colour)
{
	(static_cast<Derived &>(self).*video)[pos] = colour.Pack();
}

template<typename Derived, typename V>
static inline void blendPixelUnchecked(RasterDrawMethods<Derived> &self, V Derived::*video, Vec2<int> pos, RGBA colour)
{
	pixel &px = (static_cast<Derived &>(self).*video)[pos];
	px = RGB::Unpack(px).Blend(colour).Pack();
}

template<typename Derived, typename V>
static inline void xorPixelUnchecked(RasterDrawMethods<Derived> &self, V Derived::*video, Vec2<int> pos)
{
	pixel &px = (static_cast<Derived &>(self).*video)[pos];
	auto const c = RGB::Unpack(px);
	if (2 * c.Red + 3 * c.Green + c.Blue < 512)
		px = 0xC0C0C0_rgb .Pack();
	else
		px = 0x404040_rgb .Pack();
}

template<typename Derived>
inline void RasterDrawMethods<Derived>::DrawPixel(Vec2<int> pos, RGB colour)
{
	if (clipRect().Contains(pos))
		drawPixelUnchecked(*this, &Derived::video, pos, colour);
}

template<typename Derived>
inline void RasterDrawMethods<Derived>::BlendPixel(Vec2<int> pos, RGBA colour)
{
	if (clipRect().Contains(pos))
		blendPixelUnchecked(*this, &Derived::video, pos, colour);
}

template<typename Derived>
inline void RasterDrawMethods<Derived>::AddPixel(Vec2<int> pos, RGBA colour)
{
	if (clipRect().Contains(pos))
	{
		pixel &px = (static_cast<Derived &>(*this).video)[pos];
		px = RGB::Unpack(px).Add(colour).Pack();
	}
}

template<typename Derived>
inline void RasterDrawMethods<Derived>::AddFirePixel(Vec2<int> pos, RGB colour, int fireAlpha)
{
	if (clipRect().Contains(pos))
	{
		pixel &px = (static_cast<Derived &>(*this).video)[pos];
		px = RGB::Unpack(px).AddFire(colour, fireAlpha).Pack();
	}
}

template<typename Derived>
inline void RasterDrawMethods<Derived>::XorPixel(Vec2<int> pos)
{
	if (clipRect().Contains(pos))
		xorPixelUnchecked(*this, &Derived::video, pos);
}

template<typename Derived>
void RasterDrawMethods<Derived>::DrawLine(Vec2<int> pos1, Vec2<int> pos2, RGB colour)
{
	RasterizeLine<false>(pos1, pos2, [this, colour](Vec2<int> pos) {
		DrawPixel(pos, colour);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendLine(Vec2<int> pos1, Vec2<int> pos2, RGBA colour)
{
	RasterizeLine<false>(pos1, pos2, [this, colour](Vec2<int> pos) {
		BlendPixel(pos, colour);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::AddLine(Vec2<int> pos1, Vec2<int> pos2, RGBA colour)
{
	RasterizeLine<false>(pos1, pos2, [this, colour](Vec2<int> pos) {
		AddPixel(pos, colour);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::XorLine(Vec2<int> pos1, Vec2<int> pos2)
{
	RasterizeLine<false>(pos1, pos2, [this](Vec2<int> pos) {
		XorPixel(pos);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::DrawRect(Rect<int> rect, RGB colour)
{
	RasterizeRect(rect, [this, colour](Vec2<int> pos) {
		DrawPixel(pos, colour);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendRect(Rect<int> rect, RGBA colour)
{
	RasterizeRect(rect, [this, colour](Vec2<int> pos) {
		BlendPixel(pos, colour);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::XorDottedRect(Rect<int> rect)
{
	RasterizeDottedRect(rect, [this](Vec2<int> pos) {
		XorPixel(pos);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::DrawFilledRect(Rect<int> rect, RGB colour)
{
	rect &= clipRect();
	pixel packed = colour.Pack();
	auto &video = static_cast<Derived &>(*this).video;
	if (rect)
		for (int y = rect.pos.Y; y < rect.pos.Y + rect.size.Y; y++)
			std::fill_n(video.RowIterator(Vec2(rect.pos.X, y)), rect.size.X, packed);
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendFilledRect(Rect<int> rect, RGBA colour)
{
	for (auto pos : rect & clipRect())
		blendPixelUnchecked(*this, &Derived::video, pos, colour);
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendEllipse(Vec2<int> center, Vec2<int> size, RGBA colour)
{
	RasterizeEllipsePoints(Vec2(float(size.X * size.X), float(size.Y * size.Y)), [this, center, colour](Vec2<int> delta) {
		BlendPixel(center + delta, colour);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendFilledEllipse(Vec2<int> center, Vec2<int> size, RGBA colour)
{
	RasterizeEllipseRows(Vec2(float(size.X * size.X), float(size.Y * size.Y)), [this, center, colour](int xLim, int dy) {
		for (auto pos : clipRect() & RectBetween(center + Vec2(-xLim, dy), center + Vec2(xLim, dy)))
			blendPixelUnchecked(*this, &Derived::video, pos, colour);
	});
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendImage(pixel const *data, uint8_t alpha, Rect<int> rect)
{
	BlendImage(data, alpha, rect, rect.size.X);
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendImage(pixel const *data, uint8_t alpha, Rect<int> rect, size_t rowStride)
{
	auto origin = rect.pos;
	rect &= clipRect();
	if (alpha == 0xFF)
	{
		auto &video = static_cast<Derived &>(*this).video;
		for (int y = rect.pos.Y; y < rect.pos.Y + rect.size.Y; y++)
			std::copy_n(
				data + (rect.pos.X - origin.X) + (y - origin.Y) * rowStride,
				rect.size.X,
				video.RowIterator(Vec2(rect.pos.X, y))
			);
	}
	else
	{
		for (auto pos : rect)
		{
			pixel const px = data[(pos.X - origin.X) + (pos.Y - origin.Y) * rowStride];
			blendPixelUnchecked(*this, &Derived::video, pos, RGB::Unpack(px).WithAlpha(alpha));
		}
	}
}

template<typename Derived>
void RasterDrawMethods<Derived>::XorImage(unsigned char const *data, Rect<int> rect)
{
	XorImage(data, rect, rect.size.X);
}

template<typename Derived>
void RasterDrawMethods<Derived>::XorImage(unsigned char const *data, Rect<int> rect, size_t rowStride)
{
	auto origin = rect.pos;
	rect &= clipRect();
	for (auto pos : rect)
		if (data[(pos.X - origin.X) + (pos.Y - origin.Y) * rowStride])
			xorPixelUnchecked(*this, &Derived::video, pos);
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendRGBAImage(pixel_rgba const *data, Rect<int> rect)
{
	BlendRGBAImage(data, rect, rect.size.X);
}

template<typename Derived>
void RasterDrawMethods<Derived>::BlendRGBAImage(pixel_rgba const *data, Rect<int> rect, size_t rowStride)
{
	auto origin = rect.pos;
	rect &= clipRect();
	for (auto pos : rect)
	{
		pixel const px = data[(pos.X - origin.X) + (pos.Y - origin.Y) * rowStride];
		blendPixelUnchecked(*this, &Derived::video, pos, RGBA::Unpack(px));
	}
}

template<typename Derived>
int RasterDrawMethods<Derived>::BlendChar(Vec2<int> pos, String::value_type ch, RGBA colour)
{
	FontReader reader(ch);
	auto const rect = RectSized(Vec2(0, -2), Vec2(reader.GetWidth(), FONT_H));
	for (auto off : rect.template Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
		BlendPixel(pos + off, colour.NoAlpha().WithAlpha(reader.NextPixel() * colour.Alpha / 3));
	return reader.GetWidth();
}

template<typename Derived>
int RasterDrawMethods<Derived>::AddChar(Vec2<int> pos, String::value_type ch, RGBA colour)
{
	FontReader reader(ch);
	RGB const c = colour.NoAlpha();
	auto const rect = RectSized(Vec2(0, -2), Vec2(reader.GetWidth(), FONT_H));
	for (auto off : rect.template Range<TOP_TO_BOTTOM, LEFT_TO_RIGHT>())
		AddPixel(pos + off, c.WithAlpha(reader.NextPixel() * colour.Alpha / 3));
	return reader.GetWidth();
}

template<typename Derived>
Vec2<int> RasterDrawMethods<Derived>::BlendText(Vec2<int> orig_pos, String const &str, RGBA orig_colour)
{
	bool underline = false;
	bool invert = false;
	RGB colour = orig_colour.NoAlpha();
	uint8_t alpha = orig_colour.Alpha;
	Vec2<int> pos = orig_pos;
	for (size_t i = 0; i < str.length(); i++)
	{
		if (str[i] == '\n')
		{
			pos.X = orig_pos.X;
			pos.Y += FONT_H;
		}
		else if (str[i] == '\x0F')
		{
			if (str.length() <= i + 3)
				break;
			colour.Red = str[i + 1];
			colour.Green = str[i + 2];
			colour.Blue = str[i + 3];
			i += 3;
		}
		else if (str[i] == '\x0E')
		{
			colour = orig_colour.NoAlpha();
		}
		else if (str[i] == '\x01')
		{
			invert = !invert;
			colour = colour.Inverse();
		}
		else if (str[i] == '\b')
		{
			if (str.length() <= i + 1)
				break;
			bool colourCode = true;
			switch (str[i + 1])
			{
			case 'U': underline = !underline; colourCode = false; break;
			case 'w': colour = 0xFFFFFF_rgb; break;
			case 'g': colour = 0xC0C0C0_rgb; break;
			case 'o': colour = 0xFFD820_rgb; break;
			case 'r': colour = 0xFF0000_rgb; break;
			case 'l': colour = 0xFF4B4B_rgb; break;
			case 'b': colour = 0x0000FF_rgb; break;
			case 't': colour = 0x20AAFF_rgb; break;
			case 'u': colour = 0x9353D3_rgb; break;
			}
			if (colourCode && invert)
				colour = colour.Inverse();
			i++;
		}
		else
		{
			int dx = BlendChar(pos, str[i], colour.WithAlpha(alpha));
			if (underline)
				for (int i = 0; i < dx; i++)
					BlendPixel(pos + Vec2(i, FONT_H), colour.WithAlpha(alpha));
			pos.X += dx;
		}
	}
	return pos - orig_pos;
}

template<typename Derived>
Vec2<int> RasterDrawMethods<Derived>::BlendTextOutline(Vec2<int> pos, String const &str, RGBA colour)
{
	BlendText(pos + Vec2(-1, -1), str, 0x000000_rgb .WithAlpha(0x78));
	BlendText(pos + Vec2(-1, +1), str, 0x000000_rgb .WithAlpha(0x78));
	BlendText(pos + Vec2(+1, -1), str, 0x000000_rgb .WithAlpha(0x78));
	BlendText(pos + Vec2(+1, +1), str, 0x000000_rgb .WithAlpha(0x78));

	return BlendText(pos, str, colour);
}

template<typename Derived>
void RasterDrawMethods<Derived>::Clear()
{
	auto &video = static_cast<Derived &>(*this).video;
	std::fill_n(video.data(), video.Size().X * video.Size().Y, 0x000000_rgb .Pack());
}

template<typename Derived>
int RasterDrawMethods<Derived>::CharWidth(String::value_type ch)
{
	return FontReader(ch).GetWidth();
}

template<typename Derived>
Vec2<int> RasterDrawMethods<Derived>::TextSize(String const &str)
{
	Vec2<int> size = Vec2(0, FONT_H - 2);
	int curX = 0; // characters have 1px of spacing between them
	for (size_t i = 0; i < str.length(); i++)
	{
		if (str[i] == '\n')
		{
			size.X = std::max(curX, size.X);
			size.Y += FONT_H;
			curX = 0;
		}
		else if (str[i] == '\x0F')
		{
			if (str.length() <= i + 3)
				break;
			i += 3;
		}
		else if (str[i] == '\x0E')
			continue;
		else if (str[i] == '\x01')
			continue;
		else if (str[i] == '\b')
		{
			if (str.length() <= i + 1)
				break;
			i++;
		}
		else
			curX += CharWidth(str[i]);
	}
	size.X = std::max(curX, size.X);
	return size;
}

template<typename Derived>
String::const_iterator RasterDrawMethods<Derived>::TextFit(String const &str, int width)
{
	int curX = 0;
	for (size_t i = 0; i < str.length(); i++)
	{
		if (str[i] == '\n')
			curX = 0;
		else if (str[i] == '\x0F')
		{
			if (str.length() <= i + 3)
				break;
			i += 3;
		}
		else if (str[i] == '\x0E')
			continue;
		else if (str[i] == '\x01')
			continue;
		else if (str[i] == '\b')
		{
			if (str.length() <= i + 1)
				break;
			i++;
		}
		else
		{
			int dx = CharWidth(str[i]);
			if (curX + dx / 2 >= width)
				return str.begin() + i;
			curX += dx;
		}
	}
	return str.end();
}

#undef clipRect


=== src\graphics\RasterGraphics.cpp ===

#include <cstdlib>
#include <cstring>
#include "Graphics.h"
#include "SimulationConfig.h"
#include "RasterDrawMethodsImpl.h"

void Graphics::Finalise()
{

}

template struct RasterDrawMethods<Graphics>;


=== src\graphics\Renderer.cpp ===

#include "Renderer.h"
#include "Gradient.h"
#include "Misc.h"
#include "VideoBuffer.h"
#include "RasterDrawMethodsImpl.h"
#include "common/tpt-rand.h"
#include "common/tpt-compat.h"
#include "gui/game/RenderPreset.h"
#include "simulation/Simulation.h"
#include "simulation/ElementGraphics.h"
#include "simulation/ElementClasses.h"
#include "simulation/Air.h"
#include "simulation/gravity/Gravity.h"
#include "simulation/orbitalparts.h"
#include <cmath>
#include <algorithm>

void Renderer::RenderBackground()
{
	draw_air();
}

void Renderer::RenderSimulation()
{
	draw_grav();
	DrawWalls();
	render_parts();

	if (displayMode & DISPLAY_PERS)
	{
		std::transform(video.RowIterator({ 0, 0 }), video.RowIterator({ 0, YRES }), persistentVideo.begin(), [](pixel p) {
			return RGB::Unpack(p).Decay().Pack();
		});
	}

	render_fire();
	draw_other();
	draw_grav_zones();
	DrawSigns();

	if (displayMode & DISPLAY_WARP)
	{
		warpVideo = video;
		std::fill_n(video.data(), WINDOWW * YRES, 0);
		render_gravlensing(warpVideo);
	}
}

void Renderer::ApproximateAccumulation()
{
	for (int i = 0; i < 15; ++i)
	{
		render_parts();
		render_fire();
		Clear();
	}
}

void Renderer::render_gravlensing(const RendererFrame &source)
{
	for (auto p : RES.OriginRect())
	{
		auto cp = p / CELL;
		auto rp = Vec2{ int(p.X - sim->gravOut.forceX[cp] * 0.75f  + 0.5f), int(p.Y - sim->gravOut.forceY[cp] * 0.75f  + 0.5f) };
		auto gp = Vec2{ int(p.X - sim->gravOut.forceX[cp] * 0.875f + 0.5f), int(p.Y - sim->gravOut.forceY[cp] * 0.875f + 0.5f) };
		auto bp = Vec2{ int(p.X - sim->gravOut.forceX[cp]          + 0.5f), int(p.Y - sim->gravOut.forceY[cp]          + 0.5f) };
		if (RES.OriginRect().Contains(rp) &&
		    RES.OriginRect().Contains(gp) &&
		    RES.OriginRect().Contains(bp))
		{
			auto v = RGB::Unpack(video[p]);
			video[p] = RGB(
				std::min(0xFF, RGB::Unpack(source[rp]).Red   + v.Red  ),
				std::min(0xFF, RGB::Unpack(source[gp]).Green + v.Green),
				std::min(0xFF, RGB::Unpack(source[bp]).Blue  + v.Blue )
			).Pack();
		}
	}
}

std::unique_ptr<VideoBuffer> Renderer::WallIcon(int wallID, Vec2<int> size)
{
	auto &sd = SimulationData::CRef();
	auto &wtypes = sd.wtypes;
	if (wallID < 0 || wallID >= int(wtypes.size()))
		return nullptr;
	wall_type const &wtype = wtypes[wallID];

	RGB primary = wtype.colour;
	RGB secondary = wtype.eglow;

	auto texture = std::make_unique<VideoBuffer>(size);
	switch (wtype.drawstyle)
	{
	case 1:
		// #.#.
		// ....
		// .#.#
		// ....
		for (auto pos : size.OriginRect())
			if (~pos.Y & ~(pos.X ^ (pos.Y >> 1)) & 1)
				texture->DrawPixel(pos, primary);
		break;
	case 2:
		// #.#.
		// ....
		// #.#.
		// ....
		for (auto pos : size.OriginRect())
			if (~pos.Y & ~pos.X & 1)
				texture->DrawPixel(pos, primary);
		break;
	case 3:
		// ####
		// ####
		// ####
		// ####
		for (auto pos : size.OriginRect())
			texture->DrawPixel(pos, primary);
		break;
	case 4:
		// #+.#
		// .#+.
		// +.#+
		// #+.#
		for (auto pos : size.OriginRect())
			if (((pos.X - pos.Y) % CELL + CELL) % CELL == 0)
				texture->DrawPixel(pos, primary);
			else if (((pos.X - pos.Y) % CELL + CELL) % CELL == 1)
				texture->DrawPixel(pos, secondary);
			else
				texture->DrawPixel(pos, 0x202020_rgb);
		break;
	}

	switch (wallID)
	{
	case WL_EWALL:
		// #####  .......
		// #.#.#.  ...#.#
		// #######  .....
		// #.#.#.#.  .#.#
		for (auto pos : size.OriginRect())
			if ((pos.X < size.X / 4 + pos.Y) != (pos.X & pos.Y & 1))
				texture->DrawPixel(pos, primary);
		break;
	case WL_WALLELEC:
		// #+#+
		// ++++
		// #+#+
		// ++++
		for (auto pos : size.OriginRect())
			if (~pos.Y & ~pos.X & 1)
				texture->DrawPixel(pos, primary);
			else
				texture->DrawPixel(pos, 0x808080_rgb);
		break;
	case WL_EHOLE:
	case WL_STASIS:
		// .....  #######
		// .#.#.#  ###.#.
		// .......  #####
		// .#.#.#.#  #.#.
		for (auto pos : size.OriginRect())
			if ((pos.X < size.X / 4 + pos.Y) == (pos.X & pos.Y & 1))
				texture->DrawPixel(pos, primary);
		break;
	case WL_ERASE:
		// #.#.#.  ######
		// ......  ######
		// .#.#.#  ######
		// ......  ######
		for (auto pos : size.OriginRect())
			if ((pos.X < size.X / 2) ? ~pos.Y & ~(pos.X ^ (pos.Y >> 1)) & 1 : true)
				texture->DrawPixel(pos, primary);
		texture->BlendChar(size / 2 - Vec2(4, 2), 0xE06C, 0xFF0000_rgb .WithAlpha(0xFF));
		break;
	case WL_ERASEALL:
		{
			int r = 100, g = 150, b = 50;
			int rd = 1, gd = -1, bd = -1;
			for (int x = 0; x < size.X; x++)
			{
				r += 15 * rd;
				g += 15 * gd;
				b += 15 * bd;
				if (r > 200) rd = -1;
				if (g > 200) gd = -1;
				if (b > 200) bd = -1;
				if (r < 15) rd = 1;
				if (g < 15) gd = 1;
				if (b < 15) bd = 1;
				int rc = std::min(150, std::max(0, r));
				int gc = std::min(200, std::max(0, g));
				int bc = std::min(200, std::max(0, b));
				texture->DrawLine(Vec2(x, 0), Vec2(x, size.Y - 1), RGB(rc, gc, bc));
			}
			texture->BlendChar(size / 2 - Vec2(10, 2), 0xE06C, 0xFF0000_rgb .WithAlpha(0xFF));
			texture->BlendChar(size / 2 - Vec2(-1, 2), 0xE06C, 0xFF0000_rgb .WithAlpha(0xFF));
		}
		break;
	case WL_STREAM:
		texture->DrawRect(size.OriginRect(), 0xA0A0A0_rgb);
		texture->AddChar(Vec2(4, 2), 0xE00D, 0xFFFFFF_rgb .WithAlpha(0xFF));
		texture->AddChar(Vec2(8, 2), 0xE06D, 0xFFFFFF_rgb .WithAlpha(0xFF));
		break;
	}
	return texture;
}

void Renderer::DrawSigns()
{
	int x, y, w, h;
	std::vector<sign> signs = sim->signs;
	for (auto &currentSign : signs)
	{
		if (currentSign.text.length())
		{
			String text = currentSign.getDisplayText(sim, x, y, w, h);
			DrawFilledRect(RectSized(Vec2{ x + 1, y + 1 }, Vec2{ w, h - 1 }), 0x000000_rgb);
			DrawRect(RectSized(Vec2{ x, y }, Vec2{ w+1, h }), 0xC0C0C0_rgb);
			BlendText({ x+3, y+4 }, text, 0xFFFFFF_rgb .WithAlpha(255));

			if (currentSign.ju != sign::None)
			{
				int x = currentSign.x;
				int y = currentSign.y;
				int dx = 1 - currentSign.ju;
				int dy = (currentSign.y > 18) ? -1 : 1;
				for (int j = 0; j < 4; j++)
				{
					DrawPixel({ x, y }, 0xC0C0C0_rgb);
					x += dx;
					y += dy;
				}
			}
		}
	}
}

void Renderer::render_parts()
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	auto &graphicscache = sd.graphicscache;
	GraphicsFuncContext gfctx;
	gfctx.ren = this;
	gfctx.sim = sim;
	gfctx.rng.seed(rng());
	gfctx.pipeSubcallCpart = nullptr;
	gfctx.pipeSubcallTpart = nullptr;
	int deca, decr, decg, decb, cola, colr, colg, colb, firea, firer, fireg, fireb, pixel_mode, q, i, t, nx, ny, x, y;
	int orbd[4] = {0, 0, 0, 0}, orbl[4] = {0, 0, 0, 0};
	int drawing_budget = 1000000; //Serves as an upper bound for costly effects such as SPARK, FLARE and LFLARE

	auto &parts = sim->parts;
	if (gridSize)//draws the grid
	{
		for (ny=0; ny<YRES; ny++)
			for (nx=0; nx<XRES; nx++)
			{
				if (ny%(4*gridSize) == 0)
					BlendPixel({ nx, ny }, 0x646464_rgb .WithAlpha(80));
				if (nx%(4*gridSize) == 0 && ny%(4*gridSize) != 0)
					BlendPixel({ nx, ny }, 0x646464_rgb .WithAlpha(80));
			}
	}
	stats.foundParticles = 0;
	for(i = 0; i<=sim->parts.lastActiveIndex; i++) {
		if (sim->parts[i].type && sim->parts[i].type >= 0 && sim->parts[i].type < PT_NUM) {
			t = sim->parts[i].type;

			nx = (int)(sim->parts[i].x+0.5f);
			ny = (int)(sim->parts[i].y+0.5f);

			if(nx >= XRES || nx < 0 || ny >= YRES || ny < 0)
				continue;
			if(TYP(sim->photons[ny][nx]) && !(elements[t].Properties & TYPE_ENERGY) && t!=PT_STKM && t!=PT_STKM2 && t!=PT_FIGH)
				continue;

			//Defaults
			pixel_mode = 0 | PMODE_FLAT;
			cola = 255;
			RGB colour = elements[t].Colour;
			colr = colour.Red;
			colg = colour.Green;
			colb = colour.Blue;
			firer = fireg = fireb = firea = 0;

			deca = (sim->parts[i].dcolour>>24)&0xFF;
			decr = (sim->parts[i].dcolour>>16)&0xFF;
			decg = (sim->parts[i].dcolour>>8)&0xFF;
			decb = (sim->parts[i].dcolour)&0xFF;

			if (decorationLevel == decorationAntiClickbait)
			{
				if(deca < 250 || decr > 5 || decg > 5 || decb > 5)
					deca = 0;
				else
				{
					deca = 255;
					decr = decg = decb = 0;
				}
			}

			{
				if (graphicscache[t].isready)
				{
					pixel_mode = graphicscache[t].pixel_mode;
					cola = graphicscache[t].cola;
					colr = graphicscache[t].colr;
					colg = graphicscache[t].colg;
					colb = graphicscache[t].colb;
					firea = graphicscache[t].firea;
					firer = graphicscache[t].firer;
					fireg = graphicscache[t].fireg;
					fireb = graphicscache[t].fireb;
				}
				else if(!(colorMode & COLOUR_BASC))
				{
					auto *graphics = elements[t].Graphics;
					auto makeReady = !graphics || graphics(gfctx, &(sim->parts[i]), nx, ny, &pixel_mode, &cola, &colr, &colg, &colb, &firea, &firer, &fireg, &fireb); //That's a lot of args, a struct might be better
					if (makeReady && sim->useLuaCallbacks)
					{
						// useLuaCallbacks is true so we locked sd.elementGraphicsMx exclusively
						auto &wgraphicscache = SimulationData::Ref().graphicscache;
						wgraphicscache[t].isready = 1;
						wgraphicscache[t].pixel_mode = pixel_mode;
						wgraphicscache[t].cola = cola;
						wgraphicscache[t].colr = colr;
						wgraphicscache[t].colg = colg;
						wgraphicscache[t].colb = colb;
						wgraphicscache[t].firea = firea;
						wgraphicscache[t].firer = firer;
						wgraphicscache[t].fireg = fireg;
						wgraphicscache[t].fireb = fireb;
					}
				}
				if((elements[t].Properties & PROP_HOT_GLOW) && sim->parts[i].temp>(elements[t].HighTemperature-800.0f))
				{
					auto gradv = 3.1415/(2*elements[t].HighTemperature-(elements[t].HighTemperature-800.0f));
					auto caddress = int((sim->parts[i].temp>elements[t].HighTemperature)?elements[t].HighTemperature-(elements[t].HighTemperature-800.0f):sim->parts[i].temp-(elements[t].HighTemperature-800.0f));
					colr += int(sin(gradv*caddress) * 226);
					colg += int(sin(gradv*caddress*4.55 +TPT_PI_DBL) * 34);
					colb += int(sin(gradv*caddress*2.22 +TPT_PI_DBL) * 64);
				}

				if((pixel_mode & FIRE_ADD) && !(renderMode & FIRE_ADD))
					pixel_mode |= PMODE_GLOW;
				if((pixel_mode & FIRE_BLEND) && !(renderMode & FIRE_BLEND))
					pixel_mode |= PMODE_BLUR;
				if((pixel_mode & PMODE_BLUR) && !(renderMode & PMODE_BLUR))
					pixel_mode |= PMODE_FLAT;
				if((pixel_mode & PMODE_GLOW) && !(renderMode & PMODE_GLOW))
					pixel_mode |= PMODE_BLEND;
				if (renderMode & PMODE_BLOB)
					pixel_mode |= PMODE_BLOB;

				pixel_mode &= renderMode;

				//Alter colour based on display mode
				if(colorMode & COLOUR_HEAT)
				{
					firea = 255;
					RGB color = heatTableAt(int((sim->parts[i].temp - stats.hdispLimitMin) / (stats.hdispLimitMax - stats.hdispLimitMin) * 1024));
					firer = colr = color.Red;
					fireg = colg = color.Green;
					fireb = colb = color.Blue;
					cola = 255;
					if(pixel_mode & (FIREMODE | PMODE_GLOW))
						pixel_mode = (pixel_mode & ~(FIREMODE|PMODE_GLOW)) | PMODE_BLUR;
					else if ((pixel_mode & (PMODE_BLEND | PMODE_ADD)) == (PMODE_BLEND | PMODE_ADD))
						pixel_mode = (pixel_mode & ~(PMODE_BLEND|PMODE_ADD)) | PMODE_FLAT;
					else if (!pixel_mode)
						pixel_mode |= PMODE_FLAT;
				}
				else if(colorMode & COLOUR_LIFE)
				{
					auto gradv = 0.4f;
					if (!(sim->parts[i].life<5))
						q = int(sqrt((float)sim->parts[i].life));
					else
						q = sim->parts[i].life;
					colr = colg = colb = int(sin(gradv*q) * 100 + 128);
					cola = 255;
					if(pixel_mode & (FIREMODE | PMODE_GLOW))
						pixel_mode = (pixel_mode & ~(FIREMODE|PMODE_GLOW)) | PMODE_BLUR;
					else if ((pixel_mode & (PMODE_BLEND | PMODE_ADD)) == (PMODE_BLEND | PMODE_ADD))
						pixel_mode = (pixel_mode & ~(PMODE_BLEND|PMODE_ADD)) | PMODE_FLAT;
					else if (!pixel_mode)
						pixel_mode |= PMODE_FLAT;
				}
				else if(colorMode & COLOUR_BASC)
				{
					colr = colour.Red;
					colg = colour.Green;
					colb = colour.Blue;
					pixel_mode = PMODE_FLAT;
				}

				//Apply decoration colour
				if(!(colorMode & ~COLOUR_GRAD) && decorationLevel != decorationDisabled && deca)
				{
					deca++;
					if(!(pixel_mode & NO_DECO))
					{
						colr = (deca*decr + (256-deca)*colr) >> 8;
						colg = (deca*decg + (256-deca)*colg) >> 8;
						colb = (deca*decb + (256-deca)*colb) >> 8;
					}

					if(pixel_mode & DECO_FIRE)
					{
						firer = (deca*decr + (256-deca)*firer) >> 8;
						fireg = (deca*decg + (256-deca)*fireg) >> 8;
						fireb = (deca*decb + (256-deca)*fireb) >> 8;
					}
				}

				if (colorMode & COLOUR_GRAD)
				{
					auto frequency = 0.05f;
					auto q = int(sim->parts[i].temp-40);
					colr = int(sin(frequency*q) * 16 + colr);
					colg = int(sin(frequency*q) * 16 + colg);
					colb = int(sin(frequency*q) * 16 + colb);
					if(pixel_mode & (FIREMODE | PMODE_GLOW)) pixel_mode = (pixel_mode & ~(FIREMODE|PMODE_GLOW)) | PMODE_BLUR;
				}

				//All colours are now set, check ranges
				if(colr>255) colr = 255;
				else if(colr<0) colr = 0;
				if(colg>255) colg = 255;
				else if(colg<0) colg = 0;
				if(colb>255) colb = 255;
				else if(colb<0) colb = 0;
				if(cola>255) cola = 255;
				else if(cola<0) cola = 0;

				if(firer>255) firer = 255;
				else if(firer<0) firer = 0;
				if(fireg>255) fireg = 255;
				else if(fireg<0) fireg = 0;
				if(fireb>255) fireb = 255;
				else if(fireb<0) fireb = 0;
				if(firea>255) firea = 255;
				else if(firea<0) firea = 0;

				auto matchesFindingElement = false;
				if (findingElement)
				{
					if (findingElement->property.Offset == offsetof(Particle, type))
					{
						auto ft = std::get<int>(findingElement->value);
						matchesFindingElement = parts[i].type == TYP(ft);
						if (ID(ft))
						{
							matchesFindingElement &= parts[i].ctype == ID(ft);
						}
					}
					else
					{
						switch (findingElement->property.Type)
						{
						case StructProperty::Float:
							matchesFindingElement = *((float*)(((char*)&sim->parts[i])+findingElement->property.Offset)) == std::get<float>(findingElement->value);
							break;

						case StructProperty::ParticleType:
						case StructProperty::Integer:
							matchesFindingElement = *((int*)(((char*)&sim->parts[i])+findingElement->property.Offset)) == std::get<int>(findingElement->value);
							break;

						case StructProperty::UInteger:
							matchesFindingElement = *((unsigned int*)(((char*)&sim->parts[i])+findingElement->property.Offset)) == std::get<unsigned int>(findingElement->value);
							break;

						default:
							break;
						}
					}

					if (matchesFindingElement)
					{
						colr = firer = 255;
						colg = fireg = colb = fireb = 0;
						stats.foundParticles++;
					}
					else
					{
						colr /= 10;
						colg /= 10;
						colb /= 10;
						firer /= 5;
						fireg /= 5;
						fireb /= 5;
					}
				}

				//Pixel rendering
				if (pixel_mode & EFFECT_LINES)
				{
					if (t==PT_SOAP)
					{
						if ((parts[i].ctype&3) == 3 && parts[i].tmp >= 0 && parts[i].tmp < NPART)
							BlendLine({ nx, ny }, { int(parts[parts[i].tmp].x+0.5f), int(parts[parts[i].tmp].y+0.5f) }, RGBA(colr, colg, colb, cola));
					}
				}
				if(pixel_mode & PSPEC_STICKMAN)
				{
					int legr, legg, legb;
					const playerst *cplayer;
					if(t==PT_STKM)
						cplayer = &sim->player;
					else if(t==PT_STKM2)
						cplayer = &sim->player2;
					else if (t==PT_FIGH && sim->parts[i].tmp >= 0 && sim->parts[i].tmp < MAX_FIGHTERS)
						cplayer = &sim->fighters[(unsigned char)sim->parts[i].tmp];
					else
						continue;

					if (mousePos.X>(nx-3) && mousePos.X<(nx+3) && mousePos.Y<(ny+3) && mousePos.Y>(ny-3)) //If mouse is in the head
					{
						String hp = String::Build(Format::Width(sim->parts[i].life, 3));
						BlendText(mousePos + Vec2{ -8-2*(sim->parts[i].life<100)-2*(sim->parts[i].life<10), -12 }, hp, 0xFFFFFF_rgb .WithAlpha(255));
					}

					if (matchesFindingElement)
					{
						colr = 255;
						colg = colb = 0;
					}
					else if (colorMode != COLOUR_HEAT)
					{
						if (cplayer->fan)
						{
							auto fanColor = 0x8080FF_rgb;
							colr = fanColor.Red;
							colg = fanColor.Green;
							colb = fanColor.Blue;
						}
						else if (cplayer->elem < PT_NUM && cplayer->elem > 0)
						{
							RGB elemColour = elements[cplayer->elem].Colour;
							colr = elemColour.Red;
							colg = elemColour.Green;
							colb = elemColour.Blue;
						}
						else
						{
							colr = 0x80;
							colg = 0x80;
							colb = 0xFF;
						}
					}

					if (matchesFindingElement)
					{
						legr = 255;
						legg = legb = 0;
					}
					else if (colorMode==COLOUR_HEAT)
					{
						legr = colr;
						legg = colg;
						legb = colb;
					}
					else if (t==PT_STKM2)
					{
						legr = 100;
						legg = 100;
						legb = 255;
					}
					else
					{
						legr = 255;
						legg = 255;
						legb = 255;
					}

					if (findingElement && !matchesFindingElement)
					{
						colr /= 10;
						colg /= 10;
						colb /= 10;
						legr /= 10;
						legg /= 10;
						legb /= 10;
					}

					//head
					if(t==PT_FIGH)
					{
						DrawLine({ nx, ny+2 }, { nx+2, ny }, RGB(colr, colg, colb));
						DrawLine({ nx+2, ny }, { nx, ny-2 }, RGB(colr, colg, colb));
						DrawLine({ nx, ny-2 }, { nx-2, ny }, RGB(colr, colg, colb));
						DrawLine({ nx-2, ny }, { nx, ny+2 }, RGB(colr, colg, colb));
					}
					else
					{
						DrawLine({ nx-2, ny+2 }, { nx+2, ny+2 }, RGB(colr, colg, colb));
						DrawLine({ nx-2, ny-2 }, { nx+2, ny-2 }, RGB(colr, colg, colb));
						DrawLine({ nx-2, ny-2 }, { nx-2, ny+2 }, RGB(colr, colg, colb));
						DrawLine({ nx+2, ny-2 }, { nx+2, ny+2 }, RGB(colr, colg, colb));
					}
					//legs
					DrawLine({                    nx,                  ny+3 }, { int(cplayer->legs[ 0]), int(cplayer->legs[ 1]) }, RGB(legr, legg, legb));
					DrawLine({ int(cplayer->legs[0]), int(cplayer->legs[1]) }, { int(cplayer->legs[ 4]), int(cplayer->legs[ 5]) }, RGB(legr, legg, legb));
					DrawLine({                    nx,                  ny+3 }, { int(cplayer->legs[ 8]), int(cplayer->legs[ 9]) }, RGB(legr, legg, legb));
					DrawLine({ int(cplayer->legs[8]), int(cplayer->legs[9]) }, { int(cplayer->legs[12]), int(cplayer->legs[13]) }, RGB(legr, legg, legb));
					if (cplayer->rocketBoots)
					{
						for (int leg=0; leg<2; leg++)
						{
							int nx = int(cplayer->legs[leg*8+4]), ny = int(cplayer->legs[leg*8+5]);
							int colr = 255, colg = 0, colb = 255;
							if (((int)(cplayer->comm)&0x04) == 0x04 || (((int)(cplayer->comm)&0x01) == 0x01 && leg==0) || (((int)(cplayer->comm)&0x02) == 0x02 && leg==1))
								DrawPixel({ nx, ny }, 0x00FF00_rgb);
							else
								DrawPixel({ nx, ny }, 0xFF0000_rgb);
							BlendPixel({ nx+1, ny }, RGBA(colr, colg, colb, 223));
							BlendPixel({ nx-1, ny }, RGBA(colr, colg, colb, 223));
							BlendPixel({ nx, ny+1 }, RGBA(colr, colg, colb, 223));
							BlendPixel({ nx, ny-1 }, RGBA(colr, colg, colb, 223));

							BlendPixel({ nx+1, ny-1 }, RGBA(colr, colg, colb, 112));
							BlendPixel({ nx-1, ny-1 }, RGBA(colr, colg, colb, 112));
							BlendPixel({ nx+1, ny+1 }, RGBA(colr, colg, colb, 112));
							BlendPixel({ nx-1, ny+1 }, RGBA(colr, colg, colb, 112));
						}
					}
				}
				if(pixel_mode & PMODE_FLAT)
				{
					video[{ nx, ny }] = RGB(colr, colg, colb).Pack();
				}
				if(pixel_mode & PMODE_BLEND)
				{
					BlendPixel({ nx, ny }, RGBA(colr, colg, colb, cola));
				}
				if(pixel_mode & PMODE_ADD)
				{
					AddPixel({ nx, ny }, RGBA(colr, colg, colb, cola));
				}
				if(pixel_mode & PMODE_BLOB)
				{
					video[{ nx, ny }] = RGB(colr, colg, colb).Pack();

					BlendPixel({ nx+1, ny }, RGBA(colr, colg, colb, 223));
					BlendPixel({ nx-1, ny }, RGBA(colr, colg, colb, 223));
					BlendPixel({ nx, ny+1 }, RGBA(colr, colg, colb, 223));
					BlendPixel({ nx, ny-1 }, RGBA(colr, colg, colb, 223));

					BlendPixel({ nx+1, ny-1 }, RGBA(colr, colg, colb, 112));
					BlendPixel({ nx-1, ny-1 }, RGBA(colr, colg, colb, 112));
					BlendPixel({ nx+1, ny+1 }, RGBA(colr, colg, colb, 112));
					BlendPixel({ nx-1, ny+1 }, RGBA(colr, colg, colb, 112));
				}
				if(pixel_mode & PMODE_GLOW)
				{
					int cola1 = (5*cola)/255;
					AddPixel({ nx, ny }, RGBA(colr, colg, colb, (192*cola)/255));
					AddPixel({ nx+1, ny }, RGBA(colr, colg, colb, (96*cola)/255));
					AddPixel({ nx-1, ny }, RGBA(colr, colg, colb, (96*cola)/255));
					AddPixel({ nx, ny+1 }, RGBA(colr, colg, colb, (96*cola)/255));
					AddPixel({ nx, ny-1 }, RGBA(colr, colg, colb, (96*cola)/255));

					for (x = 1; x < 6; x++) {
						AddPixel({ nx, ny-x }, RGBA(colr, colg, colb, cola1));
						AddPixel({ nx, ny+x }, RGBA(colr, colg, colb, cola1));
						AddPixel({ nx-x, ny }, RGBA(colr, colg, colb, cola1));
						AddPixel({ nx+x, ny }, RGBA(colr, colg, colb, cola1));
						for (y = 1; y < 6; y++) {
							if(x + y > 7)
								continue;
							AddPixel({ nx+x, ny-y }, RGBA(colr, colg, colb, cola1));
							AddPixel({ nx-x, ny+y }, RGBA(colr, colg, colb, cola1));
							AddPixel({ nx+x, ny+y }, RGBA(colr, colg, colb, cola1));
							AddPixel({ nx-x, ny-y }, RGBA(colr, colg, colb, cola1));
						}
					}
				}
				if(pixel_mode & PMODE_BLUR)
				{
					for (x=-3; x<4; x++)
					{
						for (y=-3; y<4; y++)
						{
							if (abs(x)+abs(y) <2 && !(abs(x)==2||abs(y)==2))
								BlendPixel({ x+nx, y+ny }, RGBA(colr, colg, colb, 30));
							if (abs(x)+abs(y) <=3 && abs(x)+abs(y))
								BlendPixel({ x+nx, y+ny }, RGBA(colr, colg, colb, 20));
							if (abs(x)+abs(y) == 2)
								BlendPixel({ x+nx, y+ny }, RGBA(colr, colg, colb, 10));
						}
					}
				}
				if(pixel_mode & PMODE_SPARK)
				{
					auto flicker = float(gfctx.rng()%20);
					auto gradv = 4*sim->parts[i].life + flicker;
					for (x = 0; (gradv>0.5) && (drawing_budget > 0); x++) {
						auto col = RGBA(
							std::min(0xFF, colr * int(gradv) / 255),
							std::min(0xFF, colg * int(gradv) / 255),
							std::min(0xFF, colb * int(gradv) / 255)
						);
						AddPixel({ nx+x, ny }, col);
						AddPixel({ nx-x, ny }, col);
						AddPixel({ nx, ny+x }, col);
						AddPixel({ nx, ny-x }, col);
						gradv = gradv/1.5f;
						drawing_budget--;
					}
				}
				if(pixel_mode & PMODE_FLARE)
				{
					auto flicker = float(gfctx.rng()%20);
					auto gradv = flicker + fabs(parts[i].vx)*17 + fabs(sim->parts[i].vy)*17;
					BlendPixel({ nx, ny }, RGBA(colr, colg, colb, int((gradv*4)>255?255:(gradv*4)) ));
					BlendPixel({ nx+1, ny }, RGBA(colr, colg, colb,int( (gradv*2)>255?255:(gradv*2)) ));
					BlendPixel({ nx-1, ny }, RGBA(colr, colg, colb, int((gradv*2)>255?255:(gradv*2)) ));
					BlendPixel({ nx, ny+1 }, RGBA(colr, colg, colb, int((gradv*2)>255?255:(gradv*2)) ));
					BlendPixel({ nx, ny-1 }, RGBA(colr, colg, colb, int((gradv*2)>255?255:(gradv*2)) ));
					if (gradv>255) gradv=255;
					BlendPixel({ nx+1, ny-1 }, RGBA(colr, colg, colb, int(gradv)));
					BlendPixel({ nx-1, ny-1 }, RGBA(colr, colg, colb, int(gradv)));
					BlendPixel({ nx+1, ny+1 }, RGBA(colr, colg, colb, int(gradv)));
					BlendPixel({ nx-1, ny+1 }, RGBA(colr, colg, colb, int(gradv)));
					for (x = 1; (gradv>0.5) && (drawing_budget > 0); x++) {
						AddPixel({ nx+x, ny }, RGBA(colr, colg, colb, int(gradv)));
						AddPixel({ nx-x, ny }, RGBA(colr, colg, colb, int(gradv)));
						AddPixel({ nx, ny+x }, RGBA(colr, colg, colb, int(gradv)));
						AddPixel({ nx, ny-x }, RGBA(colr, colg, colb, int(gradv)));
						gradv = gradv/1.2f;
						drawing_budget--;
					}
				}
				if(pixel_mode & PMODE_LFLARE)
				{
					auto flicker = float(gfctx.rng()%20);
					auto gradv = flicker + fabs(parts[i].vx)*17 + fabs(parts[i].vy)*17;
					BlendPixel({ nx, ny }, RGBA(colr, colg, colb, int((gradv*4)>255?255:(gradv*4)) ));
					BlendPixel({ nx+1, ny }, RGBA(colr, colg, colb, int((gradv*2)>255?255:(gradv*2)) ));
					BlendPixel({ nx-1, ny }, RGBA(colr, colg, colb, int((gradv*2)>255?255:(gradv*2)) ));
					BlendPixel({ nx, ny+1 }, RGBA(colr, colg, colb, int((gradv*2)>255?255:(gradv*2)) ));
					BlendPixel({ nx, ny-1 }, RGBA(colr, colg, colb, int((gradv*2)>255?255:(gradv*2)) ));
					if (gradv>255) gradv=255;
					BlendPixel({ nx+1, ny-1 }, RGBA(colr, colg, colb, int(gradv)));
					BlendPixel({ nx-1, ny-1 }, RGBA(colr, colg, colb, int(gradv)));
					BlendPixel({ nx+1, ny+1 }, RGBA(colr, colg, colb, int(gradv)));
					BlendPixel({ nx-1, ny+1 }, RGBA(colr, colg, colb, int(gradv)));
					for (x = 1; (gradv>0.5) && (drawing_budget > 0); x++) {
						AddPixel({ nx+x, ny }, RGBA(colr, colg, colb, int(gradv)));
						AddPixel({ nx-x, ny }, RGBA(colr, colg, colb, int(gradv)));
						AddPixel({ nx, ny+x }, RGBA(colr, colg, colb, int(gradv)));
						AddPixel({ nx, ny-x }, RGBA(colr, colg, colb, int(gradv)));
						gradv = gradv/1.01f;
						drawing_budget--;
					}
				}
				if (pixel_mode & EFFECT_GRAVIN)
				{
					int nxo = 0;
					int nyo = 0;
					int r;
					float drad = 0.0f;
					float ddist = 0.0f;
					orbitalparts_get(parts[i].life, parts[i].ctype, orbd, orbl);
					for (r = 0; r < 4; r++) {
						ddist = ((float)orbd[r])/16.0f;
						drad = (TPT_PI_FLT * ((float)orbl[r]) / 180.0f)*1.41f;
						nxo = (int)(ddist*cos(drad));
						nyo = (int)(ddist*sin(drad));
						if (ny+nyo>0 && ny+nyo<YRES && nx+nxo>0 && nx+nxo<XRES && TYP(sim->pmap[ny+nyo][nx+nxo]) != PT_PRTI)
							AddPixel({ nx+nxo, ny+nyo }, RGBA(colr, colg, colb, 255-orbd[r]));
					}
				}
				if (pixel_mode & EFFECT_GRAVOUT)
				{
					int nxo = 0;
					int nyo = 0;
					int r;
					float drad = 0.0f;
					float ddist = 0.0f;
					orbitalparts_get(parts[i].life, parts[i].ctype, orbd, orbl);
					for (r = 0; r < 4; r++) {
						ddist = ((float)orbd[r])/16.0f;
						drad = (TPT_PI_FLT * ((float)orbl[r]) / 180.0f)*1.41f;
						nxo = (int)(ddist*cos(drad));
						nyo = (int)(ddist*sin(drad));
						if (ny+nyo>0 && ny+nyo<YRES && nx+nxo>0 && nx+nxo<XRES && TYP(sim->pmap[ny+nyo][nx+nxo]) != PT_PRTO)
							AddPixel({ nx+nxo, ny+nyo }, RGBA(colr, colg, colb, 255-orbd[r]));
					}
				}
				if (pixel_mode & EFFECT_DBGLINES && !(displayMode&DISPLAY_PERS))
				{
					// draw lines connecting wifi/portal channels
					if (mousePos.X == nx && mousePos.Y == ny && i == ID(sim->pmap[ny][nx]) && debugLines)
					{
						int type = parts[i].type, tmp = (int)((parts[i].temp-73.15f)/100+1), othertmp;
						if (type == PT_PRTI)
							type = PT_PRTO;
						else if (type == PT_PRTO)
							type = PT_PRTI;
						for (int z = 0; z <= sim->parts.lastActiveIndex; z++)
						{
							if (parts[z].type == type)
							{
								othertmp = (int)((parts[z].temp-73.15f)/100+1);
								if (tmp == othertmp)
									XorLine({ nx, ny }, Vec2{ int(parts[z].x+0.5f), int(parts[z].y+0.5f) });
							}
						}
					}
				}
				//Fire effects
				if(firea && (pixel_mode & FIRE_BLEND))
				{
					firea /= 2;
					fire_r[ny/CELL][nx/CELL] = (firea*firer + (255-firea)*fire_r[ny/CELL][nx/CELL]) >> 8;
					fire_g[ny/CELL][nx/CELL] = (firea*fireg + (255-firea)*fire_g[ny/CELL][nx/CELL]) >> 8;
					fire_b[ny/CELL][nx/CELL] = (firea*fireb + (255-firea)*fire_b[ny/CELL][nx/CELL]) >> 8;
				}
				if(firea && (pixel_mode & FIRE_ADD))
				{
					firea /= 8;
					firer = ((firea*firer) >> 8) + fire_r[ny/CELL][nx/CELL];
					fireg = ((firea*fireg) >> 8) + fire_g[ny/CELL][nx/CELL];
					fireb = ((firea*fireb) >> 8) + fire_b[ny/CELL][nx/CELL];

					if(firer>255)
						firer = 255;
					if(fireg>255)
						fireg = 255;
					if(fireb>255)
						fireb = 255;

					fire_r[ny/CELL][nx/CELL] = firer;
					fire_g[ny/CELL][nx/CELL] = fireg;
					fire_b[ny/CELL][nx/CELL] = fireb;
				}
				if(firea && (pixel_mode & FIRE_SPARK))
				{
					firea /= 4;
					fire_r[ny/CELL][nx/CELL] = (firea*firer + (255-firea)*fire_r[ny/CELL][nx/CELL]) >> 8;
					fire_g[ny/CELL][nx/CELL] = (firea*fireg + (255-firea)*fire_g[ny/CELL][nx/CELL]) >> 8;
					fire_b[ny/CELL][nx/CELL] = (firea*fireb + (255-firea)*fire_b[ny/CELL][nx/CELL]) >> 8;
				}
			}
		}
	}
}

void Renderer::draw_other() // EMP effect
{
	int i, j;
	int emp_decor = sim->emp_decor;
	if (emp_decor>40) emp_decor = 40;
	if (emp_decor<0) emp_decor = 0;
	if (!(renderMode & EFFECT)) // not in nothing mode
		return;
	if (emp_decor>0)
	{
		int r=int(emp_decor*2.5), g=int(100+emp_decor*1.5), b=255;
		int a=int((1.0*emp_decor/110)*255);
		if (r>255) r=255;
		if (g>255) g=255;
		if (b>255) g=255;
		if (a>255) a=255;
		for (j=0; j<YRES; j++)
			for (i=0; i<XRES; i++)
			{
				BlendPixel({ i, j }, RGBA(r, g, b, a));
			}
	}
}

void Renderer::draw_grav_zones()
{
	if (!gravityZonesEnabled)
	{
		return;
	}
	for (auto p : CELLS.OriginRect())
	{
		if (sim->gravIn.mask[p])
		{
			auto np = p * CELL;
			for (auto o : Vec2{ CELL, CELL }.OriginRect())
			{
				BlendPixel(np + o, (o.X == o.Y ? 0xFFC800_rgb : 0x202020_rgb).WithAlpha(120));
			}
		}
	}
}

void Renderer::draw_grav()
{
	if (!gravityFieldEnabled)
	{
		return;
	}
	for (auto p : CELLS.OriginRect())
	{
		auto gx = sim->gravOut.forceX[p];
		auto gy = sim->gravOut.forceY[p];
		auto agx = std::abs(gx);
		auto agy = std::abs(gy);
		if (agx <= 0.001f && agy <= 0.001f)
		{
			continue;
		}
		auto np = Vec2{ float(p.X * CELL), float(p.Y * CELL) };
		auto dist = agx + agy;
		for (auto i = 0; i < 4; ++i)
		{
			np -= Vec2{ gx * 0.5f, gy * 0.5f };
			AddPixel({ int(np.X + 0.5f), int(np.Y + 0.5f) }, 0xFFFFFF_rgb .WithAlpha(int(dist * 20.0f)));
		}
	}
}

void Renderer::draw_air()
{
	if(!sim->aheat_enable && (displayMode & DISPLAY_AIRH))
		return;
	if(!(displayMode & DISPLAY_AIR))
		return;
	int x, y, i, j;
	auto *pv = sim->pv;
	auto *hv = sim->hv;
	auto *vx = sim->vx;
	auto *vy = sim->vy;
	auto c = 0x000000_rgb;
	for (y=0; y<YCELLS; y++)
		for (x=0; x<XCELLS; x++)
		{
			if (displayMode & DISPLAY_AIRP)
			{
				if (pv[y][x] > 0.0f)
					c = RGB(clamp_flt(pv[y][x], 0.0f, 8.0f), 0, 0);//positive pressure is red!
				else
					c = RGB(0, 0, clamp_flt(-pv[y][x], 0.0f, 8.0f));//negative pressure is blue!
			}
			else if (displayMode & DISPLAY_AIRV)
			{
				c = RGB(clamp_flt(fabsf(vx[y][x]), 0.0f, 8.0f),//vx adds red
					clamp_flt(pv[y][x], 0.0f, 8.0f),//pressure adds green
					clamp_flt(fabsf(vy[y][x]), 0.0f, 8.0f));//vy adds blue
			}
			else if (displayMode & DISPLAY_AIRH)
			{
				c = RGB::Unpack(HeatToColour(hv[y][x], stats.hdispLimitMin, stats.hdispLimitMax));
				//c = RGB(clamp_flt(fabsf(vx[y][x]), 0.0f, 8.0f),//vx adds red
				//	clamp_flt(hv[y][x], 0.0f, 1600.0f),//heat adds green
				//	clamp_flt(fabsf(vy[y][x]), 0.0f, 8.0f)).Pack();//vy adds blue
			}
			else if (displayMode & DISPLAY_AIRC)
			{
				int r;
				int g;
				int b;
				// velocity adds grey
				r = clamp_flt(fabsf(vx[y][x]), 0.0f, 24.0f) + clamp_flt(fabsf(vy[y][x]), 0.0f, 20.0f);
				g = clamp_flt(fabsf(vx[y][x]), 0.0f, 20.0f) + clamp_flt(fabsf(vy[y][x]), 0.0f, 24.0f);
				b = clamp_flt(fabsf(vx[y][x]), 0.0f, 24.0f) + clamp_flt(fabsf(vy[y][x]), 0.0f, 20.0f);
				if (pv[y][x] > 0.0f)
				{
					r += clamp_flt(pv[y][x], 0.0f, 16.0f);//pressure adds red!
					if (r>255)
						r=255;
					if (g>255)
						g=255;
					if (b>255)
						b=255;
					c = RGB(r, g, b);
				}
				else
				{
					b += clamp_flt(-pv[y][x], 0.0f, 16.0f);//pressure adds blue!
					if (r>255)
						r=255;
					if (g>255)
						g=255;
					if (b>255)
						b=255;
					c = RGB(r, g, b);
				}
			}
			if (findingElement)
			{
				c.Red   /= 10;
				c.Green /= 10;
				c.Blue  /= 10;
			}
			for (j=0; j<CELL; j++)//draws the colors
				for (i=0; i<CELL; i++)
					video[{ x * CELL + i, y * CELL + j }] = c.Pack();
		}
}

void Renderer::DrawWalls()
{
	auto &sd = SimulationData::CRef();
	auto &wtypes = sd.wtypes;
	for (int y = 0; y < YCELLS; y++)
		for (int x =0; x < XCELLS; x++)
			if (sim->bmap[y][x])
			{
				unsigned char wt = sim->bmap[y][x];
				if (wt >= UI_WALLCOUNT)
					continue;
				unsigned char powered = sim->emap[y][x];
				RGB prgb = wtypes[wt].colour;
				RGB grgb = wtypes[wt].eglow;

				if (findingElement)
				{
					prgb.Red   /= 10;
					prgb.Green /= 10;
					prgb.Blue  /= 10;
					grgb.Red   /= 10;
					grgb.Green /= 10;
					grgb.Blue  /= 10;
				}

				pixel pc = prgb.Pack();
				pixel gc = grgb.Pack();

				switch (wtypes[wt].drawstyle)
				{
				case 0:
					if (wt == WL_EWALL || wt == WL_STASIS)
					{
						bool reverse = wt == WL_STASIS;
						if ((powered > 0) ^ reverse)
						{
							for (int j = 0; j < CELL; j++)
								for (int i =0; i < CELL; i++)
									if (i&j&1)
										video[{ x * CELL + i, y * CELL + j }] = pc;
						}
						else
						{
							for (int j = 0; j < CELL; j++)
								for (int i = 0; i < CELL; i++)
									if (!(i&j&1))
										video[{ x * CELL + i, y * CELL + j }] = pc;
						}
					}
					else if (wt == WL_WALLELEC)
					{
						for (int j = 0; j < CELL; j++)
							for (int i = 0; i < CELL; i++)
							{
								if (!((y*CELL+j)%2) && !((x*CELL+i)%2))
									video[{ x * CELL + i, y * CELL + j }] = pc;
								else
									video[{ x * CELL + i, y * CELL + j }] = 0x808080_rgb .Pack();
							}
					}
					else if (wt == WL_EHOLE)
					{
						if (powered)
						{
							for (int j = 0; j < CELL; j++)
								for (int i = 0; i < CELL; i++)
									video[{ x * CELL + i, y * CELL + j }] = 0x242424_rgb .Pack();
							for (int j = 0; j < CELL; j += 2)
								for (int i = 0; i < CELL; i += 2)
									video[{ x * CELL + i, y * CELL + j }] = 0x000000_rgb .Pack();
						}
						else
						{
							for (int j = 0; j < CELL; j += 2)
								for (int i =0; i < CELL; i += 2)
									video[{ x * CELL + i, y * CELL + j }] = 0x242424_rgb .Pack();
						}
					}
					else if (wt == WL_STREAM)
					{
						float xf = x*CELL + CELL*0.5f;
						float yf = y*CELL + CELL*0.5f;
						int oldX = (int)(xf+0.5f), oldY = (int)(yf+0.5f);
						int newX, newY;
						float xVel = sim->vx[y][x]*0.125f, yVel = sim->vy[y][x]*0.125f;
						// there is no velocity here, draw a streamline and continue
						if (!xVel && !yVel)
						{
							BlendText({ x*CELL, y*CELL-2 }, 0xE00D, 0xFFFFFF_rgb .WithAlpha(128));
							AddPixel({ oldX, oldY }, 0xFFFFFF_rgb .WithAlpha(255));
							continue;
						}
						bool changed = false;
						for (int t = 0; t < 1024; t++)
						{
							newX = (int)(xf+0.5f);
							newY = (int)(yf+0.5f);
							if (newX != oldX || newY != oldY)
							{
								changed = true;
								oldX = newX;
								oldY = newY;
							}
							if (changed && (newX<0 || newX>=XRES || newY<0 || newY>=YRES))
								break;
							AddPixel({ newX, newY }, 0xFFFFFF_rgb .WithAlpha(64));
							// cache velocity and other checks so we aren't running them constantly
							if (changed)
							{
								int wallX = newX/CELL;
								int wallY = newY/CELL;
								xVel = sim->vx[wallY][wallX]*0.125f;
								yVel = sim->vy[wallY][wallX]*0.125f;
								if (wallX != x && wallY != y && sim->bmap[wallY][wallX] == WL_STREAM)
									break;
							}
							xf += xVel;
							yf += yVel;
						}
						BlendText({ x*CELL, y*CELL-2 }, 0xE00D, 0xFFFFFF_rgb .WithAlpha(128));
					}
					break;
				case 1:
					for (int j = 0; j < CELL; j += 2)
						for (int i = (j>>1)&1; i < CELL; i += 2)
							video[{ x * CELL + i, y * CELL + j }] = pc;
					break;
				case 2:
					for (int j = 0; j < CELL; j += 2)
						for (int i = 0; i < CELL; i += 2)
							video[{ x * CELL + i, y * CELL + j }] = pc;
					break;
				case 3:
					for (int j = 0; j < CELL; j++)
						for (int i = 0; i < CELL; i++)
							video[{ x * CELL + i, y * CELL + j }] = pc;
					break;
				case 4:
					for (int j = 0; j < CELL; j++)
						for (int i = 0; i < CELL; i++)
							if (i == j)
								video[{ x * CELL + i, y * CELL + j }] = pc;
							else if (i == j+1 || (i == 0 && j == CELL-1))
								video[{ x * CELL + i, y * CELL + j }] = gc;
							else
								video[{ x * CELL + i, y * CELL + j }] = 0x202020_rgb .Pack();
					break;
				}

				// when in blob view, draw some blobs...
				if (renderMode & PMODE_BLOB)
				{
					switch (wtypes[wt].drawstyle)
					{
					case 0:
						if (wt == WL_EWALL || wt == WL_STASIS)
						{
							bool reverse = wt == WL_STASIS;
							if ((powered>0) ^ reverse)
							{
								for (int j = 0; j < CELL; j++)
									for (int i =0; i < CELL; i++)
										if (i&j&1)
											DrawBlob({ x*CELL+i, y*CELL+j }, prgb);
							}
							else
							{
								for (int j = 0; j < CELL; j++)
									for (int i = 0; i < CELL; i++)
										if (!(i&j&1))
											DrawBlob({ x*CELL+i, y*CELL+j }, prgb);
							}
						}
						else if (wt == WL_WALLELEC)
						{
							for (int j = 0; j < CELL; j++)
								for (int i =0; i < CELL; i++)
								{
									if (!((y*CELL+j)%2) && !((x*CELL+i)%2))
										DrawBlob({ x*CELL+i, y*CELL+j }, prgb);
									else
										DrawBlob({ x*CELL+i, y*CELL+j }, 0x808080_rgb);
								}
						}
						else if (wt == WL_EHOLE)
						{
							if (powered)
							{
								for (int j = 0; j < CELL; j++)
									for (int i = 0; i < CELL; i++)
										DrawBlob({ x*CELL+i, y*CELL+j }, 0x242424_rgb);
								for (int j = 0; j < CELL; j += 2)
									for (int i = 0; i < CELL; i += 2)
										// looks bad if drawing black blobs
										video[{ x * CELL + i, y * CELL + j }] = 0x000000_rgb .Pack();
							}
							else
							{
								for (int j = 0; j < CELL; j += 2)
									for (int i = 0; i < CELL; i += 2)
										DrawBlob({ x*CELL+i, y*CELL+j }, 0x242424_rgb);
							}
						}
						break;
					case 1:
						for (int j = 0; j < CELL; j += 2)
							for (int i = (j>>1)&1; i < CELL; i += 2)
								DrawBlob({ x*CELL+i, y*CELL+j }, prgb);
						break;
					case 2:
						for (int j = 0; j < CELL; j += 2)
							for (int i = 0; i < CELL; i+=2)
								DrawBlob({ x*CELL+i, y*CELL+j }, prgb);
						break;
					case 3:
						for (int j = 0; j < CELL; j++)
							for (int i = 0; i < CELL; i++)
								DrawBlob({ x*CELL+i, y*CELL+j }, prgb);
						break;
					case 4:
						for (int j = 0; j < CELL; j++)
							for (int i = 0; i < CELL; i++)
								if (i == j)
									DrawBlob({ x*CELL+i, y*CELL+j }, prgb);
								else if (i == j+1 || (i == 0 && j == CELL-1))
									video[{ x * CELL + i, y * CELL + j }] = gc;
								else
									// looks bad if drawing black blobs
									video[{ x * CELL + i, y * CELL + j }] = 0x202020_rgb .Pack();
						break;
					}
				}

				if (wtypes[wt].eglow.Pack() && powered)
				{
					// glow if electrified
					RGB glow = wtypes[wt].eglow;
					int alpha = 255;
					int cr = (alpha*glow.Red   + (255-alpha)*fire_r[y/CELL][x/CELL]) >> 8;
					int cg = (alpha*glow.Green + (255-alpha)*fire_g[y/CELL][x/CELL]) >> 8;
					int cb = (alpha*glow.Blue  + (255-alpha)*fire_b[y/CELL][x/CELL]) >> 8;

					if (cr > 255)
						cr = 255;
					if (cg > 255)
						cg = 255;
					if (cb > 255)
						cb = 255;
					fire_r[y][x] = cr;
					fire_g[y][x] = cg;
					fire_b[y][x] = cb;
				}
			}
}

void Renderer::render_fire()
{
	if(!(renderMode & FIREMODE))
		return;
	int i,j,x,y,r,g,b,a;
	for (j=0; j<YCELLS; j++)
		for (i=0; i<XCELLS; i++)
		{
			r = fire_r[j][i];
			g = fire_g[j][i];
			b = fire_b[j][i];
			if (r || g || b)
				for (y=-CELL; y<2*CELL; y++)
					for (x=-CELL; x<2*CELL; x++)
					{
						a = fire_alpha[y+CELL][x+CELL];
						if (findingElement)
							a /= 2;
						AddFirePixel({ i*CELL+x, j*CELL+y }, RGB(r, g, b), a);
					}
			r *= 8;
			g *= 8;
			b *= 8;
			for (y=-1; y<2; y++)
				for (x=-1; x<2; x++)
					if ((x || y) && i+x>=0 && j+y>=0 && i+x<XCELLS && j+y<YCELLS)
					{
						r += fire_r[j+y][i+x];
						g += fire_g[j+y][i+x];
						b += fire_b[j+y][i+x];
					}
			r /= 16;
			g /= 16;
			b /= 16;
			fire_r[j][i] = r>4 ? r-4 : 0;
			fire_g[j][i] = g>4 ? g-4 : 0;
			fire_b[j][i] = b>4 ? b-4 : 0;
		}
}

int HeatToColour(float temp, float hdispLimitMin, float hdispLimitMax)
{
	RGB color = Renderer::heatTableAt(int((temp - hdispLimitMin) / (hdispLimitMax - hdispLimitMin) * 1024));
	color.Red   = uint8_t(color.Red   * 0.7f);
	color.Green = uint8_t(color.Green * 0.7f);
	color.Blue  = uint8_t(color.Blue  * 0.7f);
	return color.Pack();
}

const std::vector<RenderPreset> Renderer::renderModePresets = {
	{
		"Alternative Velocity Display",
		RENDER_EFFE | RENDER_BASC,
		DISPLAY_AIRC,
		0,
	},
	{
		"Velocity Display",
		RENDER_EFFE | RENDER_BASC,
		DISPLAY_AIRV,
		0,
	},
	{
		"Pressure Display",
		RENDER_EFFE | RENDER_BASC,
		DISPLAY_AIRP,
		0,
	},
	{
		"Persistent Display",
		RENDER_EFFE | RENDER_BASC,
		DISPLAY_PERS,
		0,
	},
	{
		"Fire Display",
		RENDER_FIRE | RENDER_SPRK | RENDER_EFFE | RENDER_BASC,
		0,
		0,
	},
	{
		"Blob Display",
		RENDER_FIRE | RENDER_SPRK | RENDER_EFFE | RENDER_BLOB,
		0,
		0,
	},
	{
		"Heat Display",
		RENDER_BASC,
		DISPLAY_AIRH,
		COLOUR_HEAT,
	},
	{
		"Fancy Display",
		RENDER_FIRE | RENDER_SPRK | RENDER_GLOW | RENDER_BLUR | RENDER_EFFE | RENDER_BASC,
		DISPLAY_WARP,
		0,
	},
	{
		"Nothing Display",
		RENDER_BASC,
		0,
		0,
	},
	{
		"Heat Gradient Display",
		RENDER_BASC,
		0,
		COLOUR_GRAD,
	},
	{
		"Life Gradient Display",
		RENDER_BASC,
		0,
		COLOUR_LIFE,
	},
	{
		"Dynamic Heat Display",
		RENDER_BASC,
		DISPLAY_AIRH,
		COLOUR_HEAT,
		HdispLimitAuto{},
		HdispLimitAuto{},
	},
};

void Renderer::AdjustHdispLimit()
{
	stats.hdispLimitValid = false;
	float autoHdispLimitMin = MAX_TEMP;
	float autoHdispLimitMax = MIN_TEMP;
	auto visit = [this, &autoHdispLimitMin, &autoHdispLimitMax](Vec2<int> point, float value) {
		if (autoHdispLimitArea.Contains(point))
		{
			autoHdispLimitMin = std::min(autoHdispLimitMin, value);
			autoHdispLimitMax = std::max(autoHdispLimitMax, value);
			stats.hdispLimitValid = true;
		}
	};
	if (std::holds_alternative<HdispLimitAuto>(wantHdispLimitMin) ||
	    std::holds_alternative<HdispLimitAuto>(wantHdispLimitMax))
	{
		if (colorMode & COLOUR_HEAT)
		{
			auto &sd = SimulationData::CRef();
			for (int i = 0; i <= sim->parts.lastActiveIndex; ++i)
			{
				auto t = sim->parts[i].type;
				if (t > 0 && t < PT_NUM)
				{
					if (!sd.elements[t].HeatConduct)
					{
						continue;
					}
					auto nx = int(sim->parts[i].x + 0.5f);
					auto ny = int(sim->parts[i].y + 0.5f);
					visit({ nx, ny }, sim->parts[i].temp);
				}
			}
		}
		if (sim->aheat_enable && (displayMode & DISPLAY_AIR) && (displayMode & DISPLAY_AIRH))
		{
			auto *hv = sim->hv;
			for (auto p : CELLS.OriginRect())
			{
				visit(p * CELL, hv[p.Y][p.X]);
			}
		}
	}
	stats.hdispLimitMin = autoHdispLimitMin;
	stats.hdispLimitMax = autoHdispLimitMax;
	if (auto *hdispLimitExplicit = std::get_if<HdispLimitExplicit>(&wantHdispLimitMin))
	{
		stats.hdispLimitMin = hdispLimitExplicit->value;
	}
	if (auto *hdispLimitExplicit = std::get_if<HdispLimitExplicit>(&wantHdispLimitMax))
	{
		stats.hdispLimitMax = hdispLimitExplicit->value;
	}
	if (std::isnan(stats.hdispLimitMin)) stats.hdispLimitMin = MIN_TEMP;
	if (std::isnan(stats.hdispLimitMax)) stats.hdispLimitMax = MAX_TEMP;
	stats.hdispLimitMax = std::clamp(stats.hdispLimitMax, MIN_TEMP, MAX_TEMP);
	stats.hdispLimitMin = std::clamp(stats.hdispLimitMin, MIN_TEMP, stats.hdispLimitMax);
}

void Renderer::Clear()
{
	if(displayMode & DISPLAY_PERS)
	{
		std::copy(persistentVideo.begin(), persistentVideo.end(), video.RowIterator({ 0, 0 }));
	}
	else
	{
		std::fill_n(video.data(), WINDOWW * YRES, 0);
	}
	AdjustHdispLimit();
}

void Renderer::DrawBlob(Vec2<int> pos, RGB colour)
{
	BlendPixel(pos + Vec2{ +1,  0 }, colour.WithAlpha(112));
	BlendPixel(pos + Vec2{ -1,  0 }, colour.WithAlpha(112));
	BlendPixel(pos + Vec2{  0,  1 }, colour.WithAlpha(112));
	BlendPixel(pos + Vec2{  0, -1 }, colour.WithAlpha(112));
	BlendPixel(pos + Vec2{  1, -1 }, colour.WithAlpha(64));
	BlendPixel(pos + Vec2{ -1, -1 }, colour.WithAlpha(64));
	BlendPixel(pos + Vec2{  1,  1 }, colour.WithAlpha(64));
	BlendPixel(pos + Vec2{ -1, +1 }, colour.WithAlpha(64));
}

float temp[CELL*3][CELL*3];
float fire_alphaf[CELL*3][CELL*3];
float glow_alphaf[11][11];
float blur_alphaf[7][7];
void Renderer::prepare_alpha(int size, float intensity)
{
	fireIntensity = intensity;
	//TODO: implement size
	int x,y,i,j;
	float multiplier = 255.0f*fireIntensity;

	memset(temp, 0, sizeof(temp));
	for (x=0; x<CELL; x++)
		for (y=0; y<CELL; y++)
			for (i=-CELL; i<CELL; i++)
				for (j=-CELL; j<CELL; j++)
					temp[y+CELL+j][x+CELL+i] += expf(-0.1f*(i*i+j*j));
	for (x=0; x<CELL*3; x++)
		for (y=0; y<CELL*3; y++)
			fire_alpha[y][x] = (int)(multiplier*temp[y][x]/(CELL*CELL));

}

std::vector<RGB> Renderer::flameTable;
std::vector<RGB> Renderer::plasmaTable;
std::vector<RGB> Renderer::heatTable;
std::vector<RGB> Renderer::clfmTable;
std::vector<RGB> Renderer::firwTable;
static bool tablesPopulated = false;
static std::mutex tablesPopulatedMx;
void Renderer::PopulateTables()
{
	std::lock_guard g(tablesPopulatedMx);
	if (!tablesPopulated)
	{
		tablesPopulated = true;
		flameTable = Gradient({
			{ 0x000000_rgb, 0.00f },
			{ 0x60300F_rgb, 0.50f },
			{ 0xDFBF6F_rgb, 0.90f },
			{ 0xAF9F0F_rgb, 1.00f },
		}, 200);
		plasmaTable = Gradient({
			{ 0x000000_rgb, 0.00f },
			{ 0x301040_rgb, 0.25f },
			{ 0x301060_rgb, 0.50f },
			{ 0xAFFFFF_rgb, 0.90f },
			{ 0xAFFFFF_rgb, 1.00f },
		}, 200);
		heatTable = Gradient({
			{ 0x2B00FF_rgb, 0.00f },
			{ 0x003CFF_rgb, 0.01f },
			{ 0x00C0FF_rgb, 0.05f },
			{ 0x00FFEB_rgb, 0.08f },
			{ 0x00FF14_rgb, 0.19f },
			{ 0x4BFF00_rgb, 0.25f },
			{ 0xC8FF00_rgb, 0.37f },
			{ 0xFFDC00_rgb, 0.45f },
			{ 0xFF0000_rgb, 0.71f },
			{ 0xFF00DC_rgb, 1.00f },
		}, 1024);
		clfmTable = Gradient({
			{ 0x000000_rgb, 0.00f },
			{ 0x0A0917_rgb, 0.10f },
			{ 0x19163C_rgb, 0.20f },
			{ 0x28285E_rgb, 0.30f },
			{ 0x343E77_rgb, 0.40f },
			{ 0x49769A_rgb, 0.60f },
			{ 0x57A0B4_rgb, 0.80f },
			{ 0x5EC4C6_rgb, 1.00f },
		}, 200);
		firwTable = Gradient({
			{ 0xFF00FF_rgb, 0.00f },
			{ 0x0000FF_rgb, 0.20f },
			{ 0x00FFFF_rgb, 0.40f },
			{ 0x00FF00_rgb, 0.60f },
			{ 0xFFFF00_rgb, 0.80f },
			{ 0xFF0000_rgb, 1.00f },
		}, 200);
	}
}

Renderer::Renderer()
{
	PopulateTables();

	memset(fire_r, 0, sizeof(fire_r));
	memset(fire_g, 0, sizeof(fire_g));
	memset(fire_b, 0, sizeof(fire_b));

	//Set defauly display modes
	prepare_alpha(CELL, 1.0f);
	ClearAccumulation();
}

void Renderer::ClearAccumulation()
{
	std::fill(&fire_r[0][0], &fire_r[0][0] + NCELL, 0);
	std::fill(&fire_g[0][0], &fire_g[0][0] + NCELL, 0);
	std::fill(&fire_b[0][0], &fire_b[0][0] + NCELL, 0);
	std::fill(persistentVideo.begin(), persistentVideo.end(), 0);
}

void Renderer::ApplySettings(const RendererSettings &newSettings)
{
	if (!(newSettings.renderMode & FIREMODE) && (renderMode & FIREMODE))
	{
		ClearAccumulation();
	}
	if (!(newSettings.displayMode & DISPLAY_PERS) && (displayMode & DISPLAY_PERS))
	{
		ClearAccumulation();
	}
	static_cast<RendererSettings &>(*this) = newSettings;
}

template struct RasterDrawMethods<Renderer>;


=== src\graphics\Renderer.h ===

#pragma once
#include "Icons.h"
#include "RasterDrawMethods.h"
#include "gui/game/RenderPreset.h"
#include "RendererSettings.h"
#include "common/tpt-rand.h"
#include "RendererFrame.h"
#include <cstdint>
#include <optional>
#include <memory>
#include <mutex>
#include <vector>

struct RenderPreset;
class Renderer;
struct RenderableSimulation;
struct Particle;

struct GraphicsFuncContext
{
	const RendererSettings *ren;
	const RenderableSimulation *sim;
	RNG rng;
	const Particle *pipeSubcallCpart;
	Particle *pipeSubcallTpart;
};

int HeatToColour(float temp, float hdispLimitMin, float hdispLimitMax);

class Renderer : private RendererSettings, public RasterDrawMethods<Renderer>
{
	RendererFrame video;
	std::array<pixel, WINDOW.X * RES.Y> persistentVideo;
	RendererFrame warpVideo;
	RendererStats stats;

	Rect<int> GetClipRect() const
	{
		return video.Size().OriginRect();
	}

	friend struct RasterDrawMethods<Renderer>;

	RNG rng;
	unsigned char fire_r[YCELLS][XCELLS];
	unsigned char fire_g[YCELLS][XCELLS];
	unsigned char fire_b[YCELLS][XCELLS];
	unsigned int fire_alpha[CELL*3][CELL*3];

	void DrawBlob(Vec2<int> pos, RGB colour);
	void DrawWalls();
	void DrawSigns();
	void render_gravlensing(const RendererFrame &source);
	void render_fire();
	void prepare_alpha(int size, float intensity);
	void render_parts();
	void draw_grav_zones();
	void draw_air();
	void draw_grav();
	void draw_other();

	void AdjustHdispLimit();

public:
	Renderer();
	void ApplySettings(const RendererSettings &newSettings);
	void RenderSimulation();
	void RenderBackground();
	void ApproximateAccumulation();
	void ClearAccumulation();
	void Clear();

	const RendererFrame &GetVideo() const
	{
		return video;
	}

	RendererStats GetStats() const
	{
		return stats;
	}

	const RenderableSimulation *sim = nullptr;

	static std::unique_ptr<VideoBuffer> WallIcon(int wallID, Vec2<int> size);
	static const std::vector<RenderPreset> renderModePresets;

#define RENDERER_TABLE(name) \
	static std::vector<RGB> name; \
	static inline RGB name ## At(int index) \
	{ \
		auto size = int(name.size()); \
		if (index <        0) index =        0; \
		if (index > size - 1) index = size - 1; \
		return name[index]; \
	}
	RENDERER_TABLE(flameTable)
	RENDERER_TABLE(plasmaTable)
	RENDERER_TABLE(heatTable)
	RENDERER_TABLE(clfmTable)
	RENDERER_TABLE(firwTable)
#undef RENDERER_TABLE
	static void PopulateTables();
};


=== src\graphics\RendererFrame.h ===

#pragma once
#include "SimulationConfig.h"
#include "Pixel.h"
#include "common/Plane.h"
#include <array>

constexpr auto RendererFrameSize = Vec2<int>{ WINDOW.X, RES.Y };
using RendererFrame = PlaneAdapter<std::array<pixel, WINDOW.X * RES.Y>, RendererFrameSize.X, RendererFrameSize.Y>;

struct RendererStats
{
	int foundParticles = 0;
	float hdispLimitMin = 0;
	float hdispLimitMax = 0;
	bool hdispLimitValid = false;
};


=== src\graphics\RendererSettings.h ===

#pragma once
#include "gui/interface/Point.h"
#include "simulation/ElementGraphics.h"
#include "simulation/ElementDefs.h"
#include "FindingElement.h"
#include <cstdint>
#include <optional>
#include <variant>

struct HdispLimitExplicit
{
	float value;
};
struct HdispLimitAuto
{
};
using HdispLimit = std::variant<
	HdispLimitExplicit,
	HdispLimitAuto
>;

struct RendererSettings
{
	uint32_t renderMode = RENDER_BASC | RENDER_FIRE | RENDER_SPRK | RENDER_EFFE;
	uint32_t displayMode = 0;
	uint32_t colorMode = COLOUR_DEFAULT;
	std::optional<FindingElement> findingElement;
	bool gravityZonesEnabled = false;
	bool gravityFieldEnabled = false;
	enum DecorationLevel
	{
		decorationDisabled,
		decorationEnabled,
		decorationAntiClickbait,
	};
	DecorationLevel decorationLevel = decorationEnabled;
	bool debugLines = false;
	ui::Point mousePos = { 0, 0 };
	int gridSize = 0;
	float fireIntensity = 1;
	HdispLimit wantHdispLimitMin = HdispLimitExplicit{ MIN_TEMP };
	HdispLimit wantHdispLimitMax = HdispLimitExplicit{ MAX_TEMP };
	Rect<int> autoHdispLimitArea = RES.OriginRect();
};


=== src\graphics\VideoBuffer.h ===

#pragma once
#include <array>
#include <memory>
#include <span>
#include <vector>
#include "common/Plane.h"
#include "common/String.h"
#include "gui/interface/Point.h"
#include "Icons.h"
#include "Pixel.h"
#include "RasterDrawMethods.h"
#include "SimulationConfig.h"

class VideoBuffer: public RasterDrawMethods<VideoBuffer>
{
	PlaneAdapter<std::vector<pixel>> video;

	Rect<int> GetClipRect() const
	{
		return video.Size().OriginRect();
	}

	friend struct RasterDrawMethods<VideoBuffer>;

public:
	VideoBuffer(pixel const *data, Vec2<int> size);
	VideoBuffer(pixel const *data, Vec2<int> size, size_t rowStride);
	VideoBuffer(Vec2<int> size);

	template<class Plane>
	VideoBuffer(const Plane &plane) : VideoBuffer(plane.data(), plane.Size())
	{
	}

	Vec2<int> Size() const
	{
		return video.Size();
	}

	pixel *Data()
	{
		return video.data();
	}

	pixel const *Data() const
	{
		return video.data();
	}

	void Crop(Rect<int>);

	void Resize(float factor, bool resample = false);
	void Resize(Vec2<int> size, bool resample = false);
	// Automatically choose a size to fit within the given box, keeping aspect ratio
	void ResizeToFit(Vec2<int> bound, bool resample = false);

	static std::unique_ptr<VideoBuffer> FromPNG(std::span<const char> data);
	std::unique_ptr<std::vector<char>> ToPNG() const;
	std::vector<char> ToPPM() const;
};


=== src\gui\meson.build ===

gui_files = files(
	'Style.cpp',
)

subdir('colourpicker')
subdir('console')
subdir('credits')
subdir('dialogues')
subdir('elementsearch')
subdir('filebrowser')
subdir('font')
subdir('game')
subdir('interface')
subdir('localbrowser')
subdir('login')
subdir('options')
subdir('preview')
subdir('profile')
subdir('render')
subdir('save')
subdir('search')
subdir('tags')
subdir('update')


=== src\gui\SavePreviewType.h ===

#pragma once

enum SavePreviewType
{
	savePreviewNormal,
	savePreviewInstant,
	savePreviewUrl,
};


=== src\gui\Style.cpp ===

#include "gui/Style.h"

namespace style {
	ui::Colour Colour::InformationTitle = ui::Colour(140, 140, 255);
	ui::Colour Colour::WarningTitle = ui::Colour(255, 216, 32);
	ui::Colour Colour::ErrorTitle = ui::Colour(255, 64, 32);

	ui::Colour Colour::ConfirmButton = ui::Colour(255, 255, 50);

	ui::Colour Colour::ActiveBorder = ui::Colour(255, 255, 255);
	ui::Colour Colour::InactiveBorder = ui::Colour(100, 100, 100);

	ui::Colour Colour::ActiveBackground = ui::Colour(50, 50, 50);
	ui::Colour Colour::InactiveBackground = ui::Colour(0, 0, 0);
}


=== src\gui\Style.h ===

#pragma once
#include "gui/interface/Colour.h"

namespace style
{
	class Colour
	{
	public:
		static ui::Colour InformationTitle;
		static ui::Colour WarningTitle;
		static ui::Colour ErrorTitle;

		static ui::Colour ConfirmButton;

		static ui::Colour ActiveBorder;
		static ui::Colour InactiveBorder;

		static ui::Colour ActiveBackground;
		static ui::Colour InactiveBackground;
	};
	
	class Metrics
	{
	};
}


=== src\gui\WindowFrameOps.h ===

#pragma once
#include <variant>

struct WindowFrameOps
{
	int scale = 1;
	bool resizable = false;
	bool fullscreen = false;
	bool changeResolution = false;
	bool forceIntegerScaling = false;
	bool blurryScaling = false;

	WindowFrameOps Normalize() const
	{
		return {
			fullscreen ? 1     : scale              ,
			fullscreen ? false : resizable          ,
			fullscreen                              ,
			fullscreen ? changeResolution    : false,
			fullscreen ? forceIntegerScaling : false,
			blurryScaling                           ,
		};
	}
};


=== src\gui\colourpicker\ColourPickerActivity.cpp ===

#include "ColourPickerActivity.h"

#include "gui/interface/Textbox.h"
#include "gui/interface/Slider.h"
#include "gui/interface/Button.h"
#include "gui/interface/Label.h"
#include "gui/Style.h"

#include "graphics/Graphics.h"

#include "Misc.h"

#include <SDL.h>

ColourPickerActivity::ColourPickerActivity(ui::Colour initialColour, OnPicked onPicked_) :
	WindowActivity(ui::Point(-1, -1), ui::Point(266, 215)),
	currentHue(0),
	currentSaturation(0),
	currentValue(0),
	mouseDown(false),
	onPicked(onPicked_)
{
	auto colourChange = [this] {
		int r, g, b, alpha;
		r = rValue->GetText().ToNumber<int>(true);
		g = gValue->GetText().ToNumber<int>(true);
		b = bValue->GetText().ToNumber<int>(true);
		alpha = aValue->GetText().ToNumber<int>(true);
		if (r > 255)
			r = 255;
		if (g > 255)
			g = 255;
		if (b > 255)
			b = 255;
		if (alpha > 255)
			alpha = 255;

		RGB_to_HSV(r, g, b, &currentHue, &currentSaturation, &currentValue);
		currentAlpha = alpha;
		UpdateTextboxes(r, g, b, alpha);
		UpdateSliders();
	};

	auto colourChangeSlider = [this] {
		int r, g, b;
		currentHue = hSlider->GetValue();
		currentSaturation = sSlider->GetValue();
		currentValue = vSlider->GetValue();

		HSV_to_RGB(currentHue, currentSaturation, currentValue, &r, &g, &b);
		UpdateTextboxes(r, g, b, currentAlpha);
		UpdateSliders();
	};


	hSlider = new ui::Slider(ui::Point(0,134), ui::Point(Size.X,17), 359);
	hSlider->SetActionCallback({ colourChangeSlider });
	AddComponent(hSlider);

	sSlider = new ui::Slider(ui::Point(0, 134 + 17), ui::Point(Size.X, 17), 255);
	sSlider->SetActionCallback({ colourChangeSlider });
	AddComponent(sSlider);

	vSlider = new ui::Slider(ui::Point(0, 134 + 34), ui::Point(Size.X, 17), 255);
	vSlider->SetActionCallback({ colourChangeSlider });
	AddComponent(vSlider);


	rValue = new ui::Textbox(ui::Point(5, Size.Y-23), ui::Point(30, 17), "255");
	rValue->SetActionCallback({ colourChange });
	rValue->SetLimit(3);
	rValue->SetInputType(ui::Textbox::Number);
	AddComponent(rValue);

	gValue = new ui::Textbox(ui::Point(40, Size.Y-23), ui::Point(30, 17), "255");
	gValue->SetActionCallback({ colourChange });
	gValue->SetLimit(3);
	gValue->SetInputType(ui::Textbox::Number);
	AddComponent(gValue);

	bValue = new ui::Textbox(ui::Point(75, Size.Y-23), ui::Point(30, 17), "255");
	bValue->SetActionCallback({ colourChange });
	bValue->SetLimit(3);
	bValue->SetInputType(ui::Textbox::Number);
	AddComponent(bValue);

	aValue = new ui::Textbox(ui::Point(110, Size.Y-23), ui::Point(30, 17), "255");
	aValue->SetActionCallback({ colourChange });
	aValue->SetLimit(3);
	aValue->SetInputType(ui::Textbox::Number);
	AddComponent(aValue);

	hexValue = new::ui::Label(ui::Point(150, Size.Y-23), ui::Point(53, 17), "0xFFFFFFFF");
	AddComponent(hexValue);

	ui::Button * doneButton = new ui::Button(ui::Point(Size.X-45, Size.Y-23), ui::Point(40, 17), "Done");
	doneButton->SetActionCallback({ [this] {
		int Red, Green, Blue;
		Red = rValue->GetText().ToNumber<int>(true);
		Green = gValue->GetText().ToNumber<int>(true);
		Blue = bValue->GetText().ToNumber<int>(true);
		ui::Colour col(Red, Green, Blue, currentAlpha);
		if (onPicked)
			onPicked(col);
		Exit();
	} });
	AddComponent(doneButton);
	SetOkayButton(doneButton);

	RGB_to_HSV(initialColour.Red, initialColour.Green, initialColour.Blue, &currentHue, &currentSaturation, &currentValue);
	currentAlpha = initialColour.Alpha;
	UpdateTextboxes(initialColour.Red, initialColour.Green, initialColour.Blue, initialColour.Alpha);
	UpdateSliders();
}

void ColourPickerActivity::UpdateTextboxes(int r, int g, int b, int a)
{
	rValue->SetText(String::Build(r));
	gValue->SetText(String::Build(g));
	bValue->SetText(String::Build(b));
	aValue->SetText(String::Build(a));
	hexValue->SetText(String::Build(Format::Hex(), Format::Uppercase(), Format::Width(2), a, r, g, b));
}

void ColourPickerActivity::UpdateSliders()
{
	hSlider->SetValue(currentHue);
	sSlider->SetValue(currentSaturation);
	vSlider->SetValue(currentValue);

	int r, g, b;

	//Value gradient
	HSV_to_RGB(currentHue, currentSaturation, 255, &r, &g, &b);
	vSlider->SetColour(ui::Colour(0, 0, 0), ui::Colour(r, g, b));

	//Saturation gradient
	if (currentValue != 0)
	{
		HSV_to_RGB(currentHue, 255, currentValue, &r, &g, &b);
		sSlider->SetColour(ui::Colour(currentValue, currentValue, currentValue), ui::Colour(r, g, b));
	}
}

void ColourPickerActivity::OnTryExit(ExitMethod method)
{
	Exit();
}

void ColourPickerActivity::OnMouseMove(int x, int y, int dx, int dy)
{
	if(mouseDown)
	{
		x -= Position.X+5;
		y -= Position.Y+5;

		currentHue = int((float(x)/float(255))*359.0f);
		currentSaturation = 255-(y*2);

		if(currentSaturation > 255)
			currentSaturation = 255;
		if(currentSaturation < 0)
			currentSaturation = 0;
		if(currentHue > 359)
			currentHue = 359;
		if(currentHue < 0)
			currentHue = 0;
	}

	if(mouseDown)
	{
		int cr, cg, cb;
		HSV_to_RGB(currentHue, currentSaturation, currentValue, &cr, &cg, &cb);
		UpdateTextboxes(cr, cg, cb, currentAlpha);
		UpdateSliders();
	}
}

void ColourPickerActivity::OnMouseDown(int x, int y, unsigned button)
{
	x -= Position.X+5;
	y -= Position.Y+5;
	if(x >= 0 && x < 256 && y >= 0 && y <= 128)
	{
		mouseDown = true;
		currentHue = int((float(x)/float(255))*359.0f);
		currentSaturation = 255-(y*2);

		if(currentSaturation > 255)
			currentSaturation = 255;
		if(currentSaturation < 0)
			currentSaturation = 0;
		if(currentHue > 359)
			currentHue = 359;
		if(currentHue < 0)
			currentHue = 0;
	}

	if(mouseDown)
	{
		int cr, cg, cb;
		HSV_to_RGB(currentHue, currentSaturation, currentValue, &cr, &cg, &cb);
		UpdateTextboxes(cr, cg, cb, currentAlpha);
		UpdateSliders();
	}
}

void ColourPickerActivity::OnMouseUp(int x, int y, unsigned button)
{
	if(mouseDown)
	{
		int cr, cg, cb;
		HSV_to_RGB(currentHue, currentSaturation, currentValue, &cr, &cg, &cb);
		UpdateTextboxes(cr, cg, cb, currentAlpha);
		UpdateSliders();
	}

	if(mouseDown)
	{
		mouseDown = false;
		x -= Position.X+5;
		y -= Position.Y+5;

		currentHue = int((float(x)/float(255))*359.0f);
		currentSaturation = 255-(y*2);

		if(currentSaturation > 255)
			currentSaturation = 255;
		if(currentSaturation < 0)
			currentSaturation = 0;
		if(currentHue > 359)
			currentHue = 359;
		if(currentHue < 0)
			currentHue = 0;
	}
}

void ColourPickerActivity::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	if (key == SDLK_TAB)
	{
		if (rValue->IsFocused())
			gValue->TabFocus();
		else if (gValue->IsFocused())
			bValue->TabFocus();
		else if (bValue->IsFocused())
			aValue->TabFocus();
		else if (aValue->IsFocused())
			rValue->TabFocus();
	}
}

void ColourPickerActivity::OnDraw()
{
	Graphics * g = GetGraphics();
	g->BlendFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb .WithAlpha(currentAlpha));
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);

	g->DrawRect(RectSized(Position + Vec2{ 4, 4 }, Vec2{ 258, 130 }), 0xB4B4B4_rgb);


	auto offset = Position + Vec2{ 5, 5 };


	//draw color square
	int lastx = -1, currx = 0;
	for(int saturation = 0; saturation <= 255; saturation+=2)
	{
		for(int hue = 0; hue <= 359; hue++)
		{
			currx = clamp_flt(float(hue), 0, 359)+offset.X;
			if (currx == lastx)
				continue;
			lastx = currx;
			int cr = 0;
			int cg = 0;
			int cb = 0;
			HSV_to_RGB(hue, 255-saturation, currentValue, &cr, &cg, &cb);
			g->BlendPixel({ currx, (saturation/2)+offset.Y }, RGBA(cr, cg, cb, currentAlpha));
		}
	}

	//Draw hue bar gradient
	auto gradientWidth = hSlider->Size.X - 10;
	for (int rx = 0; rx < gradientWidth; rx++)
	{
		int red, green, blue;
		int hue = rx * 360 / gradientWidth;
		HSV_to_RGB(hue, currentSaturation, currentValue, &red, &green, &blue);
		for (int ry = 0; ry < (hSlider->Size.Y / 2) - 1; ry++)
		{
			g->BlendPixel(
				offset + hSlider->Position + Vec2{ rx, ry },
				RGBA(red, green, blue, currentAlpha)
			);
		}
	}

	//draw color square pointer
	int currentHueX = clamp_flt(float(currentHue), 0, 359);
	int currentSaturationY = ((255-currentSaturation)/2);
	g->XorLine(offset + Vec2{ currentHueX, currentSaturationY-5 }, offset + Vec2{ currentHueX, currentSaturationY-1 });
	g->XorLine(offset + Vec2{ currentHueX, currentSaturationY+1 }, offset + Vec2{ currentHueX, currentSaturationY+5 });
	g->XorLine(offset + Vec2{ currentHueX-5, currentSaturationY }, offset + Vec2{ currentHueX-1, currentSaturationY });
	g->XorLine(offset + Vec2{ currentHueX+1, currentSaturationY }, offset + Vec2{ currentHueX+5, currentSaturationY });

}


=== src\gui\colourpicker\ColourPickerActivity.h ===

#pragma once

#include "common/String.h"
#include "Activity.h"
#include "gui/interface/Colour.h"

#include <functional>

namespace ui
{
	class Textbox;
	class Label;
	class Slider;
}

class ColourPickerActivity : public WindowActivity
{
	using OnPicked = std::function<void (ui::Colour)>;

	int currentHue;
	int currentSaturation;
	int currentValue;
	int currentAlpha;

	bool mouseDown;

	ui::Slider* hSlider;
	ui::Slider* sSlider;
	ui::Slider* vSlider;

	ui::Textbox * rValue;
	ui::Textbox * gValue;
	ui::Textbox * bValue;
	ui::Textbox * aValue;
	ui::Label * hexValue;

	OnPicked onPicked;

	void UpdateTextboxes(int r, int g, int b, int a);
	void UpdateSliders();
public:
	ColourPickerActivity(ui::Colour initialColour, OnPicked onPicked = nullptr);
	virtual ~ColourPickerActivity() = default;

	void OnMouseMove(int x, int y, int dx, int dy) override;
	void OnMouseDown(int x, int y, unsigned button) override;
	void OnMouseUp(int x, int y, unsigned button) override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnTryExit(ExitMethod method) override;
	void OnDraw() override;
};


=== src\gui\colourpicker\meson.build ===

powder_files += files(
	'ColourPickerActivity.cpp',
)


=== src\gui\console\ConsoleCommand.h ===

#pragma once
#include "common/String.h"

class ConsoleCommand
{
public:
	ConsoleCommand(String command, int returnStatus, String returnValue):
		Command(command), ReturnStatus(returnStatus), ReturnValue(returnValue)
	{

	}
	String Command;
	int ReturnStatus;
	String ReturnValue;

	operator String() const
	{
		return Command;
	}
};



=== src\gui\console\ConsoleController.cpp ===

#include "ConsoleController.h"

#include "Controller.h"
#include "ConsoleView.h"
#include "ConsoleModel.h"
#include "ConsoleCommand.h"

#include "lua/CommandInterface.h"

ConsoleController::ConsoleController(std::function<void ()> onDone_, CommandInterface * commandInterface):
	HasDone(false)
{
	consoleModel = new ConsoleModel();
	consoleView = new ConsoleView();
	consoleView->AttachController(this);
	consoleModel->AddObserver(consoleView);

	onDone = onDone_;
	this->commandInterface = commandInterface;
}

void ConsoleController::EvaluateCommand(String command)
{
	if(command.length())
	{
		if (command.BeginsWith("!load "))
			CloseConsole();
		int returnCode = commandInterface->Command(command);
		consoleModel->AddLastCommand(ConsoleCommand(command, returnCode, commandInterface->GetLastError()));
	}
	else
		CloseConsole();
}

void ConsoleController::CloseConsole()
{
	consoleView->CloseActiveWindow();
}

String ConsoleController::FormatCommand(String command)
{
	return commandInterface->FormatCommand(command);
}

void ConsoleController::NextCommand()
{
	size_t cIndex = consoleModel->GetCurrentCommandIndex();
	if (cIndex < consoleModel->GetPreviousCommands().size())
		consoleModel->SetCurrentCommandIndex(cIndex+1);
}

void ConsoleController::PreviousCommand()
{
	size_t cIndex = consoleModel->GetCurrentCommandIndex();
	if(cIndex > 0)
		consoleModel->SetCurrentCommandIndex(cIndex-1);
}

void ConsoleController::Exit()
{
	consoleView->CloseActiveWindow();
	if (onDone)
		onDone();
	HasDone = true;
}

ConsoleView * ConsoleController::GetView()
{
	return consoleView;
}

ConsoleController::~ConsoleController()
{
	delete consoleModel;
	consoleView->CloseActiveWindow();
	delete consoleView;
}



=== src\gui\console\ConsoleController.h ===

#pragma once
#include "common/String.h"
#include <functional>

class CommandInterface;
class ConsoleModel;
class ConsoleView;
class ConsoleController
{
	ConsoleView * consoleView;
	ConsoleModel * consoleModel;
	CommandInterface * commandInterface;
	std::function<void ()> onDone;
public:
	bool HasDone;
	ConsoleController(std::function<void ()> onDone, CommandInterface * commandInterface);
	String FormatCommand(String command);
	void EvaluateCommand(String command);
	void NextCommand();
	void PreviousCommand();
	void Exit();
	void CloseConsole();
	ConsoleView * GetView();
	virtual ~ConsoleController();
};


=== src\gui\console\ConsoleModel.cpp ===

#include "ConsoleModel.h"
#include "ConsoleView.h"
#include "prefs/GlobalPrefs.h"

ConsoleModel::ConsoleModel() {
	std::vector<String> previousHistory = GlobalPrefs::Ref().Get("Console.History", std::vector<String>{});
	for(std::vector<String>::reverse_iterator iter = previousHistory.rbegin(), end = previousHistory.rend(); iter != end; ++iter)
	{
		if(previousCommands.size()<25)
		{
			previousCommands.push_front(ConsoleCommand(*iter, 0, ""));
			currentCommandIndex = previousCommands.size();
		}
	}
}

void ConsoleModel::AddObserver(ConsoleView * observer)
{
	observers.push_back(observer);
	observer->NotifyPreviousCommandsChanged(this);
}

size_t ConsoleModel::GetCurrentCommandIndex()
{
	return currentCommandIndex;
}

void ConsoleModel::SetCurrentCommandIndex(size_t index)
{
	currentCommandIndex = index;
	notifyCurrentCommandChanged();
}

ConsoleCommand ConsoleModel::GetCurrentCommand()
{
	if (currentCommandIndex >= previousCommands.size())
	{
		return ConsoleCommand("", 0, "");
	}
	return previousCommands[currentCommandIndex];
}

void ConsoleModel::AddLastCommand(ConsoleCommand command)
{
	previousCommands.push_back(command);
	if(previousCommands.size()>25)
		previousCommands.pop_front();
	currentCommandIndex = previousCommands.size();
	GlobalPrefs::Ref().Set("Console.History", std::vector<String>(previousCommands.begin(), previousCommands.end()));
	notifyPreviousCommandsChanged();
}

std::deque<ConsoleCommand> ConsoleModel::GetPreviousCommands()
{
	return previousCommands;
}

void ConsoleModel::notifyPreviousCommandsChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyPreviousCommandsChanged(this);
	}
}

void ConsoleModel::notifyCurrentCommandChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyCurrentCommandChanged(this);
	}
}


=== src\gui\console\ConsoleModel.h ===

#pragma once
#include "ConsoleCommand.h"
#include <vector>
#include <deque>

class ConsoleView;
class ConsoleModel
{
	size_t currentCommandIndex;
	std::vector<ConsoleView*> observers;
	std::deque<ConsoleCommand> previousCommands;
	void notifyPreviousCommandsChanged();
	void notifyCurrentCommandChanged();
public:
	size_t GetCurrentCommandIndex();
	void SetCurrentCommandIndex(size_t index);
	ConsoleCommand GetCurrentCommand();

	std::deque<ConsoleCommand> GetPreviousCommands();
	ConsoleModel();
	void AddObserver(ConsoleView * observer);
	void AddLastCommand(ConsoleCommand command);
};


=== src\gui\console\ConsoleView.cpp ===

#include "ConsoleView.h"
#include "ConsoleController.h"
#include "ConsoleModel.h"
#include "graphics/Graphics.h"
#include "ConsoleCommand.h"
#include "gui/interface/Label.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/Engine.h"
#include "SimulationConfig.h"
#include <deque>
#include <SDL.h>

ConsoleView::ConsoleView():
	ui::Window(ui::Point(0, 0), ui::Point(WINDOWW, 150)),
	commandField(nullptr)
{
	commandField = new ui::Textbox(ui::Point(0, Size.Y-16), ui::Point(Size.X, 16), "");
	commandField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	commandField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	commandField->SetActionCallback({ [this] { commandField->SetDisplayText(c->FormatCommand(commandField->GetText())); } });
	AddComponent(commandField);
	FocusComponent(commandField);
	commandField->SetBorder(false);
}

void ConsoleView::DoKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if ((ui::Engine::Ref().GraveExitsConsole && scan == SDL_SCANCODE_GRAVE && key != '~') || key == SDLK_ESCAPE || key == SDLK_AC_BACK)
	{
		if (!repeat)
			doClose = true;
		return;
	}
	switch(key)
	{
	case SDLK_RETURN:
	case SDLK_KP_ENTER:
		c->EvaluateCommand(commandField->GetText());
		commandField->SetText("");
		commandField->SetDisplayText("");
		break;
	case SDLK_DOWN:
		c->NextCommand();
		break;
	case SDLK_UP:
		if (editingNewCommand)
		{
			newCommand = commandField->GetText();
		}
		c->PreviousCommand();
		break;
	default:
		Window::DoKeyPress(key, scan, repeat, shift, ctrl, alt);
		break;
	}
}

void ConsoleView::DoTextInput(String text)
{
	if (text == "~")
		doClose = false;
	if (!doClose)
		Window::DoTextInput(text);
}

void ConsoleView::NotifyPreviousCommandsChanged(ConsoleModel * sender)
{
	for (size_t i = 0; i < commandList.size(); i++)
	{
		RemoveComponent(commandList[i]);
		delete commandList[i];
	}
	commandList.clear();
	std::deque<ConsoleCommand> commands = sender->GetPreviousCommands();
	int currentY = Size.Y - 32;
	if(commands.size())
		for(int i = commands.size()-1; i >= 0; i--)
		{
			if(currentY <= 0)
				break;
			ui::Label * tempLabel = new ui::Label(ui::Point(Size.X/2, currentY), ui::Point(Size.X/2, 16), commands[i].ReturnValue);
			tempLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
			tempLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
			commandList.push_back(tempLabel);
			AddComponent(tempLabel);
			tempLabel = new ui::Label(ui::Point(0, currentY), ui::Point(Size.X/2, 16), commands[i].Command);
			tempLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
			tempLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
			commandList.push_back(tempLabel);
			AddComponent(tempLabel);
			currentY-=16;
		}
}

void ConsoleView::NotifyCurrentCommandChanged(ConsoleModel * sender)
{
	bool oldEditingNewCommand = editingNewCommand;
	editingNewCommand = sender->GetCurrentCommandIndex() >= sender->GetPreviousCommands().size();
	if (!oldEditingNewCommand && editingNewCommand)
	{
		commandField->SetText(newCommand);
	}
	else
	{
		commandField->SetText(sender->GetCurrentCommand().Command);
	}
	commandField->SetDisplayText(c->FormatCommand(commandField->GetText()));
}


void ConsoleView::OnDraw()
{
	Graphics * g = GetGraphics();
	g->BlendFilledRect(RectSized(Position, Size), 0x000000_rgb .WithAlpha(110));
	g->BlendLine(Position + Vec2{ 0, Size.Y-16 }, Position + Size - Vec2{ 0, 16 }, 0xFFFFFF_rgb .WithAlpha(160));
	g->BlendLine(Position + Vec2{ 0, Size.Y }, Position + Size, 0xFFFFFF_rgb .WithAlpha(200));
}

void ConsoleView::OnTick()
{
	if (doClose)
	{
		c->CloseConsole();
		doClose = false;
	}
}

ConsoleView::~ConsoleView()
{
}



=== src\gui\console\ConsoleView.h ===

#pragma once
#include "gui/interface/Window.h"
#include <vector>

namespace ui
{
	class Label;
	class Textbox;
}

class ConsoleController;
class ConsoleModel;
class ConsoleView: public ui::Window
{
	ConsoleController * c;
	ui::Textbox * commandField;
	std::vector<ui::Label*> commandList;
	bool doClose = false;
	String newCommand;
	bool editingNewCommand = true;
public:
	ConsoleView();
	void OnDraw() override;
	void OnTick() override;
	void DoKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void DoTextInput(String text) override;
	void AttachController(ConsoleController * c_) { c = c_; }
	void NotifyPreviousCommandsChanged(ConsoleModel * sender);
	void NotifyCurrentCommandChanged(ConsoleModel * sender);
	virtual ~ConsoleView();
};


=== src\gui\console\meson.build ===

powder_files += files(
	'ConsoleController.cpp',
	'ConsoleModel.cpp',
	'ConsoleView.cpp',
)


=== src\gui\credits\Credits.cpp ===

#include "Credits.h"

#include <json/json.h>

#include "credits_json.h"
#include "gui/Style.h"

#include "common/platform/Platform.h"
#include "gui/interface/AvatarButton.h"
#include "gui/interface/Button.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Label.h"
#include "gui/interface/RichLabel.h"
#include "gui/interface/ScrollPanel.h"
#include "gui/interface/Separator.h"

Credits::Credits():
	ui::Window(ui::Point(-1, -1), ui::Point(WINDOWW, WINDOWH))
{
	Json::Value root;
	Json::Reader reader;
	auto credits = credits_json.AsCharSpan();
	if (bool parsed = reader.parse(credits.data(), credits.data() + credits.size(), root, false); !parsed) {
		// Failure. Shouldn't ever happen.
		return;
	}

	auto *scrollPanel = new ui::ScrollPanel(ui::Point(0, 0), ui::Point(Size.X, Size.Y - 12));
	AddComponent(scrollPanel);

	int xPos = 0, yPos = 0, row = 0;
	int nextY = 0;

	// Organize blocks of components of equal width into rows, and add them to the scroll panel
	auto organizeComponents = [&xPos, &yPos, &nextY, &row, &scrollPanel](const auto& components, const int panelWidth) {
		ui::Point blockSize = { 0, 0 };
		for (const auto &component : components)
		{
			blockSize.X = std::max(blockSize.X, component->Position.X + component->Size.X);
			blockSize.Y = std::max(blockSize.Y, component->Position.Y + component->Size.Y);
		}

		// New row, offset x position to ensure entire row is centered
		if (xPos == 0)
			xPos = (panelWidth % blockSize.X) / 2;
		for (const auto &component : components)
			component->Position += ui::Point({ xPos, yPos });

		xPos += blockSize.X;
		nextY =  std::max(nextY, yPos + blockSize.Y);
		if (xPos + blockSize.X > panelWidth)
		{
			xPos = 0;
			yPos = nextY + 8;
			row++;
		}

		for (const auto &component : components)
			scrollPanel->AddChild(component);
	};

	// Add header and separator for each section of credits
	auto addHeader = [&xPos, &yPos, &nextY, &row, &scrollPanel](const String &text, const bool addSeparator = true) {
		xPos = 0;
		yPos = nextY + 10;
		row = 0;

		if (addSeparator)
		{
			auto *separator = new ui::Separator(ui::Point(0, yPos), ui::Point(scrollPanel->Size.X, 1));
			scrollPanel->AddChild(separator);
			yPos += 6;
		}

		auto *label = new ui::RichLabel(ui::Point(4, yPos), ui::Point(scrollPanel->Size.X, 24), text);
		label->SetTextColour(style::Colour::InformationTitle);
		label->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
		label->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		scrollPanel->AddChild(label);
		yPos += label->Size.Y + 8;
	};


	addHeader("The Powder Toy is an open source project, developed by members of the community.\n"
			"We'd like to thank everyone who contributed to our \bt{a:https://github.com/The-Powder-Toy/The-Powder-Toy|GitHub repo}\x0E:", false);

	auto GitHub = root["GitHub"];
	int grayscale = 255;
	for (auto &item : GitHub)
	{
		ByteString username = item.asString();
		auto components = AddCredit(username.FromUtf8(), "", Small, "", false, grayscale);
		organizeComponents(components, scrollPanel->Size.X);
		if (grayscale > 180)
			grayscale--;
	}


	addHeader("Staff - volunteers that run the community and keep the site running");

	auto Moderators = root["Moderators"];
	for (auto &item : Moderators)
	{
		ByteString username = item["username"].asString();
		ByteString role = item["role"].asString();

		if (role == "Moderator" || role == "HalfMod")
		{
			auto components = AddCredit(username.FromUtf8(), "", Large, GetProfileUri(username), true);
			organizeComponents(components, scrollPanel->Size.X);
		}
	}


	addHeader("Former Staff", false);

	for (auto &item : Moderators)
	{
		ByteString username = item["username"].asString();
		ByteString role = item["role"].asString();

		if (role == "Former Staff")
		{
			auto components = AddCredit(username.FromUtf8(), "", Small, "", true);
			organizeComponents(components, scrollPanel->Size.X);
		}
	}


	addHeader("The following users have been credited in the intro text from the start.\n"
			"Their contributions to the early beginnings of The Powder Toy were invaluable in shaping it into what it is today.");

	auto OrigCredits = root["OrigCredits"];
	for (auto &item : OrigCredits)
	{
		ByteString realname = item["realname"].asString();
		ByteString message = item["message"].asString();

		auto components = AddCredit(realname.FromUtf8(), message.FromUtf8(), row == 0 ? Half : Small, "");
		organizeComponents(components, scrollPanel->Size.X);
	}


	scrollPanel->InnerSize = ui::Point(scrollPanel->Size.X, nextY);

	auto *closeButton = new ui::Button({ 0, Size.Y - 12 }, { Size.X, 12 }, "Close");
	closeButton->SetActionCallback({
	[this] {
		CloseActiveWindow();
	}  });
	AddComponent(closeButton);
}

std::vector<ui::Component *> Credits::AddCredit(const String &name, const String &subheader, const CreditSize size,
	const ByteString &uri, const bool includeAvatar, const int grayscale)
{
	std::vector<ui::Component *> components;
	int creditBlockWidth = size == Small ? 100 : (size == Large ? 155 : 310);
	int y = 0;

	if (includeAvatar)
	{
		int avatarWidth = size == Small ? 40 : 64;
		int avatarSize = size == Small ? 40 : 256;
		auto *avatarButton = new ui::AvatarButton(ui::Point((creditBlockWidth - avatarWidth) / 2, 0), ui::Point(avatarWidth, avatarWidth), name.ToUtf8(), avatarSize);
		if (!uri.empty())
		{
			avatarButton->SetActionCallback({[uri] {
				Platform::OpenURI(uri);
			} });
		}
		components.push_back(avatarButton);

		y += avatarButton->Size.Y + 2;
	}

	if (!name.empty())
	{
		auto labelText = !uri.empty() ? GetRichLabelText(uri, name) : name;
		auto *nameLabel = new ui::RichLabel(ui::Point(0, y), ui::Point(creditBlockWidth, 14), labelText);
		nameLabel->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
		nameLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		nameLabel->SetTextColour(ui::Colour(grayscale, grayscale, grayscale));
		components.push_back(nameLabel);

		y += nameLabel->Size.Y + 2;
	}

	if (!subheader.empty())
	{
		auto *subheaderLabel = new ui::Label(ui::Point(0, y), ui::Point(creditBlockWidth, 14), subheader);
		subheaderLabel->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
		subheaderLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		int col = (int)((float)grayscale * .67f);
		subheaderLabel->SetTextColour(ui::Colour(col, col, col));
		components.push_back(subheaderLabel);
	}

	return components;
}

ByteString Credits::GetProfileUri(const ByteString &username)
{
	return "https://powdertoy.co.uk/User.html?Name=" + username;
}

String Credits::GetRichLabelText(const ByteString &uri, const String &message)
{
	StringBuilder builder;
	builder << "{a:" << uri.FromUtf8() << "|" << message << "}";
	return builder.Build();
}

void Credits::OnTryExit(ExitMethod method)
{
	ui::Engine::Ref().CloseWindow();
}


=== src\gui\credits\Credits.h ===

#pragma once
#include <vector>
#include "gui/interface/Window.h"

class Credits : public ui::Window
{
	enum CreditSize
	{
		Small,
		Large,
		Half,
	};

	static std::vector<ui::Component *> AddCredit(const String &name, const String &subheader, CreditSize size,
		const ByteString &uri, bool includeAvatar = false, int grayscale = 255);
	static ByteString GetProfileUri(const ByteString &username);
	static ByteString GetTptLabelText(const ByteString &tpt, const ByteString &github);
	static String GetRichLabelText(const ByteString &uri, const String &message);
public:
	Credits();

	void OnTryExit(ExitMethod method) override;
};


=== src\gui\credits\meson.build ===

powder_files += files(
	'Credits.cpp',
)


=== src\gui\dialogues\ConfirmPrompt.cpp ===

#include "ConfirmPrompt.h"

#include "gui/Style.h"

#include "gui/interface/Button.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Label.h"
#include "gui/interface/ScrollPanel.h"

#include "PowderToySDL.h"

#include "graphics/Graphics.h"

ConfirmPrompt::ConfirmPrompt(String title, String message, ResultCallback callback_, String buttonText):
	ui::Window(ui::Point(-1, -1), ui::Point(250, 50)),
	callback(callback_)
{
	ui::Label * titleLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 15), title);
	titleLabel->SetTextColour(style::Colour::WarningTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);


	ui::ScrollPanel *messagePanel = new ui::ScrollPanel(ui::Point(4, 24), ui::Point(Size.X-8, 206));
	AddComponent(messagePanel);

	ui::Label * messageLabel = new ui::Label(ui::Point(4, 0), ui::Point(Size.X-28, -1), message);
	messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	messageLabel->SetMultiline(true);
	messagePanel->AddChild(messageLabel);

	messagePanel->InnerSize = ui::Point(messagePanel->Size.X, messageLabel->Size.Y+4);

	if (messageLabel->Size.Y < messagePanel->Size.Y)
		messagePanel->Size.Y = messageLabel->Size.Y+4;
	Size.Y += messagePanel->Size.Y+12;
	Position.Y = (GetGraphics()->Size().Y - Size.Y)/2;

	ui::Button * cancelButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point(Size.X-75, 16), "Cancel");
	cancelButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	cancelButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	cancelButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
	cancelButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		if (callback.cancel)
			callback.cancel();
		SelfDestruct();
	} });
	AddComponent(cancelButton);
	SetCancelButton(cancelButton);

	ui::Button * okayButton = new ui::Button(ui::Point(Size.X-76, Size.Y-16), ui::Point(76, 16), buttonText);
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.TextInactive = style::Colour::WarningTitle;
	okayButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		if (callback.okay)
			callback.okay();
		SelfDestruct();
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);

	MakeActiveWindow();
}

void ConfirmPrompt::OnDraw()
{
	Graphics * g = GetGraphics();

	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);
}


=== src\gui\dialogues\ConfirmPrompt.h ===

#pragma once
#include "gui/interface/Window.h"

#include <functional>

class ConfirmPrompt : public ui::Window
{
	struct ResultCallback
	{
		std::function<void ()> okay, cancel;
	};

	ResultCallback callback;

public:
	ConfirmPrompt(String title, String message, ResultCallback callback_ = {}, String buttonText = String("Confirm"));
	virtual ~ConfirmPrompt() = default;

	void OnDraw() override;
};


=== src\gui\dialogues\ErrorMessage.cpp ===

#include "ErrorMessage.h"

#include "gui/Style.h"

#include "gui/interface/Button.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Label.h"

#include "PowderToySDL.h"

#include "graphics/Graphics.h"

ErrorMessage::ErrorMessage(String title, String message, DismissCallback callback_):
	ui::Window(ui::Point(-1, -1), ui::Point(200, 35)),
	callback(callback_)
{
	ui::Label * titleLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 16), title);
	titleLabel->SetTextColour(style::Colour::ErrorTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);

	ui::Label * messageLabel = new ui::Label(ui::Point(4, 24), ui::Point(Size.X-8, -1), message);
	messageLabel->SetMultiline(true);
	messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	AddComponent(messageLabel);

	Size.Y += messageLabel->Size.Y+12;
	Position.Y = (GetGraphics()->Size().Y - Size.Y)/2;

	ui::Button * okayButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point(Size.X, 16), "Dismiss");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
	okayButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		if (callback.dismiss)
			callback.dismiss();
		SelfDestruct();
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);
	SetCancelButton(okayButton);

	MakeActiveWindow();
}

void ErrorMessage::OnDraw()
{
	Graphics * g = GetGraphics();

	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);
}


=== src\gui\dialogues\ErrorMessage.h ===

#pragma once
#include "gui/interface/Window.h"

#include <functional>

class ErrorMessage : public ui::Window
{
	struct DismissCallback
	{
		std::function<void ()> dismiss;
	};

	DismissCallback callback;

public:
	ErrorMessage(String title, String message, DismissCallback callback_ = {});
	virtual ~ErrorMessage() = default;

	void OnDraw() override;
};


=== src\gui\dialogues\InformationMessage.cpp ===

#include "InformationMessage.h"

#include "gui/Style.h"
#include "gui/interface/Button.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Label.h"
#include "gui/interface/ScrollPanel.h"

#include "graphics/Graphics.h"

InformationMessage::InformationMessage(String title, String message, bool large, DismissCallback callback_):
	ui::Window(ui::Point(-1, -1), ui::Point(200, 35)),
	callback(callback_)
{
	if (large) //Maybe also use this large mode for changelogs eventually, or have it as a customizable size?
	{
		Size.X += 200;
		Size.Y += 215;
	}

	if (large)
	{
		ui::ScrollPanel *messagePanel = new ui::ScrollPanel(ui::Point(4, 24), ui::Point(Size.X-8, 206));
		AddComponent(messagePanel);

		ui::Label * messageLabel = new ui::Label(ui::Point(4, 0), ui::Point(Size.X-28, -1), message);
		messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
		messageLabel->SetMultiline(true);
		messagePanel->AddChild(messageLabel);

		messagePanel->InnerSize = ui::Point(messagePanel->Size.X, messageLabel->Size.Y+4);
	}
	else
	{
		ui::ScrollPanel *messagePanel = new ui::ScrollPanel(ui::Point(4, 24), ui::Point(Size.X-8, 206));
		AddComponent(messagePanel);

		ui::Label * messageLabel = new ui::Label(ui::Point(4, 0), ui::Point(Size.X-8, -1), message);
		messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
		messageLabel->SetMultiline(true);
		messagePanel->AddChild(messageLabel);

		messagePanel->InnerSize = ui::Point(messagePanel->Size.X, messageLabel->Size.Y+4);

		if (messageLabel->Size.Y < messagePanel->Size.Y)
			messagePanel->Size.Y = messageLabel->Size.Y+4;
		Size.Y += messagePanel->Size.Y+12;
		Position.Y = (GetGraphics()->Size().Y - Size.Y) / 2;
	}

	ui::Label * titleLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 16), title);
	titleLabel->SetTextColour(style::Colour::InformationTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);

	ui::Button * okayButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point(Size.X, 16), "Dismiss");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
	okayButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		if (callback.dismiss)
			callback.dismiss();
		SelfDestruct(); //TODO: Fix component disposal
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);
	SetCancelButton(okayButton);

	MakeActiveWindow();
}

void InformationMessage::OnDraw()
{
	Graphics * g = GetGraphics();

	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);
}


=== src\gui\dialogues\InformationMessage.h ===

#pragma once
#include "gui/interface/Window.h"

class InformationMessage : public ui::Window
{
	struct DismissCallback
	{
		std::function<void ()> dismiss;
	};

	DismissCallback callback;

public:
	InformationMessage(String title, String message, bool large, DismissCallback callback_ = {});
	virtual ~InformationMessage() = default;

	void OnDraw() override;
};


=== src\gui\dialogues\meson.build ===

gui_files += files(
	'ConfirmPrompt.cpp',
	'ErrorMessage.cpp',
	'InformationMessage.cpp',
	'SaveIDMessage.cpp',
	'TextPrompt.cpp',
)


=== src\gui\dialogues\SaveIDMessage.cpp ===

#include "SaveIDMessage.h"
#include "gui/Style.h"
#include "graphics/Graphics.h"
#include "gui/interface/Button.h"
#include "gui/interface/CopyTextButton.h"
#include "gui/interface/Label.h"
#include "Format.h"
#include "SimulationConfig.h"

SaveIDMessage::SaveIDMessage(int id):
	ui::Window(ui::Point((XRES-244)/2, (YRES-90)/2), ui::Point(244, 90))
{
	int textWidth = Graphics::TextSize("Save ID").X - 1;
	ui::Label * titleLabel = new ui::Label(ui::Point(4, 5), ui::Point(textWidth+20, 16), "Save ID");
	titleLabel->SetTextColour(style::Colour::InformationTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);

	textWidth = Graphics::TextSize("Saved Successfully!").X - 1;
	ui::Label * messageLabel = new ui::Label(ui::Point(4, 24), ui::Point(textWidth+20, 16), "Saved Successfully!");
	messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	AddComponent(messageLabel);

	textWidth = Graphics::TextSize("Click the box below to copy the save ID").X - 1;
	ui::Label * copyTextLabel = new ui::Label(ui::Point((Size.X-textWidth-20)/2, 35), ui::Point(textWidth+20, 16), "Click the box below to copy the save id");
	copyTextLabel->SetTextColour(ui::Colour(150, 150, 150));
	copyTextLabel->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	AddComponent(copyTextLabel);

	textWidth = Graphics::TextSize(String::Build(id)).X - 1;
	ui::CopyTextButton * copyTextButton = new ui::CopyTextButton(ui::Point((Size.X-textWidth-10)/2, 50), ui::Point(textWidth+10, 18), String::Build(id), copyTextLabel);
	AddComponent(copyTextButton);

	ui::Button * okayButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point(Size.X, 16), "OK");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		SelfDestruct();
	} });
	AddComponent(okayButton);
	// This button has multiple personalities
	SetOkayButton(okayButton);
	SetCancelButton(okayButton);

	MakeActiveWindow();
}

void SaveIDMessage::OnDraw()
{
	Graphics * g = GetGraphics();

	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);
}

void SaveIDMessage::OnTryExit(ExitMethod method)
{
	CloseActiveWindow();
	SelfDestruct();
}


=== src\gui\dialogues\SaveIDMessage.h ===

#pragma once
#include "gui/interface/Window.h"

class SaveIDMessage : public ui::Window
{
public:
	SaveIDMessage(int id);
	virtual ~SaveIDMessage() = default;

	void OnDraw() override;
	void OnTryExit(ExitMethod method) override;
};


=== src\gui\dialogues\TextPrompt.cpp ===

#include "TextPrompt.h"

#include "gui/interface/Label.h"
#include "gui/interface/Button.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Textbox.h"

#include "gui/Style.h"

#include "graphics/Graphics.h"

TextPrompt::TextPrompt(String title, String message, String text, String placeholder, bool multiline, TextDialogueCallback callback_):
	ui::Window(ui::Point(-1, -1), ui::Point(200, 65)),
	callback(callback_)
{
	if(multiline)
		Size.X += 100;

	ui::Label * titleLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 18), title);
	titleLabel->SetTextColour(style::Colour::WarningTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);

	ui::Label * messageLabel = new ui::Label(ui::Point(4, 25), ui::Point(Size.X-8, -1), message);
	messageLabel->SetMultiline(true);
	messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	AddComponent(messageLabel);

	Size.Y += messageLabel->Size.Y+4;

	textField = new ui::Textbox(ui::Point(4, messageLabel->Position.Y + messageLabel->Size.Y + 7), ui::Point(Size.X-8, 16), text, placeholder);
	if(multiline)
	{
		textField->SetMultiline(true);
		textField->Size.Y = 60;
		Size.Y += 45;
		textField->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	}
	else
	{
		textField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	}
	textField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	AddComponent(textField);
	FocusComponent(textField);

	ui::Button * cancelButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point((Size.X/2)+1, 16), "Cancel");
	cancelButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	cancelButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	cancelButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
	cancelButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		if (callback.cancel)
			callback.cancel();
		SelfDestruct();
	} });
	AddComponent(cancelButton);
	SetCancelButton(cancelButton);

	ui::Button * okayButton = new ui::Button(ui::Point(Size.X/2, Size.Y-16), ui::Point(Size.X/2, 16), "Okay");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignRight;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.TextInactive = style::Colour::WarningTitle;
	okayButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		if (callback.text)
			callback.text(textField->GetText());
		SelfDestruct();
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);

	MakeActiveWindow();
}

void TextPrompt::OnDraw()
{
	Graphics * g = GetGraphics();

	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);
}


=== src\gui\dialogues\TextPrompt.h ===

#pragma once
#include "gui/interface/Window.h"

#include <functional>

namespace ui
{
	class Textbox;
}

class TextPrompt : public ui::Window
{
	struct TextDialogueCallback
	{
		std::function<void (String const &)> text;
		std::function<void ()> cancel;
	};

	TextDialogueCallback callback;

protected:
	ui::Textbox * textField;

public:
	TextPrompt(String title, String message, String text, String placeholder, bool multiline, TextDialogueCallback callback_ = {});
	virtual ~TextPrompt() = default;

	void OnDraw() override;
};


=== src\gui\elementsearch\ElementSearchActivity.cpp ===

#include "ElementSearchActivity.h"

#include <set>
#include <map>
#include <algorithm>
#include <SDL.h>

#include "gui/interface/Textbox.h"
#include "gui/interface/ScrollPanel.h"
#include "gui/interface/Label.h"
#include "gui/game/tool/Tool.h"
#include "gui/game/Menu.h"
#include "gui/Style.h"
#include "gui/game/Favorite.h"
#include "gui/game/GameController.h"
#include "gui/game/ToolButton.h"
#include "gui/game/Favorite.h"

#include "graphics/Graphics.h"

ElementSearchActivity::ElementSearchActivity(GameController * gameController, std::vector<Tool*> tools) :
	WindowActivity(ui::Point(-1, -1), ui::Point(236, 302)),
	firstResult(nullptr),
	gameController(gameController),
	tools(tools),
	toolTip(""),
	shiftPressed(false),
	ctrlPressed(false),
	altPressed(false),
	isToolTipFadingIn(false),
	exit(false)
{
	ui::Label * title = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 15), "Element Search");
	title->SetTextColour(style::Colour::InformationTitle);
	title->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	AddComponent(title);

	searchField = new ui::Textbox(ui::Point(8, 23), ui::Point(Size.X-16, 17), "");
	searchField->SetActionCallback({ [this] { searchTools(searchField->GetText()); } });
	searchField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	AddComponent(searchField);
	FocusComponent(searchField);

	ui::Button * closeButton = new ui::Button(ui::Point(0, Size.Y-15), ui::Point((Size.X/2)+1, 15), "Close");
	closeButton->SetActionCallback({ [this] { exit = true; } });
	ui::Button * okButton = new ui::Button(ui::Point(Size.X/2, Size.Y-15), ui::Point(Size.X/2, 15), "OK");
	okButton->SetActionCallback({ [this] {
		if (GetFirstResult())
			SetActiveTool(0, GetFirstResult());
	} });

	AddComponent(okButton);
	AddComponent(closeButton);

	scrollPanel = new ui::ScrollPanel(searchField->Position + Vec2{ 1, searchField->Size.Y+9 }, { searchField->Size.X - 2, Size.Y-(searchField->Position.Y+searchField->Size.Y+6)-23 });
	AddComponent(scrollPanel);

	searchTools("");
}

void ElementSearchActivity::searchTools(String query)
{
	firstResult = nullptr;
	for (auto &toolButton : toolButtons) {
		scrollPanel->RemoveChild(toolButton);
		delete toolButton;
	}
	toolButtons.clear();

	ui::Point viewPosition = { 1, 1 };
	ui::Point current = ui::Point(0, 0);

	String queryLower = query.ToLower();

	struct Match
	{
		int favouritePriority; // relevant by whether the tool is favourited
		int toolIndex; // relevance by position of tool in tools vector
		int haystackOrigin; // relevance by origin of haystack
		int needlePosition; // relevance by position of needle in haystack

		bool operator <(Match const &other) const
		{
			return std::tie(favouritePriority, haystackOrigin, needlePosition, toolIndex) < std::tie(other.favouritePriority, other.haystackOrigin, other.needlePosition, other.toolIndex);
		}
	};

	std::set<ByteString> favs;
	for (auto fav : Favorite::Ref().GetFavoritesList())
	{
		favs.insert(fav);
	}

	std::map<int, Match> indexToMatch;
	auto push = [ &indexToMatch ](Match match) {
		auto it = indexToMatch.find(match.toolIndex);
		if (it == indexToMatch.end())
		{
			indexToMatch.insert(std::make_pair(match.toolIndex, match));
		}
		else if (match < it->second)
		{
			it->second = match;
		}
	};

	auto pushIfMatches = [ &queryLower, &push ](String infoLower, int toolIndex, int favouritePriority, int haystackRelevance) {
		if (infoLower == queryLower)
		{
			push(Match{ favouritePriority, toolIndex, haystackRelevance, 0 });
		}
		if (infoLower.BeginsWith(queryLower))
		{
			push(Match{ favouritePriority, toolIndex, haystackRelevance, 1 });
		}
		if (infoLower.Contains(queryLower))
		{
			push(Match{ favouritePriority, toolIndex, haystackRelevance, 2 });
		}
	};

	std::map<Tool *, String> menudescriptionLower;
	for (auto *menu : gameController->GetMenuList())
	{
		for (auto *tool : menu->GetToolList())
		{
			menudescriptionLower.insert(std::make_pair(tool, menu->GetDescription().ToLower()));
		}
	}

	for (int toolIndex = 0; toolIndex < (int)tools.size(); ++toolIndex)
	{
		int favouritePriority = favs.find(tools[toolIndex]->Identifier) != favs.end() ? 0 : 1;
		pushIfMatches(tools[toolIndex]->Name.ToLower(), toolIndex, favouritePriority, 0);
		pushIfMatches(tools[toolIndex]->Description.ToLower(), toolIndex, favouritePriority, 1);
		auto it = menudescriptionLower.find(tools[toolIndex]);
		if (it != menudescriptionLower.end())
		{
			pushIfMatches(it->second, toolIndex, favouritePriority, 2);
		}
	}

	std::vector<Match> matches;
	std::transform(indexToMatch.begin(), indexToMatch.end(), std::back_inserter(matches), [](decltype(indexToMatch)::value_type const &pair) {
		return pair.second;
	});
	std::sort(matches.begin(), matches.end());
	for (auto &match : matches)
	{
		Tool *tool = tools[match.toolIndex];

		if(!firstResult)
			firstResult = tool;

		std::unique_ptr<VideoBuffer> tempTexture = tool->GetTexture(Vec2(26, 14));
		ToolButton * tempButton;

		if(tempTexture)
			tempButton = new ToolButton(current+viewPosition, ui::Point(30, 18), "", tool->Identifier, tool->Description);
		else
			tempButton = new ToolButton(current+viewPosition, ui::Point(30, 18), tool->Name, tool->Identifier, tool->Description);

		tempButton->Appearance.SetTexture(std::move(tempTexture));
		tempButton->Appearance.BackgroundInactive = tool->Colour.WithAlpha(0xFF);
		tempButton->SetActionCallback({ [this, tempButton, tool] {
			if (tempButton->GetSelectionState() >= 0 && tempButton->GetSelectionState() <= 2)
				SetActiveTool(tempButton->GetSelectionState(), tool);
		} });

		if(gameController->GetActiveTool(0) == tool)
		{
			tempButton->SetSelectionState(0);	//Primary
		}
		else if(gameController->GetActiveTool(1) == tool)
		{
			tempButton->SetSelectionState(1);	//Secondary
		}
		else if(gameController->GetActiveTool(2) == tool)
		{
			tempButton->SetSelectionState(2);	//Tertiary
		}

		toolButtons.push_back(tempButton);
		scrollPanel->AddChild(tempButton);

		current.X += 31;

		if(current.X + 30 > searchField->Size.X) {
			current.X = 0;
			current.Y += 19;
		}
	}

	if (current.X == 0)
	{
		current.Y -= 19;
	}
	scrollPanel->InnerSize = ui::Point(scrollPanel->Size.X, current.Y + 20);
}

void ElementSearchActivity::SetActiveTool(int selectionState, Tool * tool)
{
	if (ctrlPressed && shiftPressed && !altPressed)
	{
		Favorite::Ref().AddFavorite(tool->Identifier);
		gameController->RebuildFavoritesMenu();
	}
	else if (ctrlPressed && altPressed && !shiftPressed &&
	         tool->Identifier.BeginsWith("DEFAULT_PT_"))
	{
		gameController->SetActiveTool(3, tool);
	}
	else
		gameController->SetActiveTool(selectionState, tool);
	exit = true;
}

void ElementSearchActivity::OnDraw()
{
	Graphics * g = GetGraphics();
	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);

	g->BlendRect(
		RectSized(Position + scrollPanel->Position - Vec2{ 1, 1 }, scrollPanel->Size + Vec2{ 2, 2 }),
		0xFFFFFF_rgb .WithAlpha(180));
	if (toolTipPresence && toolTip.length())
	{
		g->BlendText({ 10, Size.Y+70 }, toolTip, 0xFFFFFF_rgb .WithAlpha(toolTipPresence>51?255:toolTipPresence*5));
	}
}

void ElementSearchActivity::OnTick()
{
	if (exit)
		Exit();

	if (isToolTipFadingIn)
	{
		isToolTipFadingIn = false;
		toolTipPresence.SetTarget(120);
	}
	else
	{
		toolTipPresence.SetTarget(0);
	}
}

void ElementSearchActivity::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	switch (key)
	{
	case SDLK_KP_ENTER:
	case SDLK_RETURN:
		if(firstResult)
			gameController->SetActiveTool(0, firstResult);
	case SDLK_ESCAPE:
	case SDLK_AC_BACK:
		exit = true;
		break;
	case SDLK_LSHIFT:
	case SDLK_RSHIFT:
		shiftPressed = true;
		break;
	case SDLK_LCTRL:
	case SDLK_RCTRL:
		ctrlPressed = true;
		break;
	case SDLK_LALT:
	case SDLK_RALT:
		altPressed = true;
		break;
	}
}

void ElementSearchActivity::OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	switch (key)
	{
	case SDLK_LSHIFT:
	case SDLK_RSHIFT:
		shiftPressed = false;
		break;
	case SDLK_LCTRL:
	case SDLK_RCTRL:
		ctrlPressed = false;
		break;
	case SDLK_LALT:
	case SDLK_RALT:
		altPressed = false;
		break;
	}
}

void ElementSearchActivity::ToolTip(ui::Point senderPosition, String toolTip)
{
	this->toolTip = toolTip;
	this->isToolTipFadingIn = true;
}

ElementSearchActivity::~ElementSearchActivity() {
}



=== src\gui\elementsearch\ElementSearchActivity.h ===

#pragma once
#include "Activity.h"
#include "common/String.h"
#include "gui/interface/Point.h"
#include "gui/interface/Fade.h"
#include <vector>

class Tool;
class ToolButton;
class GameController;

namespace ui
{
	class ScrollPanel;
	class Textbox;
}

class ElementSearchActivity: public WindowActivity
{
	Tool * firstResult;
	GameController * gameController;
	std::vector<Tool*> tools;
	ui::Textbox * searchField;
	std::vector<ToolButton*> toolButtons;
	ui::ScrollPanel *scrollPanel = nullptr;
	String toolTip;
	ui::Fade toolTipPresence{ ui::Fade::LinearProfile{ 120.f, 60.f }, 0, 0 };
	bool shiftPressed;
	bool ctrlPressed;
	bool altPressed;
	bool isToolTipFadingIn;
	void searchTools(String query);

public:
	bool exit;
	Tool * GetFirstResult() { return firstResult; }
	ElementSearchActivity(GameController * gameController, std::vector<Tool*> tools);
	void SetActiveTool(int selectionState, Tool * tool);
	virtual ~ElementSearchActivity();
	void OnTick() override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnDraw() override;
	void ToolTip(ui::Point senderPosition, String ToolTip) override;
};


=== src\gui\elementsearch\meson.build ===

powder_files += files(
	'ElementSearchActivity.cpp',
)


=== src\gui\filebrowser\FileBrowserActivity.cpp ===

#include "FileBrowserActivity.h"

#include "client/GameSave.h"
#include "client/SaveFile.h"
#include "common/platform/Platform.h"
#include "graphics/Graphics.h"
#include "gui/Style.h"
#include "tasks/Task.h"

#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/dialogues/TextPrompt.h"
#include "gui/interface/Label.h"
#include "gui/interface/ProgressBar.h"
#include "gui/interface/SaveButton.h"
#include "gui/interface/ScrollPanel.h"
#include "gui/interface/Textbox.h"

#include "Config.h"
#include <algorithm>

//Currently, reading is done on another thread, we can't render outside the main thread due to some bullshit with OpenGL
class LoadFilesTask: public Task
{
	ByteString directory;
	ByteString search;
	std::vector<std::unique_ptr<SaveFile>> saveFiles;

	void before() override
	{

	}

	void after() override
	{

	}

	bool doWork() override
	{
		std::vector<ByteString> files = Platform::DirectorySearch(directory, search, { ".cps" });
		std::sort(files.rbegin(), files.rend(), [](ByteString a, ByteString b) { return a.ToLower() > b.ToLower(); });

		notifyProgress(-1);
		for(std::vector<ByteString>::iterator iter = files.begin(), end = files.end(); iter != end; ++iter)
		{
			auto saveFile = std::make_unique<SaveFile>(directory + *iter, true);

			ByteString filename = (*iter).SplitFromEndBy(PATH_SEP_CHAR).After();
			filename = filename.SplitFromEndBy('.').Before();
			saveFile->SetDisplayName(filename.FromUtf8());
			saveFiles.push_back(std::move(saveFile));
		}
		return true;
	}

public:
	std::vector<std::unique_ptr<SaveFile>> TakeSaveFiles()
	{
		return std::move(saveFiles);
	}

	LoadFilesTask(ByteString directory, ByteString search):
		directory(directory),
		search(search)
	{

	}
};

FileBrowserActivity::FileBrowserActivity(ByteString directory, OnSelected onSelected_):
	WindowActivity(ui::Point(-1, -1), ui::Point(500, 350)),
	onSelected(onSelected_),
	directory(directory),
	hasQueuedSearch(false),
	totalFiles(0)
{

	ui::Label * titleLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 18), "Save Browser");
	titleLabel->SetTextColour(style::Colour::WarningTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);

	ui::Textbox * textField = new ui::Textbox(ui::Point(8, 25), ui::Point(Size.X-16, 16), "", "[search]");
	textField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	textField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	textField->SetActionCallback({ [this, textField] { DoSearch(textField->GetText().ToUtf8()); } });
	AddComponent(textField);
	FocusComponent(textField);

	itemList = new ui::ScrollPanel(ui::Point(4, 45), ui::Point(Size.X-8, Size.Y-53));
	itemList->Visible = false;
	AddComponent(itemList);

	progressBar = new ui::ProgressBar(ui::Point((Size.X-200)/2, 45+(Size.Y-66)/2), ui::Point(200, 17));
	AddComponent(progressBar);

	infoText = new ui::Label(ui::Point((Size.X-200)/2, 45+(Size.Y-66)/2), ui::Point(200, 17), "No saves found");
	AddComponent(infoText);

	filesX = 4;
	filesY = 3;
	buttonPadding = 2;
	fileX = 0;
	fileY = 0;

	buttonXOffset = 0;
	buttonYOffset = 0;
	buttonAreaWidth = itemList->Size.X - 5;
	buttonAreaHeight = itemList->Size.Y;// - buttonYOffset - 18;
	buttonWidth = (buttonAreaWidth/filesX) - buttonPadding*2;
	buttonHeight = (buttonAreaHeight/filesY) - buttonPadding*2;

	loadDirectory(directory, "");
}

void FileBrowserActivity::DoSearch(ByteString search)
{
	if (loadFiles)
	{
		hasQueuedSearch = true;
		queuedSearch = search;
	}
	else
	{
		loadDirectory(directory, search);
	}
}

void FileBrowserActivity::SelectSave(int index)
{
	if (onSelected)
	{
		auto file = std::move(files[index]);
		files.clear();
		onSelected(std::move(file));
	}
	Exit();
}

void FileBrowserActivity::DeleteSave(int index)
{
	String deleteMessage = "Are you sure you want to delete " + files[index]->GetDisplayName() + ".cps?";
	new ConfirmPrompt("Delete Save", deleteMessage, { [this, index]() {
		auto &file = files[index];
		Platform::RemoveFile(file->GetName());
		loadDirectory(directory, "");
	} });
}

void FileBrowserActivity::RenameSave(int index)
{
	new TextPrompt("Rename", "Change save name", files[index]->GetDisplayName(), "", 0, { [this, index](const String &input) {
		auto &file = files[index];
		auto newName = input.ToUtf8();
		if (newName.length())
		{
			newName = ByteString::Build(directory, PATH_SEP_CHAR, newName, ".cps");
			if (!Platform::RenameFile(file->GetName(), newName, false))
			{
				new ErrorMessage("Error", "Could not rename file");
			}
			else
			{
				loadDirectory(directory, "");
			}
		}
		else
		{
			new ErrorMessage("Error", "No save name given");
		}
	} });
}

void FileBrowserActivity::cleanup()
{
	for (auto comp : componentsQueue)
	{
		delete comp;
	}
	componentsQueue.clear();

	files.clear();
}

void FileBrowserActivity::loadDirectory(ByteString directory, ByteString search)
{
	for (size_t i = 0; i < components.size(); i++)
	{
		RemoveComponent(components[i]);
		itemList->RemoveChild(components[i]);
	}

	cleanup();

	infoText->Visible = false;
	itemList->Visible = false;
	progressBar->Visible = true;
	progressBar->SetProgress(-1);
	progressBar->SetStatus("Loading files");
	loadFiles = new LoadFilesTask(directory, search);
	loadFiles->AddTaskListener(this);
	loadFiles->Start();
}

void FileBrowserActivity::NotifyDone(Task * task)
{
	fileX = 0;
	fileY = 0;
	files = ((LoadFilesTask*)task)->TakeSaveFiles();
	createButtons = true;
	totalFiles = files.size();
	delete loadFiles;
	loadFiles = nullptr;
	if (!files.size())
	{
		progressBar->Visible = false;
		infoText->Visible = true;
	}
	else
		itemList->Visible = true;
	for (size_t i = 0; i < components.size(); i++)
	{
		delete components[i];
	}
	components.clear();

	if (hasQueuedSearch)
	{
		hasQueuedSearch = false;
		loadDirectory(directory, queuedSearch);
	}
}

void FileBrowserActivity::OnMouseDown(int x, int y, unsigned button)
{
	if (!(x > Position.X && y > Position.Y && y < Position.Y+Size.Y && x < Position.X+Size.X)) //Clicked outside window
		Exit();
}

void FileBrowserActivity::OnTryExit(ExitMethod method)
{
	Exit();
}

void FileBrowserActivity::NotifyError(Task * task)
{

}

void FileBrowserActivity::NotifyProgress(Task * task)
{
	progressBar->SetProgress(task->GetProgress());
}

void FileBrowserActivity::NotifyStatus(Task * task)
{

}

void FileBrowserActivity::OnTick()
{
	if(loadFiles)
		loadFiles->Poll();

	if (createButtons)
	{
		createButtons = false;
		for (auto i = 0; i < int(files.size()); ++i)
		{
			auto &saveFile = files[i];
			if(fileX == filesX)
			{
				fileX = 0;
				fileY++;
			}
			ui::SaveButton * saveButton = new ui::SaveButton(
							ui::Point(
								buttonXOffset + buttonPadding + fileX*(buttonWidth+buttonPadding*2),
								buttonYOffset + buttonPadding + fileY*(buttonHeight+buttonPadding*2)
								),
							ui::Point(buttonWidth, buttonHeight),
							saveFile.get());
			saveButton->AddContextMenu(1);
			saveButton->Tick();
			saveButton->SetActionCallback({
				[this, i] { SelectSave(i); },
				[this, i] { RenameSave(i); },
				[this, i] { DeleteSave(i); }
			});

			progressBar->SetStatus("Rendering thumbnails");
			progressBar->SetProgress(totalFiles ? (totalFiles - files.size()) * 100 / totalFiles : 0);
			componentsQueue.push_back(saveButton);
			fileX++;
		}
	}
	if(componentsQueue.size())
	{
		for(std::vector<ui::Component*>::iterator iter = componentsQueue.begin(), end = componentsQueue.end(); iter != end; ++iter)
		{
			components.push_back(*iter);
			itemList->AddChild(*iter);
		}
		componentsQueue.clear();
		itemList->InnerSize.Y = (buttonHeight+(buttonPadding*2))*(fileY+1);
		if(!componentsQueue.size())
			progressBar->Visible = false;
	}
}

void FileBrowserActivity::OnDraw()
{
	Graphics * g = GetGraphics();

	//Window Background+Outline
	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);
}

FileBrowserActivity::~FileBrowserActivity()
{
	cleanup();
}


=== src\gui\filebrowser\FileBrowserActivity.h ===

#pragma once

#include "common/String.h"
#include "Activity.h"
#include "tasks/TaskListener.h"

#include <vector>
#include <functional>
#include <memory>

class SaveFile;

namespace ui
{
	class Label;
	class ScrollPanel;
	class ProgressBar;
}

class LoadFilesTask;
class FileBrowserActivity: public TaskListener, public WindowActivity
{
	using OnSelected = std::function<void (std::unique_ptr<SaveFile>)>;

	LoadFilesTask * loadFiles;
	OnSelected onSelected;
	ui::ScrollPanel * itemList;
	ui::Label * infoText;
	std::vector<std::unique_ptr<SaveFile>> files;
	bool createButtons = false;
	std::vector<ui::Component*> components;
	std::vector<ui::Component*> componentsQueue;
	ByteString directory;
	bool hasQueuedSearch;
	ByteString queuedSearch;

	ui::ProgressBar * progressBar;

	int totalFiles;
	int filesX, filesY, buttonPadding;
	int fileX, fileY;
	int buttonWidth, buttonHeight, buttonAreaWidth, buttonAreaHeight, buttonXOffset, buttonYOffset;

	void populateList();
	void cleanup();
public:
	FileBrowserActivity(ByteString directory, OnSelected onSelected = nullptr);
	virtual ~FileBrowserActivity();
	
	void OnDraw() override;
	void OnTick() override;
	void OnTryExit(ExitMethod method) override;
	void OnMouseDown(int x, int y, unsigned button) override;
	void loadDirectory(ByteString directory, ByteString search);
	void SelectSave(int index);
	void DeleteSave(int index);
	void RenameSave(int index);
	void DoSearch(ByteString search);

	void NotifyDone(Task * task) override;
	void NotifyError(Task * task) override;
	void NotifyProgress(Task * task) override;
	void NotifyStatus(Task * task) override;
};


=== src\gui\filebrowser\meson.build ===

powder_files += files(
	'FileBrowserActivity.cpp',
)


=== src\gui\font\FontEditor.cpp ===

#include "FontEditor.h"
#include "bzip2/bz2wrap.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Point.h"
#include "gui/interface/Button.h"
#include "gui/interface/ScrollPanel.h"
#include "graphics/Graphics.h"
#include "SimulationConfig.h"
#include <stdexcept>
#include <fstream>
#include <iterator>
#include <iomanip>
#include <iostream>
#include <cstdint>
#include <SDL.h>

extern unsigned char *font_data;
extern unsigned int *font_ptrs;
extern unsigned int (*font_ranges)[2];

void FontEditor::ReadDataFile(ByteString dataFile)
{
	std::fstream file;
	file.open(dataFile, std::ios_base::in | std::ios_base::binary);
	if(!file)
		throw std::runtime_error("Could not open " + dataFile);
	file.seekg(0, std::ios_base::end);
	std::vector<char> fileData(file.tellg());
	file.seekg(0);
	file.read(fileData.data(), fileData.size());
	file.close();

	std::vector<char> fontDataBuf;
	std::vector<int> fontPtrsBuf;
	std::vector< std::array<int, 2> > fontRangesBuf;
	if (BZ2WDecompress(fontDataBuf, fileData) != BZ2WDecompressOk)
	{
		throw std::runtime_error("Could not decompress font data");
	}
	int first = -1;
	int last = -1;
	char *begin = fontDataBuf.data();
	char *ptr = fontDataBuf.data();
	char *end = fontDataBuf.data() + fontDataBuf.size();
	while (ptr != end)
	{
		if (ptr + 4 > end)
		{
			throw std::runtime_error("Could not decompress font data");
		}
		auto codePoint = *reinterpret_cast<uint32_t *>(ptr) & 0xFFFFFFU;
		if (codePoint >= 0x110000U)
		{
			throw std::runtime_error("Could not decompress font data");
		}
		auto width = *reinterpret_cast<uint8_t *>(ptr + 3);
		if (width > 64)
		{
			throw std::runtime_error("Could not decompress font data");
		}
		if (ptr + 4 + width * 3 > end)
		{
			throw std::runtime_error("Could not decompress font data");
		}
		auto cp = (int)codePoint;
		if (last >= cp)
		{
			throw std::runtime_error("Could not decompress font data");
		}
		if (first != -1 && last + 1 < cp)
		{
			fontRangesBuf.push_back({ { first, last } });
			first = -1;
		}
		if (first == -1)
		{
			first = cp;
		}
		last = cp;
		fontPtrsBuf.push_back(ptr + 3 - begin);
		ptr += width * 3 + 4;
	}
	if (first != -1)
	{
		fontRangesBuf.push_back({ { first, last } });
	}
	fontRangesBuf.push_back({ { 0, 0 } });

	fontData.clear();
	for (auto ch : fontDataBuf)
	{
		fontData.push_back(ch);
	}
	fontPtrs.clear();
	for (auto ptr : fontPtrsBuf)
	{
		fontPtrs.push_back(ptr);
	}
	fontRanges.clear();
	for (auto rng : fontRangesBuf)
	{
		fontRanges.push_back({ { (unsigned int)rng[0], (unsigned int)rng[1] } });
	}
}

void FontEditor::WriteDataFile(ByteString dataFile, std::vector<unsigned char> const &fontData, std::vector<unsigned int> const &fontPtrs, std::vector<std::array<unsigned int, 2> > const &fontRanges)
{
	std::fstream file;
	file.open(dataFile, std::ios_base::out | std::ios_base::trunc | std::ios_base::binary);
	if(!file)
		throw std::runtime_error("Could not open " + dataFile);

	std::vector<char> uncompressed;
	size_t pos = 0;
	for (size_t i = 0; pos < fontPtrs.size() && fontRanges[i][1]; i++)
	{
		for (String::value_type ch = fontRanges[i][0]; ch <= fontRanges[i][1]; ch++)
		{
			uncompressed.push_back((char)ch);
			uncompressed.push_back((char)(ch >> 8));
			uncompressed.push_back((char)(ch >> 16));
			auto ptr = fontPtrs[pos++];
			auto width = fontData[ptr];
			uncompressed.push_back(width);
			for (auto j = 0; j < 3 * width; ++j)
			{
				uncompressed.push_back(fontData[ptr + 1 + j]);
			}
		}
	}

	std::vector<char> compressed;
	if (BZ2WCompress(compressed, uncompressed) != BZ2WCompressOk)
	{
		throw std::runtime_error("Could not compress font data");
	}
	file.write(compressed.data(), compressed.size());

	file.close();
}

void FontEditor::UnpackData(
		std::map<String::value_type, unsigned char> &fontWidths,
		std::map<String::value_type, std::array<std::array<char, MAX_WIDTH>, FONT_H> > &fontPixels,
		std::vector<unsigned char> const &fontData,
		std::vector<unsigned int> const &fontPtrs,
		std::vector<std::array<unsigned int, 2> > const &fontRanges)
{
	fontWidths.clear();
	fontPixels.clear();
	size_t pos = 0;
	for(size_t range = 0; fontRanges[range][1]; range++)
		for(String::value_type ch = fontRanges[range][0]; ch <= fontRanges[range][1]; ch++)
		{
			unsigned char const *pointer = &fontData[fontPtrs[pos]];
			int width = fontWidths[ch] = *(pointer++);
			int pixels = 0;
			int data = 0;
			for(int j = 0; j < FONT_H; j++)
				for(int i = 0; i < width; i++)
				{
					if(!pixels)
					{
						data = *(pointer++);
						pixels = 4;
					}
					fontPixels[ch][j][i] = data & 3;
					data >>= 2;
					pixels--;
				}
			pos++;
		}
}

void FontEditor::PackData(
		std::map<String::value_type, unsigned char> const &fontWidths,
		std::map<String::value_type, std::array<std::array<char, MAX_WIDTH>, FONT_H> > const &fontPixels,
		std::vector<unsigned char> &fontData,
		std::vector<unsigned int> &fontPtrs,
		std::vector<std::array<unsigned int, 2> > &fontRanges)
{
	fontData.clear();
	fontPtrs.clear();
	fontRanges.clear();
	bool first = true;
	String::value_type rangeStart = 0;
	String::value_type prev = 0;
	for(std::map<String::value_type, unsigned char>::const_iterator it = fontWidths.begin(); it != fontWidths.end(); it++)
	{
		String::value_type ch = it->first;
		if(first)
		{
			rangeStart = ch;
			first = false;
		}
		else
			if(ch != prev + 1)
			{
				fontRanges.push_back({rangeStart, prev});
				rangeStart = ch;
			}

		fontPtrs.push_back(fontData.size());
		fontData.push_back(it->second);

		int pixels = 0;
		int data = 0;
		for(int j = 0; j < FONT_H; j++)
			for(int i = 0; i < it->second; i++)
			{
				if(pixels == 4)
				{
					fontData.push_back(data);
					pixels = 0;
					data = 0;
				}
				data >>= 2;
				data |= fontPixels.at(ch)[j][i] << 6;
				pixels++;
			}
		if(pixels)
			fontData.push_back(data);

		prev = ch;
	}
	fontRanges.push_back({rangeStart, prev});
	fontRanges.push_back({0, 0});
}

class StretchLabel: public ui::Label
{
	using Label::Label;
public:
	int WrappedLines() const
	{
		return displayTextWrapper.WrappedLines();
	}
};

class StretchTextbox: public ui::Textbox
{
	using Textbox::Textbox;
public:
	int WrappedLines() const
	{
		return displayTextWrapper.WrappedLines();
	}
};

constexpr int FONT_SCALE = 16;
FontEditor::FontEditor(ByteString _dataFile):
	ui::Window(ui::Point(0, 0), ui::Point(WINDOWW, WINDOWH)),
	dataFile(_dataFile),
	currentChar(0x80),
	fgR(255), fgG(255), fgB(255), bgR(0), bgG(0), bgB(0),
	grid(1),
	rulers(1)
{
	ReadDataFile(dataFile);
	UnpackData(fontWidths, fontPixels, fontData, fontPtrs, fontRanges);
	font_data = fontData.data();
	font_ptrs = fontPtrs.data();
	font_ranges = (unsigned int (*)[2])fontRanges.data();
	
	int baseline = 8 + FONT_H * FONT_SCALE + 4 + FONT_H + 4 + 1;
	int currentX = 1;

	ui::Button *prev = new ui::Button(ui::Point(currentX, baseline), ui::Point(17, 17), 0xE016);
	currentX += 18;
	prev->SetActionCallback({ [this] { PrevChar(); } });
	AddComponent(prev);

	currentCharTextbox = new ui::Textbox(ui::Point(currentX, baseline), ui::Point(31, 17));
	currentX += 32;
	currentCharTextbox->SetActionCallback({ [this] {
		unsigned int number = currentCharTextbox->GetText().ToNumber<unsigned int>(Format::Hex(), true);
		if(number <= 0x10FFFF)
			currentChar = number;
	} });
	UpdateCharNumber();
	AddComponent(currentCharTextbox);

	ui::Button *next = new ui::Button(ui::Point(currentX, baseline), ui::Point(17, 17), 0xE015);
	currentX += 18;
	next->SetActionCallback({ [this] { NextChar(); } });
	AddComponent(next);

	ui::Button *shrink = new ui::Button(ui::Point(currentX, baseline), ui::Point(17, 17), "><");
	currentX += 18;
	shrink->SetActionCallback({ [this] { ShrinkChar(); } });
	AddComponent(shrink);

	ui::Button *grow = new ui::Button(ui::Point(currentX, baseline), ui::Point(17, 17), "<>");
	currentX += 18;
	grow->SetActionCallback({ [this] { GrowChar(); } });
	AddComponent(grow);

	ui::Button *add = new ui::Button(ui::Point(currentX, baseline), ui::Point(36, 17), "Add");
	currentX += 37;
	add->SetActionCallback({ [this] {
		if (fontWidths.find(currentChar) == fontWidths.end())
		{
			savedButton->SetToggleState(false);
			fontWidths[currentChar] = 5;
			fontPixels[currentChar];
		}
	} });
	AddComponent(add);

	ui::Button *remove = new ui::Button(ui::Point(currentX, baseline), ui::Point(36, 17), "Remove");
	currentX += 37;
	remove->SetActionCallback({ [this] {
		if (fontWidths.find(currentChar) != fontWidths.end())
		{
			savedButton->SetToggleState(false);
			fontWidths.erase(currentChar);
			fontPixels.erase(currentChar);
		}
	} });
	AddComponent(remove);
	
	ui::Button *showGrid = new ui::Button(ui::Point(currentX, baseline), ui::Point(32, 17), "Grid");
	currentX += 33;
	showGrid->SetTogglable(true);
	showGrid->SetToggleState(grid);
	showGrid->SetActionCallback({ [this, showGrid] {
		grid = showGrid->GetToggleState();
	} });
	AddComponent(showGrid);
	
	ui::Button *showRulers = new ui::Button(ui::Point(currentX, baseline), ui::Point(32, 17), "Rulers");
	currentX += 33;
	showRulers->SetTogglable(true);
	showRulers->SetToggleState(rulers);
	showRulers->SetActionCallback({ [this, showRulers] {
		rulers = showRulers->GetToggleState();
	} });
	AddComponent(showRulers);

	baseline += 18;
	currentX = 1;
	
	int *refs[6] = {&fgR, &fgG, &fgB, &bgR, &bgG, &bgB};
	for(int i = 0; i < 6; i++)
	{
		ui::Textbox *colorComponent = new ui::Textbox(ui::Point(currentX, baseline), ui::Point(27, 17), String::Build(*refs[i]));
		currentX += 28;
		colorComponent->SetActionCallback({ [colorComponent, refs, i] {
			*refs[i] = colorComponent->GetText().ToNumber<int>(true);
		} });
		AddComponent(colorComponent);
	}

	baseline += 18;
	currentX = 1;
	
	ui::Button *render = new ui::Button(ui::Point(currentX, baseline), ui::Point(50, 17), "Render");
	currentX += 51;
	render->SetActionCallback({ [this] { Render(); } });
	AddComponent(render);
	
	savedButton = new ui::Button(ui::Point(currentX, baseline), ui::Point(50, 17), "Save");
	currentX += 51;
	savedButton->SetTogglable(true);
	savedButton->SetToggleState(true);
	savedButton->SetActionCallback({ [this] { Save(); } });
	AddComponent(savedButton);

	baseline += 18;
	
	ui::ScrollPanel *outputPanel = new ui::ScrollPanel(ui::Point(Size.X / 2, baseline), ui::Point(Size.X / 2, Size.Y - baseline));
	AddComponent(outputPanel);
	StretchLabel *outputPreview = new StretchLabel(ui::Point(0, 0), ui::Point(Size.X / 2, 0), "");
	outputPreview->SetMultiline(true);
	outputPreview->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	outputPreview->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	outputPanel->AddChild(outputPreview);
	
	ui::ScrollPanel *inputPanel = new ui::ScrollPanel(ui::Point(0, baseline), ui::Point(Size.X / 2, Size.Y - baseline));
	AddComponent(inputPanel);
	StretchTextbox *inputPreview = new StretchTextbox(ui::Point(0, 0), ui::Point(Size.X / 2, 0));
	inputPreview->SetMultiline(true);
	inputPreview->SetInputType(ui::Textbox::Multiline);
	inputPreview->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	inputPreview->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	auto textChangedCallback = [outputPreview, outputPanel, inputPreview, inputPanel] {
		String str = inputPreview->GetText();
		size_t at = 0;
		StringBuilder text;
		while(at < str.size())
		{
			unsigned int ch1, ch2;
			if(str[at] != ' ')
				if(String::Split split1 = str.SplitNumber(ch1, Format::Hex(), at))
				{
					if(str[split1.PositionAfter()] == ':')
						if(String::Split split2 = str.SplitNumber(ch2, Format::Hex(), split1.PositionAfter() + 1))
						{
							for(unsigned int ch = ch1; ch <= ch2; ch++)
								text << String::value_type(ch);
							at = split2.PositionAfter();
							continue;
						}
					text << String::value_type(ch1);
					at = split1.PositionAfter();
				}
				else
				{
					text << str[at++];
				}
			else
				at++;
		}
		outputPreview->SetText(text.Build());
		outputPanel->InnerSize.Y = outputPreview->Size.Y = std::max(outputPreview->WrappedLines(), 1) * FONT_H + 2;
		inputPanel->InnerSize.Y = inputPreview->Size.Y = std::max(inputPreview->WrappedLines(), 1) * FONT_H + 2;
	};
	inputPreview->SetActionCallback({ textChangedCallback });
	inputPanel->AddChild(inputPreview);

	StringBuilder input;
	input << Format::Hex() << Format::Width(2);
	for(auto p : fontRanges)
		if(p[1] >= 0x20)
		{
			if(p[0] < 0x20)
				p[0] = 0x20;
			if(p[0] == p[1])
				input << p[0] << "\n";
			else
				input << p[0] << ":" << p[1] << "\n";
		}
	inputPreview->SetText(input.Build());
	textChangedCallback();
	AddComponent(inputPreview);
}

FontEditor::FontEditor(ByteString target, ByteString source):
	ui::Window(ui::Point(0, 0), ui::Point(WINDOWW, WINDOWH))
{
	ReadDataFile(target);
	std::map<String::value_type, unsigned char> tgtFontWidths, srcFontWidths;
	std::map<String::value_type, std::array<std::array<char, MAX_WIDTH>, FONT_H> > tgtFontPixels, srcFontPixels;
	UnpackData(tgtFontWidths, tgtFontPixels, fontData, fontPtrs, fontRanges);
	ReadDataFile(source);
	UnpackData(srcFontWidths, srcFontPixels, fontData, fontPtrs, fontRanges);
	for(auto const &p : srcFontPixels)
		if(tgtFontPixels.count(p.first))
		{
			bool same = tgtFontWidths[p.first] == srcFontWidths[p.first];
			if(same)
				for(int j = 0; j < FONT_H; j++)
					for(int i = 0; i < tgtFontWidths[p.first]; i++)
						same = same && tgtFontPixels[p.first][j][i] == srcFontPixels[p.first][j][i];
			if(!same)
				std::cout << "U+" << std::hex << (unsigned int)p.first << " is present in both files and is different!" << std::endl;
		}
		else
		{
			std::cout << "Adding U+" << std::hex << (unsigned int)p.first << " to the target" << std::endl;
			tgtFontWidths[p.first] = srcFontWidths[p.first];
			tgtFontPixels[p.first] = p.second;
		}
	std::vector<unsigned char> tmpFontData;
	std::vector<unsigned int> tmpFontPtrs;
	std::vector<std::array<unsigned int, 2> > tmpFontRanges;
	PackData(tgtFontWidths, tgtFontPixels, tmpFontData, tmpFontPtrs, tmpFontRanges);
	WriteDataFile(target, tmpFontData, tmpFontPtrs, tmpFontRanges);
}

void FontEditor::OnDraw()
{
	Graphics *g = GetGraphics();
	
	if(fontWidths.find(currentChar) != fontWidths.end())
	{
		int width = fontWidths[currentChar];
		std::array<std::array<char, MAX_WIDTH>, FONT_H> const &pixels = fontPixels[currentChar];

		int areaWidth = 8 + width * FONT_SCALE + 8;
		g->DrawFilledRect(RectSized(Vec2{ 0, 0 }, Vec2{ areaWidth, 8 + FONT_H * FONT_SCALE + 4 + FONT_H + 4 }), RGB(bgR, bgG, bgB));
		for(int j = 0; j < FONT_H; j++)
			for(int i = 0; i < width; i++)
				g->BlendFilledRect(RectSized(Vec2{ 8 + i * FONT_SCALE, 8 + j * FONT_SCALE }, Vec2{ FONT_SCALE - grid, FONT_SCALE - grid }), RGBA(fgR, fgG, fgB, pixels[j][i] * 255 / 3));

		for(int j = 0; j < FONT_H; j++)
			for(int i = 0; i < width; i++)
				g->BlendPixel({ 8 + i, 8 + FONT_H * FONT_SCALE + 4 + j }, RGBA(fgR, fgG, fgB, pixels[j][i] * 255 / 3));


		if(rulers)
		{
			g->DrawLine({ 0, 7 + 0 * FONT_SCALE }, { areaWidth - 1, 7 + 0 * FONT_SCALE }, 0x808080_rgb);
			g->DrawLine({ 0, 7 + 2 * FONT_SCALE }, { areaWidth - 1, 7 + 2 * FONT_SCALE }, 0x808080_rgb);
			g->DrawLine({ 0, 7 + 4 * FONT_SCALE }, { areaWidth - 1, 7 + 4 * FONT_SCALE }, 0x808080_rgb);
			g->DrawLine({ 0, 7 + 9 * FONT_SCALE }, { areaWidth - 1, 7 + 9 * FONT_SCALE }, 0x808080_rgb);
			g->DrawLine({ 0, 7 + 12 * FONT_SCALE }, { areaWidth - 1, 7 + 12 * FONT_SCALE }, 0x808080_rgb);

			g->DrawLine({ 7, 8 }, { 7, 7 + FONT_H * FONT_SCALE }, 0x808080_rgb);
			g->DrawLine({ 7 + width * FONT_SCALE, 8}, { 7 + width * FONT_SCALE, 7 + FONT_H * FONT_SCALE }, 0x808080_rgb);
		}
	}
	else
	{
		g->BlendText({ 8, 8 }, "No character", 0xFF0000_rgb .WithAlpha(255));
	}
}

void FontEditor::OnMouseDown(int x, int y, unsigned button)
{
	if(fontWidths.find(currentChar) != fontWidths.end())
	{
		x = (x - 8) / FONT_SCALE;
		y = (y - 8) / FONT_SCALE;
		if(x >= 0 && y >= 0 && x < fontWidths[currentChar] && y < FONT_H)
		{
			if(button == SDL_BUTTON_LEFT)
				fontPixels[currentChar][y][x] = (fontPixels[currentChar][y][x] + 1) % 4;
			else
				fontPixels[currentChar][y][x] = (fontPixels[currentChar][y][x] + 3) % 4;
			savedButton->SetToggleState(false);
		}
	}
}

void FontEditor::Translate(std::array<std::array<char, MAX_WIDTH>, FONT_H> &pixels, int dx, int dy)
{
	std::array<std::array<char, MAX_WIDTH>, FONT_H> old = pixels;
	for(int j = 0; j < FONT_H; j++)
		for(int i = 0; i < MAX_WIDTH; i++)
			if(i - dx >= 0 && i - dx < MAX_WIDTH && j - dy >= 0 && j - dy < FONT_H)
				pixels[j][i] = old[j - dy][i - dx];
			else
				pixels[j][i] = 0;
	savedButton->SetToggleState(false);
}

void FontEditor::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (IsFocused(nullptr))
	{
		switch(scan)
		{
		case SDL_SCANCODE_UP:
			if(shift)
				Translate(fontPixels[currentChar], 0, -1);
			break;
		case SDL_SCANCODE_DOWN:
			if(shift)
				Translate(fontPixels[currentChar], 0, 1);
			break;
		case SDL_SCANCODE_LEFT:
			if(shift)
				Translate(fontPixels[currentChar], -1, 0);
			else
				PrevChar();
			break;
		case SDL_SCANCODE_RIGHT:
			if(shift)
				Translate(fontPixels[currentChar], 1, 0);
			else
				NextChar();
			break;
		case SDL_SCANCODE_ESCAPE:
		case SDL_SCANCODE_Q:
			if(savedButton->GetToggleState())
				ui::Engine::Ref().Exit();
			else
				ui::Engine::Ref().ConfirmExit();
			break;
		case SDL_SCANCODE_C:
			clipboardWidth = fontWidths[currentChar];
			clipboardPixels = fontPixels[currentChar];
			break;
		case SDL_SCANCODE_V:
			fontWidths[currentChar] = clipboardWidth;
			fontPixels[currentChar] = clipboardPixels;
			break;
		}
	}
}

void FontEditor::UpdateCharNumber()
{
	currentCharTextbox->SetText(String::Build(Format::Hex((unsigned int)currentChar)));
}

void FontEditor::PrevChar()
{
	if(currentChar > 0)
		currentChar--;
	UpdateCharNumber();
}

void FontEditor::NextChar()
{
	if(currentChar <= 0x10FFFF)
		currentChar++;
	UpdateCharNumber();
}

void FontEditor::ShrinkChar()
{
	if(fontWidths[currentChar] > 0)
		fontWidths[currentChar]--;
	savedButton->SetToggleState(false);
}

void FontEditor::GrowChar()
{
	if(fontWidths[currentChar] < MAX_WIDTH - 1)
		fontWidths[currentChar]++;
	savedButton->SetToggleState(false);
}

void FontEditor::Render()
{
	PackData(fontWidths, fontPixels, fontData, fontPtrs, fontRanges);
	font_data = fontData.data();
	font_ptrs = fontPtrs.data();
	font_ranges = (unsigned int (*)[2])fontRanges.data();
}

void FontEditor::Save()
{
	std::vector<unsigned char> tmpFontData;
	std::vector<unsigned int> tmpFontPtrs;
	std::vector<std::array<unsigned int, 2> > tmpFontRanges;
	PackData(fontWidths, fontPixels, tmpFontData, tmpFontPtrs, tmpFontRanges);
	WriteDataFile(dataFile, tmpFontData, tmpFontPtrs, tmpFontRanges);
	savedButton->SetToggleState(true);
}


=== src\gui\font\FontEditor.h ===

#pragma once
#include <vector>
#include <array>
#include <map>

#include "graphics/FontReader.h"
#include "gui/interface/Window.h"

namespace ui
{
	class Textbox;
	class Label;
	class Button;
}

constexpr int MAX_WIDTH = 64;
class FontEditor: public ui::Window
{
	void HandleExit();

private:
	ByteString dataFile;
	std::map<String::value_type, unsigned char> fontWidths;
	std::map<String::value_type, std::array<std::array<char, MAX_WIDTH>, FONT_H> > fontPixels;

	std::vector<unsigned char> fontData;
	std::vector<unsigned int> fontPtrs;
	std::vector<std::array<unsigned int, 2> > fontRanges;

	ByteString beforeFontData;
	ByteString afterFontData;
	ByteString afterFontPtrs;
	ByteString afterFontRanges;

	void ReadDataFile(ByteString dataFile);
	void WriteDataFile(ByteString dataFile, std::vector<unsigned char> const &fontData, std::vector<unsigned int> const &fontPtrs, std::vector<std::array<unsigned int, 2> > const &fontRanges);
	static void PackData(
			std::map<String::value_type, unsigned char> const &fontWidths,
			std::map<String::value_type, std::array<std::array<char, MAX_WIDTH>, FONT_H> > const &fontPixels,
			std::vector<unsigned char> &fontData,
			std::vector<unsigned int> &fontPtrs,
			std::vector<std::array<unsigned int, 2> > &fontRanges);
	static void UnpackData(
			std::map<String::value_type, unsigned char> &fontWidths,
			std::map<String::value_type, std::array<std::array<char, MAX_WIDTH>, FONT_H> > &fontPixels,
			std::vector<unsigned char> const &fontData,
			std::vector<unsigned int> const &fontPtrs,
			std::vector<std::array<unsigned int, 2> > const &fontRanges);

	ui::Textbox *currentCharTextbox;
	ui::Button *savedButton;

	String::value_type currentChar;
	int fgR, fgG, fgB;
	int bgR, bgG, bgB;

	int grid;
	int rulers;

	unsigned char clipboardWidth;
	std::array<std::array<char, MAX_WIDTH>, FONT_H> clipboardPixels;

	void UpdateCharNumber();
	void PrevChar();
	void NextChar();
	void ShrinkChar();
	void GrowChar();
	void Render();
	void Save();
	void Translate(std::array<std::array<char, MAX_WIDTH>, FONT_H> &, int dx, int dy);

public:
	FontEditor(ByteString dataFile);
	FontEditor(ByteString target, ByteString source); /* Merge mode */

	void OnDraw() override;
	void OnMouseDown(int x, int y, unsigned button) override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
};


=== src\gui\font\meson.build ===

font_files += files(
	'FontEditor.cpp',
)


=== src\gui\game\BitmapBrush.cpp ===

#include "BitmapBrush.h"
#include "Misc.h"
#include <algorithm>
#include <cmath>

BitmapBrush::BitmapBrush(ui::Point inputSize, unsigned char const *inputBitmap)
{
	ui::Point newSize = inputSize;

	//Ensure the rect has odd dimensions so we can pull an integer radius with a 1x1 centre
	if (!(newSize.X % 2))
		newSize.X += 1;
	if (!(newSize.Y % 2))
		newSize.Y += 1;

	origSize = newSize;
	origBitmap = PlaneAdapter<std::vector<unsigned char>>(newSize, 0);
	for (int y = 0; y < inputSize.Y; y++)
		for (int x = 0; x < inputSize.X; x++)
			origBitmap[{ x, y }] = inputBitmap[x + y * inputSize.X];
}

BitmapBrush::BitmapBrush(const BitmapBrush &other) : BitmapBrush(other.origSize, other.origBitmap.data())
{
}

PlaneAdapter<std::vector<unsigned char>> BitmapBrush::GenerateBitmap() const
{
	ui::Point size = radius * 2 + Vec2{ 1, 1 };
	PlaneAdapter<std::vector<unsigned char>> bitmap;
	if (size == origSize)
		bitmap = origBitmap;
	else
	{
		bitmap = PlaneAdapter<std::vector<unsigned char>>(size);
		//Bilinear interpolation
		float factorX = ((float)origSize.X)/((float)size.X);
		float factorY = ((float)origSize.Y)/((float)size.Y);
		for (int y = 0; y < size.Y; y++)
		{
			for (int x = 0; x < size.X; x++)
			{
				float originalY = ((float)y)*factorY;
				float originalX = ((float)x)*factorX;

				auto lowerX = int(std::floor(originalX));
				auto upperX = int(std::min((float)(origSize.X-1), std::floor(originalX+1.0f)));
				auto lowerY = int(std::floor(originalY));
				auto upperY = int(std::min((float)(origSize.Y-1), std::floor(originalY+1.0f)));

				unsigned char topRight = origBitmap[{ upperX, lowerY }];
				unsigned char topLeft = origBitmap[{ lowerX, lowerY }];
				unsigned char bottomRight = origBitmap[{ upperX, upperY }];
				unsigned char bottomLeft = origBitmap[{ lowerX, upperY }];
				float top = LinearInterpolate<float>(topLeft, topRight, float(lowerX), float(upperX), originalX);
				float bottom = LinearInterpolate<float>(bottomLeft, bottomRight, float(lowerX), float(upperX), originalX);
				float mid = LinearInterpolate<float>(top, bottom, float(lowerY), float(upperY), originalY);
				bitmap[{ x, y }] = mid > 128 ? 255 : 0;
			}
		}
	}
	return bitmap;
}

std::unique_ptr<Brush> BitmapBrush::Clone() const
{
	return std::make_unique<BitmapBrush>(*this);
}


=== src\gui\game\BitmapBrush.h ===

#pragma once
#include "Brush.h"

class BitmapBrush: public Brush
{
	ui::Point origSize{ 0, 0 };
	// 2D array with coords [0, origSize.X) by [0, origSize.Y)
	PlaneAdapter<std::vector<unsigned char>> origBitmap;

public:
	BitmapBrush(ui::Point size, unsigned char const *bitmap);
	BitmapBrush(const BitmapBrush &other);
	virtual ~BitmapBrush() override = default;
	PlaneAdapter<std::vector<unsigned char>> GenerateBitmap() const override;

	std::unique_ptr<Brush> Clone() const override;
};


=== src\gui\game\Brush.cpp ===

#include "Brush.h"
#include "graphics/Graphics.h"

void Brush::InitBitmap()
{
	bitmap = GenerateBitmap();
}

void Brush::InitOutline()
{
	InitBitmap();
	ui::Point bounds = GetSize();
	outline = PlaneAdapter<std::vector<unsigned char>>(bounds);
	for (int j = 0; j < bounds.Y; j++)
	{
		for (int i = 0; i < bounds.X; i++)
		{
			bool value = false;
			if (bitmap[{ i, j }])
			{
				if (i == 0 || j == 0 || i == bounds.X - 1 || j == bounds.Y - 1)
					value = true;
				else if (!bitmap[{ i + 1, j }])
					value = true;
				else if (!bitmap[{ i - 1, j }])
					value = true;
				else if (!bitmap[{ i, j + 1 }])
					value = true;
				else if (!bitmap[{ i, j - 1 }])
					value = true;
			}
			outline[{ i, j }] = value ? 0xFF : 0;
		}
	}
}

void Brush::SetRadius(ui::Point newRadius)
{
	if (newRadius.X < 0)
		newRadius.X = 0;
	if (newRadius.Y < 0)
		newRadius.Y = 0;
	if (newRadius.X > 200)
		newRadius.X = 200;
	if (newRadius.Y > 200)
		newRadius.Y = 200;
	radius = newRadius;
	InitOutline();
}

void Brush::AdjustSize(int delta, bool logarithmic, bool keepX, bool keepY)
{
	if (keepX && keepY)
		return;

	ui::Point newSize(0, 0);
	ui::Point oldSize = GetRadius();
	if (logarithmic)
		newSize = oldSize + ui::Point(delta * std::max(oldSize.X / 5, 1), delta * std::max(oldSize.Y / 5, 1));
	else
		newSize = oldSize + ui::Point(delta, delta);

	if (keepY)
		SetRadius(ui::Point(newSize.X, oldSize.Y));
	else if (keepX)
		SetRadius(ui::Point(oldSize.X, newSize.Y));
	else
		SetRadius(newSize);
}

void Brush::RenderRect(Graphics *g, ui::Point position1, ui::Point position2) const
{
	int width, height;
	width = position2.X-position1.X;
	height = position2.Y-position1.Y;
	if (height<0)
	{
		position1.Y += height;
		height *= -1;
	}
	if (width<0)
	{
		position1.X += width;
		width *= -1;
	}

	g->XorLine(position1, position1 + Vec2{ width, 0 });
	if (height > 0)
	{
		g->XorLine(position1 + Vec2{ 0, height }, position1 + Vec2{ width, height });
		if (height > 1)
		{
			g->XorLine(position1 + Vec2{ width, 1 }, position1 + Vec2{ width, height - 1 });
			if (width > 0)
			{
				g->XorLine(position1 + Vec2{ 0, 1 }, position1 + Vec2{ 0, height - 1 });
			}
		}
	}
}

void Brush::RenderLine(Graphics *g, ui::Point position1, ui::Point position2) const
{
	g->XorLine(position1, position2);
}

void Brush::RenderPoint(Graphics *g, ui::Point position) const
{
	g->XorImage(outline.data(), RectBetween(position - radius, position + radius));
}

void Brush::RenderFill(Graphics *g, ui::Point position) const
{
	g->XorLine(position - Vec2{ 5, 0 }, position - Vec2{ 1, 0 });
	g->XorLine(position + Vec2{ 5, 0 }, position + Vec2{ 1, 0 });
	g->XorLine(position - Vec2{ 0, 5 }, position - Vec2{ 0, 1 });
	g->XorLine(position + Vec2{ 0, 5 }, position + Vec2{ 0, 1 });
}


=== src\gui\game\Brush.h ===

#pragma once
#include "gui/interface/Point.h"
#include "common/Plane.h"
#include <memory>
#include <vector>

class Graphics;
class Brush
{
private:
	// 2D arrays indexed by coordinates from [-radius.X, radius.X] by [-radius.Y, radius.Y]
	PlaneAdapter<std::vector<unsigned char>> bitmap;
	PlaneAdapter<std::vector<unsigned char>> outline;

	void InitBitmap();
	void InitOutline();

	struct iterator
	{
		Brush const &parent;
		int x, y;

		iterator &operator++()
		{
			auto radius = parent.GetRadius();
			do
			{
				if (++x > radius.X)
				{
					--y;
					x = -radius.X;
				}
			} while (y >= -radius.Y && !parent.bitmap[radius + Vec2<int>{ x, y }]);
			return *this;
		}

		ui::Point operator*() const
		{
			return ui::Point(x, y);
		}

		bool operator!=(iterator other) const
		{
			return x != other.x || y != other.y;
		}

		using difference_type = void;
		using value_type = ui::Point;
		using pointer = void;
		using reference = void;
		using iterator_category = std::forward_iterator_tag;
	};

protected:
	ui::Point radius{ 0, 0 };

	virtual PlaneAdapter<std::vector<unsigned char>> GenerateBitmap() const = 0;

public:
	virtual ~Brush() = default;
	virtual void AdjustSize(int delta, bool logarithmic, bool keepX, bool keepY);
	virtual std::unique_ptr<Brush> Clone() const = 0;

	ui::Point GetSize() const
	{
		return radius * 2 + Vec2{ 1, 1 };
	}

	ui::Point GetRadius() const
	{
		return radius;
	}

	iterator begin() const
	{
		// bottom to top is the preferred order for Simulation::CreateParts
		return ++iterator{*this, radius.X, radius.Y + 1};
	}

	iterator end() const
	{
		return iterator{*this, -radius.X, -radius.Y - 1};
	}

	void RenderRect(Graphics *g, ui::Point position1, ui::Point position2) const;
	void RenderLine(Graphics *g, ui::Point position1, ui::Point position2) const;
	void RenderPoint(Graphics *g, ui::Point position) const;
	void RenderFill(Graphics *g, ui::Point position) const;

	void SetRadius(ui::Point newRadius);
};


=== src\gui\game\EllipseBrush.h ===

#pragma once
#include "Brush.h"
#include <cmath>

class EllipseBrush: public Brush
{
	bool perfectCircle;

public:
	EllipseBrush(bool newPerfectCircle) :
		perfectCircle(newPerfectCircle)
	{
	}
	virtual ~EllipseBrush() override = default;

	PlaneAdapter<std::vector<unsigned char>> GenerateBitmap() const override
	{
		ui::Point size = radius * 2 + Vec2{ 1, 1 };
		PlaneAdapter<std::vector<unsigned char>> bitmap(size);

		int rx = radius.X;
		int ry = radius.Y;

		if (!rx)
		{
			for (int j = 0; j <= 2*ry; j++)
			{
				bitmap[{ rx, j }] = 255;
			}
		}
		else
		{
			int yTop = ry+1, yBottom, i;
			for (i = 0; i <= rx; i++)
			{
				if (perfectCircle)
				{
					while (pow(i - rx, 2.0) * pow(ry - 0.5, 2.0) + pow(yTop - ry, 2.0) * pow(rx - 0.5, 2.0) <= pow(rx, 2.0) * pow(ry, 2.0))
						yTop++;
				}
				else
				{
					while (pow(i - rx, 2.0) * pow(ry, 2.0) + pow(yTop - ry, 2.0) * pow(rx, 2.0) <= pow(rx, 2.0) * pow(ry, 2.0))
						yTop++;
				}
				yBottom = 2*ry - yTop;
				for (int j = 0; j <= ry*2; j++)
				{
					if (j > yBottom && j < yTop)
					{
						bitmap[{ i, j }] = 255;
						bitmap[{ 2*rx-i, j }] = 255;
					}
					else
					{
						bitmap[{ i, j }] = 0;
						bitmap[{ 2*rx-i, j }] = 0;
					}
				}
			}
			bitmap[{ size.X/2, 0 }] = 255;
			bitmap[{ size.X/2, size.Y-1 }] = 255;
		}
		return bitmap;
	}

	std::unique_ptr<Brush> Clone() const override
	{
		return std::make_unique<EllipseBrush>(*this);
	}
};


=== src\gui\game\Favorite.cpp ===

#include "Favorite.h"
#include "prefs/GlobalPrefs.h"
#include <json/json.h>
#include <algorithm>

Favorite::Favorite():
    favoritesList(std::vector<ByteString>())
{}


std::vector<ByteString> Favorite::GetFavoritesList()
{
	return favoritesList;
}

bool Favorite::IsFavorite(ByteString identifier)
{
	return std::find(favoritesList.begin(), favoritesList.end(), identifier) != favoritesList.end();
}

bool Favorite::AnyFavorites()
{
	return favoritesList.size() != 0;
}

void Favorite::AddFavorite(ByteString identifier)
{
	if (!IsFavorite(identifier))
	{
		favoritesList.push_back(identifier);
		SaveFavoritesToPrefs();
	}
}

void Favorite::RemoveFavorite(ByteString identifier)
{
	favoritesList.erase(std::remove(favoritesList.begin(), favoritesList.end(), identifier), favoritesList.end());
	SaveFavoritesToPrefs();
}

void Favorite::SaveFavoritesToPrefs()
{
	GlobalPrefs::Ref().Set("Favorites", favoritesList);
}

void Favorite::LoadFavoritesFromPrefs()
{
	favoritesList = GlobalPrefs::Ref().Get("Favorites", std::vector<ByteString>{});
}


=== src\gui\game\Favorite.h ===

#pragma once
#include "common/String.h"
#include "common/ExplicitSingleton.h"
#include <vector>

class Favorite : public ExplicitSingleton<Favorite>
{
	std::vector<ByteString> favoritesList;
public:
	Favorite();

	std::vector<ByteString> GetFavoritesList();
	bool IsFavorite(ByteString identifier);
	bool AnyFavorites();

	void AddFavorite(ByteString identifier);
	void RemoveFavorite(ByteString identifier);

	void SaveFavoritesToPrefs();
	void LoadFavoritesFromPrefs();
};


=== src\gui\game\GameController.cpp ===

#include "GameController.h"

#include "Brush.h"
#include "Controller.h"
#include "Format.h"
#include "GameModel.h"
#include "GameModelException.h"
#include "GameView.h"
#include "Menu.h"
#include "Notification.h"
#include "QuickOptions.h"
#include "RenderPreset.h"
#include "tool/PropertyTool.h"
#include "tool/GOLTool.h"

#include "GameControllerEvents.h"
#include "lua/CommandInterface.h"

#include "prefs/GlobalPrefs.h"
#include "client/Client.h"
#include "client/GameSave.h"
#include "common/platform/Platform.h"
#include "debug/DebugInfo.h"
#include "debug/DebugLines.h"
#include "debug/DebugParts.h"
#include "debug/ElementPopulation.h"
#include "debug/ParticleDebug.h"
#include "debug/SurfaceNormals.h"
#include "debug/AirVelocity.h"
#include "graphics/Renderer.h"
#include "simulation/Air.h"
#include "simulation/ElementClasses.h"
#include "simulation/Simulation.h"
#include "simulation/SimulationData.h"
#include "simulation/Snapshot.h"
#include "simulation/elements/STKM.h"

#include "gui/dialogues/ErrorMessage.h"
#include "gui/dialogues/InformationMessage.h"
#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/interface/Engine.h"

#include "gui/colourpicker/ColourPickerActivity.h"
#include "gui/elementsearch/ElementSearchActivity.h"
#include "gui/filebrowser/FileBrowserActivity.h"
#include "gui/profile/ProfileActivity.h"
#include "gui/save/LocalSaveActivity.h"
#include "gui/save/ServerSaveActivity.h"
#include "gui/update/UpdateActivity.h"

#include "gui/console/ConsoleController.h"
#include "gui/console/ConsoleView.h"
#include "gui/localbrowser/LocalBrowserController.h"
#include "gui/localbrowser/LocalBrowserView.h"
#include "gui/login/LoginController.h"
#include "gui/login/LoginView.h"
#include "gui/options/OptionsController.h"
#include "gui/options/OptionsView.h"
#include "gui/preview/PreviewController.h"
#include "gui/preview/PreviewView.h"
#include "gui/render/RenderController.h"
#include "gui/render/RenderView.h"
#include "gui/search/SearchController.h"
#include "gui/search/SearchView.h"
#include "gui/tags/TagsController.h"
#include "gui/tags/TagsView.h"

#include "Config.h"
#include <SDL.h>
#include <iostream>

GameController::GameController():
	firstTick(true),
	foundSignID(-1),
	activePreview(nullptr),
	search(nullptr),
	renderOptions(nullptr),
	loginWindow(nullptr),
	console(nullptr),
	tagsWindow(nullptr),
	localBrowser(nullptr),
	options(nullptr),
	debugFlags(0),
	HasDone(false)
{
	gameView = new GameView();
	gameModel = new GameModel(gameView); // mvc is a joke
	gameModel->BuildQuickOptionMenu(this);

	gameView->AttachController(this);
	gameModel->AddObserver(gameView);

	gameView->SetDebugHUD(GlobalPrefs::Ref().Get("Renderer.DebugMode", false));

	commandInterface = CommandInterface::Create(this, gameModel);

	Client::Ref().AddListener(this);

	debugInfo.push_back(std::make_unique<DebugParts            >(DEBUG_PARTS     , gameModel->GetSimulation()));
	debugInfo.push_back(std::make_unique<ElementPopulationDebug>(DEBUG_ELEMENTPOP, gameModel->GetSimulation()));
	debugInfo.push_back(std::make_unique<DebugLines            >(DEBUG_LINES     , gameView, this));
	debugInfo.push_back(std::make_unique<ParticleDebug         >(DEBUG_PARTICLE  , gameModel->GetSimulation(), gameModel));
	debugInfo.push_back(std::make_unique<SurfaceNormals        >(DEBUG_SURFNORM  , gameModel->GetSimulation(), gameView, this));
	debugInfo.push_back(std::make_unique<AirVelocity           >(DEBUG_AIRVEL    , gameModel->GetSimulation(), gameView, this));
}

GameController::~GameController()
{
	if(search)
	{
		delete search;
	}
	if(renderOptions)
	{
		delete renderOptions;
	}
	if(loginWindow)
	{
		delete loginWindow;
	}
	if(tagsWindow)
	{
		delete tagsWindow;
	}
	if(console)
	{
		delete console;
	}
	if(activePreview)
	{
		delete activePreview;
	}
	if(localBrowser)
	{
		delete localBrowser;
	}
	if (options)
	{
		delete options;
	}
	debugInfo.clear();
	std::vector<QuickOption*> quickOptions = gameModel->GetQuickOptions();
	for(std::vector<QuickOption*>::iterator iter = quickOptions.begin(), end = quickOptions.end(); iter != end; ++iter)
	{
		delete *iter;
	}
	std::vector<Notification*> notifications = gameModel->GetNotifications();
	for(std::vector<Notification*>::iterator iter = notifications.begin(); iter != notifications.end(); ++iter)
	{
		delete *iter;
	}
	gameView->PauseRendererThread();
	commandInterface->RemoveComponents();
	gameView->CloseActiveWindow();
	delete gameView;
	commandInterface.reset();
	delete gameModel;
}

bool GameController::HistoryRestore()
{
	if (!gameModel->HistoryCanRestore())
	{
		return false;
	}
	// * When undoing for the first time since the last call to HistorySnapshot, save the current state.
	//   Ctrl+Y needs this in order to bring you back to the point right before your last Ctrl+Z, because
	//   the last history entry is what this Ctrl+Z brings you back to, not the current state.
	if (!beforeRestore)
	{
		beforeRestore = gameModel->GetSimulation()->CreateSnapshot();
		beforeRestore->Authors = Client::Ref().GetAuthorInfo();
	}
	gameModel->HistoryRestore();
	auto &current = *gameModel->HistoryCurrent();
	gameModel->GetSimulation()->Restore(current);
	Client::Ref().OverwriteAuthorInfo(current.Authors);

	return true;
}

void GameController::HistorySnapshot()
{
	// * Calling HistorySnapshot means the user decided to use the current state and
	//   forfeit the option to go back to whatever they Ctrl+Z'd their way back from.
	beforeRestore.reset();
	gameModel->HistoryPush(gameModel->GetSimulation()->CreateSnapshot());
}

bool GameController::HistoryForward()
{
	if (!gameModel->HistoryCanForward())
	{
		return false;
	}
	gameModel->HistoryForward();
	// * If gameModel has nothing more to give, we've Ctrl+Y'd our way back to the original
	//   state; restore this instead, then get rid of it.
	auto &current = gameModel->HistoryCurrent() ? *gameModel->HistoryCurrent() : *beforeRestore;
	gameModel->GetSimulation()->Restore(current);
	Client::Ref().OverwriteAuthorInfo(current.Authors);
	if (&current == beforeRestore.get())
	{
		beforeRestore.reset();
	}

	return true;
}

GameView * GameController::GetView()
{
	return gameView;
}

int GameController::GetSignAt(int x, int y)
{
	Simulation * sim = gameModel->GetSimulation();
	for (int i = sim->signs.size()-1; i >= 0; i--)
	{
		int signx, signy, signw, signh;
		sim->signs[i].getDisplayText(sim, signx, signy, signw, signh);
		if (x>=signx && x<=signx+signw && y>=signy && y<=signy+signh)
			return i;
	}
	return -1;
}

// assumed to already be a valid sign
String GameController::GetSignText(int signID)
{
	return gameModel->GetSimulation()->signs[signID].text;
}

std::pair<int, sign::Type> GameController::GetSignSplit(int signID)
{
	return gameModel->GetSimulation()->signs[signID].split();
}

void GameController::PlaceSave(ui::Point position)
{
	auto *placeSave = gameModel->GetTransformedPlaceSave();
	if (placeSave)
	{
		HistorySnapshot();
		gameModel->GetSimulation()->Load(placeSave, !gameView->ShiftBehaviour(), position);
		gameModel->SetPaused(placeSave->paused | gameModel->GetPaused());
		Client::Ref().MergeStampAuthorInfo(placeSave->authors);
	}
	gameModel->SetPlaceSave(nullptr);
}

void GameController::Install()
{
	if constexpr (CAN_INSTALL)
	{
		new ConfirmPrompt("Install " + String(APPNAME), "Do you wish to install " + String(APPNAME) + " on this computer?\nThis allows you to open save files and saves directly from the website.", { [] {
			if (Platform::Install())
			{
				new InformationMessage("Success", "Installation completed", false);
			}
			else
			{
				new ErrorMessage("Could not install", "The installation did not complete due to an error");
			}
		} });
	}
	else
	{
		new InformationMessage("No installation necessary", "You don't need to install " + String(APPNAME) + " on this platform", false);
	}
}

void GameController::AdjustGridSize(int direction)
{
	if(direction > 0)
		gameModel->GetRendererSettings().gridSize = (gameModel->GetRendererSettings().gridSize+1)%10;
	else
		gameModel->GetRendererSettings().gridSize = (gameModel->GetRendererSettings().gridSize+9)%10;
}

void GameController::InvertAirSim()
{
	gameModel->GetSimulation()->air->Invert();
}


void GameController::AdjustBrushSize(int delta, bool logarithmic, bool keepX, bool keepY)
{
	gameModel->GetBrush().AdjustSize(delta, logarithmic, keepX, keepY);
}

void GameController::SetBrushSize(ui::Point newSize)
{
	gameModel->GetBrush().SetRadius(newSize);
}

void GameController::AdjustZoomSize(int delta, bool logarithmic)
{
	int newSize;
	if(logarithmic)
		newSize = gameModel->GetZoomSize() + std::max(gameModel->GetZoomSize() / 10, 1) * delta;
	else
		newSize = gameModel->GetZoomSize() + delta;
	if(newSize<5)
			newSize = 5;
	if(newSize>64)
			newSize = 64;
	gameModel->SetZoomSize(newSize);

	int newZoomFactor = 256/newSize;
	if(newZoomFactor<3)
		newZoomFactor = 3;
	gameModel->SetZoomFactor(newZoomFactor);
}

bool GameController::MouseInZoom(ui::Point position)
{
	if(position.X >= XRES)
		position.X = XRES-1;
	if(position.Y >= YRES)
		position.Y = YRES-1;
	if(position.Y < 0)
		position.Y = 0;
	if(position.X < 0)
		position.X = 0;

	return gameModel->MouseInZoom(position);
}

ui::Point GameController::PointTranslate(ui::Point point)
{
	if(point.X >= XRES)
		point.X = XRES-1;
	if(point.Y >= YRES)
		point.Y = YRES-1;
	if(point.Y < 0)
		point.Y = 0;
	if(point.X < 0)
		point.X = 0;

	return gameModel->AdjustZoomCoords(point);
}

ui::Point GameController::NormaliseBlockCoord(ui::Point point)
{
	return (point/CELL)*CELL;
}

void GameController::DrawRect(int toolSelection, ui::Point point1, ui::Point point2)
{
	Simulation * sim = gameModel->GetSimulation();
	Tool * activeTool = gameModel->GetActiveTool(toolSelection);
	gameModel->SetLastTool(activeTool);
	Brush &cBrush = gameModel->GetBrush();
	if (!activeTool)
		return;
	activeTool->Strength = 1.0f;
	activeTool->DrawRect(sim, cBrush, point1, point2);
}

void GameController::DrawLine(int toolSelection, ui::Point point1, ui::Point point2)
{
	Simulation * sim = gameModel->GetSimulation();
	Tool * activeTool = gameModel->GetActiveTool(toolSelection);
	gameModel->SetLastTool(activeTool);
	Brush &cBrush = gameModel->GetBrush();
	if (!activeTool)
		return;
	activeTool->Strength = 1.0f;
	activeTool->DrawLine(sim, cBrush, point1, point2, false);
}

void GameController::DrawFill(int toolSelection, ui::Point point)
{
	Simulation * sim = gameModel->GetSimulation();
	Tool * activeTool = gameModel->GetActiveTool(toolSelection);
	gameModel->SetLastTool(activeTool);
	Brush &cBrush = gameModel->GetBrush();
	if (!activeTool)
		return;
	activeTool->Strength = 1.0f;
	activeTool->DrawFill(sim, cBrush, point);
}

void GameController::DrawPoints(int toolSelection, ui::Point oldPos, ui::Point newPos, bool held)
{
	Simulation * sim = gameModel->GetSimulation();
	Tool * activeTool = gameModel->GetActiveTool(toolSelection);
	gameModel->SetLastTool(activeTool);
	Brush &cBrush = gameModel->GetBrush();
	if (!activeTool)
	{
		return;
	}

	activeTool->Strength = gameModel->GetToolStrength();
	// This is a joke, the game mvc has to go >_>
	activeTool->shiftBehaviour = gameView->ShiftBehaviour();
	activeTool->ctrlBehaviour = gameView->CtrlBehaviour();
	activeTool->altBehaviour = gameView->AltBehaviour();
	if (!held)
		activeTool->Draw(sim, cBrush, newPos);
	else
		activeTool->DrawLine(sim, cBrush, oldPos, newPos, true);
}

bool GameController::LoadClipboard()
{
	auto *clip = gameModel->GetClipboard();
	if (!clip)
		return false;
	gameModel->SetPlaceSave(std::make_unique<GameSave>(*clip));
	return true;
}

void GameController::LoadStamp(std::unique_ptr<GameSave> stamp)
{
	gameModel->SetPlaceSave(std::move(stamp));
}

void GameController::TransformPlaceSave(Mat2<int> transform, Vec2<int> nudge)
{
	gameModel->TransformPlaceSave(transform, nudge);
}

void GameController::ToolClick(int toolSelection, ui::Point point)
{
	Simulation * sim = gameModel->GetSimulation();
	Tool * activeTool = gameModel->GetActiveTool(toolSelection);
	Brush &cBrush = gameModel->GetBrush();
	if (!activeTool)
		return;
	activeTool->Click(sim, cBrush, point);
}

void GameController::ToolDrag(int toolSelection, ui::Point point1, ui::Point point2)
{
	Simulation * sim = gameModel->GetSimulation();
	Tool * activeTool = gameModel->GetActiveTool(toolSelection);
	Brush &cBrush = gameModel->GetBrush();
	if (!activeTool)
		return;
	activeTool->Drag(sim, cBrush, point1, point2);
}

static Rect<int> SaneSaveRect(Vec2<int> point1, Vec2<int> point2)
{
	point1 = point1.Clamp(RES.OriginRect());
	point2 = point2.Clamp(RES.OriginRect());
	auto tlx = std::min(point1.X, point2.X);
	auto tly = std::min(point1.Y, point2.Y);
	auto brx = std::max(point1.X, point2.X);
	auto bry = std::max(point1.Y, point2.Y);
	return RectBetween(Vec2{ tlx, tly }, Vec2{ brx, bry });
}

ByteString GameController::StampRegion(ui::Point point1, ui::Point point2)
{
	return StampRegion(point1, point2, gameModel->GetIncludePressure() != gameView->ShiftBehaviour());
}

ByteString GameController::StampRegion(ui::Point point1, ui::Point point2, bool includePressure)
{
	auto newSave = gameModel->GetSimulation()->Save(includePressure, SaneSaveRect(point1, point2));
	if(newSave)
	{
		newSave->paused = gameModel->GetPaused();
		ByteString stampName = Client::Ref().AddStamp(std::move(newSave));
		if (stampName.length() == 0)
			new ErrorMessage("Could not create stamp", "Error serializing save file");
		return stampName;
	}
	else
	{
		new ErrorMessage("Could not create stamp", "Error generating save file");
		return "";
	}
}

void GameController::CopyRegion(ui::Point point1, ui::Point point2)
{
	auto newSave = gameModel->GetSimulation()->Save(gameModel->GetIncludePressure() != gameView->ShiftBehaviour(), SaneSaveRect(point1, point2));
	if(newSave)
	{
		Json::Value clipboardInfo;
		clipboardInfo["type"] = "clipboard";
		clipboardInfo["username"] = Client::Ref().GetAuthUser().Username;
		clipboardInfo["date"] = (Json::Value::UInt64)time(nullptr);
		Client::Ref().SaveAuthorInfo(&clipboardInfo);
		newSave->authors = clipboardInfo;

		newSave->paused = gameModel->GetPaused();
		gameModel->SetClipboard(std::move(newSave));
	}
}

void GameController::CutRegion(ui::Point point1, ui::Point point2)
{
	CopyRegion(point1, point2);
	HistorySnapshot();
	gameModel->GetSimulation()->clear_area(point1.X, point1.Y, point2.X-point1.X, point2.Y-point1.Y);
}

bool GameController::MouseMove(int x, int y, int dx, int dy)
{
	return commandInterface->HandleEvent(MouseMoveEvent{ x, y, dx, dy });
}

bool GameController::MouseDown(int x, int y, unsigned button)
{
	bool ret = commandInterface->HandleEvent(MouseDownEvent{ x, y, button });
	if (ret && y<YRES && x<XRES && !gameView->GetPlacingSave() && !gameView->GetPlacingZoom())
	{
		ui::Point point = gameModel->AdjustZoomCoords(ui::Point(x, y));
		x = point.X;
		y = point.Y;
		if (!gameModel->GetActiveTool(0) || gameModel->GetActiveTool(0)->Identifier != "DEFAULT_UI_SIGN" || button != SDL_BUTTON_LEFT) //If it's not a sign tool or you are right/middle clicking
		{
			foundSignID = GetSignAt(x, y);
			if (foundSignID != -1)
			{
				if (gameModel->GetSimulation()->signs[foundSignID].split().first)
				{
					return false;
				}
			}
		}
	}
	return ret;
}

bool GameController::MouseUp(int x, int y, unsigned button, MouseupReason reason)
{
	bool ret = commandInterface->HandleEvent(MouseUpEvent{ x, y, button, reason });
	if (reason != mouseUpNormal)
		return ret;
	if (ret && foundSignID != -1 && y<YRES && x<XRES && !gameView->GetPlacingSave())
	{
		ui::Point point = gameModel->AdjustZoomCoords(ui::Point(x, y));
		x = point.X;
		y = point.Y;
		if (!gameModel->GetActiveTool(0) || gameModel->GetActiveTool(0)->Identifier != "DEFAULT_UI_SIGN" || button != SDL_BUTTON_LEFT) //If it's not a sign tool or you are right/middle clicking
		{
			int foundSignID = GetSignAt(x, y);
			if (foundSignID != -1)
			{
				sign &foundSign = gameModel->GetSimulation()->signs[foundSignID];
				String str = foundSign.text;
				auto si = gameModel->GetSimulation()->signs[foundSignID].split();
				if (si.first)
				{
					ret = false;
					switch (si.second)
					{
					case sign::Type::Save:
						{
							int saveID = str.Substr(3, si.first - 3).ToNumber<int>(true);
							if (saveID)
								OpenSavePreview(saveID, 0, savePreviewNormal);
						}
						break;
					case sign::Type::Thread:
						Platform::OpenURI(ByteString::Build(SERVER, "/Discussions/Thread/View.html?Thread=", str.Substr(3, si.first - 3).ToUtf8()));
						break;
					case sign::Type::Search:
						OpenSearch(str.Substr(3, si.first - 3));
						break;
					case sign::Type::Button:
						gameModel->GetSimulation()->create_part(-1, foundSign.x, foundSign.y, PT_SPRK);
						break;
					default: break;
					}
				}
			}
		}
	}
	foundSignID = -1;
	return ret;
}

bool GameController::MouseWheel(int x, int y, int d)
{
	return commandInterface->HandleEvent(MouseWheelEvent{ x, y, d });
}

bool GameController::TextInput(String text)
{
	return commandInterface->HandleEvent(TextInputEvent{ text });
}

bool GameController::TextEditing(String text)
{
	return commandInterface->HandleEvent(TextEditingEvent{ text });
}

bool GameController::KeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	bool ret = commandInterface->HandleEvent(KeyPressEvent{ { key, scan, repeat, shift, ctrl, alt } });
	if (repeat)
		return ret;
	if (ret)
	{
		Simulation * sim = gameModel->GetSimulation();
		if (!gameView->GetPlacingSave())
		{
			// Go right command
			if (key == SDLK_RIGHT)
			{
				sim->player.comm = (int)(sim->player.comm)|0x02;
			}
			// Go left command
			else if (key == SDLK_LEFT)
			{
				sim->player.comm = (int)(sim->player.comm)|0x01;
			}
			// Use element command
			else if (key == SDLK_DOWN && ((int)(sim->player.comm)&0x08)!=0x08)
			{
				sim->player.comm = (int)(sim->player.comm)|0x08;
			}
			// Jump command
			else if (key == SDLK_UP && ((int)(sim->player.comm)&0x04)!=0x04)
			{
				sim->player.comm = (int)(sim->player.comm)|0x04;
			}
		}

		// Go right command
		if (scan == SDL_SCANCODE_D)
		{
			sim->player2.comm = (int)(sim->player2.comm)|0x02;
		}
		// Go left command
		else if (scan == SDL_SCANCODE_A)
		{
			sim->player2.comm = (int)(sim->player2.comm)|0x01;
		}
		// Use element command
		else if (scan == SDL_SCANCODE_S && ((int)(sim->player2.comm)&0x08)!=0x08)
		{
			sim->player2.comm = (int)(sim->player2.comm)|0x08;
		}
		// Jump command
		else if (scan == SDL_SCANCODE_W && ((int)(sim->player2.comm)&0x04)!=0x04)
		{
			sim->player2.comm = (int)(sim->player2.comm)|0x04;
		}

		if (!sim->elementCount[PT_STKM2] || ctrl)
		{
			switch(scan)
			{
			case SDL_SCANCODE_W:
				SwitchGravity();
				break;
			case SDL_SCANCODE_D:
				gameView->SetDebugHUD(!gameView->GetDebugHUD());
				break;
			case SDL_SCANCODE_S:
				gameView->BeginStampSelection();
				break;
			}
		}

		for (auto &debug : debugInfo)
		{
			if (debug->debugID & debugFlags)
			{
				if (!debug->KeyPress(key, scan, shift, ctrl, alt, gameView->GetMousePosition()))
				{
					ret = false;
				}
			}
		}
	}
	return ret;
}

bool GameController::KeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	bool ret = commandInterface->HandleEvent(KeyReleaseEvent{ { key, scan, repeat, shift, ctrl, alt } });
	if (repeat)
		return ret;
	if (ret)
	{
		Simulation * sim = gameModel->GetSimulation();
		if (key == SDLK_RIGHT || key == SDLK_LEFT)
		{
			sim->player.pcomm = sim->player.comm;  //Saving last movement
			sim->player.comm = (int)(sim->player.comm)&12;  //Stop command
		}
		else if (key == SDLK_UP)
		{
			sim->player.comm = (int)(sim->player.comm)&11;
		}
		else if (key == SDLK_DOWN)
		{
			sim->player.comm = (int)(sim->player.comm)&7;
		}

		if (scan == SDL_SCANCODE_D || scan == SDL_SCANCODE_A)
		{
			sim->player2.pcomm = sim->player2.comm;  //Saving last movement
			sim->player2.comm = (int)(sim->player2.comm)&12;  //Stop command
		}
		else if (scan == SDL_SCANCODE_W)
		{
			sim->player2.comm = (int)(sim->player2.comm)&11;
		}
		else if (scan == SDL_SCANCODE_S)
		{
			sim->player2.comm = (int)(sim->player2.comm)&7;
		}
	}
	return ret;
}

void GameController::InitCommandInterface()
{
	commandInterface->Init();
}

void GameController::Tick()
{
	gameModel->Tick();
	if(firstTick)
	{
		if constexpr (INSTALL_CHECK)
		{
			if (Client::Ref().IsFirstRun())
			{
				Install();
			}
		}
		firstTick = false;
	}
	if (gameModel->SelectNextIdentifier.length())
	{
		gameModel->BuildMenus();
		gameModel->SetActiveTool(gameModel->SelectNextTool, gameModel->GetToolFromIdentifier(gameModel->SelectNextIdentifier));
		gameModel->SelectNextIdentifier.clear();
	}
	for (auto &debug : debugInfo)
	{
		if (debug->debugID & debugFlags)
		{
			debug->Draw();
		}
	}
	commandInterface->OnTick();
}

void GameController::Blur()
{
	// Tell lua that mouse is up (even if it really isn't)
	MouseUp(0, 0, 0, mouseUpBlur);
	commandInterface->HandleEvent(BlurEvent{});
}

void GameController::Exit()
{
	commandInterface->HandleEvent(CloseEvent{});
	gameView->CloseActiveWindow();
	HasDone = true;
}

void GameController::ResetAir()
{
	Simulation * sim = gameModel->GetSimulation();
	sim->air->Clear();
	for (int i = 0; i < NPART; i++)
	{
		if (GameSave::PressureInTmp3(sim->parts[i].type))
		{
			sim->parts[i].tmp3 = 0;
		}
	}
}

void GameController::ResetSpark()
{
	auto &sd = SimulationData::CRef();
	Simulation * sim = gameModel->GetSimulation();
	for (int i = 0; i < NPART; i++)
		if (sim->parts[i].type == PT_SPRK)
		{
			if (sim->parts[i].ctype >= 0 && sim->parts[i].ctype < PT_NUM && sd.elements[sim->parts[i].ctype].Enabled)
			{
				sim->parts[i].type = sim->parts[i].ctype;
				sim->parts[i].ctype = sim->parts[i].life = 0;
			}
			else
				sim->kill_part(i);
		}
	memset(sim->wireless, 0, sizeof(sim->wireless));
}

void GameController::SwitchGravity()
{
	gameModel->GetSimulation()->gravityMode = (gameModel->GetSimulation()->gravityMode + 1) % NUM_GRAVMODES;

	switch (gameModel->GetSimulation()->gravityMode)
	{
	case GRAV_VERTICAL:
		gameModel->SetInfoTip("Gravity: Vertical");
		break;
	case GRAV_OFF:
		gameModel->SetInfoTip("Gravity: Off");
		break;
	case GRAV_RADIAL:
		gameModel->SetInfoTip("Gravity: Radial");
		break;
	case GRAV_CUSTOM:
		gameModel->SetInfoTip("Gravity: Custom");
		break;
	}
}

void GameController::SwitchAir()
{
	gameModel->GetSimulation()->air->airMode = (gameModel->GetSimulation()->air->airMode + 1) % NUM_AIRMODES;

	switch (gameModel->GetSimulation()->air->airMode)
	{
	case AIR_ON:
		gameModel->SetInfoTip("Air: On");
		break;
	case AIR_PRESSUREOFF:
		gameModel->SetInfoTip("Air: Pressure Off");
		break;
	case AIR_VELOCITYOFF:
		gameModel->SetInfoTip("Air: Velocity Off");
		break;
	case AIR_OFF:
		gameModel->SetInfoTip("Air: Off");
		break;
	case AIR_NOUPDATE:
		gameModel->SetInfoTip("Air: No Update");
		break;
	}
}

void GameController::ToggleAHeat()
{
	gameModel->SetAHeatEnable(!gameModel->GetAHeatEnable());
}

bool GameController::GetAHeatEnable()
{
	return gameModel->GetAHeatEnable();
}

void GameController::ResetAHeat()
{
	gameModel->ResetAHeat();
}

void GameController::ToggleNewtonianGravity()
{
	gameModel->SetNewtonianGravity(!gameModel->GetNewtonianGrvity());
}

void GameController::LoadRenderPreset(int presetNum)
{
	auto &settings = gameModel->GetRendererSettings();
	RenderPreset preset = Renderer::renderModePresets[presetNum];
	gameModel->SetInfoTip(preset.Name);
	settings.renderMode = preset.renderMode;
	settings.displayMode = preset.displayMode;
	settings.colorMode = preset.colorMode;
	settings.wantHdispLimitMin = preset.wantHdispLimitMin;
	settings.wantHdispLimitMax = preset.wantHdispLimitMax;
}

void GameController::Update()
{
	auto &sd = SimulationData::CRef();
	ui::Point pos = gameView->GetMousePosition();
	gameModel->GetRendererSettings().mousePos = PointTranslate(pos);
	if (pos.X < XRES && pos.Y < YRES)
		gameView->SetSample(gameModel->GetSimulation()->GetSample(PointTranslate(pos).X, PointTranslate(pos).Y));
	else
		gameView->SetSample(gameModel->GetSimulation()->GetSample(pos.X, pos.Y));

	Simulation * sim = gameModel->GetSimulation();
	if (!sim->sys_pause || sim->framerender)
	{
		gameModel->UpdateUpTo(NPART);
	}
	else
	{
		gameModel->BeforeSim();
	}

	//if either STKM or STK2 isn't out, reset it's selected element. Defaults to PT_DUST unless right selected is something else
	//This won't run if the stickmen dies in a frame, since it respawns instantly
	if (!sim->player.spwn || !sim->player2.spwn)
	{
		int rightSelected = PT_DUST;
		Tool * activeTool = gameModel->GetActiveTool(1);
		if (activeTool->Identifier.BeginsWith("DEFAULT_PT_"))
		{
			int sr = activeTool->ToolID;
			if (sr && sd.IsElementOrNone(sr))
				rightSelected = sr;
		}

		if (!sim->player.spwn)
			Element_STKM_set_element(sim, &sim->player, rightSelected);
		if (!sim->player2.spwn)
			Element_STKM_set_element(sim, &sim->player2, rightSelected);
	}
	if(renderOptions && renderOptions->HasExited)
	{
		delete renderOptions;
		renderOptions = nullptr;
	}

	if(search && search->HasExited)
	{
		delete search;
		search = nullptr;
	}

	if(activePreview && activePreview->HasExited)
	{
		delete activePreview;
		activePreview = nullptr;
	}

	if(loginWindow && loginWindow->HasExited)
	{
		delete loginWindow;
		loginWindow = nullptr;
	}

	if(localBrowser && localBrowser->HasDone)
	{
		delete localBrowser;
		localBrowser = nullptr;
	}
}

void GameController::SetZoomEnabled(bool zoomEnabled)
{
	gameModel->SetZoomEnabled(zoomEnabled);
}

void GameController::SetToolStrength(float value)
{
	gameModel->SetToolStrength(value);
}

void GameController::SetZoomPosition(ui::Point position)
{
	auto zoomhalf = gameModel->GetZoomSize() / 2;
	ui::Point zoomPosition = position - Vec2{ zoomhalf, zoomhalf };
	if(zoomPosition.X < 0)
			zoomPosition.X = 0;
	if(zoomPosition.Y < 0)
			zoomPosition.Y = 0;
	if(zoomPosition.X >= XRES-gameModel->GetZoomSize())
			zoomPosition.X = XRES-gameModel->GetZoomSize();
	if(zoomPosition.Y >= YRES-gameModel->GetZoomSize())
			zoomPosition.Y = YRES-gameModel->GetZoomSize();

	ui::Point zoomWindowPosition = ui::Point(0, 0);
	if(position.X < XRES/2)
		zoomWindowPosition.X = XRES-(gameModel->GetZoomSize()*gameModel->GetZoomFactor());

	gameModel->SetZoomPosition(zoomPosition);
	gameModel->SetZoomWindowPosition(zoomWindowPosition);
}

bool GameController::GetPaused() const
{
	return gameModel->GetPaused();
}

void GameController::SetPaused(bool pauseState)
{
	gameModel->SetPaused(pauseState);
}

void GameController::SetPaused()
{
	gameModel->SetPaused(!gameModel->GetPaused());
}

void GameController::SetDecoration(bool decorationState)
{
	gameModel->SetDecoration(decorationState);
}

void GameController::SetDecoration()
{
	gameModel->SetDecoration(!gameModel->GetDecoration());
}

void GameController::ShowGravityGrid()
{
	gameModel->ShowGravityGrid(!gameModel->GetGravityGrid());
	gameModel->UpdateQuickOptions();
}

void GameController::SetHudEnable(bool hudState)
{
	gameView->SetHudEnable(hudState);
}

bool GameController::GetHudEnable()
{
	return gameView->GetHudEnable();
}

void GameController::SetBrushEnable(bool brushState)
{
	gameView->SetBrushEnable(brushState);
}

bool GameController::GetBrushEnable()
{
	return gameView->GetBrushEnable();
}

void GameController::SetDebugHUD(bool hudState)
{
	gameView->SetDebugHUD(hudState);
}

bool GameController::GetDebugHUD()
{
	return gameView->GetDebugHUD();
}

void GameController::SetTemperatureScale(int temperatureScale)
{
	gameModel->SetTemperatureScale(temperatureScale);
}

int GameController::GetTemperatureScale()
{
	return gameModel->GetTemperatureScale();
}

int GameController::GetEdgeMode()
{
	return gameModel->GetEdgeMode();
}

void GameController::SetEdgeMode(int edgeMode)
{
	if (edgeMode < 0 || edgeMode >= NUM_EDGEMODES)
		edgeMode = 0;

	gameModel->SetEdgeMode(edgeMode);

	switch (edgeMode)
	{
		case EDGE_VOID:
			gameModel->SetInfoTip("Edge Mode: Void");
			break;
		case EDGE_SOLID:
			gameModel->SetInfoTip("Edge Mode: Solid");
			break;
		case EDGE_LOOP:
			gameModel->SetInfoTip("Edge Mode: Loop");
			break;
	}
}

void GameController::SetActiveColourPreset(int preset)
{
	gameModel->SetActiveColourPreset(preset);
}

void GameController::SetColour(ui::Colour colour)
{
	gameModel->SetColourSelectorColour(colour);
	gameModel->SetPresetColour(colour);
}

void GameController::SetActiveMenu(int menuID)
{
	gameModel->SetActiveMenu(menuID);
	if(menuID == SC_DECO)
		gameModel->SetColourSelectorVisibility(true);
	else
		gameModel->SetColourSelectorVisibility(false);
}

std::vector<Menu*> GameController::GetMenuList()
{
	return gameModel->GetMenuList();
}

int GameController::GetNumMenus(bool onlyEnabled)
{
	int count = 0;
	if (onlyEnabled)
	{
		std::vector<Menu*> menuList = gameModel->GetMenuList();
		for (std::vector<Menu*>::iterator it = menuList.begin(), end = menuList.end(); it != end; ++it)
			if ((*it)->GetVisible())
				count++;
	}
	else
		count = gameModel->GetMenuList().size();
	return count;
}

void GameController::RebuildFavoritesMenu()
{
	gameModel->BuildMenus();
}

Tool * GameController::GetActiveTool(int selection)
{
	return gameModel->GetActiveTool(selection);
}

void GameController::SetActiveTool(int toolSelection, Tool * tool)
{
	if (gameModel->GetActiveMenu() == SC_DECO && toolSelection == 2)
		toolSelection = 0;
	gameModel->SetActiveTool(toolSelection, tool);
	gameModel->GetRendererSettings().gravityZonesEnabled = false;
	if (toolSelection == 3)
		gameModel->GetSimulation()->replaceModeSelected = tool->ToolID;
	gameModel->SetLastTool(tool);
	for(int i = 0; i < 3; i++)
	{
		auto *activeTool = gameModel->GetActiveTool(i);
		if (activeTool && activeTool->Identifier == "DEFAULT_WL_GRVTY")
		{
			gameModel->GetRendererSettings().gravityZonesEnabled = true;
		}
	}
	tool->Select(toolSelection);
}

void GameController::SetActiveTool(int toolSelection, ByteString identifier)
{
	Tool *tool = gameModel->GetToolFromIdentifier(identifier);
	if (!tool)
		return;
	SetActiveTool(toolSelection, tool);
}

void GameController::SetLastTool(Tool * tool)
{
	gameModel->SetLastTool(tool);
}

Tool *GameController::GetLastTool()
{
	return gameModel->GetLastTool();
}

int GameController::GetReplaceModeFlags()
{
	return gameModel->GetSimulation()->replaceModeFlags;
}

void GameController::SetReplaceModeFlags(int flags)
{
	int old_flags = gameModel->GetSimulation()->replaceModeFlags;
	if (!(old_flags & REPLACE_MODE) && (flags & REPLACE_MODE))
	{
		// if replace mode has just been enabled, disable specific delete
		flags &= ~SPECIFIC_DELETE;
	}
	if (!(old_flags & SPECIFIC_DELETE) && (flags & SPECIFIC_DELETE))
	{
		// if specific delete has just been enabled, disable replace mode
		flags &= ~REPLACE_MODE;
	}
	if ((flags & SPECIFIC_DELETE) && (flags & REPLACE_MODE))
	{
		// if both have just been enabled, arbitrarily disable one of them
		flags &= ~SPECIFIC_DELETE;
	}
	gameModel->GetSimulation()->replaceModeFlags = flags;
}

void GameController::OpenSearch(String searchText)
{
	if(!search)
		search = new SearchController([this] {
			if (search->GetLoadedSave())
			{
				try
				{
					HistorySnapshot();
					gameModel->SetSave(search->TakeLoadedSave(), gameView->ShiftBehaviour());
				}
				catch(GameModelException & ex)
				{
					new ErrorMessage("Cannot open save", ByteString(ex.what()).FromUtf8());
				}
			}
		});
	if (searchText.length())
		search->DoSearch2(searchText);
	ui::Engine::Ref().ShowWindow(search->GetView());
}

void GameController::OpenLocalSaveWindow(bool asCurrent)
{
	Simulation * sim = gameModel->GetSimulation();
	auto gameSave = sim->Save(gameModel->GetIncludePressure() != gameView->ShiftBehaviour(), RES.OriginRect());
	if(!gameSave)
	{
		new ErrorMessage("Error", "Unable to build save.");
	}
	else
	{
		gameSave->paused = gameModel->GetPaused();

		auto tempSave = std::make_unique<SaveFile>("");
		if (gameModel->GetSaveFile())
		{
			tempSave->SetFileName(gameModel->GetSaveFile()->GetName());
			tempSave->SetDisplayName(gameModel->GetSaveFile()->GetDisplayName());
		}

		if (!asCurrent || !gameModel->GetSaveFile())
		{
			tempSave->SetGameSave(std::move(gameSave));
			new LocalSaveActivity(std::move(tempSave), [this](auto file) {
				gameModel->SetSaveFile(std::move(file), gameView->ShiftBehaviour());
			});
		}
		else if (gameModel->GetSaveFile())
		{
			Json::Value localSaveInfo;
			localSaveInfo["type"] = "localsave";
			localSaveInfo["username"] = Client::Ref().GetAuthUser().Username;
			localSaveInfo["title"] = gameModel->GetSaveFile()->GetName();
			localSaveInfo["date"] = (Json::Value::UInt64)time(nullptr);
			Client::Ref().SaveAuthorInfo(&localSaveInfo);
			gameSave->authors = localSaveInfo;

			Platform::MakeDirectory(LOCAL_SAVE_DIR);
			std::vector<char> saveData;
			std::tie(std::ignore, saveData) = gameSave->Serialise();
			tempSave->SetGameSave(std::move(gameSave));
			gameModel->SetSaveFile(std::move(tempSave), gameView->ShiftBehaviour());
			if (saveData.size() == 0)
				new ErrorMessage("Error", "Unable to serialize game data.");
			else if (!Platform::WriteFile(saveData, gameModel->GetSaveFile()->GetName()))
				new ErrorMessage("Error", "Unable to write save file.");
			else
				gameModel->SetInfoTip("Saved Successfully");
		}
	}
}

void GameController::LoadSaveFile(std::unique_ptr<SaveFile> file)
{
	gameModel->SetSaveFile(std::move(file), gameView->ShiftBehaviour());
}


void GameController::LoadSave(std::unique_ptr<SaveInfo> save)
{
	gameModel->SetSave(std::move(save), gameView->ShiftBehaviour());
}

void GameController::OpenSaveDone()
{
	if (activePreview->GetDoOpen() && activePreview->GetSaveInfo())
	{
		try
		{
			HistorySnapshot();
			LoadSave(activePreview->TakeSaveInfo());
		}
		catch(GameModelException & ex)
		{
			new ErrorMessage("Cannot open save", ByteString(ex.what()).FromUtf8());
		}
	}
}

void GameController::OpenSavePreview(int saveID, int saveDate, SavePreviewType savePreviewType)
{
	if (savePreviewType == savePreviewUrl)
	{
		gameView->SkipIntroText();
	}
	activePreview = new PreviewController(saveID, saveDate, savePreviewType, [this] { OpenSaveDone(); }, nullptr);
	ui::Engine::Ref().ShowWindow(activePreview->GetView());
}

void GameController::OpenSavePreview()
{
	if(gameModel->GetSave())
	{
		activePreview = new PreviewController(gameModel->GetSave()->GetID(), 0, savePreviewNormal, [this] { OpenSaveDone(); }, nullptr);
		ui::Engine::Ref().ShowWindow(activePreview->GetView());
	}
}

void GameController::OpenLocalBrowse()
{
	new FileBrowserActivity(ByteString::Build(LOCAL_SAVE_DIR, PATH_SEP_CHAR), [this](auto file) {
		HistorySnapshot();
		LoadSaveFile(std::move(file));
	});
}

void GameController::OpenLogin()
{
	loginWindow = new LoginController();
	ui::Engine::Ref().ShowWindow(loginWindow->GetView());
}

void GameController::OpenProfile()
{
	if(Client::Ref().GetAuthUser().UserID)
	{
		new ProfileActivity(Client::Ref().GetAuthUser().Username);
	}
	else
	{
		loginWindow = new LoginController();
		ui::Engine::Ref().ShowWindow(loginWindow->GetView());
	}
}

void GameController::OpenElementSearch()
{
	std::vector<Tool *> toolList;
	for (auto &ptr : gameModel->GetTools())
	{
		if (!ptr)
		{
			continue;
		}
		toolList.push_back(ptr.get());
	}
	new ElementSearchActivity(this, toolList);
}

void GameController::OpenColourPicker()
{
	new ColourPickerActivity(gameModel->GetColourSelectorColour(), [this](ui::Colour colour) {
		SetColour(colour);
	});
}

void GameController::OpenTags()
{
	if(gameModel->GetSave() && gameModel->GetSave()->GetID())
	{
		delete tagsWindow;
		tagsWindow = new TagsController([this] { gameView->NotifySaveChanged(gameModel); }, gameModel->GetSave());
		ui::Engine::Ref().ShowWindow(tagsWindow->GetView());
	}
	else
	{
		new ErrorMessage("Error", "No save open");
	}
}

void GameController::OpenStamps()
{
	localBrowser = new LocalBrowserController([this] {
		auto file = localBrowser->TakeSave();
		if (file)
		{
			if (file->GetError().length())
				new ErrorMessage("Error loading stamp", file->GetError());
			else if (localBrowser->GetMoveToFront())
				Client::Ref().MoveStampToFront(file->GetDisplayName().ToUtf8());
			LoadStamp(file->TakeGameSave());
		}
	});
	ui::Engine::Ref().ShowWindow(localBrowser->GetView());
}

void GameController::OpenOptions()
{
	options = new OptionsController(gameModel, [this] {
		gameModel->UpdateQuickOptions();
	});
	ui::Engine::Ref().ShowWindow(options->GetView());

}

void GameController::ShowConsole()
{
	if (!console)
		console = new ConsoleController(nullptr, commandInterface.get());
	if (console->GetView() != ui::Engine::Ref().GetWindow())
		ui::Engine::Ref().ShowWindow(console->GetView());
}

void GameController::HideConsole()
{
	if (!console)
		return;
	console->GetView()->CloseActiveWindow();
}

void GameController::OpenRenderOptions()
{
	renderOptions = new RenderController(gameModel->GetSimulation(), gameModel->GetRenderer(), &gameModel->GetRendererSettings(), nullptr);
	ui::Engine::Ref().ShowWindow(renderOptions->GetView());
}

void GameController::OpenSaveWindow()
{
	if(gameModel->GetUser().UserID)
	{
		Simulation * sim = gameModel->GetSimulation();
		auto gameSave = sim->Save(gameModel->GetIncludePressure() != gameView->ShiftBehaviour(), RES.OriginRect());
		if(!gameSave)
		{
			new ErrorMessage("Error", "Unable to build save.");
		}
		else
		{
			gameSave->paused = gameModel->GetPaused();

			if(gameModel->GetSave())
			{
				auto tempSave = gameModel->GetSave()->CloneInfo();
				tempSave->SetGameSave(std::move(gameSave));
				new ServerSaveActivity(std::move(tempSave), [this](auto save) {
					save->SetVote(1);
					save->SetVotesUp(1);
					LoadSave(std::move(save));
				});
			}
			else
			{
				auto tempSave = std::make_unique<SaveInfo>(0, 0, 0, 0, 0, gameModel->GetUser().Username, "");
				tempSave->SetGameSave(std::move(gameSave));
				new ServerSaveActivity(std::move(tempSave), [this](auto save) {
					save->SetVote(1);
					save->SetVotesUp(1);
					LoadSave(std::move(save));
				});
			}
		}
	}
	else
	{
		new ErrorMessage("Error", "You need to login to upload saves.");
	}
}

void GameController::SaveAsCurrent()
{
	if(gameModel->GetSave() && gameModel->GetUser().UserID && gameModel->GetUser().Username == gameModel->GetSave()->GetUserName())
	{
		Simulation * sim = gameModel->GetSimulation();
		auto gameSave = sim->Save(gameModel->GetIncludePressure() != gameView->ShiftBehaviour(), RES.OriginRect());
		if(!gameSave)
		{
			new ErrorMessage("Error", "Unable to build save.");
		}
		else
		{
			gameSave->paused = gameModel->GetPaused();

			if(gameModel->GetSave())
			{
				auto tempSave = gameModel->GetSave()->CloneInfo();
				tempSave->SetGameSave(std::move(gameSave));
				new ServerSaveActivity(std::move(tempSave), true, [this](auto save) { LoadSave(std::move(save)); });
			}
			else
			{
				auto tempSave = std::make_unique<SaveInfo>(0, 0, 0, 0, 0, gameModel->GetUser().Username, "");
				tempSave->SetGameSave(std::move(gameSave));
				new ServerSaveActivity(std::move(tempSave), true, [this](auto save) { LoadSave(std::move(save)); });
			}
		}
	}
	else if(gameModel->GetUser().UserID)
	{
		OpenSaveWindow();
	}
	else
	{
		new ErrorMessage("Error", "You need to login to upload saves.");
	}
}

void GameController::FrameStep()
{
	gameModel->FrameStep(1);
	gameModel->SetPaused(true);
}

void GameController::Vote(int direction)
{
	if (gameModel->GetSave() && gameModel->GetUser().UserID && gameModel->GetSave()->GetID())
	{
		gameModel->SetVote(direction);
	}
}

void GameController::ChangeBrush()
{
	gameModel->SetBrushID(gameModel->GetBrushID()+1);
}

void GameController::ClearSim()
{
	HistorySnapshot();
	gameModel->SetSave(nullptr, false);
	gameModel->ClearSimulation();
}

String GameController::ElementResolve(int type, int ctype)
{
	// "NONE" should never be displayed in the HUD
	if (!type)
		return "";
	auto &sd = SimulationData::CRef();
	return sd.ElementResolve(type, ctype);
}

String GameController::BasicParticleInfo(Particle const &sample_part)
{
	auto &sd = SimulationData::CRef();
	return sd.BasicParticleInfo(sample_part);
}

void GameController::ReloadSim()
{
	if(gameModel->GetSave() && gameModel->GetSave()->GetGameSave())
	{
		HistorySnapshot();
		gameModel->SetSave(gameModel->TakeSave(), gameView->ShiftBehaviour());
	}
	else if(gameModel->GetSaveFile() && gameModel->GetSaveFile()->GetGameSave())
	{
		HistorySnapshot();
		gameModel->SetSaveFile(gameModel->TakeSaveFile(), gameView->ShiftBehaviour());
	}
}

bool GameController::IsValidElement(int type)
{
	auto &sd = SimulationData::CRef();
	return type && sd.IsElement(type);
}

String GameController::WallName(int type)
{
	auto &sd = SimulationData::CRef();
	if(type >= 0 && type < UI_WALLCOUNT)
		return sd.wtypes[type].name;
	else
		return String();
}

ByteString GameController::TakeScreenshot(int captureUI, int fileType)
{
	return gameView->TakeScreenshot(captureUI, fileType);
}

int GameController::Record(bool record)
{
	return gameView->Record(record);
}

void GameController::NotifyAuthUserChanged(Client * sender)
{
	User newUser = sender->GetAuthUser();
	gameModel->SetUser(newUser);
}

void GameController::NotifyNewNotification(Client * sender, ServerNotification notification)
{
	class LinkNotification : public Notification
	{
		ByteString link;
	public:
		LinkNotification(ByteString link_, String message) : Notification(message), link(link_) {}
		virtual ~LinkNotification() {}

		void Action() override
		{
			Platform::OpenURI(link);
		}
	};
	gameModel->AddNotification(new LinkNotification(notification.link, notification.text));
}

void GameController::NotifyUpdateAvailable(Client * sender)
{
	class UpdateNotification : public Notification
	{
		GameController * c;
	public:
		UpdateNotification(GameController * c, String message) : Notification(message), c(c) {}
		virtual ~UpdateNotification() {}

		void Action() override
		{
			auto optinfo = Client::Ref().GetUpdateInfo();
			if (!optinfo.has_value())
			{
				std::cerr << "odd, the update has disappeared" << std::endl;
				return;
			}
			UpdateInfo info = optinfo.value();
			StringBuilder updateMessage;
			if (Platform::CanUpdate())
			{
				updateMessage << "Are you sure you want to run the updater? Please save any changes before updating.\n\nCurrent version:\n ";
			}
			else
			{
				updateMessage << "Click \"Continue\" to download the latest version from our website.\n\nCurrent version:\n ";
			}

			if constexpr (MOD)
			{
				updateMessage << "Mod " << MOD_ID << " ";
			}
			if constexpr (SNAPSHOT)
			{
				updateMessage << "Snapshot " << APP_VERSION.build;
			}
			else if constexpr (BETA)
			{
				updateMessage << DISPLAY_VERSION[0] << "." << DISPLAY_VERSION[1] << " Beta, Build " << APP_VERSION.build;
			}
			else
			{
				updateMessage << DISPLAY_VERSION[0] << "." << DISPLAY_VERSION[1] << " Stable, Build " << APP_VERSION.build;
			}

			updateMessage << "\nNew version:\n ";
			if (info.channel == UpdateInfo::channelBeta)
			{
				updateMessage << info.major << "." << info.minor << " Beta, Build " << info.build;
			}
			else if (info.channel == UpdateInfo::channelSnapshot)
			{
				if constexpr (MOD)
				{
					updateMessage << "Mod version " << info.build;
				}
				else
				{
					updateMessage << "Snapshot " << info.build;
				}
			}
			else if(info.channel == UpdateInfo::channelStable)
			{
				updateMessage << info.major << "." << info.minor << " Stable, Build " << info.build;
			}

			if (info.changeLog.length())
				updateMessage << "\n\nChangelog:\n" << info.changeLog;

			new ConfirmPrompt("Run Updater", updateMessage.Build(), { [this, info] { c->RunUpdater(info); } });
		}
	};

	auto optinfo = sender->GetUpdateInfo();
	if (!optinfo.has_value())
	{
		return;
	}
	switch(optinfo.value().channel)
	{
		case UpdateInfo::channelSnapshot:
			if constexpr (MOD)
			{
				gameModel->AddNotification(new UpdateNotification(this, "A new mod update is available - click here to update"));
			}
			else
			{
				gameModel->AddNotification(new UpdateNotification(this, "A new snapshot is available - click here to update"));
			}
			break;
		case UpdateInfo::channelStable:
			gameModel->AddNotification(new UpdateNotification(this, "A new version is available - click here to update"));
			break;
		case UpdateInfo::channelBeta:
			gameModel->AddNotification(new UpdateNotification(this, "A new beta is available - click here to update"));
			break;
	}
}

void GameController::RemoveNotification(Notification * notification)
{
	gameModel->RemoveNotification(notification);
}

void GameController::RunUpdater(UpdateInfo info)
{
	if (Platform::CanUpdate())
	{
		Exit();
		new UpdateActivity(info);
	}
	else
	{
		Platform::OpenURI(info.file);
	}
}

bool GameController::GetMouseClickRequired()
{
	return gameModel->GetMouseClickRequired();
}

bool GameController::GetThreadedRendering()
{
	return gameModel->GetThreadedRendering();
}

void GameController::RemoveCustomGol(const ByteString &identifier)
{
	gameModel->RemoveCustomGol(identifier);
}

void GameController::BeforeSimDraw()
{
	commandInterface->HandleEvent(BeforeSimDrawEvent{});
}

void GameController::AfterSimDraw()
{
	commandInterface->HandleEvent(AfterSimDrawEvent{});
}

bool GameController::ThreadedRenderingAllowed()
{
	return gameModel->GetThreadedRendering() && !GetPaused() && !commandInterface->HaveSimGraphicsEventHandlers();
}

void GameController::SetToolIndex(ByteString identifier, std::optional<int> index)
{
	if (commandInterface)
	{
		commandInterface->SetToolIndex(identifier, index);
	}
}


=== src\gui\game\GameController.h ===

#pragma once
#include "lua/CommandInterfacePtr.h"
#include "client/ClientListener.h"
#include "client/StartupInfo.h"
#include "common/ExplicitSingleton.h"
#include "gui/interface/Point.h"
#include "gui/interface/Colour.h"
#include "gui/SavePreviewType.h"
#include "simulation/Sign.h"
#include "simulation/Particle.h"
#include "Misc.h"
#include <vector>
#include <utility>
#include <memory>

constexpr auto DEBUG_PARTS      = 0x0001;
constexpr auto DEBUG_ELEMENTPOP = 0x0002;
constexpr auto DEBUG_LINES      = 0x0004;
constexpr auto DEBUG_PARTICLE   = 0x0008;
constexpr auto DEBUG_SURFNORM   = 0x0010;
constexpr auto DEBUG_SIMHUD     = 0x0020;
constexpr auto DEBUG_RENHUD     = 0x0040;
constexpr auto DEBUG_AIRVEL     = 0x0080;

class DebugInfo;
class SaveFile;
class Notification;
class GameModel;
class GameView;
class Snapshot;
class OptionsController;
class LocalBrowserController;
class SearchController;
class PreviewController;
class RenderController;
class VideoBuffer;
class Tool;
class Menu;
class SaveInfo;
class GameSave;
class LoginController;
class TagsController;
class ConsoleController;
class GameController : public ClientListener, public ExplicitSingleton<GameController>
{
	CommandInterfacePtr commandInterface;

private:
	bool firstTick;
	int foundSignID;

	PreviewController * activePreview;
	GameView * gameView;
	GameModel * gameModel;
	SearchController * search;
	RenderController * renderOptions;
	LoginController * loginWindow;
	ConsoleController * console;
	TagsController * tagsWindow;
	LocalBrowserController * localBrowser;
	OptionsController * options;
	std::vector<std::unique_ptr<DebugInfo>> debugInfo;
	std::unique_ptr<Snapshot> beforeRestore;
	unsigned int debugFlags;
	
	void OpenSaveDone();
public:
	enum MouseupReason
	{
		mouseUpNormal,
		mouseUpBlur,
		mouseUpDrawEnd,
	};

	bool HasDone;
	GameController();
	~GameController();
	GameView * GetView();
	int GetSignAt(int x, int y);
	String GetSignText(int signID);
	std::pair<int, sign::Type> GetSignSplit(int signID);

	bool MouseMove(int x, int y, int dx, int dy);
	bool MouseDown(int x, int y, unsigned button);
	bool MouseUp(int x, int y, unsigned button, MouseupReason reason);
	bool MouseWheel(int x, int y, int d);
	bool TextInput(String text);
	bool TextEditing(String text);
	bool KeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
	bool KeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
	void Tick();
	void Blur();
	void Exit();

	void Install();

	bool HistoryRestore();
	void HistorySnapshot();
	bool HistoryForward();

	void AdjustGridSize(int direction);
	void InvertAirSim();
	void LoadRenderPreset(int presetNum);
	void SetZoomEnabled(bool zoomEnable);
	void SetZoomPosition(ui::Point position);
	void AdjustBrushSize(int direction, bool logarithmic = false, bool xAxis = false, bool yAxis = false);
	void SetBrushSize(ui::Point newSize);
	void AdjustZoomSize(int direction, bool logarithmic = false);
	void ToolClick(int toolSelection, ui::Point point);
	void ToolDrag(int toolSelection, ui::Point point1, ui::Point point2);
	void DrawPoints(int toolSelection, ui::Point oldPos, ui::Point newPos, bool held);
	void DrawRect(int toolSelection, ui::Point point1, ui::Point point2);
	void DrawLine(int toolSelection, ui::Point point1, ui::Point point2);
	void DrawFill(int toolSelection, ui::Point point);
	ByteString StampRegion(ui::Point point1, ui::Point point2);
	ByteString StampRegion(ui::Point point1, ui::Point point2, bool includePressure);
	void CopyRegion(ui::Point point1, ui::Point point2);
	void CutRegion(ui::Point point1, ui::Point point2);
	void Update();
	bool GetPaused() const;
	void SetPaused(bool pauseState);
	void SetPaused();
	void SetDecoration(bool decorationState);
	void SetDecoration();
	void ShowGravityGrid();
	void SetHudEnable(bool hudState);
	bool GetHudEnable();
	void SetBrushEnable(bool brushState);
	bool GetBrushEnable();
	void SetDebugHUD(bool hudState);
	bool GetDebugHUD();
	void SetTemperatureScale(int temperatureScale);
	int GetTemperatureScale();
	int GetEdgeMode();
	void SetEdgeMode(int edgeMode);
	void SetDebugFlags(unsigned int flags) { debugFlags = flags; }
	unsigned int GetDebugFlags() const { return debugFlags; }
	void SetActiveMenu(int menuID);
	std::vector<Menu*> GetMenuList();
	int GetNumMenus(bool onlyEnabled);
	void RebuildFavoritesMenu();
	Tool * GetActiveTool(int selection);
	void SetActiveTool(int toolSelection, Tool * tool);
	void SetActiveTool(int toolSelection, ByteString identifier);
	void SetLastTool(Tool * tool);
	Tool *GetLastTool();
	int GetReplaceModeFlags();
	void SetReplaceModeFlags(int flags);
	void SetActiveColourPreset(int preset);
	void SetColour(ui::Colour colour);
	void SetToolStrength(float value);
	void LoadSaveFile(std::unique_ptr<SaveFile> file);
	void LoadSave(std::unique_ptr<SaveInfo> save);
	void OpenSearch(String searchText);
	void OpenLogin();
	void OpenProfile();
	void OpenTags();
	void OpenSavePreview(int saveID, int saveDate, SavePreviewType savePreiviewType);
	void OpenSavePreview();
	void OpenLocalSaveWindow(bool asCurrent);
	void OpenLocalBrowse();
	void OpenOptions();
	void OpenRenderOptions();
	void OpenSaveWindow();
	void SaveAsCurrent();
	void OpenStamps();
	void OpenElementSearch();
	void OpenColourPicker();
	void PlaceSave(ui::Point position);
	void ClearSim();
	void ReloadSim();
	void Vote(int direction);
	void ChangeBrush();
	void ShowConsole();
	void HideConsole();
	void FrameStep();
	void TransformPlaceSave(Mat2<int> transform, Vec2<int> nudge);
	bool MouseInZoom(ui::Point position);
	ui::Point PointTranslate(ui::Point point);
	ui::Point NormaliseBlockCoord(ui::Point point);
	String ElementResolve(int type, int ctype);
	String BasicParticleInfo(Particle const &sample_part);
	bool IsValidElement(int type);
	String WallName(int type);
	ByteString TakeScreenshot(int captureUI, int fileType);
	int Record(bool record);

	void ResetAir();
	void ResetSpark();
	void SwitchGravity();
	void SwitchAir();
	void ToggleAHeat();
	bool GetAHeatEnable();
	void ResetAHeat();
	void ToggleNewtonianGravity();

	bool LoadClipboard();
	void LoadStamp(std::unique_ptr<GameSave> stamp);

	void RemoveNotification(Notification * notification);

	void NotifyUpdateAvailable(Client * sender) override;
	void NotifyAuthUserChanged(Client * sender) override;
	void NotifyNewNotification(Client * sender, ServerNotification notification) override;
	void RunUpdater(UpdateInfo info);
	bool GetMouseClickRequired();
	bool GetThreadedRendering();

	void RemoveCustomGol(const ByteString &identifier);

	void BeforeSimDraw();
	void AfterSimDraw();
	bool ThreadedRenderingAllowed();

	void SetToolIndex(ByteString identifier, std::optional<int> index);
	void InitCommandInterface();
};


=== src\gui\game\GameControllerEvents.h ===

#pragma once
#include "common/String.h"
#include <variant>
#include <cstdint>

enum EventTraits : uint32_t
{
	eventTraitNone              = UINT32_C(0x00000000),
	eventTraitSimRng            = UINT32_C(0x00000001),
	eventTraitSimGraphics       = UINT32_C(0x00000002),
	eventTraitHindersSrt        = UINT32_C(0x00000004),
	eventTraitInterface         = UINT32_C(0x00000008),
	eventTraitInterfaceGraphics = UINT32_C(0x00000010),
	eventTraitConstSim          = UINT32_C(0x00000020),
	eventTraitConstTools        = UINT32_C(0x00000040),
	eventTraitMonopartAccess    = UINT32_C(0x00000080),
};
constexpr EventTraits operator |(EventTraits lhs, EventTraits rhs)
{
    return static_cast<EventTraits>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

struct TextInputEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
	String text;
};

struct TextEditingEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
	String text;
};

struct KeyEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
	int key;
	int scan;
	bool repeat;
	bool shift;
	bool ctrl;
	bool alt;
};

struct KeyPressEvent : public KeyEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
};

struct KeyReleaseEvent : public KeyEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
};

struct MouseDownEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
	int x;
	int y;
	unsigned int button;
};

struct MouseUpEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
	int x;
	int y;
	unsigned int button;
	int reason;
};

struct MouseMoveEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
	int x;
	int y;
	int dx;
	int dy;
};

struct MouseWheelEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
	int x;
	int y;
	int d;
};

struct TickEvent
{
	static constexpr EventTraits traits = eventTraitInterface | eventTraitInterfaceGraphics;
};

struct BlurEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
};

struct CloseEvent
{
	static constexpr EventTraits traits = eventTraitInterface;
};

struct BeforeSimEvent
{
	static constexpr EventTraits traits = eventTraitSimRng;
};

struct AfterSimEvent
{
	static constexpr EventTraits traits = eventTraitSimRng;
};

struct BeforeSimDrawEvent
{
	static constexpr EventTraits traits = eventTraitSimGraphics | eventTraitHindersSrt | eventTraitInterface | eventTraitConstSim;
};

struct AfterSimDrawEvent
{
	static constexpr EventTraits traits = eventTraitSimGraphics | eventTraitInterface | eventTraitConstSim;
};

using GameControllerEvent = std::variant<
	TextInputEvent,
	TextEditingEvent,
	KeyPressEvent,
	KeyReleaseEvent,
	MouseDownEvent,
	MouseUpEvent,
	MouseMoveEvent,
	MouseWheelEvent,
	TickEvent,
	BlurEvent,
	CloseEvent,
	BeforeSimEvent,
	AfterSimEvent,
	BeforeSimDrawEvent,
	AfterSimDrawEvent
>;


=== src\gui\game\GameModel.cpp ===

#include "Config.h"
#include "GameModel.h"
#include "BitmapBrush.h"
#include "EllipseBrush.h"
#include "Favorite.h"
#include "Format.h"
#include "GameController.h"
#include "GameModelException.h"
#include "GameView.h"
#include "Menu.h"
#include "Notification.h"
#include "RectangleBrush.h"
#include "TriangleBrush.h"
#include "QuickOptions.h"
#include "lua/CommandInterface.h"
#include "prefs/GlobalPrefs.h"
#include "client/Client.h"
#include "client/GameSave.h"
#include "client/SaveFile.h"
#include "client/SaveInfo.h"
#include "client/http/ExecVoteRequest.h"
#include "common/platform/Platform.h"
#include "common/clipboard/Clipboard.h"
#include "graphics/Renderer.h"
#include "simulation/Air.h"
#include "simulation/GOLString.h"
#include "simulation/gravity/Gravity.h"
#include "simulation/Simulation.h"
#include "simulation/Snapshot.h"
#include "simulation/SnapshotDelta.h"
#include "simulation/ElementClasses.h"
#include "simulation/ElementGraphics.h"
#include "simulation/ToolClasses.h"
#include "gui/game/tool/DecorationTool.h"
#include "gui/game/tool/ElementTool.h"
#include "gui/game/tool/GOLTool.h"
#include "gui/game/tool/PropertyTool.h"
#include "gui/game/tool/SampleTool.h"
#include "gui/game/tool/SignTool.h"
#include "gui/game/tool/WallTool.h"
#include "gui/interface/Engine.h"
#include "gui/dialogues/ErrorMessage.h"
#include <iostream>
#include <algorithm>
#include <optional>

HistoryEntry::~HistoryEntry()
{
	// * Needed because Snapshot and SnapshotDelta are incomplete types in GameModel.h,
	//   so the default dtor for ~HistoryEntry cannot be generated.
}

GameModel::GameModel(GameView *newView):
	activeMenu(SC_POWDERS),
	currentBrush(0),
	currentUser(0, ""),
	toolStrength(1.0f),
	historyPosition(0),
	activeColourPreset(0),
	colourSelector(false),
	colour(255, 0, 0, 255),
	edgeMode(EDGE_VOID),
	ambientAirTemp(R_TEMP + 273.15f),
	decoSpace(DECOSPACE_SRGB),
	view(newView)
{
	sim = new Simulation();
	sim->useLuaCallbacks = true;
	ren = new Renderer();

	activeTools = regularToolset.data();

	std::fill(decoToolset.begin(), decoToolset.end(), nullptr);
	std::fill(regularToolset.begin(), regularToolset.end(), nullptr);

	//Load config into renderer
	auto &prefs = GlobalPrefs::Ref();

	auto handleOldModes = [&prefs](ByteString prefName, ByteString oldPrefName, uint32_t defaultValue, auto setFunc) {
		auto pref = prefs.Get<uint32_t>(prefName);
		if (!pref.has_value())
		{
			auto modes = prefs.Get(oldPrefName, std::vector<unsigned int>{});
			if (modes.size())
			{
				uint32_t mode = 0;
				for (auto partial : modes)
				{
					mode |= partial;
				}
				pref = mode;
			}
			else
			{
				pref = defaultValue;
			}
		}
		setFunc(*pref);
	};
	handleOldModes("Renderer.RenderMode", "Renderer.RenderModes", RENDER_FIRE | RENDER_EFFE | RENDER_BASC, [this](uint32_t renderMode) {
		rendererSettings.renderMode = renderMode;
	});
	handleOldModes("Renderer.DisplayMode", "Renderer.DisplayModes", 0, [this](uint32_t displayMode) {
		rendererSettings.displayMode = displayMode;
	});
	rendererSettings.colorMode = prefs.Get("Renderer.ColourMode", UINT32_C(0));

	rendererSettings.gravityFieldEnabled = prefs.Get("Renderer.GravityField", false);
	rendererSettings.decorationLevel = prefs.Get("Renderer.Decorations", true) ? RendererSettings::decorationEnabled : RendererSettings::decorationDisabled;
	threadedRendering = prefs.Get("Renderer.SeparateThread", true);

	//Load config into simulation
	edgeMode = prefs.Get("Simulation.EdgeMode", NUM_EDGEMODES, EDGE_VOID);
	sim->SetEdgeMode(edgeMode);
	ambientAirTemp = float(R_TEMP) + 273.15f;
	{
		auto temp = prefs.Get("Simulation.AmbientAirTemp", ambientAirTemp);
		if (MIN_TEMP <= temp && MAX_TEMP >= temp)
		{
			ambientAirTemp = temp;
		}
	}
	sim->air->ambientAirTemp = ambientAirTemp;
	decoSpace = prefs.Get("Simulation.DecoSpace", NUM_DECOSPACES, DECOSPACE_SRGB);
	sim->SetDecoSpace(decoSpace);
	if (prefs.Get("Simulation.NewtonianGravity", false))
	{
		sim->EnableNewtonianGravity(true);
	}
	sim->aheat_enable = prefs.Get("Simulation.AmbientHeat", 0); // TODO: AmbientHeat enum
	sim->pretty_powder = prefs.Get("Simulation.PrettyPowder", 0); // TODO: PrettyPowder enum

	Favorite::Ref().LoadFavoritesFromPrefs();

	//Load last user
	if(Client::Ref().GetAuthUser().UserID)
	{
		currentUser = Client::Ref().GetAuthUser();
	}

	perfectCircle = prefs.Get("PerfectCircleBrush", true);
	BuildBrushList();

	InitTools();

	//Set default decoration colour
	unsigned char colourR = std::max(std::min(prefs.Get("Decoration.Red", 200), 255), 0);
	unsigned char colourG = std::max(std::min(prefs.Get("Decoration.Green", 100), 255), 0);
	unsigned char colourB = std::max(std::min(prefs.Get("Decoration.Blue", 50), 255), 0);
	unsigned char colourA = std::max(std::min(prefs.Get("Decoration.Alpha", 255), 255), 0);

	SetColourSelectorColour(ui::Colour(colourR, colourG, colourB, colourA));

	colourPresets.push_back(ui::Colour(255, 255, 255));
	colourPresets.push_back(ui::Colour(0, 255, 255));
	colourPresets.push_back(ui::Colour(255, 0, 255));
	colourPresets.push_back(ui::Colour(255, 255, 0));
	colourPresets.push_back(ui::Colour(255, 0, 0));
	colourPresets.push_back(ui::Colour(0, 255, 0));
	colourPresets.push_back(ui::Colour(0, 0, 255));
	colourPresets.push_back(ui::Colour(0, 0, 0));

	undoHistoryLimit = prefs.Get("Simulation.UndoHistoryLimit", 5U);
	// cap due to memory usage (this is about 3.4GB of RAM)
	if (undoHistoryLimit > 200)
		SetUndoHistoryLimit(200);

	mouseClickRequired = prefs.Get("MouseClickRequired", false);
	includePressure = prefs.Get("Simulation.IncludePressure", true);
	temperatureScale = prefs.Get("Renderer.TemperatureScale", 1); // TODO: TemperatureScale enum

	ClearSimulation();
}

GameModel::~GameModel()
{
	auto &prefs = GlobalPrefs::Ref();
	{
		//Save to config:
		Prefs::DeferWrite dw(prefs);
		prefs.Set("Renderer.ColourMode", rendererSettings.colorMode);
		prefs.Set("Renderer.DisplayMode", rendererSettings.displayMode);
		prefs.Set("Renderer.RenderMode", rendererSettings.renderMode);
		prefs.Set("Renderer.GravityField", rendererSettings.gravityFieldEnabled);
		prefs.Set("Renderer.Decorations", GetDecoration());
		prefs.Set("Renderer.DebugMode", rendererSettings.debugLines); //These two should always be equivalent, even though they are different things
		prefs.Set("Simulation.NewtonianGravity", bool(sim->grav));
		prefs.Set("Simulation.AmbientHeat", sim->aheat_enable);
		prefs.Set("Simulation.PrettyPowder", sim->pretty_powder);
		prefs.Set("Decoration.Red", (int)colour.Red);
		prefs.Set("Decoration.Green", (int)colour.Green);
		prefs.Set("Decoration.Blue", (int)colour.Blue);
		prefs.Set("Decoration.Alpha", (int)colour.Alpha);
	}

	delete sim;
	delete ren;
	//if(activeTools)
	//	delete[] activeTools;
}

void GameModel::UpdateQuickOptions()
{
	for(std::vector<QuickOption*>::iterator iter = quickOptions.begin(), end = quickOptions.end(); iter != end; ++iter)
	{
		QuickOption * option = *iter;
		option->Update();
	}
}

void GameModel::BuildQuickOptionMenu(GameController * controller)
{
	for(std::vector<QuickOption*>::iterator iter = quickOptions.begin(), end = quickOptions.end(); iter != end; ++iter)
	{
		delete *iter;
	}
	quickOptions.clear();

	quickOptions.push_back(new SandEffectOption(this));
	quickOptions.push_back(new DrawGravOption(this));
	quickOptions.push_back(new DecorationsOption(this));
	quickOptions.push_back(new NGravityOption(this));
	quickOptions.push_back(new AHeatOption(this));
	quickOptions.push_back(new ConsoleShowOption(this, controller));

	notifyQuickOptionsChanged();
	UpdateQuickOptions();
}

void GameModel::BuildBrushList()
{
	ui::Point radius{ 4, 4 };
	if (brushList.size())
		radius = brushList[currentBrush]->GetRadius();
	brushList.clear();

	brushList.push_back(std::make_unique<EllipseBrush>(perfectCircle));
	brushList.push_back(std::make_unique<RectangleBrush>());
	brushList.push_back(std::make_unique<TriangleBrush>());

	//Load more from brushes folder
	for (ByteString brushFile : Platform::DirectorySearch(BRUSH_DIR, "", { ".ptb" }))
	{
		std::vector<char> brushData;
		if (!Platform::ReadFile(brushData, ByteString::Build(BRUSH_DIR, PATH_SEP_CHAR, brushFile)))
		{
			std::cout << "Brushes: Skipping " << brushFile << ". Could not open" << std::endl;
			continue;
		}
		auto dimension = size_t(std::sqrt(brushData.size()));
		if (dimension * dimension != brushData.size())
		{
			std::cout << "Brushes: Skipping " << brushFile << ". Invalid bitmap size" << std::endl;
			continue;
		}
		brushList.push_back(std::make_unique<BitmapBrush>(ui::Point(dimension, dimension), reinterpret_cast<unsigned char const *>(brushData.data())));
	}

	brushList[currentBrush]->SetRadius(radius);
	notifyBrushChanged();
}

Tool *GameModel::GetToolFromIdentifier(ByteString const &identifier)
{
	for (auto &ptr : tools)
	{
		if (!ptr)
		{
			continue;
		}
		if (ptr->Identifier == identifier)
		{
			return ptr.get();
		}
	}
	return nullptr;
}

void GameModel::SetEdgeMode(int edgeMode)
{
	this->edgeMode = edgeMode;
	sim->SetEdgeMode(edgeMode);
}

int GameModel::GetEdgeMode()
{
	return this->edgeMode;
}

void GameModel::SetTemperatureScale(int temperatureScale)
{
	this->temperatureScale = temperatureScale;
}

void GameModel::SetThreadedRendering(bool newThreadedRendering)
{
	threadedRendering = newThreadedRendering;
}

void GameModel::SetAmbientAirTemperature(float ambientAirTemp)
{
	this->ambientAirTemp = ambientAirTemp;
	sim->air->ambientAirTemp = ambientAirTemp;
}

float GameModel::GetAmbientAirTemperature()
{
	return this->ambientAirTemp;
}

void GameModel::SetDecoSpace(int decoSpace)
{
	sim->SetDecoSpace(decoSpace);
	this->decoSpace = sim->deco_space;
}

int GameModel::GetDecoSpace()
{
	return this->decoSpace;
}

// * SnapshotDelta d is the difference between the two Snapshots A and B (i.e. d = B - A)
//   if auto d = SnapshotDelta::FromSnapshots(A, B). In this case, a Snapshot that is
//   identical to B can be constructed from d and A via d.Forward(A) (i.e. B = A + d)
//   and a Snapshot that is identical to A can be constructed from d and B via
//   d.Restore(B) (i.e. A = B - d). SnapshotDeltas often consume less memory than Snapshots,
//   although pathological cases of pairs of Snapshots exist, the SnapshotDelta constructed
//   from which actually consumes more than the two snapshots combined.
// * GameModel::history is an N-item deque of HistoryEntry structs, each of which owns either
//   a SnapshotDelta, except for history[N-1], which always owns a Snapshot. A logical Snapshot
//   accompanies each item in GameModel::history. This logical Snapshot may or may not be
//   materialised (present in memory). If an item owns an actual Snapshot, the aforementioned
//   logical Snapshot is this materialised Snapshot. If, however, an item owns a SnapshotDelta d,
//   the accompanying logical Snapshot A is the Snapshot obtained via A = d.Restore(B), where B
//   is the logical Snapshot accompanying the next (at an index that is one higher than the
//   index of this item) item in history. Slightly more visually:
//
//      i   |    history[i]   |  the logical Snapshot   | relationships |
//          |                 | accompanying history[i] |               |
//   -------|-----------------|-------------------------|---------------|
//          |                 |                         |               |
//    N - 1 |   Snapshot A    |       Snapshot A        |            A  |
//          |                 |                         |           /   |
//    N - 2 | SnapshotDelta b |       Snapshot B        |  B+b=A   b-B  |
//          |                 |                         |           /   |
//    N - 3 | SnapshotDelta c |       Snapshot C        |  C+c=B   c-C  |
//          |                 |                         |           /   |
//    N - 4 | SnapshotDelta d |       Snapshot D        |  D+d=C   d-D  |
//          |                 |                         |           /   |
//     ...  |      ...        |          ...            |   ...    ...  |
//
// * GameModel::historyPosition is an integer in the closed range 0 to N, which is decremented
//   by GameModel::HistoryRestore and incremented by GameModel::HistoryForward, by 1 at a time.
//   GameModel::historyCurrent "follows" historyPosition such that it always holds a Snapshot
//   that is identical to the logical Snapshot of history[historyPosition], except when
//   historyPosition = N, in which case it's empty. This following behaviour is achieved either
//   by "stepping" historyCurrent by Forwarding and Restoring it via the SnapshotDelta in
//   history[historyPosition], cloning the Snapshot in history[historyPosition] into it if
//   historyPosition = N-1, or clearing if it historyPosition = N.
// * GameModel::historyCurrent is lost when a new Snapshot item is pushed into GameModel::history.
//   This item appears wherever historyPosition currently points, and every other item above it
//   is deleted. If historyPosition is below N, this gets rid of the Snapshot in history[N-1].
//   Thus, N is set to historyPosition, after which the new Snapshot is pushed and historyPosition
//   is incremented to the new N.
// * Pushing a new Snapshot into the history is a bit involved:
//   * If there are no history entries yet, the new Snapshot is simply placed into GameModel::history.
//     From now on, we consider cases in which GameModel::history is originally not empty.
//
//     === after pushing Snapshot A' into the history
//  
//        i   |    history[i]   |  the logical Snapshot   | relationships |
//            |                 | accompanying history[i] |               |
//     -------|-----------------|-------------------------|---------------|
//            |                 |                         |               |
//        0   |   Snapshot A    |       Snapshot A        |            A  |
//
//   * If there were discarded history entries (i.e. the user decided to continue from some state
//     which they arrived to via at least one Ctrl+Z), history[N-2] is a SnapshotDelta that when
//     Forwarded with the logical Snapshot of history[N-2] yields the logical Snapshot of history[N-1]
//     from before the new item was pushed. This is not what we want, so we replace it with a
//     SnapshotDelta that is the difference between the logical Snapshot of history[N-2] and the
//     Snapshot freshly placed in history[N-1].
//
//     === after pushing Snapshot A' into the history
//  
//        i   |    history[i]   |  the logical Snapshot   | relationships |
//            |                 | accompanying history[i] |               |
//     -------|-----------------|-------------------------|---------------|
//            |                 |                         |               |
//      N - 1 |   Snapshot A'   |       Snapshot A'       |            A' | b needs to be replaced with b',
//            |                 |                         |           /   | B+b'=A'; otherwise we'd run
//      N - 2 | SnapshotDelta b |       Snapshot B        |  B+b=A   b-B  | into problems when trying to
//            |                 |                         |           /   | reconstruct B from A' and b
//      N - 3 | SnapshotDelta c |       Snapshot C        |  C+c=B   c-C  | in HistoryRestore.
//            |                 |                         |           /   |
//      N - 4 | SnapshotDelta d |       Snapshot D        |  D+d=C   d-D  |
//            |                 |                         |           /   |
//       ...  |      ...        |          ...            |   ...    ...  |
//  
//     === after replacing b with b'
//  
//        i   |    history[i]   |  the logical Snapshot   | relationships |
//            |                 | accompanying history[i] |               |
//     -------|-----------------|-------------------------|---------------|
//            |                 |                         |               |
//      N - 1 |   Snapshot A'   |       Snapshot A'       |            A' |
//            |                 |                         |           /   |
//      N - 2 | SnapshotDelta b'|       Snapshot B        | B+b'=A' b'-B  |
//            |                 |                         |           /   |
//      N - 3 | SnapshotDelta c |       Snapshot C        |  C+c=B   c-C  |
//            |                 |                         |           /   |
//      N - 4 | SnapshotDelta d |       Snapshot D        |  D+d=C   d-D  |
//            |                 |                         |           /   |
//       ...  |      ...        |          ...            |   ...    ...  |
//  
//   * If there weren't any discarded history entries, history[N-2] is now also a Snapshot. Since
//     the freshly pushed Snapshot in history[N-1] should be the only Snapshot in history, this is
//     replaced with the SnapshotDelta that is the difference between history[N-2] and the Snapshot
//     freshly placed in history[N-1].
//
//     === after pushing Snapshot A' into the history
//
//        i   |    history[i]   |  the logical Snapshot   | relationships |
//            |                 | accompanying history[i] |               |
//     -------|-----------------|-------------------------|---------------|
//            |                 |                         |               |
//      N - 1 |   Snapshot A'   |       Snapshot A'       |            A' | A needs to be converted to a,
//            |                 |                         |               | otherwise Snapshots would litter
//      N - 1 |   Snapshot A    |       Snapshot A        |            A  | GameModel::history, which we
//            |                 |                         |           /   | want to avoid because they
//      N - 2 | SnapshotDelta b |       Snapshot B        |  B+b=A   b-B  | waste a ton of memory
//            |                 |                         |           /   |
//      N - 3 | SnapshotDelta c |       Snapshot C        |  C+c=B   c-C  |
//            |                 |                         |           /   |
//      N - 4 | SnapshotDelta d |       Snapshot D        |  D+d=C   d-D  |
//            |                 |                         |           /   |
//       ...  |      ...        |          ...            |   ...    ...  |
//
//     === after replacing A with a
//
//        i   |    history[i]   |  the logical Snapshot   | relationships |
//            |                 | accompanying history[i] |               |
//     -------|-----------------|-------------------------|---------------|
//            |                 |                         |               |
//      N - 1 |   Snapshot A'   |       Snapshot A'       |            A' |
//            |                 |                         |           /   |
//      N - 1 | SnapshotDelta a |       Snapshot A        |  A+a=A'  a-A  |
//            |                 |                         |           /   |
//      N - 2 | SnapshotDelta b |       Snapshot B        |  B+b=A   b-B  |
//            |                 |                         |           /   |
//      N - 3 | SnapshotDelta c |       Snapshot C        |  C+c=B   c-C  |
//            |                 |                         |           /   |
//      N - 4 | SnapshotDelta d |       Snapshot D        |  D+d=C   d-D  |
//            |                 |                         |           /   |
//       ...  |      ...        |          ...            |   ...    ...  |
//
//   * After all this, the front of the deque is truncated such that there are on more than
//     undoHistoryLimit entries left.

const Snapshot *GameModel::HistoryCurrent() const
{
	return historyCurrent.get();
}

bool GameModel::HistoryCanRestore() const
{
	return historyPosition > 0U;
}

void GameModel::HistoryRestore()
{
	if (!HistoryCanRestore())
	{
		return;
	}
	historyPosition -= 1U;
	if (history[historyPosition].snap)
	{
		historyCurrent = std::make_unique<Snapshot>(*history[historyPosition].snap);
	}
	else
	{
		historyCurrent = history[historyPosition].delta->Restore(*historyCurrent);
	}
}

bool GameModel::HistoryCanForward() const
{
	return historyPosition < history.size();
}

void GameModel::HistoryForward()
{
	if (!HistoryCanForward())
	{
		return;
	}
	historyPosition += 1U;
	if (historyPosition == history.size())
	{
		historyCurrent = nullptr;
	}
	else if (history[historyPosition].snap)
	{
		historyCurrent = std::make_unique<Snapshot>(*history[historyPosition].snap);
	}
	else
	{
		historyCurrent = history[historyPosition - 1U].delta->Forward(*historyCurrent);
	}
}

void GameModel::HistoryPush(std::unique_ptr<Snapshot> last)
{
	Snapshot *rebaseOnto = nullptr;
	if (historyPosition)
	{
		rebaseOnto = history.back().snap.get();
		if (historyPosition < history.size())
		{
			historyCurrent = history[historyPosition - 1U].delta->Restore(*historyCurrent);
			rebaseOnto = historyCurrent.get();
		}
	}
	while (historyPosition < history.size())
	{
		history.pop_back();
	}
	if (rebaseOnto)
	{
		auto &prev = history.back();
		prev.delta = SnapshotDelta::FromSnapshots(*rebaseOnto, *last);
		prev.snap.reset();
	}
	history.emplace_back();
	history.back().snap = std::move(last);
	historyPosition += 1U;
	historyCurrent.reset();
	while (undoHistoryLimit < history.size())
	{
		history.pop_front();
		historyPosition -= 1U;
	}
}

unsigned int GameModel::GetUndoHistoryLimit()
{
	return undoHistoryLimit;
}

void GameModel::SetUndoHistoryLimit(unsigned int undoHistoryLimit_)
{
	undoHistoryLimit = undoHistoryLimit_;
	GlobalPrefs::Ref().Set("Simulation.UndoHistoryLimit", undoHistoryLimit);
}

void GameModel::SetVote(int direction)
{
	currentSave.queuedVote = direction;
}

void GameModel::Tick()
{
	if (currentSave.execVoteRequest && currentSave.execVoteRequest->CheckDone())
	{
		try
		{
			currentSave.execVoteRequest->Finish();
			currentSave.saveInfo->vote = currentSave.execVoteRequest->Direction();
			notifySaveChanged();
		}
		catch (const http::RequestError &ex)
		{
			new ErrorMessage("Error while voting", ByteString(ex.what()).FromUtf8());
		}
		currentSave.execVoteRequest.reset();
	}
	if (!currentSave.execVoteRequest && currentSave.queuedVote)
	{
		if (currentSave.saveInfo)
		{
			currentSave.execVoteRequest = std::make_unique<http::ExecVoteRequest>(currentSave.saveInfo->GetID(), *currentSave.queuedVote);
			currentSave.execVoteRequest->Start();
		}
		currentSave.queuedVote.reset();
	}
}

Brush &GameModel::GetBrush()
{
	return *brushList[currentBrush];
}

Brush *GameModel::GetBrushByID(int i)
{
	if (i >= 0 && i < (int)brushList.size())
		return brushList[i].get();
	else
		return nullptr;
}

int GameModel::GetBrushIndex(const Brush &brush)
{
	auto it = std::find_if(brushList.begin(), brushList.end(), [&brush](auto &ptr) {
		return ptr.get() == &brush;
	});
	return int(it - brushList.begin());
}

int GameModel::GetBrushID()
{
	return currentBrush;
}

void GameModel::SetBrushID(int i)
{
	auto prevRadius = brushList[currentBrush]->GetRadius();
	currentBrush = i%brushList.size();
	brushList[currentBrush]->SetRadius(prevRadius);
	notifyBrushChanged();
}

void GameModel::AddObserver(GameView * observer){
	observers.push_back(observer);

	observer->NotifySimulationChanged(this);
	observer->NotifyRendererChanged(this);
	observer->NotifyPausedChanged(this);
	observer->NotifySaveChanged(this);
	observer->NotifyBrushChanged(this);
	observer->NotifyMenuListChanged(this);
	observer->NotifyActiveMenuToolListChanged(this);
	observer->NotifyUserChanged(this);
	observer->NotifyZoomChanged(this);
	observer->NotifyColourSelectorVisibilityChanged(this);
	observer->NotifyColourSelectorColourChanged(this);
	observer->NotifyColourPresetsChanged(this);
	observer->NotifyColourActivePresetChanged(this);
	observer->NotifyQuickOptionsChanged(this);
	observer->NotifyLastToolChanged(this);
	UpdateQuickOptions();
}

void GameModel::SetToolStrength(float value)
{
	toolStrength = value;
}

float GameModel::GetToolStrength()
{
	return toolStrength;
}

void GameModel::SetActiveMenu(int menuID)
{
	activeMenu = menuID;
	notifyActiveMenuToolListChanged();

	if(menuID == SC_DECO)
	{
		if(activeTools != decoToolset.data())
		{
			activeTools = decoToolset.data();
			notifyActiveToolsChanged();
		}
	}
	else
	{
		if(activeTools != regularToolset.data())
		{
			activeTools = regularToolset.data();
			notifyActiveToolsChanged();
		}
	}
}

std::vector<Tool *> GameModel::GetActiveMenuToolList()
{
	std::vector<Tool *> activeMenuToolList;
	if (activeMenu >= 0 && activeMenu < int(menuList.size()))
	{
		activeMenuToolList = menuList[activeMenu]->GetToolList();
	}
	return activeMenuToolList;
}

int GameModel::GetActiveMenu()
{
	return activeMenu;
}

Tool * GameModel::GetActiveTool(int selection)
{
	return activeTools[selection];
}

void GameModel::SetActiveTool(int selection, Tool * tool)
{
	activeTools[selection] = tool;
	notifyActiveToolsChanged();
}

std::vector<QuickOption*> GameModel::GetQuickOptions()
{
	return quickOptions;
}

std::vector<Menu *> GameModel::GetMenuList()
{
	std::vector<Menu *> ptrs;
	for (auto &ptr : menuList)
	{
		ptrs.push_back(ptr.get());
	}
	return ptrs;
}

SaveInfo *GameModel::GetSave() // non-owning
{
	return currentSave.saveInfo.get();
}

std::unique_ptr<SaveInfo> GameModel::TakeSave()
{
	// we don't notify listeners because we'll get a new save soon anyway
	SaveInfoWrapper empty;
	std::swap(empty, currentSave);
	return std::move(empty.saveInfo);
}

void GameModel::SaveToSimParameters(const GameSave &saveData)
{
	SetPaused(saveData.paused | GetPaused());
	sim->gravityMode = saveData.gravityMode;
	sim->customGravityX = saveData.customGravityX;
	sim->customGravityY = saveData.customGravityY;
	sim->air->airMode = saveData.airMode;
	sim->air->ambientAirTemp = saveData.ambientAirTemp;
	sim->edgeMode = saveData.edgeMode;
	sim->legacy_enable = saveData.legacyEnable;
	sim->water_equal_test = saveData.waterEEnabled;
	sim->aheat_enable = saveData.aheatEnable;
	sim->EnableNewtonianGravity(saveData.gravityEnable);
	sim->frameCount = saveData.frameCount;
	if (saveData.hasRngState)
	{
		sim->rng.state(saveData.rngState);
	}
	else
	{
		sim->rng = RNG();
	}
	sim->ensureDeterminism = saveData.ensureDeterminism;
}

void GameModel::SetSave(std::unique_ptr<SaveInfo> newSave, bool invertIncludePressure)
{
	currentSave = { std::move(newSave) };
	currentFile.reset();

	if (currentSave.saveInfo && currentSave.saveInfo->GetGameSave())
	{
		auto *saveData = currentSave.saveInfo->GetGameSave();
		SaveToSimParameters(*saveData);
		sim->clear_sim();
		view->PauseRendererThread();
		ren->ClearAccumulation();
		sim->Load(saveData, !invertIncludePressure, { 0, 0 });
		// This save was created before logging existed
		// Add in the correct info
		if (saveData->authors.size() == 0)
		{
			auto gameSave = currentSave.saveInfo->TakeGameSave();
			gameSave->authors["type"] = "save";
			gameSave->authors["id"] = currentSave.saveInfo->id;
			gameSave->authors["username"] = currentSave.saveInfo->userName;
			gameSave->authors["title"] = currentSave.saveInfo->name.ToUtf8();
			gameSave->authors["description"] = currentSave.saveInfo->Description.ToUtf8();
			gameSave->authors["published"] = (int)currentSave.saveInfo->Published;
			gameSave->authors["date"] = (Json::Value::UInt64)currentSave.saveInfo->updatedDate;
			currentSave.saveInfo->SetGameSave(std::move(gameSave));
		}
		// This save was probably just created, and we didn't know the ID when creating it
		// Update with the proper ID
		else if (saveData->authors.get("id", -1) == 0 || saveData->authors.get("id", -1) == -1)
		{
			auto gameSave = currentSave.saveInfo->TakeGameSave();
			gameSave->authors["id"] = currentSave.saveInfo->id;
			currentSave.saveInfo->SetGameSave(std::move(gameSave));
		}
		Client::Ref().OverwriteAuthorInfo(saveData->authors);
	}
	notifySaveChanged();
	UpdateQuickOptions();
}

const SaveFile *GameModel::GetSaveFile() const
{
	return currentFile.get();
}

std::unique_ptr<SaveFile> GameModel::TakeSaveFile()
{
	// we don't notify listeners because we'll get a new save soon anyway
	return std::move(currentFile);
}

void GameModel::SetSaveFile(std::unique_ptr<SaveFile> newSave, bool invertIncludePressure)
{
	currentFile = std::move(newSave);
	currentSave = {};

	if (currentFile && currentFile->GetGameSave())
	{
		auto *saveData = currentFile->GetGameSave();
		SaveToSimParameters(*saveData);
		sim->clear_sim();
		view->PauseRendererThread();
		ren->ClearAccumulation();
		sim->Load(saveData, !invertIncludePressure, { 0, 0 });
		Client::Ref().OverwriteAuthorInfo(saveData->authors);
	}

	notifySaveChanged();
	UpdateQuickOptions();
}

Simulation * GameModel::GetSimulation()
{
	return sim;
}

Renderer * GameModel::GetRenderer()
{
	return ren;
}

User GameModel::GetUser()
{
	return currentUser;
}

Tool * GameModel::GetLastTool()
{
	return lastTool;
}

void GameModel::SetLastTool(Tool * newTool)
{
	if(lastTool != newTool)
	{
		lastTool = newTool;
		notifyLastToolChanged();
	}
}

void GameModel::SetZoomEnabled(bool enabled)
{
	view->GetGraphics()->zoomEnabled = enabled;
	notifyZoomChanged();
}

bool GameModel::GetZoomEnabled()
{
	return view->GetGraphics()->zoomEnabled;
}

void GameModel::SetZoomPosition(ui::Point position)
{
	view->GetGraphics()->zoomScopePosition = position;
	notifyZoomChanged();
}

ui::Point GameModel::GetZoomPosition()
{
	return view->GetGraphics()->zoomScopePosition;
}

bool GameModel::MouseInZoom(ui::Point position)
{
	if (!GetZoomEnabled())
		return false;

	int zoomFactor = GetZoomFactor();
	ui::Point zoomWindowPosition = GetZoomWindowPosition();
	ui::Point zoomWindowSize = ui::Point(GetZoomSize()*zoomFactor, GetZoomSize()*zoomFactor);

	if (position.X >= zoomWindowPosition.X && position.Y >= zoomWindowPosition.Y && position.X < zoomWindowPosition.X+zoomWindowSize.X && position.Y < zoomWindowPosition.Y+zoomWindowSize.Y)
		return true;
	return false;
}

ui::Point GameModel::AdjustZoomCoords(ui::Point position)
{
	if (!GetZoomEnabled())
		return position;

	int zoomFactor = GetZoomFactor();
	ui::Point zoomWindowPosition = GetZoomWindowPosition();
	ui::Point zoomWindowSize = ui::Point(GetZoomSize()*zoomFactor, GetZoomSize()*zoomFactor);

	if (position.X >= zoomWindowPosition.X && position.Y >= zoomWindowPosition.Y && position.X < zoomWindowPosition.X+zoomWindowSize.X && position.Y < zoomWindowPosition.Y+zoomWindowSize.Y)
		return ((position-zoomWindowPosition)/GetZoomFactor())+GetZoomPosition();
	return position;
}

void GameModel::SetZoomWindowPosition(ui::Point position)
{
	view->GetGraphics()->zoomWindowPosition = position;
	notifyZoomChanged();
}

ui::Point GameModel::GetZoomWindowPosition()
{
	return view->GetGraphics()->zoomWindowPosition;
}

void GameModel::SetZoomSize(int size)
{
	view->GetGraphics()->zoomScopeSize = size;
	notifyZoomChanged();
}

int GameModel::GetZoomSize()
{
	return view->GetGraphics()->zoomScopeSize;
}

void GameModel::SetZoomFactor(int factor)
{
	view->GetGraphics()->ZFACTOR = factor;
	notifyZoomChanged();
}

int GameModel::GetZoomFactor()
{
	return view->GetGraphics()->ZFACTOR;
}

void GameModel::SetActiveColourPreset(size_t preset)
{
	if (activeColourPreset-1 != preset)
		activeColourPreset = preset+1;
	else
	{
		activeTools[0] = GetToolFromIdentifier("DEFAULT_DECOR_SET");
		notifyActiveToolsChanged();
	}
	notifyColourActivePresetChanged();
}

size_t GameModel::GetActiveColourPreset()
{
	return activeColourPreset-1;
}

void GameModel::SetPresetColour(ui::Colour colour)
{
	if (activeColourPreset > 0 && activeColourPreset <= colourPresets.size())
	{
		colourPresets[activeColourPreset-1] = colour;
		notifyColourPresetsChanged();
	}
}

std::vector<ui::Colour> GameModel::GetColourPresets()
{
	return colourPresets;
}

void GameModel::SetColourSelectorVisibility(bool visibility)
{
	if(colourSelector != visibility)
	{
		colourSelector = visibility;
		notifyColourSelectorVisibilityChanged();
	}
}

bool GameModel::GetColourSelectorVisibility()
{
	return colourSelector;
}

void GameModel::SetColourSelectorColour(ui::Colour colour_)
{
	colour = colour_;

	std::vector<Tool*> tools = GetMenuList()[SC_DECO]->GetToolList();
	for (auto tool : tools)
		static_cast<DecorationTool *>(tool)->Colour = colour;

	notifyColourSelectorColourChanged();
}

ui::Colour GameModel::GetColourSelectorColour()
{
	return colour;
}

void GameModel::SetUser(User user)
{
	currentUser = user;
	//Client::Ref().SetAuthUser(user);
	notifyUserChanged();
}

void GameModel::SetPaused(bool pauseState)
{
	if (!pauseState && sim->debug_nextToUpdate > 0)
	{
		String logmessage = String::Build("Updated particles from #", sim->debug_nextToUpdate, " to end due to unpause");
		UpdateUpTo(NPART);
		Log(logmessage, false);
	}

	sim->sys_pause = pauseState?1:0;
	notifyPausedChanged();
}

bool GameModel::GetPaused() const
{
	return sim->sys_pause?true:false;
}

void GameModel::SetDecoration(bool decorationState)
{
	auto desiredLevel = decorationState ? RendererSettings::decorationEnabled : RendererSettings::decorationDisabled;
	if (rendererSettings.decorationLevel != desiredLevel)
	{
		rendererSettings.decorationLevel = desiredLevel;
		notifyDecorationChanged();
		UpdateQuickOptions();
		if (decorationState)
			SetInfoTip("Decorations Layer: On");
		else
			SetInfoTip("Decorations Layer: Off");
	}
}

bool GameModel::GetDecoration()
{
	return rendererSettings.decorationLevel != RendererSettings::decorationDisabled;
}

void GameModel::SetAHeatEnable(bool aHeat)
{
	sim->aheat_enable = aHeat;
	UpdateQuickOptions();
	if (aHeat)
		SetInfoTip("Ambient Heat: On");
	else
		SetInfoTip("Ambient Heat: Off");
}

bool GameModel::GetAHeatEnable()
{
	return sim->aheat_enable;
}

void GameModel::ResetAHeat()
{
	sim->air->ClearAirH();
}

void GameModel::SetNewtonianGravity(bool newtonainGravity)
{
	sim->EnableNewtonianGravity(newtonainGravity);
    if (newtonainGravity)
    {
        SetInfoTip("Newtonian Gravity: On");
    }
    else
    {
        SetInfoTip("Newtonian Gravity: Off");
    }
    UpdateQuickOptions();
}

bool GameModel::GetNewtonianGrvity()
{
    return bool(sim->grav);
}

void GameModel::ShowGravityGrid(bool showGrid)
{
	rendererSettings.gravityFieldEnabled = showGrid;
	if (showGrid)
		SetInfoTip("Gravity Grid: On");
	else
		SetInfoTip("Gravity Grid: Off");
}

bool GameModel::GetGravityGrid()
{
	return rendererSettings.gravityFieldEnabled;
}

void GameModel::FrameStep(int frames)
{
	sim->framerender += frames;
}

void GameModel::ClearSimulation()
{
	//Load defaults
	sim->gravityMode = GRAV_VERTICAL;
	sim->customGravityX = 0.0f;
	sim->customGravityY = 0.0f;
	sim->air->airMode = AIR_ON;
	sim->legacy_enable = false;
	sim->water_equal_test = false;
	sim->SetEdgeMode(edgeMode);
	sim->air->ambientAirTemp = ambientAirTemp;

	sim->clear_sim();
	ren->ClearAccumulation();
	Client::Ref().ClearAuthorInfo();

	notifySaveChanged();
	UpdateQuickOptions();
}

void GameModel::SetPlaceSave(std::unique_ptr<GameSave> save)
{
	transformedPlaceSave.reset();
	placeSave = std::move(save);
	notifyPlaceSaveChanged();
	if (placeSave && placeSave->missingElements)
	{
		Log("Paste content has missing custom elements", false);
	}
}

void GameModel::TransformPlaceSave(Mat2<int> transform, Vec2<int> nudge)
{
	if (placeSave)
	{
		transformedPlaceSave = std::make_unique<GameSave>(*placeSave);
		transformedPlaceSave->Transform(transform, nudge);
	}
	notifyTransformedPlaceSaveChanged();
}

void GameModel::SetClipboard(std::unique_ptr<GameSave> save)
{
	Clipboard::SetClipboardData(std::move(save));
}

const GameSave *GameModel::GetClipboard() const
{
	return Clipboard::GetClipboardData();
}

const GameSave *GameModel::GetTransformedPlaceSave() const
{
	return transformedPlaceSave.get();
}

void GameModel::Log(String message, bool printToFile)
{
	if (logSink)
	{
		logSink(message);
	}
	else
	{
		consoleLog.push_front(message);
		if(consoleLog.size()>100)
			consoleLog.pop_back();
		notifyLogChanged(message);
	}
	if (printToFile)
		std::cout << format::CleanString(message, false, true, false).ToUtf8() << std::endl;
}

std::deque<String> GameModel::GetLog()
{
	return consoleLog;
}

std::vector<Notification*> GameModel::GetNotifications()
{
	return notifications;
}

void GameModel::AddNotification(Notification * notification)
{
	notifications.push_back(notification);
	notifyNotificationsChanged();
}

void GameModel::RemoveNotification(Notification * notification)
{
	for(std::vector<Notification*>::iterator iter = notifications.begin(); iter != notifications.end(); ++iter)
	{
		if(*iter == notification)
		{
			delete *iter;
			notifications.erase(iter);
			break;
		}
	}
	notifyNotificationsChanged();
}

void GameModel::SetToolTip(String text)
{
	toolTip = text;
	notifyToolTipChanged();
}

void GameModel::SetInfoTip(String text)
{
	infoTip = text;
	notifyInfoTipChanged();
}

String GameModel::GetToolTip()
{
	return toolTip;
}

String GameModel::GetInfoTip()
{
	return infoTip;
}

void GameModel::notifyNotificationsChanged()
{
	for (std::vector<GameView*>::iterator iter = observers.begin(); iter != observers.end(); ++iter)
	{
		(*iter)->NotifyNotificationsChanged(this);
	}
}

void GameModel::notifyColourPresetsChanged()
{
	for (std::vector<GameView*>::iterator iter = observers.begin(); iter != observers.end(); ++iter)
	{
		(*iter)->NotifyColourPresetsChanged(this);
	}
}

void GameModel::notifyColourActivePresetChanged()
{
	for (std::vector<GameView*>::iterator iter = observers.begin(); iter != observers.end(); ++iter)
	{
		(*iter)->NotifyColourActivePresetChanged(this);
	}
}

void GameModel::notifyColourSelectorColourChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyColourSelectorColourChanged(this);
	}
}

void GameModel::notifyColourSelectorVisibilityChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyColourSelectorVisibilityChanged(this);
	}
}

void GameModel::notifyRendererChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyRendererChanged(this);
	}
}

void GameModel::notifySaveChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifySaveChanged(this);
	}
}

void GameModel::notifySimulationChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifySimulationChanged(this);
	}
}

void GameModel::notifyPausedChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyPausedChanged(this);
	}
}

void GameModel::notifyDecorationChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		//observers[i]->NotifyPausedChanged(this);
	}
}

void GameModel::notifyBrushChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyBrushChanged(this);
	}
}

void GameModel::notifyMenuListChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyMenuListChanged(this);
	}
}

void GameModel::notifyActiveMenuToolListChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyActiveMenuToolListChanged(this);
	}
}

void GameModel::notifyActiveToolsChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyActiveToolsChanged(this);
	}
}

void GameModel::notifyUserChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyUserChanged(this);
	}
}

void GameModel::notifyZoomChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyZoomChanged(this);
	}
}

void GameModel::notifyPlaceSaveChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyPlaceSaveChanged(this);
	}
}

void GameModel::notifyTransformedPlaceSaveChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyTransformedPlaceSaveChanged(this);
	}
}

void GameModel::notifyLogChanged(String entry)
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyLogChanged(this, entry);
	}
}

void GameModel::notifyInfoTipChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyInfoTipChanged(this);
	}
}

void GameModel::notifyToolTipChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyToolTipChanged(this);
	}
}

void GameModel::notifyQuickOptionsChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyQuickOptionsChanged(this);
	}
}

void GameModel::notifyLastToolChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyLastToolChanged(this);
	}
}

bool GameModel::GetMouseClickRequired()
{
	return mouseClickRequired;
}

void GameModel::SetMouseClickRequired(bool mouseClickRequired)
{
	this->mouseClickRequired = mouseClickRequired;
}

bool GameModel::GetIncludePressure()
{
	return includePressure;
}

void GameModel::SetIncludePressure(bool includePressure)
{
	this->includePressure = includePressure;
}

void GameModel::SetPerfectCircle(bool perfectCircle)
{
	if (perfectCircle != this->perfectCircle)
	{
		this->perfectCircle = perfectCircle;
		BuildBrushList();
	}
}

bool GameModel::AddCustomGol(String ruleString, String nameString, RGB color1, RGB color2)
{
	if (auto gd = CheckCustomGol(ruleString, nameString, color1, color2))
	{
		auto &sd = SimulationData::Ref();
		auto newCustomGol = sd.GetCustomGol();
		newCustomGol.push_back(*gd);
		sd.SetCustomGOL(newCustomGol);
		AllocCustomGolTool(*gd);
		SaveCustomGol();
		BuildMenus();
		return true;
	}
	return false;
}

bool GameModel::RemoveCustomGol(const ByteString &identifier)
{
	bool removedAny = false;
	std::vector<CustomGOLData> newCustomGol;
	auto &sd = SimulationData::Ref();
	for (auto gol : sd.GetCustomGol())
	{
		if ("DEFAULT_PT_LIFECUST_" + gol.nameString == identifier.FromUtf8())
		{
			removedAny = true;
		}
		else
		{
			newCustomGol.push_back(gol);
		}
	}
	if (removedAny)
	{
		sd.SetCustomGOL(newCustomGol);
		FreeTool(GetToolFromIdentifier(identifier));
		BuildMenus();
		SaveCustomGol();
	}
	return removedAny;
}

void GameModel::LoadCustomGol()
{
	auto &prefs = GlobalPrefs::Ref();
	auto customGOLTypes = prefs.Get("CustomGOL.Types", std::vector<ByteString>{});
	bool removedAny = false;
	std::vector<CustomGOLData> newCustomGol;
	for (auto gol : customGOLTypes)
	{
		auto parts = gol.FromUtf8().PartitionBy(' ');
		if (parts.size() != 4)
		{
			removedAny = true;
			continue;
		}
		auto nameString = parts[0];
		auto ruleString = parts[1];
		auto &colour1String = parts[2];
		auto &colour2String = parts[3];
		RGB color1;
		RGB color2;
		try
		{
			color1 = RGB::Unpack(colour1String.ToNumber<int>());
			color2 = RGB::Unpack(colour2String.ToNumber<int>());
		}
		catch (std::exception &)
		{
			removedAny = true;
			continue;
		}
		if (auto gd = CheckCustomGol(ruleString, nameString, color1, color2))
		{
			newCustomGol.push_back(*gd);
			AllocCustomGolTool(*gd);
		}
		else
		{
			removedAny = true;
		}
	}
	auto &sd = SimulationData::Ref();
	sd.SetCustomGOL(newCustomGol);
	if (removedAny)
	{
		SaveCustomGol();
	}
}

void GameModel::SaveCustomGol()
{
	auto &prefs = GlobalPrefs::Ref();
	std::vector<ByteString> newCustomGOLTypes;
	auto &sd = SimulationData::Ref();
	for (auto &gd : sd.GetCustomGol())
	{
		StringBuilder sb;
		sb << gd.nameString << " " << SerialiseGOLRule(gd.rule) << " " << gd.colour1.Pack() << " " << gd.colour2.Pack();
		newCustomGOLTypes.push_back(sb.Build().ToUtf8());
	}
	prefs.Set("CustomGOL.Types", newCustomGOLTypes);
}

std::optional<CustomGOLData> GameModel::CheckCustomGol(String ruleString, String nameString, RGB color1, RGB color2)
{
	if (!ValidateGOLName(nameString))
	{
		return std::nullopt;
	}
	auto rule = ParseGOLString(ruleString);
	if (rule == -1)
	{
		return std::nullopt;
	}
	auto &sd = SimulationData::Ref();
	for (auto &gd : sd.GetCustomGol())
	{
		if (gd.nameString == nameString)
		{
			return std::nullopt;
		}
	}
	return CustomGOLData{ rule, color1, color2, nameString };
}

void GameModel::UpdateUpTo(int upTo)
{
	if (upTo < sim->debug_nextToUpdate)
	{
		upTo = NPART;
	}
	if (sim->debug_nextToUpdate == 0)
	{
		BeforeSim();
	}
	sim->UpdateParticles(sim->debug_nextToUpdate, upTo);
	if (upTo < NPART)
	{
		sim->debug_nextToUpdate = upTo;
	}
	else
	{
		AfterSim();
		sim->debug_nextToUpdate = 0;
	}
}

void GameModel::BeforeSim()
{
	if (!sim->sys_pause || sim->framerender)
	{
		CommandInterface::Ref().HandleEvent(BeforeSimEvent{});
	}
	sim->BeforeSim();
}

void GameModel::AfterSim()
{
	sim->AfterSim();
	CommandInterface::Ref().HandleEvent(AfterSimEvent{});
}

Tool *GameModel::GetToolByIndex(int index)
{
	if (index < 0 || index >= int(tools.size()))
	{
		return nullptr;
	}
	return tools[index].get();
}

void GameModel::SanitizeToolsets()
{
	if (!decoToolset   [0]) decoToolset   [0] = GetToolFromIdentifier("DEFAULT_DECOR_SET");
	if (!decoToolset   [1]) decoToolset   [1] = GetToolFromIdentifier("DEFAULT_DECOR_CLR");
	if (!decoToolset   [2]) decoToolset   [2] = GetToolFromIdentifier("DEFAULT_UI_SAMPLE");
	if (!decoToolset   [3]) decoToolset   [3] = GetToolFromIdentifier("DEFAULT_PT_NONE"  );
	if (!regularToolset[0]) regularToolset[0] = GetToolFromIdentifier("DEFAULT_PT_DUST"  );
	if (!regularToolset[1]) regularToolset[1] = GetToolFromIdentifier("DEFAULT_PT_NONE"  );
	if (!regularToolset[2]) regularToolset[2] = GetToolFromIdentifier("DEFAULT_UI_SAMPLE");
	if (!regularToolset[3]) regularToolset[3] = GetToolFromIdentifier("DEFAULT_PT_NONE"  );
	if (!lastTool)
	{
		lastTool = activeTools[0];
	}
}

void GameModel::DeselectTool(ByteString identifier)
{
	auto *tool = GetToolFromIdentifier(identifier);
	for (auto &slot : decoToolset)
	{
		if (slot == tool)
		{
			slot = nullptr;
		}
	}
	for (auto &slot : regularToolset)
	{
		if (slot == tool)
		{
			slot = nullptr;
		}
	}
	if (lastTool == tool)
	{
		lastTool = nullptr;
	}
	SanitizeToolsets();
}

void GameModel::AllocTool(std::unique_ptr<Tool> tool)
{
	std::optional<int> index;
	for (int i = 0; i < int(tools.size()); ++i)
	{
		if (!tools[i])
		{
			index = i;
			break;
		}
	}
	if (!index)
	{
		index = int(tools.size());
		tools.emplace_back();
	}
	GameController::Ref().SetToolIndex(tool->Identifier, *index);
	tools[*index] = std::move(tool);
}

void GameModel::FreeTool(Tool *tool)
{
	auto index = GetToolIndex(tool);
	if (!index)
	{
		return;
	}
	auto &ptr = tools[*index];
	DeselectTool(ptr->Identifier);
	GameController::Ref().SetToolIndex(ptr->Identifier, std::nullopt);
	ptr.reset();
}

std::optional<int> GameModel::GetToolIndex(Tool *tool)
{
	if (tool)
	{
		for (int i = 0; i < int(tools.size()); ++i)
		{
			if (tools[i].get() == tool)
			{
				return i;
			}
		}
	}
	return std::nullopt;
}

void GameModel::AllocCustomGolTool(const CustomGOLData &gd)
{
	auto tool = std::make_unique<ElementTool>(PMAP(gd.rule, PT_LIFE), gd.nameString, "Custom GOL type: " + SerialiseGOLRule(gd.rule), gd.colour1, "DEFAULT_PT_LIFECUST_" + gd.nameString.ToAscii(), nullptr);
	tool->MenuSection = SC_LIFE;
	AllocTool(std::move(tool));
}

void GameModel::UpdateElementTool(int element)
{
	auto &sd = SimulationData::Ref();
	auto &elements = sd.elements;
	auto &elem = elements[element];
	auto *tool = GetToolFromIdentifier(elem.Identifier);
	tool->Name = elem.Name;
	tool->Description = elem.Description;
	tool->Colour = elem.Colour;
	tool->textureGen = elem.IconGenerator;
	tool->MenuSection = elem.MenuSection;
	tool->MenuVisible = elem.MenuVisible;
}

void GameModel::AllocElementTool(int element)
{
	auto &sd = SimulationData::Ref();
	auto &elements = sd.elements;
	auto &elem = elements[element];
	switch (element)
	{
	case PT_LIGH:
		AllocTool(std::make_unique<Element_LIGH_Tool>(element, elem.Identifier));
		break;

	case PT_TESC:
		AllocTool(std::make_unique<Element_TESC_Tool>(element, elem.Identifier));
		break;

	case PT_STKM:
	case PT_FIGH:
	case PT_STKM2:
		AllocTool(std::make_unique<PlopTool>(element, elem.Identifier));
		break;

	default:
		AllocTool(std::make_unique<ElementTool>(element, elem.Identifier));
		break;
	}
	UpdateElementTool(element);
}

void GameModel::InitTools()
{
	auto &sd = SimulationData::Ref();
	auto &elements = sd.elements;
	auto &builtinGol = SimulationData::builtinGol;
	for (int i = 0; i < PT_NUM; ++i)
	{
		if (elements[i].Enabled)
		{
			AllocElementTool(i);
		}
	}
	for (int i = 0; i < NGOL; ++i)
	{
		auto tool = std::make_unique<ElementTool>(PMAP(i, PT_LIFE), builtinGol[i].name, builtinGol[i].description, builtinGol[i].colour, "DEFAULT_PT_LIFE_" + builtinGol[i].name.ToAscii());
		tool->MenuSection = SC_LIFE;
		AllocTool(std::move(tool));
	}
	for (int i = 0; i < UI_WALLCOUNT; ++i)
	{
		auto tool = std::make_unique<WallTool>(i, sd.wtypes[i].descs, sd.wtypes[i].colour, sd.wtypes[i].identifier, sd.wtypes[i].textureGen);
		tool->MenuSection = SC_WALL;
		AllocTool(std::move(tool));
	}
	for (auto &tool : ::GetTools())
	{
		AllocTool(std::make_unique<SimTool>(tool));
	}
	AllocTool(std::make_unique<DecorationTool>(view, DECO_ADD     , "ADD" , "Colour blending: Add."                         , 0x000000_rgb, "DEFAULT_DECOR_ADD" ));
	AllocTool(std::make_unique<DecorationTool>(view, DECO_SUBTRACT, "SUB" , "Colour blending: Subtract."                    , 0x000000_rgb, "DEFAULT_DECOR_SUB" ));
	AllocTool(std::make_unique<DecorationTool>(view, DECO_MULTIPLY, "MUL" , "Colour blending: Multiply."                    , 0x000000_rgb, "DEFAULT_DECOR_MUL" ));
	AllocTool(std::make_unique<DecorationTool>(view, DECO_DIVIDE  , "DIV" , "Colour blending: Divide."                      , 0x000000_rgb, "DEFAULT_DECOR_DIV" ));
	AllocTool(std::make_unique<DecorationTool>(view, DECO_SMUDGE  , "SMDG", "Smudge tool, blends surrounding deco together.", 0x000000_rgb, "DEFAULT_DECOR_SMDG"));
	AllocTool(std::make_unique<DecorationTool>(view, DECO_CLEAR   , "CLR" , "Erase any set decoration."                     , 0x000000_rgb, "DEFAULT_DECOR_CLR" ));
	AllocTool(std::make_unique<DecorationTool>(view, DECO_DRAW    , "SET" , "Draw decoration (No blending)."                , 0x000000_rgb, "DEFAULT_DECOR_SET" ));
	AllocTool(std::make_unique<PropertyTool>(*this));
	AllocTool(std::make_unique<SignTool>(*this));
	AllocTool(std::make_unique<SampleTool>(*this));
	AllocTool(std::make_unique<GOLTool>(*this));
	LoadCustomGol();

	SanitizeToolsets();
	lastTool = activeTools[0];
	BuildMenus();
}

void GameModel::BuildMenus()
{
	auto &sd = SimulationData::Ref();

	menuList.clear();
	for (auto &section : sd.msections)
	{
		menuList.push_back(std::make_unique<Menu>(section.icon, section.name, section.doshow));
	}

	for (auto &tool : tools)
	{
		if (!tool)
		{
			continue;
		}
		if (tool->MenuSection >= 0 && tool->MenuSection < int(sd.msections.size()) && tool->MenuVisible)
		{
			menuList[tool->MenuSection]->AddTool(tool.get());
		}
	}

	for (auto &fav : Favorite::Ref().GetFavoritesList())
	{
		if (auto *tool = GetToolFromIdentifier(fav))
		{
			menuList[SC_FAVORITES]->AddTool(tool);
		}
	}

	notifyMenuListChanged();
	notifyActiveMenuToolListChanged();
	notifyActiveToolsChanged();
	notifyLastToolChanged();
}


=== src\gui\game\GameModel.h ===

#pragma once
#include "gui/interface/Colour.h"
#include "client/User.h"
#include "gui/interface/Point.h"
#include "graphics/RendererSettings.h"
#include "simulation/CustomGOLData.h"
#include <vector>
#include <deque>
#include <memory>
#include <optional>
#include <functional>
#include <array>

constexpr auto NUM_TOOLINDICES = 4;

class Menu;
class Tool;
class QuickOption;
class Brush;
class GameView;
class Notification;
class GameController;
class SaveInfo;
class SaveFile;
class Simulation;
class Renderer;
class Snapshot;
struct SnapshotDelta;
class GameSave;

namespace http
{
	class ExecVoteRequest;
};

class ToolSelection
{
public:
	enum
	{
		ToolPrimary, ToolSecondary, ToolTertiary
	};
};

struct HistoryEntry
{
	std::unique_ptr<Snapshot> snap;
	std::unique_ptr<SnapshotDelta> delta;

	~HistoryEntry();
};

class GameModel
{

private:
	std::vector<Notification*> notifications;
	std::unique_ptr<GameSave> placeSave;
	std::unique_ptr<GameSave> transformedPlaceSave;
	std::deque<String> consoleLog;
	std::vector<GameView*> observers;

	std::vector<std::unique_ptr<Tool>> tools;

	void SanitizeToolsets();
	void DeselectTool(ByteString identifier);
	void InitTools();

	Simulation * sim;
	Renderer * ren;
	RendererSettings rendererSettings;
	std::vector<std::unique_ptr<Menu>> menuList;
	std::vector<QuickOption*> quickOptions;
	int activeMenu;
	int currentBrush;
	std::vector<std::unique_ptr<Brush>> brushList;
	struct SaveInfoWrapper
	{
		std::unique_ptr<SaveInfo> saveInfo;
		std::optional<int> queuedVote;
		std::unique_ptr<http::ExecVoteRequest> execVoteRequest;
	};
	SaveInfoWrapper currentSave;
	std::unique_ptr<SaveFile> currentFile;
	Tool *lastTool = nullptr;
	Tool **activeTools = nullptr;
	std::array<Tool *, NUM_TOOLINDICES> decoToolset;
	std::array<Tool *, NUM_TOOLINDICES> regularToolset;
	User currentUser;
	float toolStrength;
	std::deque<HistoryEntry> history;
	std::unique_ptr<Snapshot> historyCurrent;
	unsigned int historyPosition;
	unsigned int undoHistoryLimit;
	bool mouseClickRequired;
	bool includePressure;
	bool perfectCircle = true;
	int temperatureScale;

	size_t activeColourPreset;
	std::vector<ui::Colour> colourPresets;
	bool colourSelector;
	ui::Colour colour;

	int edgeMode;
	float ambientAirTemp;
	int decoSpace;

	String infoTip;
	String toolTip;
	//bool zoomEnabled;
	void notifyRendererChanged();
	void notifySimulationChanged();
	void notifyPausedChanged();
	void notifyDecorationChanged();
	void notifySaveChanged();
	void notifyBrushChanged();
	void notifyMenuListChanged();
	void notifyActiveMenuToolListChanged();
	void notifyActiveToolsChanged();
	void notifyUserChanged();
	void notifyZoomChanged();
	void notifyClipboardChanged();
	void notifyPlaceSaveChanged();
	void notifyTransformedPlaceSaveChanged();
	void notifyColourSelectorColourChanged();
	void notifyColourSelectorVisibilityChanged();
	void notifyColourPresetsChanged();
	void notifyColourActivePresetChanged();
	void notifyNotificationsChanged();
	void notifyLogChanged(String entry);
	void notifyInfoTipChanged();
	void notifyToolTipChanged();
	void notifyQuickOptionsChanged();
	void notifyLastToolChanged();

	void SaveToSimParameters(const GameSave &saveData);

	bool threadedRendering = false;

	GameView *view;

public:
	GameModel(GameView *newView);
	~GameModel();

	void Tick();

	Tool *GetToolByIndex(int index);

	void SetEdgeMode(int edgeMode);
	int GetEdgeMode();
	void SetTemperatureScale(int temperatureScale);
	inline int GetTemperatureScale() const
	{
		return temperatureScale;
	}
	void SetThreadedRendering(bool newThreadedRendering);
	bool GetThreadedRendering() const
	{
		return threadedRendering;
	}
	void SetAmbientAirTemperature(float ambientAirTemp);
	float GetAmbientAirTemperature();
	void SetDecoSpace(int decoSpace);
	int GetDecoSpace();

	void SetActiveColourPreset(size_t preset);
	size_t GetActiveColourPreset();

	void SetPresetColour(ui::Colour colour);

	std::vector<ui::Colour> GetColourPresets();

	void SetColourSelectorVisibility(bool visibility);
	bool GetColourSelectorVisibility();

	void SetColourSelectorColour(ui::Colour colour);
	ui::Colour GetColourSelectorColour();

	void SetToolTip(String text);
	void SetInfoTip(String text);
	String GetToolTip();
	String GetInfoTip();

	void BuildMenus();
	void BuildBrushList();
	void BuildQuickOptionMenu(GameController * controller);

	const Snapshot *HistoryCurrent() const;
	bool HistoryCanRestore() const;
	void HistoryRestore();
	bool HistoryCanForward() const;
	void HistoryForward();
	void HistoryPush(std::unique_ptr<Snapshot> last);
	unsigned int GetUndoHistoryLimit();
	void SetUndoHistoryLimit(unsigned int undoHistoryLimit_);

	void UpdateQuickOptions();

	Tool * GetActiveTool(int selection);
	void SetActiveTool(int selection, Tool * tool);
	void SetToolStrength(float value);
	float GetToolStrength();
	Tool * GetLastTool();
	void SetLastTool(Tool * newTool);
	Tool *GetToolFromIdentifier(ByteString const &identifier);
	std::optional<int> GetToolIndex(Tool *tool);
	std::vector<Tool *> GetActiveMenuToolList();
	void AllocTool(std::unique_ptr<Tool> tool);
	void AllocElementTool(int element);
	void UpdateElementTool(int element);
	void AllocCustomGolTool(const CustomGOLData &gd);
	void FreeTool(Tool *tool);

	const std::vector<std::unique_ptr<Tool>> &GetTools()
	{
		return tools;
	}

	Brush &GetBrush();
	Brush *GetBrushByID(int i);
	int GetBrushID();
	int GetBrushIndex(const Brush &brush);
	int BrushListSize() const
	{
		return int(brushList.size());
	}
	void SetBrushID(int i);

	void SetVote(int direction);
	SaveInfo *GetSave(); // non-owning
	std::unique_ptr<SaveInfo> TakeSave();
	const SaveFile *GetSaveFile() const;
	std::unique_ptr<SaveFile> TakeSaveFile();
	void SetSave(std::unique_ptr<SaveInfo> newSave, bool invertIncludePressure);
	void SetSaveFile(std::unique_ptr<SaveFile> newSave, bool invertIncludePressure);
	void AddObserver(GameView * observer);

	void SetPaused(bool pauseState);
	bool GetPaused() const;
	void SetDecoration(bool decorationState);
	bool GetDecoration();
	void SetAHeatEnable(bool aHeat);
	bool GetAHeatEnable();
	void ResetAHeat();
	void SetNewtonianGravity(bool newtonainGravity);
	bool GetNewtonianGrvity();
	void ShowGravityGrid(bool showGrid);
	bool GetGravityGrid();
	void ClearSimulation();
	std::vector<Menu*> GetMenuList();
	std::vector<QuickOption*> GetQuickOptions();
	void SetActiveMenu(int menuID);
	int GetActiveMenu();
	void FrameStep(int frames);
	User GetUser();
	void SetUser(User user);
	Simulation * GetSimulation();
	Renderer * GetRenderer();
	RendererSettings &GetRendererSettings()
	{
		return rendererSettings;
	}
	void SetZoomEnabled(bool enabled);
	bool GetZoomEnabled();
	void SetZoomSize(int size);
	int GetZoomSize();
	void SetZoomFactor(int factor);
	int GetZoomFactor();
	void SetZoomPosition(ui::Point position);
	ui::Point GetZoomPosition();
	bool MouseInZoom(ui::Point position);
	ui::Point AdjustZoomCoords(ui::Point position);
	void SetZoomWindowPosition(ui::Point position);
	ui::Point GetZoomWindowPosition();
	void SetClipboard(std::unique_ptr<GameSave> save);
	void SetPlaceSave(std::unique_ptr<GameSave> save);
	void TransformPlaceSave(Mat2<int> transform, Vec2<int> nudge);

	std::function<void (String)> logSink;
	void Log(String message, bool printToFile);

	std::deque<String> GetLog();
	const GameSave *GetClipboard() const;
	const GameSave *GetPlaceSave() const;
	const GameSave *GetTransformedPlaceSave() const;
	bool GetMouseClickRequired();
	void SetMouseClickRequired(bool mouseClickRequired);
	bool GetIncludePressure();
	void SetIncludePressure(bool includePressure);
	void SetPerfectCircle(bool perfectCircle);
	inline bool GetPerfectCircle() const
	{
		return perfectCircle;
	}

	std::vector<Notification*> GetNotifications();
	void AddNotification(Notification * notification);
	void RemoveNotification(Notification * notification);

	bool AddCustomGol(String ruleString, String nameString, RGB color1, RGB color2);
	bool RemoveCustomGol(const ByteString &identifier);
	void LoadCustomGol();
	void SaveCustomGol();
	std::optional<CustomGOLData> CheckCustomGol(String ruleString, String nameString, RGB color1, RGB color2);

	ByteString SelectNextIdentifier;
	int SelectNextTool;

	void UpdateUpTo(int upTo);
	void BeforeSim();
	void AfterSim();

	GameView *GetView() const
	{
		return view;
	}
};


=== src\gui\game\GameModelException.h ===

#pragma once
#include "common/String.h"
#include <exception>

struct GameModelException: public std::exception
{
	ByteString message;
public:
	GameModelException(String message_): message(message_.ToUtf8()) {}
	const char * what() const throw() override
	{
		return message.c_str();
	}
	~GameModelException() throw() {}
};


=== src\gui\game\GameView.cpp ===

#include "GameView.h"

#include "Brush.h"
#include "tool/DecorationTool.h"
#include "tool/PropertyTool.h"
#include "Favorite.h"
#include "Format.h"
#include "GameController.h"
#include "GameModel.h"
#include "IntroText.h"
#include "Menu.h"
#include "MenuButton.h"
#include "Misc.h"
#include "Notification.h"
#include "ToolButton.h"
#include "QuickOptions.h"
#include "PowderToySDL.h"

#include "client/SaveInfo.h"
#include "client/SaveFile.h"
#include "client/Client.h"
#include "client/GameSave.h"
#include "common/platform/Platform.h"
#include "graphics/Graphics.h"
#include "graphics/Renderer.h"
#include "graphics/VideoBuffer.h"
#include "gui/Style.h"
#include "simulation/ElementClasses.h"
#include "simulation/ElementDefs.h"
#include "simulation/SaveRenderer.h"
#include "simulation/SimulationData.h"
#include "simulation/Simulation.h"

#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/dialogues/InformationMessage.h"
#include "gui/interface/Button.h"
#include "gui/interface/Colour.h"
#include "gui/interface/Engine.h"

#include "Config.h"
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <SDL.h>

class SplitButton : public ui::Button
{
	bool rightDown;
	bool leftDown;
	bool showSplit;
	int splitPosition;
	String toolTip2;

	struct SplitButtonAction
	{
		std::function<void ()> left, right;
	};
	SplitButtonAction actionCallback;

public:
	SplitButton(ui::Point position, ui::Point size, String buttonText, String toolTip, String toolTip2, int split) :
		Button(position, size, buttonText, toolTip),
		showSplit(true),
		splitPosition(split),
		toolTip2(toolTip2)
	{

	}
	virtual ~SplitButton() = default;

	void SetRightToolTip(String tooltip) { toolTip2 = tooltip; }
	bool GetShowSplit() { return showSplit; }
	void SetShowSplit(bool split) { showSplit = split; }
	inline SplitButtonAction const &GetSplitActionCallback() { return actionCallback; }
	inline void SetSplitActionCallback(SplitButtonAction const &action) { actionCallback = action; }
	void SetToolTip(int x, int y)
	{
		if(x >= splitPosition || !showSplit)
		{
			if(toolTip2.length()>0 && GetParentWindow())
			{
				GetParentWindow()->ToolTip(Position, toolTip2);
			}
		}
		else if(x < splitPosition)
		{
			if(toolTip.length()>0 && GetParentWindow())
			{
				GetParentWindow()->ToolTip(Position, toolTip);
			}
		}
	}
	void OnMouseClick(int x, int y, unsigned int button) override
	{
		if(isButtonDown)
		{
			if(leftDown)
				DoLeftAction();
			else if(rightDown)
				DoRightAction();
		}
		ui::Button::OnMouseClick(x, y, button);

	}
	void OnMouseHover(int x, int y) override
	{
		SetToolTip(x, y);
	}
	void OnMouseEnter(int x, int y) override
	{
		isMouseInside = true;
		if(!Enabled)
			return;
		SetToolTip(x, y);
	}
	void TextPosition(String ButtonText) override
	{
		ui::Button::TextPosition(ButtonText);
		textPosition.X += 3;
	}
	void SetToolTips(String newToolTip1, String newToolTip2)
	{
		toolTip = newToolTip1;
		toolTip2 = newToolTip2;
	}
	void OnMouseDown(int x, int y, unsigned int button) override
	{
		ui::Button::OnMouseDown(x, y, button);
		if (MouseDownInside)
		{
			rightDown = false;
			leftDown = false;
			if(x - Position.X >= splitPosition)
				rightDown = true;
			else if(x - Position.X < splitPosition)
				leftDown = true;
		}
	}
	void DoRightAction()
	{
		if(!Enabled)
			return;
		if (actionCallback.right)
			actionCallback.right();
	}
	void DoLeftAction()
	{
		if(!Enabled)
			return;
		if (actionCallback.left)
			actionCallback.left();
	}
	void Draw(const ui::Point& screenPos) override
	{
		ui::Button::Draw(screenPos);
		Graphics * g = GetGraphics();
		drawn = true;

		if(showSplit)
			g->DrawLine(screenPos + Vec2{ splitPosition, 1 }, screenPos + Vec2{ splitPosition, Size.Y-2 }, 0xB4B4B4_rgb);
	}
};


GameView::GameView():
	ui::Window(ui::Point(0, 0), ui::Point(WINDOWW, WINDOWH)),
	isMouseDown(false),
	skipDraw(false),
	zoomEnabled(false),
	zoomCursorFixed(false),
	mouseInZoom(false),
	drawSnap(false),
	shiftBehaviour(false),
	ctrlBehaviour(false),
	altBehaviour(false),
	showHud(true),
	showBrush(true),
	showDebug(false),
	delayedActiveMenu(-1),
	wallBrush(false),
	toolBrush(false),
	decoBrush(false),
	toolIndex(0),
	currentSaveType(0),
	lastMenu(-1),

	toolTip(""),
	isToolTipFadingIn(false),
	toolTipPosition(-1, -1),
	infoTip(""),
	buttonTip(""),
	isButtonTipFadingIn(false),
	introTextMessage(IntroText().FromUtf8()),

	doScreenshot(false),
	screenshotIndex(1),
	lastScreenshotTime(0),
	recordingIndex(0),
	recording(false),
	recordingFolder(0),
	currentPoint(ui::Point(0, 0)),
	lastPoint(ui::Point(0, 0)),
	activeBrush(nullptr),
	saveSimulationButtonEnabled(false),
	saveReuploadAllowed(true),
	drawMode(DrawPoints),
	drawPoint1(0, 0),
	drawPoint2(0, 0),
	selectMode(SelectNone),
	selectPoint1(0, 0),
	selectPoint2(0, 0),
	currentMouse(0, 0),
	mousePosition(0, 0)
{
	contributesToFps = true;

	int currentX = 1;
	//Set up UI

	scrollBar = new ui::Button(ui::Point(0,YRES+21), ui::Point(XRES, 2), "");
	scrollBar->Appearance.BorderHover = ui::Colour(200, 200, 200);
	scrollBar->Appearance.BorderActive = ui::Colour(200, 200, 200);
	scrollBar->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	scrollBar->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(scrollBar);

	searchButton = new ui::Button(ui::Point(currentX, Size.Y-16), ui::Point(17, 15), "", "Find & open a simulation. Hold Ctrl to load offline saves.");  //Open
	searchButton->SetIcon(IconOpen);
	currentX+=18;
	searchButton->SetTogglable(false);
	searchButton->SetActionCallback({ [this] {
		if (CtrlBehaviour())
			c->OpenLocalBrowse();
		else
			c->OpenSearch("");
	} });
	AddComponent(searchButton);

	reloadButton = new ui::Button(ui::Point(currentX, Size.Y-16), ui::Point(17, 15), "", "Reload the simulation");
	reloadButton->SetIcon(IconReload);
	reloadButton->Appearance.Margin.Left+=2;
	currentX+=18;
	reloadButton->SetActionCallback({ [this] { c->ReloadSim(); }, [this] { c->OpenSavePreview(); } });
	AddComponent(reloadButton);

	saveSimulationButton = new SplitButton(ui::Point(currentX, Size.Y-16), ui::Point(150, 15), "[untitled simulation]", "", "", 19);
	saveSimulationButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	saveSimulationButton->SetIcon(IconSave);
	currentX+=151;
	saveSimulationButton->SetSplitActionCallback({
		[this] {
			if (CtrlBehaviour() || !Client::Ref().GetAuthUser().UserID)
				c->OpenLocalSaveWindow(true);
			else
				c->SaveAsCurrent();
		},
		[this] {
			if (CtrlBehaviour() || !Client::Ref().GetAuthUser().UserID)
				c->OpenLocalSaveWindow(false);
			else
				c->OpenSaveWindow();
		}
	});
	SetSaveButtonTooltips();
	AddComponent(saveSimulationButton);

	upVoteButton = new ui::Button(ui::Point(currentX, Size.Y-16), ui::Point(39, 15), "", "");
	upVoteButton->SetIcon(IconVoteUp);
	upVoteButton->Appearance.Margin.Top+=2;
	upVoteButton->Appearance.Margin.Left+=2;
	currentX+=38;
	AddComponent(upVoteButton);

	downVoteButton = new ui::Button(ui::Point(currentX, Size.Y-16), ui::Point(15, 15), "", "");
	downVoteButton->SetIcon(IconVoteDown);
	downVoteButton->Appearance.Margin.Bottom+=2;
	downVoteButton->Appearance.Margin.Left+=2;
	currentX+=16;
	AddComponent(downVoteButton);

	ResetVoteButtons();

	tagSimulationButton = new ui::Button(ui::Point(currentX, Size.Y-16), ui::Point(WINDOWW - 402, 15), "[no tags set]", "Add simulation tags");
	tagSimulationButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	tagSimulationButton->SetIcon(IconTag);
	//currentX+=252;
	tagSimulationButton->SetActionCallback({ [this] { c->OpenTags(); } });
	AddComponent(tagSimulationButton);

	clearSimButton = new ui::Button(ui::Point(Size.X-159, Size.Y-16), ui::Point(17, 15), "", "Erase everything");
	clearSimButton->SetIcon(IconNew);
	clearSimButton->Appearance.Margin.Left+=2;
	clearSimButton->SetActionCallback({ [this] { c->ClearSim(); } });
	AddComponent(clearSimButton);

	loginButton = new SplitButton(ui::Point(Size.X-141, Size.Y-16), ui::Point(92, 15), "[sign in]", "Sign into simulation server", "Edit Profile", 19);
	loginButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	loginButton->SetIcon(IconLogin);
	loginButton->SetSplitActionCallback({
		[this] { c->OpenLogin(); },
		[this] { c->OpenProfile(); }
	});
	AddComponent(loginButton);

	simulationOptionButton = new ui::Button(ui::Point(Size.X-48, Size.Y-16), ui::Point(15, 15), "", "Settings");
	simulationOptionButton->SetIcon(IconSimulationSettings);
	simulationOptionButton->Appearance.Margin.Left+=2;
	simulationOptionButton->SetActionCallback({ [this] { c->OpenOptions(); } });
	AddComponent(simulationOptionButton);

	displayModeButton = new ui::Button(ui::Point(Size.X-32, Size.Y-16), ui::Point(15, 15), "", "Renderer options");
	displayModeButton->SetIcon(IconRenderSettings);
	displayModeButton->Appearance.Margin.Left+=2;
	displayModeButton->SetActionCallback({ [this] { c->OpenRenderOptions(); } });
	AddComponent(displayModeButton);

	pauseButton = new ui::Button(ui::Point(Size.X-16, Size.Y-16), ui::Point(15, 15), "", "Pause/Resume the simulation");  //Pause
	pauseButton->SetIcon(IconPause);
	pauseButton->SetTogglable(true);
	pauseButton->SetActionCallback({ [this] { c->SetPaused(pauseButton->GetToggleState()); } });
	AddComponent(pauseButton);

	ui::Button * tempButton = new ui::Button(ui::Point(WINDOWW-16, WINDOWH-32), ui::Point(15, 15), 0xE065, "Search for elements");
	tempButton->Appearance.Margin = ui::Border(0, 2, 3, 2);
	tempButton->SetActionCallback({ [this] { c->OpenElementSearch(); } });
	AddComponent(tempButton);

	colourPicker = new ui::Button(ui::Point((XRES/2)-8, YRES+1), ui::Point(16, 16), "", "Pick Colour");
	colourPicker->SetActionCallback({ [this] { c->OpenColourPicker(); } });
}

GameView::~GameView()
{
	StopRendererThread();
	if(!colourPicker->GetParentWindow())
		delete colourPicker;

	for(std::vector<ToolButton*>::iterator iter = colourPresets.begin(), end = colourPresets.end(); iter != end; ++iter)
	{
		ToolButton * button = *iter;
		if(!button->GetParentWindow())
		{
			delete button;
		}

	}
}

class GameView::OptionListener: public QuickOptionListener
{
	ui::Button * button;
public:
	OptionListener(ui::Button * _button) { button = _button; }
	void OnValueChanged(QuickOption * option) override
	{
		switch(option->GetType())
		{
		case QuickOption::Toggle:
			button->SetTogglable(true);
			button->SetToggleState(option->GetToggle());
			break;
		default:
			break;
		}
	}
};

void GameView::NotifyQuickOptionsChanged(GameModel * sender)
{
	for (size_t i = 0; i < quickOptionButtons.size(); i++)
	{
		RemoveComponent(quickOptionButtons[i]);
		delete quickOptionButtons[i];
	}

	int currentY = 1;
	std::vector<QuickOption*> optionList = sender->GetQuickOptions();
	for(auto *option : optionList)
	{
		ui::Button * tempButton = new ui::Button(ui::Point(WINDOWW-16, currentY), ui::Point(15, 15), option->GetIcon(), option->GetDescription());
		//tempButton->Appearance.Margin = ui::Border(0, 2, 3, 2);
		tempButton->SetTogglable(true);
		tempButton->SetActionCallback({ [option] {
			option->Perform();
		} });
		option->AddListener(new OptionListener(tempButton));
		AddComponent(tempButton);

		quickOptionButtons.push_back(tempButton);
		currentY += 16;
	}
}

void GameView::NotifyMenuListChanged(GameModel * sender)
{
	int currentY = WINDOWH-48;//-(sender->GetMenuList().size()*16);
	for (size_t i = 0; i < menuButtons.size(); i++)
	{
		RemoveComponent(menuButtons[i]);
		delete menuButtons[i];
	}
	menuButtons.clear();
	for (size_t i = 0; i < toolButtons.size(); i++)
	{
		RemoveComponent(toolButtons[i]);
		delete toolButtons[i];
	}
	toolButtons.clear();
	std::vector<Menu*> menuList = sender->GetMenuList();
	for (int i = (int)menuList.size()-1; i >= 0; i--)
	{
		if (menuList[i]->GetVisible())
		{
			String tempString = "";
			tempString += menuList[i]->GetIcon();
			String description = menuList[i]->GetDescription();
			if (i == SC_FAVORITES && !Favorite::Ref().AnyFavorites())
				description += " (Use ctrl+shift+click to toggle the favorite status of an element)";
			auto *tempButton = new MenuButton(ui::Point(WINDOWW-16, currentY), ui::Point(15, 15), tempString, description);
			tempButton->Appearance.Margin = ui::Border(0, 2, 3, 2);
			tempButton->menuID = i;
			tempButton->needsClick = i == SC_DECO;
			tempButton->SetTogglable(true);
			auto mouseEnterCallback = [this, tempButton] {
				// don't immediately change the active menu, the actual set is done inside GameView::OnMouseMove
				// if we change it here it causes components to be removed, which causes the window to stop sending events
				// and then the previous menusection button never gets sent the OnMouseLeave event and is never unhighlighted
				if(!(tempButton->needsClick || c->GetMouseClickRequired()) && !GetMouseDown())
					SetActiveMenuDelayed(tempButton->menuID);
			};
			auto actionCallback = [this, tempButton, mouseEnterCallback] {
				if (tempButton->needsClick || c->GetMouseClickRequired())
					c->SetActiveMenu(tempButton->menuID);
				else
					mouseEnterCallback();
			};
			tempButton->SetActionCallback({ actionCallback, nullptr, mouseEnterCallback });
			currentY-=16;
			AddComponent(tempButton);
			menuButtons.push_back(tempButton);
		}
	}
}

void GameView::SetSample(SimulationSample sample)
{
	this->sample = sample;
}

void GameView::SetHudEnable(bool hudState)
{
	showHud = hudState;
}

bool GameView::GetHudEnable()
{
	return showHud;
}

void GameView::SetBrushEnable(bool brushState)
{
	showBrush = brushState;
}

bool GameView::GetBrushEnable()
{
	return showBrush;
}

void GameView::SetDebugHUD(bool mode)
{
	showDebug = mode;
	rendererSettings->debugLines = showDebug;
}

bool GameView::GetDebugHUD()
{
	return showDebug;
}

ui::Point GameView::GetMousePosition()
{
	return currentMouse;
}

bool GameView::GetPlacingSave()
{
	return selectMode != SelectNone;
}

bool GameView::GetPlacingZoom()
{
	return zoomEnabled && !zoomCursorFixed;
}

void GameView::NotifyActiveToolsChanged(GameModel * sender)
{
	for (size_t i = 0; i < toolButtons.size(); i++)
	{
		auto *tool = toolButtons[i]->tool;
		// Primary
		if (sender->GetActiveTool(0) == tool)
			toolButtons[i]->SetSelectionState(0);
		// Secondary
		else if (sender->GetActiveTool(1) == tool)
			toolButtons[i]->SetSelectionState(1);
		// Tertiary
		else if (sender->GetActiveTool(2) == tool)
			toolButtons[i]->SetSelectionState(2);
		// Replace Mode
		else if (sender->GetActiveTool(3) == tool)
			toolButtons[i]->SetSelectionState(3);
		// Not selected at all
		else
			toolButtons[i]->SetSelectionState(-1);
	}

	decoBrush = sender->GetActiveTool(0)->Identifier.BeginsWith("DEFAULT_DECOR_");

	auto &settings = sender->GetRendererSettings();
	if (settings.findingElement)
	{
		settings.findingElement = FindingElementCandidate();
	}
}

void GameView::NotifyLastToolChanged(GameModel * sender)
{
	if (sender->GetLastTool())
	{
		wallBrush = sender->GetLastTool()->Blocky;
		toolBrush = sender->GetLastTool()->Identifier.BeginsWith("DEFAULT_TOOL_");
	}
}

void GameView::NotifyActiveMenuToolListChanged(GameModel * sender)
{
	for (size_t i = 0; i < menuButtons.size(); i++)
	{
		if (menuButtons[i]->menuID==sender->GetActiveMenu())
		{
			menuButtons[i]->SetToggleState(true);
		}
		else
		{
			menuButtons[i]->SetToggleState(false);
		}
	}
	for (size_t i = 0; i < toolButtons.size(); i++)
	{
		RemoveComponent(toolButtons[i]);
		delete toolButtons[i];
	}
	toolButtons.clear();
	std::vector<Tool*> toolList = sender->GetActiveMenuToolList();
	int currentX = 0;
	for (size_t i = 0; i < toolList.size(); i++)
	{
		auto *tool = toolList[i];
		auto tempTexture = tool->GetTexture(Vec2(26, 14));
		ToolButton * tempButton;

		//get decotool texture manually, since it changes depending on it's own color
		if (sender->GetActiveMenu() == SC_DECO)
			tempTexture = static_cast<DecorationTool *>(tool)->GetIcon(tool->ToolID, Vec2(26, 14));

		if (tempTexture)
			tempButton = new ToolButton(ui::Point(currentX, YRES+1), ui::Point(30, 18), "", tool->Identifier, tool->Description);
		else
			tempButton = new ToolButton(ui::Point(currentX, YRES+1), ui::Point(30, 18), tool->Name, tool->Identifier, tool->Description);

		tempButton->ClipRect = RectSized(Vec2(1, RES.Y + 1), Vec2(RES.X - 1, 18));

		//currentY -= 17;
		currentX -= 31;
		tempButton->tool = tool;
		tempButton->SetActionCallback({ [this, tempButton] {
			auto *tool = tempButton->tool;
			if (ShiftBehaviour() && CtrlBehaviour() && !AltBehaviour())
			{
				if (tempButton->GetSelectionState() == 0)
				{
					if (Favorite::Ref().IsFavorite(tool->Identifier))
					{
						Favorite::Ref().RemoveFavorite(tool->Identifier);
					}
					else
					{
						Favorite::Ref().AddFavorite(tool->Identifier);
					}
					c->RebuildFavoritesMenu();
				}
				else if (tempButton->GetSelectionState() == 1)
				{
					auto identifier = tool->Identifier;
					if (Favorite::Ref().IsFavorite(identifier))
					{
						Favorite::Ref().RemoveFavorite(identifier);
						c->RebuildFavoritesMenu();
					}
					else if (identifier.BeginsWith("DEFAULT_PT_LIFECUST_"))
					{
						new ConfirmPrompt("Remove custom GOL type", "Are you sure you want to remove " + identifier.Substr(20).FromUtf8() + "?", { [this, identifier]() {
							c->RemoveCustomGol(identifier);
						} });
					}
				}
			}
			else
			{
				if (CtrlBehaviour() && AltBehaviour() && !ShiftBehaviour())
				{
					if (tool->Identifier.Contains("_PT_"))
					{
						tempButton->SetSelectionState(3);
					}
				}

				if (tempButton->GetSelectionState() >= 0 && tempButton->GetSelectionState() <= 3)
					c->SetActiveTool(tempButton->GetSelectionState(), tool);
			}
		} });

		tempButton->Appearance.SetTexture(std::move(tempTexture));

		tempButton->Appearance.BackgroundInactive = toolList[i]->Colour.WithAlpha(0xFF);

		if(sender->GetActiveTool(0) == toolList[i])
		{
			tempButton->SetSelectionState(0);	//Primary
		}
		else if(sender->GetActiveTool(1) == toolList[i])
		{
			tempButton->SetSelectionState(1);	//Secondary
		}
		else if(sender->GetActiveTool(2) == toolList[i])
		{
			tempButton->SetSelectionState(2);	//Tertiary
		}
		else if(sender->GetActiveTool(3) == toolList[i])
		{
			tempButton->SetSelectionState(3);	//Replace mode
		}

		tempButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
		tempButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		AddComponent(tempButton);
		toolButtons.push_back(tempButton);
	}
	if (sender->GetActiveMenu() != SC_DECO)
		lastMenu = sender->GetActiveMenu();

	updateToolButtonScroll();
}

void GameView::NotifyColourSelectorVisibilityChanged(GameModel * sender)
{
	for(std::vector<ToolButton*>::iterator iter = colourPresets.begin(), end = colourPresets.end(); iter != end; ++iter)
	{
		ToolButton * button = *iter;
		RemoveComponent(button);
		button->SetParentWindow(nullptr);
	}

	RemoveComponent(colourPicker);
	colourPicker->SetParentWindow(nullptr);

	if(sender->GetColourSelectorVisibility())
	{
		for(std::vector<ToolButton*>::iterator iter = colourPresets.begin(), end = colourPresets.end(); iter != end; ++iter)
		{
			ToolButton * button = *iter;
			AddComponent(button);
		}
		AddComponent(colourPicker);
		c->SetActiveColourPreset(-1);
	}
}

void GameView::NotifyColourPresetsChanged(GameModel * sender)
{
	for (auto *button : colourPresets)
	{
		RemoveComponent(button);
		delete button;
	}
	colourPresets.clear();

	int currentX = 5;
	std::vector<ui::Colour> colours = sender->GetColourPresets();
	int i = 0;
	for(std::vector<ui::Colour>::iterator iter = colours.begin(), end = colours.end(); iter != end; ++iter)
	{
		ToolButton * tempButton = new ToolButton(ui::Point(currentX, YRES+1), ui::Point(30, 18), "", "", "Decoration Presets.");
		tempButton->Appearance.BackgroundInactive = *iter;
		tempButton->SetActionCallback({ [this, i, tempButton] {
			c->SetActiveColourPreset(i);
			c->SetColour(tempButton->Appearance.BackgroundInactive);
		} });

		currentX += 31;

		if(sender->GetColourSelectorVisibility())
			AddComponent(tempButton);
		colourPresets.push_back(tempButton);

		i++;
	}
	NotifyColourActivePresetChanged(sender);
}

void GameView::NotifyColourActivePresetChanged(GameModel * sender)
{
	for (size_t i = 0; i < colourPresets.size(); i++)
	{
		if (sender->GetActiveColourPreset() == i)
		{
			colourPresets[i]->SetSelectionState(0);	//Primary
		}
		else
		{
			colourPresets[i]->SetSelectionState(-1);
		}
	}
}

void GameView::NotifyColourSelectorColourChanged(GameModel * sender)
{
	colourPicker->Appearance.BackgroundInactive = sender->GetColourSelectorColour();
	colourPicker->Appearance.BackgroundHover = sender->GetColourSelectorColour();
	NotifyActiveMenuToolListChanged(sender);
}

void GameView::NotifyRendererChanged(GameModel * sender)
{
	ren = sender->GetRenderer();
	rendererFrame = &ren->GetVideo();
	rendererSettings = &sender->GetRendererSettings();
}

void GameView::NotifySimulationChanged(GameModel * sender)
{
	sim = sender->GetSimulation();
}
void GameView::NotifyUserChanged(GameModel * sender)
{
	if(!sender->GetUser().UserID)
	{
		loginButton->SetText("[sign in]");
		loginButton->SetShowSplit(false);
		loginButton->SetRightToolTip("Sign in to simulation server");
	}
	else
	{
		loginButton->SetText(sender->GetUser().Username.FromUtf8());
		loginButton->SetShowSplit(true);
		loginButton->SetRightToolTip("Edit profile");
	}
	// saveSimulationButtonEnabled = sender->GetUser().ID;
	saveSimulationButtonEnabled = true;
	NotifySaveChanged(sender);
}


void GameView::NotifyPausedChanged(GameModel * sender)
{
	pauseButton->SetToggleState(sender->GetPaused());
	ApplySimFpsLimit();
}

void GameView::NotifyToolTipChanged(GameModel * sender)
{
	toolTip = sender->GetToolTip();
}

void GameView::NotifyInfoTipChanged(GameModel * sender)
{
	infoTip = sender->GetInfoTip();
	infoTipPresence = 120;
}

void GameView::ResetVoteButtons()
{
	upVoteButton->SetToolTip("Like this save");
	downVoteButton->SetToolTip("Dislike this save");
	upVoteButton->Appearance.BackgroundPulse = false;
	downVoteButton->Appearance.BackgroundPulse = false;
}

void GameView::NotifySaveChanged(GameModel * sender)
{
	saveReuploadAllowed = true;
	ResetVoteButtons();
	if (sender->GetSave())
	{
		if (introText > 50)
			introText = 50;

		saveSimulationButton->SetText(sender->GetSave()->GetName());
		if (sender->GetSave()->GetUserName() == sender->GetUser().Username)
			saveSimulationButton->SetShowSplit(true);
		else
			saveSimulationButton->SetShowSplit(false);
		reloadButton->Enabled = true;
		upVoteButton->Enabled = sender->GetSave()->GetID() && sender->GetUser().UserID && sender->GetUser().Username != sender->GetSave()->GetUserName();

		auto upVoteButtonColor = [this](bool active) {
			if(active)
			{
				upVoteButton->Appearance.BackgroundHover = (ui::Colour(20, 128, 30, 255));
				upVoteButton->Appearance.BackgroundInactive = (ui::Colour(0, 108, 10, 255));
				upVoteButton->Appearance.BackgroundDisabled = (ui::Colour(0, 108, 10, 255));
			}
			else
			{
				upVoteButton->Appearance.BackgroundHover = (ui::Colour(20, 20, 20));
				upVoteButton->Appearance.BackgroundInactive = (ui::Colour(0, 0, 0));
				upVoteButton->Appearance.BackgroundDisabled = (ui::Colour(0, 0, 0));
			}
		};
		auto upvoted = sender->GetSave()->GetID() && sender->GetUser().UserID && sender->GetSave()->GetVote() == 1;
		upVoteButtonColor(upvoted);

		downVoteButton->Enabled = upVoteButton->Enabled;
		auto downVoteButtonColor = [this](bool active) {
			if (active)
			{
				downVoteButton->Appearance.BackgroundHover = (ui::Colour(128, 20, 30, 255));
				downVoteButton->Appearance.BackgroundInactive = (ui::Colour(108, 0, 10, 255));
				downVoteButton->Appearance.BackgroundDisabled = (ui::Colour(108, 0, 10, 255));
			}
			else
			{
				downVoteButton->Appearance.BackgroundHover = (ui::Colour(20, 20, 20));
				downVoteButton->Appearance.BackgroundInactive = (ui::Colour(0, 0, 0));
				downVoteButton->Appearance.BackgroundDisabled = (ui::Colour(0, 0, 0));
			}
		};
		auto downvoted = sender->GetSave()->GetID() && sender->GetUser().UserID && sender->GetSave()->GetVote() == -1;
		downVoteButtonColor(downvoted);

		if (sender->GetUser().UserID)
		{
			upVoteButton->Appearance.BorderDisabled = upVoteButton->Appearance.BorderInactive;
			downVoteButton->Appearance.BorderDisabled = downVoteButton->Appearance.BorderInactive;
		}
		else
		{
			upVoteButton->Appearance.BorderDisabled = ui::Colour(100, 100, 100);
			downVoteButton->Appearance.BorderDisabled = ui::Colour(100, 100, 100);
		}

		upVoteButton->SetActionCallback({ [this, upVoteButtonColor, upvoted] {
			upVoteButtonColor(true);
			upVoteButton->SetToolTip("Saving vote...");
			upVoteButton->Appearance.BackgroundPulse = true;
			c->Vote(upvoted ? 0 : 1);
		} });
		downVoteButton->SetActionCallback({ [this, downVoteButtonColor, downvoted] {
			downVoteButtonColor(true);
			downVoteButton->SetToolTip("Saving vote...");
			downVoteButton->Appearance.BackgroundPulse = true;
			c->Vote(downvoted ? 0 : -1);
		} });

		tagSimulationButton->Enabled = sender->GetSave()->GetID();
		if (sender->GetSave()->GetID())
		{
			StringBuilder tagsStream;
			std::list<ByteString> tags = sender->GetSave()->GetTags();
			if (tags.size())
			{
				for (std::list<ByteString>::const_iterator iter = tags.begin(), begin = tags.begin(), end = tags.end(); iter != end; iter++)
				{
					if (iter != begin)
						tagsStream << " ";
					tagsStream << iter->FromUtf8();
				}
				tagSimulationButton->SetText(tagsStream.Build());
			}
			else
			{
				tagSimulationButton->SetText("[no tags set]");
			}
		}
		else
		{
			tagSimulationButton->SetText("[no tags set]");
		}
		currentSaveType = 1;
		int saveID = sender->GetSave()->GetID();
		if (saveID == 404 || saveID == 2157797)
			saveReuploadAllowed = false;
	}
	else if (sender->GetSaveFile())
	{
		if (ctrlBehaviour)
			saveSimulationButton->SetShowSplit(true);
		else
			saveSimulationButton->SetShowSplit(false);
		saveSimulationButton->SetText(sender->GetSaveFile()->GetDisplayName());
		reloadButton->Enabled = true;
		upVoteButton->Enabled = false;
		upVoteButton->Appearance.BackgroundDisabled = (ui::Colour(0, 0, 0));
		upVoteButton->Appearance.BorderDisabled = ui::Colour(100, 100, 100);
		downVoteButton->Enabled = false;
		downVoteButton->Appearance.BackgroundDisabled = (ui::Colour(0, 0, 0));
		downVoteButton->Appearance.BorderDisabled = ui::Colour(100, 100, 100);
		tagSimulationButton->Enabled = false;
		tagSimulationButton->SetText("[no tags set]");
		currentSaveType = 2;
	}
	else
	{
		saveSimulationButton->SetShowSplit(false);
		saveSimulationButton->SetText("[untitled simulation]");
		reloadButton->Enabled = false;
		upVoteButton->Enabled = false;
		upVoteButton->Appearance.BackgroundDisabled = (ui::Colour(0, 0, 0));
		upVoteButton->Appearance.BorderDisabled = ui::Colour(100, 100, 100),
		downVoteButton->Enabled = false;
		downVoteButton->Appearance.BackgroundDisabled = (ui::Colour(0, 0, 0));
		downVoteButton->Appearance.BorderDisabled = ui::Colour(100, 100, 100),
		tagSimulationButton->Enabled = false;
		tagSimulationButton->SetText("[no tags set]");
		currentSaveType = 0;
	}
	saveSimulationButton->Enabled = (saveSimulationButtonEnabled && saveReuploadAllowed) || ctrlBehaviour;
	SetSaveButtonTooltips();
}

void GameView::NotifyBrushChanged(GameModel * sender)
{
	activeBrush = &sender->GetBrush();
}

ByteString GameView::TakeScreenshot(int captureUI, int fileType)
{
	std::unique_ptr<VideoBuffer> screenshot;
	if (captureUI)
	{
		screenshot = std::make_unique<VideoBuffer>(*rendererFrame);
	}
	else
	{
		screenshot = std::make_unique<VideoBuffer>(ui::Engine::Ref().g->DumpFrame());
	}

	ByteString filename;
	{
		// Optional suffix to distinguish screenshots taken at the exact same time
		ByteString suffix = "";
		time_t screenshotTime = time(nullptr);
		if (screenshotTime == lastScreenshotTime)
		{
			screenshotIndex++;
			suffix = ByteString::Build(" (", screenshotIndex, ")");
		}
		else
		{
			screenshotIndex = 1;
		}
		lastScreenshotTime = screenshotTime;
		std::string date = format::UnixtimeToDate(screenshotTime, "%Y-%m-%d %H.%M.%S");
		filename = ByteString::Build("screenshot ", date, suffix);
	}

	if (fileType == 1)
	{
		filename += ".bmp";
		// We should be able to simply use SDL_PIXELFORMAT_XRGB8888 here with a bit depth of 32 to convert RGBA data to RGB data,
		// and save the resulting surface directly. However, ubuntu-18.04 ships SDL2 so old that it doesn't have
		// SDL_PIXELFORMAT_XRGB8888, so we first create an RGBA surface and then convert it.
		auto *rgbaSurface = SDL_CreateRGBSurfaceWithFormatFrom(screenshot->Data(), screenshot->Size().X, screenshot->Size().Y, 32, screenshot->Size().X * sizeof(pixel), SDL_PIXELFORMAT_ARGB8888);
		auto *rgbSurface = SDL_ConvertSurfaceFormat(rgbaSurface, SDL_PIXELFORMAT_RGB888, 0);
		if (!rgbSurface || SDL_SaveBMP(rgbSurface, filename.c_str()))
		{
			std::cerr << "SDL_SaveBMP failed: " << SDL_GetError() << std::endl;
			filename = "";
		}
		SDL_FreeSurface(rgbSurface);
		SDL_FreeSurface(rgbaSurface);
	}
	else if (fileType == 2)
	{
		filename += ".ppm";
		if (!Platform::WriteFile(screenshot->ToPPM(), filename))
		{
			filename = "";
		}
	}
	else
	{
		filename += ".png";
		if (auto data = screenshot->ToPNG())
		{
			if (!Platform::WriteFile(*data, filename))
				filename = "";
		}
		else
			filename = "";
	}

	return filename;
}

int GameView::Record(bool record)
{
	if (!record)
	{
		recording = false;
		recordingFolder = 0;
	}
	else if (!recording)
	{
		time_t startTime = time(nullptr);
		recordingFolder = startTime;
		Platform::MakeDirectory("recordings");
		Platform::MakeDirectory(ByteString::Build("recordings", PATH_SEP_CHAR, recordingFolder));
		recording = true;
		recordingIndex = 0;
	}
	return recordingFolder;
}

void GameView::updateToolButtonScroll()
{
	if (toolButtons.size())
	{
		int x = currentMouse.X;
		int y = currentMouse.Y;

		int offsetDelta = 0;

		int newInitialX = WINDOWW - 56;
		int totalWidth = (toolButtons[0]->Size.X + 1) * toolButtons.size();
		int scrollSize = (int)(((float)(XRES - BARSIZE))/((float)totalWidth) * ((float)XRES - BARSIZE));

		if (scrollSize > XRES - 1)
			scrollSize = XRES - 1;
		
		if (totalWidth > XRES - 15)
		{			
			int mouseX = x;

			float overflow = 0;
			float mouseLocation = 0;

			if (mouseX > XRES)
				mouseX = XRES;

			// if (mouseX < 15) // makes scrolling a little nicer at edges but apparently if you put hundreds of elements in a menu it makes the end not show ...
			// 	mouseX = 15;

			scrollBar->Visible = true;

			scrollBar->Position.X = (int)(((float)mouseX / (float)XRES) * (float)(XRES - scrollSize)) + 1;

			overflow = (float)(totalWidth - (XRES - BARSIZE));
			mouseLocation = (float)(XRES - 3)/(float)((XRES - 2) - mouseX); // mouseLocation adjusted slightly in case you have 200 elements in one menu

			newInitialX += (int)(overflow/mouseLocation);
		}
		else
		{
			scrollBar->Visible = false;
		}

		scrollBar->Size.X = scrollSize - 1;

		offsetDelta = toolButtons[0]->Position.X - newInitialX;

		for (auto *button : toolButtons)
		{
			button->Position.X -= offsetDelta;
		}

		// Ensure that mouseLeave events are make their way to the buttons should they move from underneath the mouse pointer
		if (toolButtons[0]->Position.Y < y && toolButtons[0]->Position.Y + toolButtons[0]->Size.Y > y)
		{
			for (auto *button : toolButtons)
			{
				auto inside = button->Position.X < x && button->Position.X + button->Size.X > x;
				if (inside && !button->MouseInside)
				{
					button->MouseInside = true;
					button->OnMouseEnter(x, y);
				}
				if (!inside && button->MouseInside)
				{
					button->MouseInside = false;
					button->OnMouseLeave(x, y);
				}
			}
		}
	}
}

void GameView::OnMouseMove(int x, int y, int dx, int dy)
{
	bool newMouseInZoom = c->MouseInZoom(ui::Point(x, y));
	mousePosition = c->PointTranslate(ui::Point(x, y));
	currentMouse = ui::Point(x, y);
	if (selectMode != SelectNone)
	{
		if (selectMode == PlaceSave)
			selectPoint1 = c->PointTranslate(ui::Point(x, y));
		if (selectPoint1.X != -1)
			selectPoint2 = c->PointTranslate(ui::Point(x, y));
	}
	else if (isMouseDown)
	{
		if (newMouseInZoom == mouseInZoom)
		{
			if (drawMode == DrawPoints)
			{
				currentPoint = mousePosition;
				c->DrawPoints(toolIndex, lastPoint, currentPoint, true);
				lastPoint = currentPoint;
				skipDraw = true;
			}
			else if (drawMode == DrawFill)
			{
				c->DrawFill(toolIndex, mousePosition);
				skipDraw = true;
			}
		}
		else if (drawMode == DrawPoints || drawMode == DrawFill)
		{
			isMouseDown = false;
			drawMode = DrawPoints;
			c->MouseUp(x, y, 0, GameController::mouseUpDrawEnd);
		}
	}
	mouseInZoom = newMouseInZoom;

	// set active menu (delayed)
	if (delayedActiveMenu != -1)
	{
		c->SetActiveMenu(delayedActiveMenu);
		delayedActiveMenu = -1;
	}

	updateToolButtonScroll();
}

void GameView::OnMouseDown(int x, int y, unsigned button)
{
	currentMouse = ui::Point(x, y);
	if (altBehaviour && !shiftBehaviour && !ctrlBehaviour)
		button = SDL_BUTTON_MIDDLE;
	if  (!(zoomEnabled && !zoomCursorFixed))
	{
		if (selectMode != SelectNone)
		{
			isMouseDown = true;
			if (button == SDL_BUTTON_LEFT && selectPoint1.X == -1)
			{
				selectPoint1 = c->PointTranslate(currentMouse);
				selectPoint2 = selectPoint1;
			}
			return;
		}
		if (currentMouse.X >= 0 && currentMouse.X < XRES && currentMouse.Y >= 0 && currentMouse.Y < YRES)
		{
			// update tool index, set new "last" tool so GameView can detect certain tools properly
			if (button == SDL_BUTTON_LEFT)
				toolIndex = 0;
			else if (button == SDL_BUTTON_RIGHT)
				toolIndex = 1;
			else if (button == SDL_BUTTON_MIDDLE)
				toolIndex = 2;
			else
				return;
			Tool *lastTool = c->GetActiveTool(toolIndex);
			c->SetLastTool(lastTool);
			decoBrush = lastTool->Identifier.BeginsWith("DEFAULT_DECOR_");

			UpdateDrawMode();

			isMouseDown = true;
			c->HistorySnapshot();
			if (drawMode == DrawRect || drawMode == DrawLine)
			{
				drawPoint1 = c->PointTranslate(currentMouse);
			}
			else if (drawMode == DrawPoints)
			{
				lastPoint = currentPoint = c->PointTranslate(currentMouse);
				c->DrawPoints(toolIndex, lastPoint, currentPoint, false);
			}
			else if (drawMode == DrawFill)
			{
				c->DrawFill(toolIndex, c->PointTranslate(currentMouse));
			}
		}
	}
}

Vec2<int> GameView::PlaceSavePos() const
{
	auto [ trQuoX, trRemX ] = floorDiv(placeSaveTranslate.X, CELL);
	auto [ trQuoY, trRemY ] = floorDiv(placeSaveTranslate.Y, CELL);
	auto usefulSize = placeSaveThumb->Size();
	if (trRemX) usefulSize.X -= CELL;
	if (trRemY) usefulSize.Y -= CELL;
	auto cursorCell = (usefulSize - Vec2{ CELL, CELL }) / 2 - Vec2{ trQuoX, trQuoY } * CELL; // stamp coordinates
	auto unaligned = selectPoint2 - cursorCell;
	auto quoX = floorDiv(unaligned.X, CELL).first;
	auto quoY = floorDiv(unaligned.Y, CELL).first;
	return { quoX, quoY };
}

void GameView::OnMouseUp(int x, int y, unsigned button)
{
	currentMouse = ui::Point(x, y);
	if (zoomEnabled && !zoomCursorFixed)
	{
		zoomCursorFixed = true;
		drawMode = DrawPoints;
		isMouseDown = false;
	}
	else if (isMouseDown)
	{
		isMouseDown = false;
		if (selectMode != SelectNone)
		{
			if (button == SDL_BUTTON_LEFT && selectPoint1.X != -1 && selectPoint1.Y != -1 && selectPoint2.X != -1 && selectPoint2.Y != -1)
			{
				if (selectMode == PlaceSave)
				{
					if (placeSaveThumb && y <= WINDOWH-BARSIZE)
					{
						c->PlaceSave(PlaceSavePos());
					}
				}
				else
				{
					int x2 = (selectPoint1.X>selectPoint2.X) ? selectPoint1.X : selectPoint2.X;
					int y2 = (selectPoint1.Y>selectPoint2.Y) ? selectPoint1.Y : selectPoint2.Y;
					int x1 = (selectPoint2.X<selectPoint1.X) ? selectPoint2.X : selectPoint1.X;
					int y1 = (selectPoint2.Y<selectPoint1.Y) ? selectPoint2.Y : selectPoint1.Y;
					if (selectMode ==SelectCopy)
						c->CopyRegion(ui::Point(x1, y1), ui::Point(x2, y2));
					else if (selectMode == SelectCut)
						c->CutRegion(ui::Point(x1, y1), ui::Point(x2, y2));
					else if (selectMode == SelectStamp)
						c->StampRegion(ui::Point(x1, y1), ui::Point(x2, y2));
				}
			}
			selectMode = SelectNone;
			return;
		}

		ui::Point finalDrawPoint2 = c->PointTranslate(currentMouse);
		if (drawMode == DrawRect || drawMode == DrawLine)
		{
			drawPoint2 = finalDrawPoint2;
			if (drawSnap && drawMode == DrawLine)
			{
				finalDrawPoint2 = lineSnapCoords(c->PointTranslate(drawPoint1), drawPoint2);
			}
			if (drawSnap && drawMode == DrawRect)
			{
				finalDrawPoint2 = rectSnapCoords(c->PointTranslate(drawPoint1), drawPoint2);
			}

			if (drawMode == DrawRect)
			{
				c->DrawRect(toolIndex, c->PointTranslate(drawPoint1), finalDrawPoint2);
			}
			if (drawMode == DrawLine)
			{
				c->DrawLine(toolIndex, c->PointTranslate(drawPoint1), finalDrawPoint2);
			}
		}
		else if (drawMode == DrawPoints)
		{
			// draw final line
			c->DrawPoints(toolIndex, lastPoint, finalDrawPoint2, true);
			// plop tool stuff (like STKM)
			c->ToolClick(toolIndex, finalDrawPoint2);
		}
		else if (drawMode == DrawFill)
		{
			c->DrawFill(toolIndex, finalDrawPoint2);
		}
	}
	// this shouldn't happen, but do this just in case
	else if (selectMode != SelectNone && button != SDL_BUTTON_LEFT)
		selectMode = SelectNone;

	// update the drawing mode for the next line
	// since ctrl/shift state may have changed since we started drawing
	UpdateDrawMode();
}

void GameView::ToolTip(ui::Point senderPosition, String toolTip)
{
	// buttom button tooltips
	if (senderPosition.Y > Size.Y-17)
	{
		if (selectMode == PlaceSave || selectMode == SelectNone)
		{
			buttonTip = toolTip;
			isButtonTipFadingIn = true;
		}
	}
	// quickoption and menu tooltips
	else if(senderPosition.X > Size.X-BARSIZE)// < Size.Y-(quickOptionButtons.size()+1)*16)
	{
		this->toolTip = toolTip;
		toolTipPosition = ui::Point(Size.X-27-(Graphics::TextSize(toolTip).X - 1), senderPosition.Y+3);
		if(toolTipPosition.Y+10 > Size.Y-MENUSIZE)
			toolTipPosition = ui::Point(Size.X-27-(Graphics::TextSize(toolTip).X - 1), Size.Y-MENUSIZE-10);
		isToolTipFadingIn = true;
	}
	// element tooltips
	else
	{
		this->toolTip = toolTip;
		toolTipPosition = ui::Point(Size.X-27-(Graphics::TextSize(toolTip).X - 1), Size.Y-MENUSIZE-10);
		isToolTipFadingIn = true;
	}
}

void GameView::OnMouseWheel(int x, int y, int d)
{
	if (!d)
		return;
	if (selectMode != SelectNone)
	{
		return;
	}
	if (zoomEnabled && !zoomCursorFixed)
	{
		c->AdjustZoomSize(d);
	}
	else
	{
		c->AdjustBrushSize(d, false, ctrlBehaviour, shiftBehaviour);
	}
}

void GameView::BeginStampSelection()
{
	selectMode = SelectStamp;
	selectPoint1 = selectPoint2 = ui::Point(-1, -1);
	isMouseDown = false;
	buttonTip = "\x0F\xEF\xEF\020Click-and-drag to specify an area to create a stamp (right click = cancel)";
	buttonTipShow = 120;
}

void GameView::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (introText > 50)
	{
		introText = 50;
	}

	if (selectMode != SelectNone)
	{
		if (selectMode == PlaceSave)
		{
			switch (key)
			{
			case SDLK_RIGHT:
				TranslateSave({  1,  0 });
				return;
			case SDLK_LEFT:
				TranslateSave({ -1,  0 });
				return;
			case SDLK_UP:
				TranslateSave({  0, -1 });
				return;
			case SDLK_DOWN:
				TranslateSave({  0,  1 });
				return;
			}
			if (scan == SDL_SCANCODE_R && !repeat)
			{
				if (ctrl && shift)
				{
					//Vertical flip
					TransformSave(Mat2<int>::MirrorY);
				}
				else if (!ctrl && shift)
				{
					//Horizontal flip
					TransformSave(Mat2<int>::MirrorX);
				}
				else
				{
					//Rotate 90deg
					TransformSave(Mat2<int>::CCW);
				}
				return;
			}
		}
	}

	if (repeat)
		return;
	bool didKeyShortcut = true;
	switch(scan)
	{
	case SDL_SCANCODE_GRAVE:
		c->ShowConsole();
		break;
	case SDL_SCANCODE_SPACE: //Space
		c->SetPaused();
		break;
	case SDL_SCANCODE_Z:
		if (selectMode != SelectNone && isMouseDown)
			break;
		if (ctrl && !isMouseDown)
		{
			if (shift)
				c->HistoryForward();
			else
				c->HistoryRestore();
		}
		else
		{
			isMouseDown = false;
			zoomCursorFixed = false;
			c->SetZoomEnabled(true);
		}
		break;
	case SDL_SCANCODE_P:
	case SDL_SCANCODE_F2:
		if (ctrl)
		{
			if (shift)
				c->SetActiveTool(1, "DEFAULT_UI_PROPERTY");
			else
				c->SetActiveTool(0, "DEFAULT_UI_PROPERTY");
		}
		else
			doScreenshot = true;
		break;
	case SDL_SCANCODE_F3:
		SetDebugHUD(!GetDebugHUD());
		break;
	case SDL_SCANCODE_F5:
		c->ReloadSim();
		break;
	case SDL_SCANCODE_A:
		if (Client::Ref().GetAuthUser().UserElevation != User::ElevationNone && ctrl)
		{
			ByteString authorString = Client::Ref().GetAuthorInfo().toStyledString();
			new InformationMessage("Save authorship info", authorString.FromUtf8(), true);
		}
		break;
	case SDL_SCANCODE_R:
		if (ctrl)
			c->ReloadSim();
		break;
	case SDL_SCANCODE_E:
		if (ctrl)
			c->SetEdgeMode(c->GetEdgeMode() + 1);
		else
			c->OpenElementSearch();
		break;
	case SDL_SCANCODE_F:
		if (ctrl)
		{
			auto findingElementCandidate = FindingElementCandidate();
			if (rendererSettings->findingElement == findingElementCandidate)
			{
				rendererSettings->findingElement = std::nullopt;
			}
			else
			{
				rendererSettings->findingElement = findingElementCandidate;
			}
		}
		else
			c->FrameStep();
		break;
	case SDL_SCANCODE_G:
		if (ctrl)
			c->ShowGravityGrid();
		else if(shift)
			c->AdjustGridSize(-1);
		else
			c->AdjustGridSize(1);
		break;
	case SDL_SCANCODE_F1:
		if(!introText)
			introText = 8047;
		else
			introText = 0;
		break;
	case SDL_SCANCODE_F11:
		ui::Engine::Ref().SetFullscreen(!ui::Engine::Ref().GetFullscreen());
		break;
	case SDL_SCANCODE_H:
		if(ctrl)
		{
			if(!introText)
				introText = 8047;
			else
				introText = 0;
		}
		else
			showHud = !showHud;
		break;
	case SDL_SCANCODE_B:
		if(ctrl)
			c->SetDecoration();
		else
			if (colourPicker->GetParentWindow())
				c->SetActiveMenu(lastMenu);
			else
			{
				c->SetDecoration(true);
				c->SetPaused(true);
				c->SetActiveMenu(SC_DECO);
			}
		break;
	case SDL_SCANCODE_Y:
		if (ctrl)
		{
			c->HistoryForward();
		}
		else
		{
			c->SwitchAir();
		}
		break;
	case SDL_SCANCODE_ESCAPE:
	case SDL_SCANCODE_Q:
		if (ALLOW_QUIT)
		{
			ui::Engine::Ref().ConfirmExit();
		}
		break;
	case SDL_SCANCODE_U:
		if (ctrl)
			c->ResetAHeat();
		else
			c->ToggleAHeat();
		break;
	case SDL_SCANCODE_N:
		c->ToggleNewtonianGravity();
		break;
	case SDL_SCANCODE_EQUALS:
		if(ctrl)
			c->ResetSpark();
		else
			c->ResetAir();
		break;
	case SDL_SCANCODE_C:
		if(ctrl)
		{
			selectMode = SelectCopy;
			selectPoint1 = selectPoint2 = ui::Point(-1, -1);
			isMouseDown = false;
			buttonTip = "\x0F\xEF\xEF\020Click-and-drag to specify an area to copy (right click = cancel)";
			buttonTipShow = 120;
		}
		break;
	case SDL_SCANCODE_X:
		if(ctrl)
		{
			selectMode = SelectCut;
			selectPoint1 = selectPoint2 = ui::Point(-1, -1);
			isMouseDown = false;
			buttonTip = "\x0F\xEF\xEF\020Click-and-drag to specify an area to copy then cut (right click = cancel)";
			buttonTipShow = 120;
		}
		break;
	case SDL_SCANCODE_V:
		if (ctrl)
		{
			if (c->LoadClipboard())
			{
				selectPoint1 = selectPoint2 = mousePosition;
				isMouseDown = false;
			}
		}
		break;
	case SDL_SCANCODE_L:
	{
		auto &stampIDs = Client::Ref().GetStamps();
		if (stampIDs.size())
		{
			auto saveFile = Client::Ref().GetStamp(stampIDs[0]);
			if (!saveFile || !saveFile->GetGameSave())
				break;
			c->LoadStamp(saveFile->TakeGameSave());
			selectPoint1 = selectPoint2 = mousePosition;
			isMouseDown = false;
			break;
		}
	}
	case SDL_SCANCODE_K:
		selectMode = SelectNone;
		selectPoint1 = selectPoint2 = ui::Point(-1, -1);
		c->OpenStamps();
		break;
	case SDL_SCANCODE_RIGHTBRACKET:
		if(zoomEnabled && !zoomCursorFixed)
			c->AdjustZoomSize(1, !alt);
		else
			c->AdjustBrushSize(1, !alt, ctrlBehaviour, shiftBehaviour);
		break;
	case SDL_SCANCODE_LEFTBRACKET:
		if(zoomEnabled && !zoomCursorFixed)
			c->AdjustZoomSize(-1, !alt);
		else
			c->AdjustBrushSize(-1, !alt, ctrlBehaviour, shiftBehaviour);
		break;
	case SDL_SCANCODE_I:
		if(ctrl)
			c->Install();
		else
			c->InvertAirSim();
		break;
	case SDL_SCANCODE_SEMICOLON:
		if (ctrl)
			c->SetReplaceModeFlags(c->GetReplaceModeFlags()^SPECIFIC_DELETE);
		else
			c->SetReplaceModeFlags(c->GetReplaceModeFlags()^REPLACE_MODE);
		break;
	default:
		didKeyShortcut = false;
	}
	if (!didKeyShortcut)
	{
		switch (key)
		{
		case SDLK_AC_BACK:
			if (ALLOW_QUIT)
			{
				ui::Engine::Ref().ConfirmExit();
			}
			break;
		case SDLK_TAB: //Tab
			c->ChangeBrush();
			break;
		case SDLK_INSERT:
			if (ctrl)
				c->SetReplaceModeFlags(c->GetReplaceModeFlags()^SPECIFIC_DELETE);
			else
				c->SetReplaceModeFlags(c->GetReplaceModeFlags()^REPLACE_MODE);
			break;
		case SDLK_DELETE:
			c->SetReplaceModeFlags(c->GetReplaceModeFlags()^SPECIFIC_DELETE);
			break;
		}
	}

	if (shift && showDebug && key == '1')
	{
		c->LoadRenderPreset(10);
	}
	else if (shift && key == '6')
	{
		c->LoadRenderPreset(11);
	}
	else if (key >= '0' && key <= '9')
	{
		c->LoadRenderPreset(key-'0');
	}
}

void GameView::OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	if (scan == SDL_SCANCODE_Z)
	{
		if (!zoomCursorFixed && !alt)
			c->SetZoomEnabled(false);
		return;
	}
}

void GameView::OnBlur()
{
	disableAltBehaviour();
	disableCtrlBehaviour();
	disableShiftBehaviour();
	isMouseDown = false;
	drawMode = DrawPoints;
	c->Blur();
}

void GameView::OnFileDrop(ByteString filename)
{
	if (!(filename.EndsWith(".cps") || filename.EndsWith(".stm")))
	{
		new ErrorMessage("Error loading save", "Dropped file is not a TPT save file (.cps or .stm format)");
		return;
	}


	if (filename.EndsWith(".stm"))
	{
		auto saveFile = Client::Ref().GetStamp(filename);
		if (!saveFile || !saveFile->GetGameSave())
		{
			new ErrorMessage("Error loading stamp", "Dropped stamp could not be loaded: " + saveFile->GetError());
			return;
		}
		c->LoadStamp(saveFile->TakeGameSave());
	}
	else
	{
		auto saveFile = Client::Ref().LoadSaveFile(filename);
		if (!saveFile)
			return;
		if (saveFile->GetError().length())
		{
			new ErrorMessage("Error loading save", "Dropped save file could not be loaded: " + saveFile->GetError());
			return;
		}
		c->LoadSaveFile(std::move(saveFile));
	}

	// hide the info text if it's not already hidden
	SkipIntroText();
}

void GameView::SkipIntroText()
{
	introText = 0;
}

void GameView::OnTick()
{
	if (selectMode == PlaceSave && !placeSaveThumb)
		selectMode = SelectNone;
	if (zoomEnabled && !zoomCursorFixed)
		c->SetZoomPosition(currentMouse);

	if (skipDraw)
	{
		skipDraw = false;
	}
	else if (selectMode == SelectNone && isMouseDown)
	{
		if (drawMode == DrawPoints)
		{
			c->DrawPoints(toolIndex, lastPoint, currentPoint, true);
			lastPoint = currentPoint;
		}
		else if (drawMode == DrawFill)
		{
			c->DrawFill(toolIndex, c->PointTranslate(currentMouse));
		}
		else if (drawMode == DrawLine)
		{
			ui::Point drawPoint2 = currentMouse;
			if (altBehaviour)
				drawPoint2 = lineSnapCoords(c->PointTranslate(drawPoint1), currentMouse);
			c->ToolDrag(toolIndex, c->PointTranslate(drawPoint1), c->PointTranslate(drawPoint2));
		}
	}

	int foundSignID = c->GetSignAt(mousePosition.X, mousePosition.Y);
	if (foundSignID != -1)
	{
		String str = c->GetSignText(foundSignID);
		auto si = c->GetSignSplit(foundSignID);

		StringBuilder tooltip;
		switch (si.second)
		{
		case sign::Type::Save:
			tooltip << "Go to save ID:" << str.Substr(3, si.first - 3);
			break;
		case sign::Type::Thread:
			tooltip << "Open forum thread " << str.Substr(3, si.first - 3) << " in browser";
			break;
		case sign::Type::Search:
			tooltip << "Search for " << str.Substr(3, si.first - 3);
			break;
		default: break;
		}

		if (tooltip.Size())
		{
			ToolTip(ui::Point(0, Size.Y), tooltip.Build());
		}
	}

	if (isButtonTipFadingIn || (selectMode != PlaceSave && selectMode != SelectNone))
	{
		isButtonTipFadingIn = false;
		buttonTipShow.SetTarget(120);
	}
	else
	{
		buttonTipShow.SetTarget(0);
	}
	if (isToolTipFadingIn)
	{
		isToolTipFadingIn = false;
		toolTipPresence.SetTarget(120);
	}
	else
	{
		toolTipPresence.SetTarget(0);
	}
}

void GameView::OnSimTick()
{
	c->Update();
	wantFrame = true;
}

void GameView::DoMouseMove(int x, int y, int dx, int dy)
{
	if(c->MouseMove(x, y, dx, dy))
		Window::DoMouseMove(x, y, dx, dy);
}

void GameView::DoMouseDown(int x, int y, unsigned button)
{
	if(introText > 50)
		introText = 50;
	if(c->MouseDown(x, y, button))
		Window::DoMouseDown(x, y, button);
}

void GameView::DoMouseUp(int x, int y, unsigned button)
{
	if(c->MouseUp(x, y, button, GameController::mouseUpNormal))
		Window::DoMouseUp(x, y, button);
}

void GameView::DoMouseWheel(int x, int y, int d)
{
	if(c->MouseWheel(x, y, d))
		Window::DoMouseWheel(x, y, d);
}

void GameView::DoTextInput(String text)
{
	if (c->TextInput(text))
		Window::DoTextInput(text);
}

void GameView::DoTextEditing(String text)
{
	if (c->TextEditing(text))
		Window::DoTextEditing(text);
}

void GameView::DoKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (shift && !shiftBehaviour)
		enableShiftBehaviour();
	if (ctrl && !ctrlBehaviour)
		enableCtrlBehaviour();
	if (alt && !altBehaviour)
		enableAltBehaviour();
	if (c->KeyPress(key, scan, repeat, shift, ctrl, alt))
		Window::DoKeyPress(key, scan, repeat, shift, ctrl, alt);
}

void GameView::DoKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (!shift && shiftBehaviour)
		disableShiftBehaviour();
	if (!ctrl && ctrlBehaviour)
		disableCtrlBehaviour();
	if (!alt && altBehaviour)
		disableAltBehaviour();
	if (c->KeyRelease(key, scan, repeat, shift, ctrl, alt))
		Window::DoKeyRelease(key, scan, repeat, shift, ctrl, alt);
}

void GameView::DoExit()
{
	Window::DoExit();
	c->Exit();
}

void GameView::DoDraw()
{
	Window::DoDraw();
	constexpr std::array<int, 9> fadeout = { { // * Gamma-corrected.
		255, 195, 145, 103, 69, 42, 23, 10, 3
	} };
	auto *g = GetGraphics();
	for (auto x = 0; x < int(fadeout.size()); ++x)
	{
		g->BlendLine({ x, YRES + 1 }, { x, YRES + 18 }, 0x000000_rgb .WithAlpha(fadeout[x]));
		g->BlendLine({ XRES - x, YRES + 1 }, { XRES - x, YRES + 18 }, 0x000000_rgb .WithAlpha(fadeout[x]));
	}

	c->Tick();
	{
		auto rect = g->Size().OriginRect();
		g->SwapClipRect(rect);  // reset any nonsense cliprect Lua left configured
	}
}

void GameView::NotifyNotificationsChanged(GameModel * sender)
{
	for (auto *notificationComponent : notificationComponents)
	{
		RemoveComponent(notificationComponent);
		delete notificationComponent;
	}
	notificationComponents.clear();

	std::vector<Notification*> notifications = sender->GetNotifications();

	int currentY = YRES-23;
	for (auto *notification : notifications)
	{
		int width = Graphics::TextSize(notification->Message).X + 7;
		ui::Button * tempButton = new ui::Button(ui::Point(XRES-width-22, currentY), ui::Point(width, 15), notification->Message);
		tempButton->SetActionCallback({ [notification] {
			notification->Action();
		} });
		tempButton->Appearance.BorderInactive = style::Colour::WarningTitle;
		tempButton->Appearance.TextInactive = style::Colour::WarningTitle;
		tempButton->Appearance.BorderHover = ui::Colour(255, 175, 0);
		tempButton->Appearance.TextHover = ui::Colour(255, 175, 0);
		AddComponent(tempButton);
		notificationComponents.push_back(tempButton);

		tempButton = new ui::Button(ui::Point(XRES-20, currentY), ui::Point(15, 15), 0xE02A);
		//tempButton->SetIcon(IconClose);
		auto closeNotification = [this, notification] {
			c->RemoveNotification(notification);
		};
		tempButton->SetActionCallback({ closeNotification, closeNotification });
		tempButton->Appearance.Margin.Left -= 1;
		tempButton->Appearance.Margin.Top -= 1;
		tempButton->Appearance.BorderInactive = style::Colour::WarningTitle;
		tempButton->Appearance.TextInactive = style::Colour::WarningTitle;
		tempButton->Appearance.BorderHover = ui::Colour(255, 175, 0);
		tempButton->Appearance.TextHover = ui::Colour(255, 175, 0);
		AddComponent(tempButton);
		notificationComponents.push_back(tempButton);

		currentY -= 17;
	}
}

void GameView::NotifyZoomChanged(GameModel * sender)
{
	zoomEnabled = sender->GetZoomEnabled();
}

void GameView::NotifyLogChanged(GameModel * sender, String entry)
{
	logEntries.push_front(std::pair<String, int>(entry, 600));
	if (logEntries.size() > 20)
		logEntries.pop_back();
}

void GameView::NotifyPlaceSaveChanged(GameModel * sender)
{
	placeSaveTransform = Mat2<int>::Identity;
	placeSaveTranslate = Vec2<int>::Zero;
	ApplyTransformPlaceSave();
}

void GameView::TranslateSave(Vec2<int> addToTranslate)
{
	placeSaveTranslate += addToTranslate;
	ApplyTransformPlaceSave();
}

void GameView::TransformSave(Mat2<int> mulToTransform)
{
	placeSaveTranslate = Vec2<int>::Zero; // reset offset
	placeSaveTransform = mulToTransform * placeSaveTransform;
	ApplyTransformPlaceSave();
}

void GameView::ApplyTransformPlaceSave()
{
	auto remX = floorDiv(placeSaveTranslate.X, CELL).second;
	auto remY = floorDiv(placeSaveTranslate.Y, CELL).second;
	c->TransformPlaceSave(placeSaveTransform, { remX, remY });
}

void GameView::NotifyTransformedPlaceSaveChanged(GameModel *sender)
{
	if (sender->GetTransformedPlaceSave())
	{
		placeSaveThumb = SaveRenderer::Ref().Render(sender->GetTransformedPlaceSave(), true, sender->GetRendererSettings());
		selectMode = PlaceSave;
		selectPoint2 = mousePosition;
	}
	else
	{
		placeSaveThumb.reset();
		selectMode = SelectNone;
	}
}

void GameView::enableShiftBehaviour()
{
	if (!shiftBehaviour)
	{
		shiftBehaviour = true;
		if (!isMouseDown || selectMode != SelectNone)
			UpdateDrawMode();
		UpdateToolStrength();
	}
}

void GameView::disableShiftBehaviour()
{
	if (shiftBehaviour)
	{
		shiftBehaviour = false;
		if (!isMouseDown || selectMode != SelectNone)
			UpdateDrawMode();
		UpdateToolStrength();
	}
}

void GameView::enableAltBehaviour()
{
	if (!altBehaviour)
	{
		altBehaviour = true;
		drawSnap = true;
	}
}

void GameView::disableAltBehaviour()
{
	if (altBehaviour)
	{
		altBehaviour = false;
		drawSnap = false;
	}
}

void GameView::enableCtrlBehaviour()
{
	if (!ctrlBehaviour)
	{
		ctrlBehaviour = true;
		if (!isMouseDown || selectMode != SelectNone)
			UpdateDrawMode();
		UpdateToolStrength();

		//Show HDD save & load buttons
		saveSimulationButton->Appearance.BackgroundInactive = saveSimulationButton->Appearance.BackgroundHover = ui::Colour(255, 255, 255);
		saveSimulationButton->Appearance.TextInactive = saveSimulationButton->Appearance.TextHover = ui::Colour(0, 0, 0);

		saveSimulationButton->Enabled = true;
		SetSaveButtonTooltips();

		searchButton->Appearance.BackgroundInactive = searchButton->Appearance.BackgroundHover = ui::Colour(255, 255, 255);
		searchButton->Appearance.TextInactive = searchButton->Appearance.TextHover = ui::Colour(0, 0, 0);

		searchButton->SetToolTip("Open a simulation from your hard drive.");
		if (currentSaveType == 2)
			saveSimulationButton->SetShowSplit(true);
	}
}

void GameView::disableCtrlBehaviour()
{
	if (ctrlBehaviour)
	{
		ctrlBehaviour = false;
		if (!isMouseDown || selectMode != SelectNone)
			UpdateDrawMode();
		UpdateToolStrength();

		//Hide HDD save & load buttons
		saveSimulationButton->Appearance.BackgroundInactive = ui::Colour(0, 0, 0);
		saveSimulationButton->Appearance.BackgroundHover = ui::Colour(20, 20, 20);
		saveSimulationButton->Appearance.TextInactive = saveSimulationButton->Appearance.TextHover = ui::Colour(255, 255, 255);
		saveSimulationButton->Enabled = saveSimulationButtonEnabled && saveReuploadAllowed;
		SetSaveButtonTooltips();
		searchButton->Appearance.BackgroundInactive = ui::Colour(0, 0, 0);
		searchButton->Appearance.BackgroundHover = ui::Colour(20, 20, 20);
		searchButton->Appearance.TextInactive = searchButton->Appearance.TextHover = ui::Colour(255, 255, 255);
		searchButton->SetToolTip("Find & open a simulation. Hold Ctrl to load offline saves.");
		if (currentSaveType == 2)
			saveSimulationButton->SetShowSplit(false);
	}
}

void GameView::UpdateDrawMode()
{
	if (ctrlBehaviour && shiftBehaviour)
	{
		if (toolBrush)
			drawMode = DrawPoints;
		else
			drawMode = DrawFill;
	}
	else if (ctrlBehaviour)
		drawMode = DrawRect;
	else if (shiftBehaviour)
		drawMode = DrawLine;
	else
		drawMode = DrawPoints;
	// TODO: have tools decide on draw mode
	if (c->GetLastTool() && c->GetLastTool()->Identifier == "DEFAULT_UI_SAMPLE")
	{
		drawMode = DrawPoints;
	}
}

void GameView::UpdateToolStrength()
{
	if (shiftBehaviour)
		c->SetToolStrength(10.0f);
	else if (ctrlBehaviour)
		c->SetToolStrength(.1f);
	else
		c->SetToolStrength(1.0f);
}

void GameView::SetSaveButtonTooltips()
{
	if (!Client::Ref().GetAuthUser().UserID)
		saveSimulationButton->SetToolTips("Overwrite the open simulation on your hard drive.", "Save the simulation to your hard drive. Login to save online.");
	else if (ctrlBehaviour)
		saveSimulationButton->SetToolTips("Overwrite the open simulation on your hard drive.", "Save the simulation to your hard drive.");
	else if (saveSimulationButton->GetShowSplit())
		saveSimulationButton->SetToolTips("Re-upload the current simulation", "Modify simulation properties");
	else
		saveSimulationButton->SetToolTips("Re-upload the current simulation", "Upload a new simulation. Hold Ctrl to save offline.");
}

void GameView::RenderSimulation(const RenderableSimulation &sim, bool handleEvents)
{
	ren->sim = &sim;
	ren->Clear();
	ren->RenderBackground();
	if (handleEvents)
	{
		c->BeforeSimDraw();
	}
	{
		// we may write graphicscache here
		auto &sd = SimulationData::Ref();
		std::unique_lock lk(sd.elementGraphicsMx);
		ren->RenderSimulation();
	}
	ren->sim = nullptr;
}

void GameView::AfterSimDraw(const RenderableSimulation &sim)
{
	ren->sim = &sim;
	c->AfterSimDraw();
	ren->sim = nullptr;
}

void GameView::OnDraw()
{
	Graphics * g = GetGraphics();

	auto threadedRenderingAllowed = c->ThreadedRenderingAllowed();
	if (wantFrame)
	{
		wantFrame = false;
		if (threadedRenderingAllowed)
		{
			StartRendererThread();
			WaitForRendererThread();
			AfterSimDraw(*sim);
			rendererStats = ren->GetStats();
			*rendererThreadResult = ren->GetVideo();
			rendererFrame = rendererThreadResult.get();
			DispatchRendererThread();
		}
		else
		{
			PauseRendererThread();
			ren->ApplySettings(*rendererSettings);
			RenderSimulation(*sim, true);
			AfterSimDraw(*sim);
			rendererStats = ren->GetStats();
			rendererFrame = &ren->GetVideo();
		}
	}

	std::copy_n(rendererFrame->data(), rendererFrame->Size().X * rendererFrame->Size().Y, g->Data());

	if (showBrush && selectMode == SelectNone && (!zoomEnabled || zoomCursorFixed) && activeBrush && (isMouseDown || (currentMouse.X >= 0 && currentMouse.X < XRES && currentMouse.Y >= 0 && currentMouse.Y < YRES)))
	{
		ui::Point finalCurrentMouse = c->PointTranslate(currentMouse);
		ui::Point initialDrawPoint = drawPoint1;

		if (wallBrush)
		{
			finalCurrentMouse = c->NormaliseBlockCoord(finalCurrentMouse);
			initialDrawPoint = c->NormaliseBlockCoord(initialDrawPoint);
		}

		if (drawMode == DrawRect && isMouseDown)
		{
			if (drawSnap)
			{
				finalCurrentMouse = rectSnapCoords(c->PointTranslate(initialDrawPoint), finalCurrentMouse);
			}
			if (wallBrush)
			{
				if (finalCurrentMouse.X > initialDrawPoint.X)
					finalCurrentMouse.X += CELL-1;
				else
					initialDrawPoint.X += CELL-1;

				if (finalCurrentMouse.Y > initialDrawPoint.Y)
					finalCurrentMouse.Y += CELL-1;
				else
					initialDrawPoint.Y += CELL-1;
			}
			activeBrush->RenderRect(g, c->PointTranslate(initialDrawPoint), finalCurrentMouse);
		}
		else if (drawMode == DrawLine && isMouseDown)
		{
			if (drawSnap)
			{
				finalCurrentMouse = lineSnapCoords(c->PointTranslate(initialDrawPoint), finalCurrentMouse);
			}
			activeBrush->RenderLine(g, c->PointTranslate(initialDrawPoint), finalCurrentMouse);
		}
		else if (drawMode == DrawFill)// || altBehaviour)
		{
			if (!decoBrush)
				activeBrush->RenderFill(g, finalCurrentMouse);
		}
		if (drawMode == DrawPoints || drawMode==DrawLine || (drawMode == DrawRect && !isMouseDown))
		{
			if (wallBrush)
			{
				ui::Point finalBrushRadius = c->NormaliseBlockCoord(activeBrush->GetRadius());
				auto topLeft     = finalCurrentMouse - finalBrushRadius;
				auto bottomRight = finalCurrentMouse + finalBrushRadius + Vec2{ CELL - 1, CELL - 1 };
				g->XorLine({     topLeft.X,     topLeft.Y     }, { bottomRight.X,     topLeft.Y     });
				g->XorLine({     topLeft.X, bottomRight.Y     }, { bottomRight.X, bottomRight.Y     });
				g->XorLine({     topLeft.X,     topLeft.Y + 1 }, {     topLeft.X, bottomRight.Y - 1 }); // offset by 1 so the corners don't get xor'd twice
				g->XorLine({ bottomRight.X,     topLeft.Y + 1 }, { bottomRight.X, bottomRight.Y - 1 }); // offset by 1 so the corners don't get xor'd twice
			}
			else
			{
				activeBrush->RenderPoint(g, finalCurrentMouse);
			}
		}
	}

	if(selectMode!=SelectNone)
	{
		if(selectMode==PlaceSave)
		{
			if(placeSaveThumb && selectPoint2.X!=-1)
			{
				auto rect = RectSized(PlaceSavePos() * CELL, placeSaveThumb->Size());
				g->BlendImage(placeSaveThumb->Data(), 0x80, rect);
				g->XorDottedRect(rect);
			}
		}
		else
		{
			if(selectPoint1.X==-1)
			{
				g->BlendFilledRect(RectSized(Vec2{ 0, 0 }, Vec2{ XRES, YRES }), 0x000000_rgb .WithAlpha(100));
			}
			else
			{
				int x2 = (selectPoint1.X>selectPoint2.X)?selectPoint1.X:selectPoint2.X;
				int y2 = (selectPoint1.Y>selectPoint2.Y)?selectPoint1.Y:selectPoint2.Y;
				int x1 = (selectPoint2.X<selectPoint1.X)?selectPoint2.X:selectPoint1.X;
				int y1 = (selectPoint2.Y<selectPoint1.Y)?selectPoint2.Y:selectPoint1.Y;

				if(x2>XRES-1)
					x2 = XRES-1;
				if(y2>YRES-1)
					y2 = YRES-1;

				g->BlendFilledRect(RectSized(Vec2{ 0, 0 }, Vec2{ XRES, y1 }), 0x000000_rgb .WithAlpha(100));
				g->BlendFilledRect(RectSized(Vec2{ 0, y2+1 }, Vec2{ XRES, YRES-y2-1 }), 0x000000_rgb .WithAlpha(100));

				g->BlendFilledRect(RectSized(Vec2{ 0, y1 }, Vec2{ x1, (y2-y1)+1 }), 0x000000_rgb .WithAlpha(100));
				g->BlendFilledRect(RectSized(Vec2{ x2+1, y1 }, Vec2{ XRES-x2-1, (y2-y1)+1 }), 0x000000_rgb .WithAlpha(100));

				g->XorDottedRect(RectBetween(Vec2{ x1, y1 }, Vec2{ x2, y2 }));
			}
		}
	}

	g->RenderZoom();

	if (doScreenshot)
	{
		doScreenshot = false;
		TakeScreenshot(0, 0);
	}

	if(recording)
	{
		std::vector<char> data = VideoBuffer(*rendererFrame).ToPPM();

		ByteString filename = ByteString::Build("recordings", PATH_SEP_CHAR, recordingFolder, PATH_SEP_CHAR, "frame_", Format::Width(recordingIndex++, 6), ".ppm");

		Platform::WriteFile(data, filename);
	}

	if (logEntries.size())
	{
		int startX = 20;
		int startY = YRES-20;
		std::deque<std::pair<String, int> >::iterator iter;
		for(iter = logEntries.begin(); iter != logEntries.end(); iter++)
		{
			String message = (*iter).first;
			int alpha = std::min((*iter).second, 255);
			if (alpha <= 0) //erase this and everything older
			{
				logEntries.erase(iter, logEntries.end());
				break;
			}
			startY -= 14;
			g->BlendFilledRect(RectSized(Vec2{ startX-3, startY-3 }, Vec2{ Graphics::TextSize(message).X + 5, 14 }), 0x000000_rgb .WithAlpha(std::min(100, alpha)));
			g->BlendText({ startX, startY }, message, 0xFFFFFF_rgb .WithAlpha(alpha));
			(*iter).second -= 3;
		}
	}

	if (recording)
	{
		String sampleInfo = String::Build("#", screenshotIndex, " ", String(0xE00E), " REC");

		int textWidth = Graphics::TextSize(sampleInfo).X - 1;
		g->BlendFilledRect(RectSized(Vec2{ XRES-20-textWidth, 12 }, Vec2{ textWidth+8, 15 }), 0x000000_rgb .WithAlpha(127));
		g->BlendText({ XRES-16-textWidth, 16 }, sampleInfo, 0xFF3214_rgb .WithAlpha(255));
	}
	else if(showHud)
	{
		//Draw info about simulation under cursor
		int wavelengthGfx = 0;
		int alpha = 255-introText*5;
		if (toolTipPosition.Y < 120)
			alpha -= toolTipPresence*3;
		if (alpha < 0)
			alpha = 0;
		StringBuilder sampleInfo;
		sampleInfo << Format::Precision(2);

		int type = sample.particle.type;
		if (type)
		{
			int ctype = sample.particle.ctype;

			if (type == PT_PHOT || type == PT_BIZR || type == PT_BIZRG || type == PT_BIZRS || type == PT_FILT || type == PT_BRAY || type == PT_C5)
				wavelengthGfx = (ctype&0x3FFFFFFF);

			if (showDebug)
			{
				if (type == PT_LAVA && c->IsValidElement(ctype))
				{
					sampleInfo << "Molten " << c->ElementResolve(ctype, 0);
				}
				else if ((type == PT_PIPE || type == PT_PPIP) && c->IsValidElement(ctype))
				{
					if (ctype == PT_LAVA && c->IsValidElement(sample.particle.tmp4))
					{
						sampleInfo << c->ElementResolve(type, 0) << " with molten " << c->ElementResolve(sample.particle.tmp4, -1);
					}
					else
					{
						sampleInfo << c->ElementResolve(type, 0) << " with " << c->ElementResolve(ctype, sample.particle.tmp4);
					}
				}
				else if (type == PT_LIFE)
				{
					sampleInfo << c->ElementResolve(type, ctype);
				}
				else if (type == PT_FILT)
				{
					sampleInfo << c->ElementResolve(type, ctype);
					String filtModes[] = {"set colour", "AND", "OR", "subtract colour", "red shift", "blue shift", "no effect", "XOR", "NOT", "old QRTZ scattering", "variable red shift", "variable blue shift"};
					if (sample.particle.tmp>=0 && sample.particle.tmp<=11)
						sampleInfo << " (" << filtModes[sample.particle.tmp] << ")";
					else
						sampleInfo << " (unknown mode)";
				}
				else
				{
					sampleInfo << c->ElementResolve(type, ctype);
					if (wavelengthGfx || type == PT_EMBR || type == PT_PRTI || type == PT_PRTO)
					{
						// Do nothing, ctype is meaningless for these elements
					}
					// Some elements store extra LIFE info in upper bits of ctype, instead of tmp/tmp2
					else if (type == PT_CRAY || type == PT_DRAY || type == PT_CONV || type == PT_LDTC)
						sampleInfo << " (" << c->ElementResolve(TYP(ctype), ID(ctype)) << ")";
					else if (type == PT_CLNE || type == PT_BCLN || type == PT_PCLN || type == PT_PBCN || type == PT_DTEC)
						sampleInfo << " (" << c->ElementResolve(ctype, sample.particle.tmp) << ")";
					else if (c->IsValidElement(ctype) && type != PT_GLOW && type != PT_WIRE && type != PT_SOAP && type != PT_LITH)
						sampleInfo << " (" << c->ElementResolve(ctype, 0) << ")";
					else if (ctype)
						sampleInfo << " (" << ctype << ")";
				}
				sampleInfo << ", Temp: ";
				format::RenderTemperature(sampleInfo, sample.particle.temp, c->GetTemperatureScale());
				sampleInfo << ", Life: " << sample.particle.life;
				if (sample.particle.type != PT_RFRG && sample.particle.type != PT_RFGL && sample.particle.type != PT_LIFE)
				{
					if (sample.particle.type == PT_CONV)
					{
						String elemName = c->ElementResolve(
							TYP(sample.particle.tmp),
							ID(sample.particle.tmp));
						if (elemName == "")
							sampleInfo << ", Tmp: " << sample.particle.tmp;
						else
							sampleInfo << ", Tmp: " << elemName;
					}
					else
						sampleInfo << ", Tmp: " << sample.particle.tmp;
				}

				// only elements that use .tmp2 show it in the debug HUD
				if (type == PT_CRAY || type == PT_DRAY || type == PT_EXOT || type == PT_LIGH || type == PT_SOAP || type == PT_TRON
						|| type == PT_VIBR || type == PT_VIRS || type == PT_WARP || type == PT_LCRY || type == PT_CBNW || type == PT_TSNS
						|| type == PT_DTEC || type == PT_LSNS || type == PT_PSTN || type == PT_LDTC || type == PT_VSNS || type == PT_LITH
						|| type == PT_CONV || type == PT_ETRD)
					sampleInfo << ", Tmp2: " << sample.particle.tmp2;

				sampleInfo << ", Pressure: " << sample.AirPressure;
			}
			else
			{
				sampleInfo << c->BasicParticleInfo(sample.particle);
				sampleInfo << ", Temp: ";
				format::RenderTemperature(sampleInfo, sample.particle.temp, c->GetTemperatureScale());
				sampleInfo << ", Pressure: " << sample.AirPressure;
			}
		}
		else if (sample.WallType)
		{
			sampleInfo << c->WallName(sample.WallType);
			sampleInfo << ", Pressure: " << sample.AirPressure;
		}
		else if (sample.isMouseInSim)
		{
			sampleInfo << "Empty, Pressure: " << sample.AirPressure;
		}
		else
		{
			sampleInfo << "Empty";
		}

		int textWidth = Graphics::TextSize(sampleInfo.Build()).X - 1;
		g->BlendFilledRect(RectSized(Vec2{ XRES-20-textWidth, 12 }, Vec2{ textWidth+8, 15 }), 0x000000_rgb .WithAlpha(int(alpha*0.5f)));
		g->BlendText({ XRES-16-textWidth, 16 }, sampleInfo.Build(), 0xFFFFFF_rgb .WithAlpha(int(alpha*0.75f)));

		if (wavelengthGfx)
		{
			int i, cr, cg, cb, j, h = 3, x = XRES-19-textWidth, y = 10;
			int tmp;
			g->BlendFilledRect(RectSized(Vec2{ x, y }, Vec2{ 30, h }), 0x404040_rgb .WithAlpha(alpha));
			for (i = 0; i < 30; i++)
			{
				if ((wavelengthGfx >> i)&1)
				{
					// Need a spread of wavelengths to get a smooth spectrum, 5 bits seems to work reasonably well
					if (i>2) tmp = 0x1F << (i-2);
					else tmp = 0x1F >> (2-i);

					cg = 0;
					cb = 0;
					cr = 0;

					for (j=0; j<12; j++)
					{
						cr += (tmp >> (j+18)) & 1;
						cb += (tmp >> j) & 1;
					}
					for (j=0; j<13; j++)
						cg += (tmp >> (j+9)) & 1;

					tmp = 624/(cr+cg+cb+1);
					cr *= tmp;
					cg *= tmp;
					cb *= tmp;
					for (j=0; j<h; j++)
						g->BlendPixel({ x+29-i, y+j }, RGBA(cr>255?255:cr, cg>255?255:cg, cb>255?255:cb, alpha));
				}
			}
		}

		if (showDebug)
		{
			StringBuilder sampleInfo;
			sampleInfo << Format::Precision(2);

			if (type)
				sampleInfo << "#" << sample.ParticleID << ", ";

			sampleInfo << "X:" << sample.PositionX << " Y:" << sample.PositionY;

			auto gravtot = std::abs(sample.GravityVelocityX) +
			               std::abs(sample.GravityVelocityY);
			if (gravtot)
				sampleInfo << ", GX: " << sample.GravityVelocityX << " GY: " << sample.GravityVelocityY;

			if (c->GetAHeatEnable())
			{
				sampleInfo << ", AHeat: ";
				format::RenderTemperature(sampleInfo, sample.AirTemperature, c->GetTemperatureScale());
			}

			auto textWidth = Graphics::TextSize(sampleInfo.Build()).X - 1;
			g->BlendFilledRect(RectSized(Vec2{ XRES-20-textWidth, 27 }, Vec2{ textWidth+8, 14 }), 0x000000_rgb .WithAlpha(int(alpha*0.5f)));
			g->BlendText({ XRES-16-textWidth, 30 }, sampleInfo.Build(), 0xFFFFFF_rgb .WithAlpha(int(alpha*0.75f)));
		}
	}

	if(showHud && introText < 51)
	{
		//FPS and some version info
		StringBuilder fpsInfo;
		fpsInfo << Format::Precision(2) << "FPS: " << ui::Engine::Ref().GetFps();

		if (showDebug)
		{
			if (rendererSettings->findingElement)
				fpsInfo << " Parts: " << rendererStats.foundParticles << "/" << sample.NumParts;
			else
				fpsInfo << " Parts: " << sample.NumParts;
		}
		if ((std::holds_alternative<HdispLimitAuto>(rendererSettings->wantHdispLimitMin) ||
		     std::holds_alternative<HdispLimitAuto>(rendererSettings->wantHdispLimitMax)) && rendererStats.hdispLimitValid)
		{
			fpsInfo << " [TEMP L:";
			format::RenderTemperature(fpsInfo, rendererStats.hdispLimitMin, c->GetTemperatureScale());
			fpsInfo << " H:";
			format::RenderTemperature(fpsInfo, rendererStats.hdispLimitMax, c->GetTemperatureScale());
			fpsInfo << "]";
		}
		if (c->GetReplaceModeFlags()&REPLACE_MODE)
			fpsInfo << " [REPLACE MODE]";
		if (c->GetReplaceModeFlags()&SPECIFIC_DELETE)
			fpsInfo << " [SPECIFIC DELETE]";
		if (rendererSettings->gridSize)
			fpsInfo << " [GRID: " << rendererSettings->gridSize << "]";
		if (rendererSettings->findingElement)
			fpsInfo << " [FIND]";
		if (c->GetDebugFlags() & DEBUG_SIMHUD)
		{
			fpsInfo << "\nSimulation";
			fpsInfo << "\n  FPS cap: ";
			if (std::holds_alternative<FpsLimitNone>(simFpsLimit))
			{
				fpsInfo << "none";
			}
			else
			{
				fpsInfo << std::get<FpsLimitExplicit>(simFpsLimit).value;
			}
		}
		if (c->GetDebugFlags() & DEBUG_RENHUD)
		{
			fpsInfo << "\nRendering";
			fpsInfo << "\n  Draw cap: ";
			auto drawLimit = ui::Engine::Ref().GetDrawingFrequencyLimit();
			if (std::holds_alternative<DrawLimitDisplay>(drawLimit))
			{
				fpsInfo << "display";
			}
			else if (std::holds_alternative<DrawLimitNone>(drawLimit))
			{
				fpsInfo << "none";
			}
			else
			{
				fpsInfo << std::get<DrawLimitExplicit>(drawLimit).value;
			}
			fpsInfo << ", effective: ";
			if (auto drawCap = ui::Engine::Ref().GetEffectiveDrawCap())
			{
				fpsInfo << *drawCap;
			}
			else
			{
				fpsInfo << "none";
			}
			fpsInfo << "\n  SRT: ";
			if (!c->GetThreadedRendering())
			{
				fpsInfo << "disabled";
			}
			else if (threadedRenderingAllowed)
			{
				fpsInfo << "enabled";
			}
			else
			{
				fpsInfo << "hindered";
			}
			fpsInfo << "\n  Refresh rate: ";
			auto refreshRate = ui::Engine::Ref().GetRefreshRate();
			fpsInfo << std::visit([](auto &refreshRate) {
				return refreshRate.value;
			}, refreshRate);
			if (std::holds_alternative<RefreshRateDefault>(refreshRate))
			{
				fpsInfo << " (default)";
			}
		}

		int textWidth = Graphics::TextSize(fpsInfo.Build()).X - 1;
		int alpha = 255-introText*5;
		g->BlendFilledRect(RectSized(Vec2{ 12, 12 }, Vec2{ textWidth+8, 15 }), 0x000000_rgb .WithAlpha(int(alpha*0.5)));
		g->BlendText({ 16, 16 }, fpsInfo.Build(), 0x20D8FF_rgb .WithAlpha(int(alpha*0.75)));
	}

	//Tooltips
	if(infoTipPresence)
	{
		int infoTipAlpha = (infoTipPresence>50?50:int(infoTipPresence))*5;
		g->BlendTextOutline({ (XRES - (Graphics::TextSize(infoTip).X - 1)) / 2, YRES / 2 - 2 }, infoTip, 0xFFFFFF_rgb .WithAlpha(infoTipAlpha));
	}

	if(toolTipPresence && toolTipPosition.X!=-1 && toolTipPosition.Y!=-1 && toolTip.length())
	{
		if (toolTipPosition.Y == Size.Y-MENUSIZE-10)
			g->BlendTextOutline(toolTipPosition, toolTip, 0xFFFFFF_rgb .WithAlpha(toolTipPresence>51?255:toolTipPresence*5));
		else
			g->BlendText(toolTipPosition, toolTip, 0xFFFFFF_rgb .WithAlpha(toolTipPresence>51?255:toolTipPresence*5));
	}

	if(buttonTipShow > 0)
	{
		g->BlendText({ 16, Size.Y-MENUSIZE-24 }, buttonTip, 0xFFFFFF_rgb .WithAlpha(buttonTipShow>51?255:buttonTipShow*5));
	}

	//Introduction text
	if(introText && showHud)
	{
		g->BlendFilledRect(RectSized(Vec2{ 0, 0 }, WINDOW), 0x000000_rgb .WithAlpha(introText>51?102:introText*2));
		g->BlendText({ 16, 16 }, introTextMessage, 0xFFFFFF_rgb .WithAlpha(introText>51?255:introText*5));
	}
}

ui::Point GameView::lineSnapCoords(ui::Point point1, ui::Point point2)
{
	ui::Point diff = point2 - point1;
	if(abs(diff.X / 2) > abs(diff.Y)) // vertical
		return point1 + ui::Point(diff.X, 0);
	if(abs(diff.X) < abs(diff.Y / 2)) // horizontal
		return point1 + ui::Point(0, diff.Y);
	if(diff.X * diff.Y > 0) // NW-SE
		return point1 + ui::Point((diff.X + diff.Y)/2, (diff.X + diff.Y)/2);
	// SW-NE
	return point1 + ui::Point((diff.X - diff.Y)/2, (diff.Y - diff.X)/2);
}

ui::Point GameView::rectSnapCoords(ui::Point point1, ui::Point point2)
{
	ui::Point diff = point2 - point1;
	if(diff.X * diff.Y > 0) // NW-SE
		return point1 + ui::Point((diff.X + diff.Y)/2, (diff.X + diff.Y)/2);
	// SW-NE
	return point1 + ui::Point((diff.X - diff.Y)/2, (diff.Y - diff.X)/2);
}

std::optional<FindingElement> GameView::FindingElementCandidate() const
{
	Tool *active = c->GetActiveTool(0);
	auto &properties = Particle::GetProperties();
	if (active->Identifier.Contains("_PT_"))
	{
		return FindingElement{ properties[FIELD_TYPE], active->ToolID };
	}
	else if (active->Identifier == "DEFAULT_UI_PROPERTY")
	{
		auto configuration = static_cast<PropertyTool *>(active)->GetConfiguration();
		if (configuration)
		{
			return FindingElement{ properties[configuration->changeProperty.propertyIndex], configuration->changeProperty.propertyValue };
		}
	}
	return std::nullopt;
}

pixel GameView::GetPixelUnderMouse() const
{
	auto point = c->PointTranslate(currentMouse);
	if (!rendererFrame->Size().OriginRect().Contains(point))
	{
		return 0;
	}
	return (*rendererFrame)[point];
}

void GameView::RendererThread()
{
	while (true)
	{
		{
			std::unique_lock lk(rendererThreadMx);
			rendererThreadOwnsRenderer = false;
			rendererThreadCv.notify_one();
			rendererThreadCv.wait(lk, [this]() {
				return rendererThreadState == rendererThreadStopping || rendererThreadOwnsRenderer;
			});
			if (rendererThreadState == rendererThreadStopping)
			{
				break;
			}
		}
		RenderSimulation(*rendererThreadSim, false);
	}
}

void GameView::StartRendererThread()
{
	bool start = false;
	bool notify = false;
	{
		std::lock_guard lk(rendererThreadMx);
		if (rendererThreadState == rendererThreadAbsent)
		{
			rendererThreadSim = std::make_unique<RenderableSimulation>();
			rendererThreadResult = std::make_unique<RendererFrame>();
			rendererThreadState = rendererThreadRunning;
			start = true;
		}
		else if (rendererThreadState == rendererThreadPaused)
		{
			rendererThreadState = rendererThreadRunning;
			notify = true;
		}
	}
	if (start)
	{
		rendererThread = std::thread([this]() {
			RendererThread();
		});
		notify = true;
	}
	if (notify)
	{
		DispatchRendererThread();
	}
}

void GameView::StopRendererThread()
{
	bool join = false;
	{
		std::lock_guard lk(rendererThreadMx);
		if (rendererThreadState != rendererThreadAbsent)
		{
			rendererThreadState = rendererThreadStopping;
			join = true;
		}
	}
	if (join)
	{
		rendererThreadCv.notify_one();
		rendererThread.join();
	}
}

void GameView::PauseRendererThread()
{
	std::unique_lock lk(rendererThreadMx);
	if (rendererThreadState == rendererThreadRunning)
	{
		rendererThreadState = rendererThreadPaused;
		rendererThreadCv.notify_one();
		rendererThreadCv.wait(lk, [this]() {
			return !rendererThreadOwnsRenderer;
		});
	}
}

void GameView::DispatchRendererThread()
{
	ren->ApplySettings(*rendererSettings);
	*rendererThreadSim = *sim;
	rendererThreadSim->useLuaCallbacks = false;
	rendererThreadOwnsRenderer = true;
	{
		std::lock_guard lk(rendererThreadMx);
		rendererThreadOwnsRenderer = true;
	}
	rendererThreadCv.notify_one();
}

void GameView::WaitForRendererThread()
{
	std::unique_lock lk(rendererThreadMx);
	rendererThreadCv.wait(lk, [this]() {
		return !rendererThreadOwnsRenderer;
	});
}

void GameView::ApplySimFpsLimit()
{
	if (std::holds_alternative<FpsLimitNone>(simFpsLimit))
	{
		if (c->GetPaused())
		{
			SetFpsLimit(FpsLimitFollowDraw{});
		}
		else
		{
			SetFpsLimit(FpsLimitNone{});
		}
	}
	else
	{
		SetFpsLimit(std::get<FpsLimitExplicit>(simFpsLimit));
	}
}

void GameView::SetSimFpsLimit(SimFpsLimit newSimFpsLimit)
{
	simFpsLimit = newSimFpsLimit;
	ApplySimFpsLimit();
}


=== src\gui\game\GameView.h ===

#pragma once
#include "common/String.h"
#include "gui/interface/Window.h"
#include "gui/interface/Fade.h"
#include "simulation/Sample.h"
#include "graphics/FindingElement.h"
#include "graphics/RendererFrame.h"
#include <ctime>
#include <deque>
#include <memory>
#include <vector>
#include <optional>
#include <thread>
#include <mutex>
#include <condition_variable>

enum DrawMode
{
	DrawPoints, DrawLine, DrawRect, DrawFill
};

enum SelectMode
{
	SelectNone, SelectStamp, SelectCopy, SelectCut, PlaceSave
};

namespace ui
{
	class Button;
	class Slider;
	class Textbox;
}

class SplitButton;
class Simulation;
struct RenderableSimulation;

class MenuButton;
class Renderer;
struct RendererSettings;
class VideoBuffer;
class ToolButton;
class GameController;
class Brush;
class GameModel;
class GameView: public ui::Window
{
private:
	bool isMouseDown;
	bool skipDraw;
	bool zoomEnabled;
	bool zoomCursorFixed;
	bool mouseInZoom;
	bool drawSnap;
	bool shiftBehaviour;
	bool ctrlBehaviour;
	bool altBehaviour;
	bool showHud;
	bool showBrush;
	bool showDebug;
	int delayedActiveMenu;
	bool wallBrush;
	bool toolBrush;
	bool decoBrush;
	int toolIndex;
	int currentSaveType;
	int lastMenu;

	ui::Fade toolTipPresence{ ui::Fade::LinearProfile{ 120.f, 60.f }, 0, 0 };
	String toolTip;
	bool isToolTipFadingIn;
	ui::Point toolTipPosition;
	ui::Fade infoTipPresence{ ui::Fade::LinearProfile{ 60.f, 60.f }, 0, 0 };
	String infoTip;
	ui::Fade buttonTipShow{ ui::Fade::LinearProfile{ 120.f, 60.f }, 0, 0 };
	String buttonTip;
	bool isButtonTipFadingIn;
	ui::Fade introText{ ui::Fade::LinearProfile{ 60.f, 60.f }, 0, 2048 };
	String introTextMessage;

	bool doScreenshot;
	int screenshotIndex;
	time_t lastScreenshotTime;
	int recordingIndex;
	bool recording;
	int recordingFolder;

	ui::Point currentPoint, lastPoint;
	GameController * c;
	Renderer *ren = nullptr;
	RendererSettings *rendererSettings = nullptr;
	bool wantFrame = false;
	Simulation *sim = nullptr;
	Brush const *activeBrush;
	//UI Elements
	std::vector<ui::Button*> quickOptionButtons;

	std::vector<MenuButton*> menuButtons;

	std::vector<ToolButton*> toolButtons;
	std::vector<ui::Component*> notificationComponents;
	std::deque<std::pair<String, int> > logEntries;
	ui::Button * scrollBar;
	ui::Button * searchButton;
	ui::Button * reloadButton;
	SplitButton * saveSimulationButton;
	bool saveSimulationButtonEnabled;
	bool saveReuploadAllowed;
	ui::Button * downVoteButton;
	ui::Button * upVoteButton;
	void ResetVoteButtons();
	ui::Button * tagSimulationButton;
	ui::Button * clearSimButton;
	SplitButton * loginButton;
	ui::Button * simulationOptionButton;
	ui::Button * displayModeButton;
	ui::Button * pauseButton;

	ui::Button * colourPicker;
	std::vector<ToolButton*> colourPresets;

	DrawMode drawMode;
	ui::Point drawPoint1;
	ui::Point drawPoint2;

	SelectMode selectMode;
	ui::Point selectPoint1;
	ui::Point selectPoint2;

	ui::Point currentMouse;
	ui::Point mousePosition;

	std::unique_ptr<VideoBuffer> placeSaveThumb;
	Mat2<int> placeSaveTransform = Mat2<int>::Identity;
	Vec2<int> placeSaveTranslate = Vec2<int>::Zero;
	void TranslateSave(Vec2<int> addToTranslate);
	void TransformSave(Mat2<int> mulToTransform);
	void ApplyTransformPlaceSave();

	SimulationSample sample;

	void updateToolButtonScroll();

	void SetSaveButtonTooltips();

	void enableShiftBehaviour();
	void disableShiftBehaviour();
	void enableCtrlBehaviour();
	void disableCtrlBehaviour();
	void enableAltBehaviour();
	void disableAltBehaviour();
	void UpdateDrawMode();
	void UpdateToolStrength();

	Vec2<int> PlaceSavePos() const;

	std::optional<FindingElement> FindingElementCandidate() const;
	enum RendererThreadState
	{
		rendererThreadAbsent,
		rendererThreadRunning,
		rendererThreadPaused,
		rendererThreadStopping,
	};
	RendererThreadState rendererThreadState = rendererThreadAbsent;
	std::thread rendererThread;
	std::mutex rendererThreadMx;
	std::condition_variable rendererThreadCv;
	bool rendererThreadOwnsRenderer = false;
	void StartRendererThread();
	void StopRendererThread();
	void RendererThread();
	void WaitForRendererThread();
	void DispatchRendererThread();
	std::unique_ptr<RenderableSimulation> rendererThreadSim;
	std::unique_ptr<RendererFrame> rendererThreadResult;
	RendererStats rendererStats;
	const RendererFrame *rendererFrame = nullptr;

	SimFpsLimit simFpsLimit = FpsLimitExplicit{ 60.f };
	void ApplySimFpsLimit();

public:
	GameView();
	~GameView();

	//Breaks MVC, but any other way is going to be more of a mess.
	ui::Point GetMousePosition();
	void SetSample(SimulationSample sample);
	void SetHudEnable(bool hudState);
	bool GetHudEnable();
	void SetBrushEnable(bool hudState);
	bool GetBrushEnable();
	void SetDebugHUD(bool mode);
	bool GetDebugHUD();
	bool GetPlacingSave();
	bool GetPlacingZoom();
	void SetActiveMenuDelayed(int activeMenu) { delayedActiveMenu = activeMenu; }
	bool CtrlBehaviour(){ return ctrlBehaviour; }
	bool ShiftBehaviour(){ return shiftBehaviour; }
	bool AltBehaviour(){ return altBehaviour; }
	SelectMode GetSelectMode() { return selectMode; }
	void BeginStampSelection();
	ByteString TakeScreenshot(int captureUI, int fileType);
	int Record(bool record);

	//all of these are only here for one debug lines
	bool GetMouseDown() { return isMouseDown; }
	bool GetDrawingLine() { return drawMode == DrawLine && isMouseDown && selectMode == SelectNone; }
	bool GetDrawSnap() { return drawSnap; }
	ui::Point GetLineStartCoords() { return drawPoint1; }
	ui::Point GetLineFinishCoords() { return currentMouse; }
	ui::Point GetCurrentMouse() { return currentMouse; }
	ui::Point lineSnapCoords(ui::Point point1, ui::Point point2);
	ui::Point rectSnapCoords(ui::Point point1, ui::Point point2);

	void AttachController(GameController * _c){ c = _c; }
	void NotifyRendererChanged(GameModel * sender);
	void NotifySimulationChanged(GameModel * sender);
	void NotifyPausedChanged(GameModel * sender);
	void NotifySaveChanged(GameModel * sender);
	void NotifyBrushChanged(GameModel * sender);
	void NotifyMenuListChanged(GameModel * sender);
	void NotifyActiveMenuToolListChanged(GameModel * sender);
	void NotifyActiveToolsChanged(GameModel * sender);
	void NotifyUserChanged(GameModel * sender);
	void NotifyZoomChanged(GameModel * sender);
	void NotifyColourSelectorVisibilityChanged(GameModel * sender);
	void NotifyColourSelectorColourChanged(GameModel * sender);
	void NotifyColourPresetsChanged(GameModel * sender);
	void NotifyColourActivePresetChanged(GameModel * sender);
	void NotifyPlaceSaveChanged(GameModel * sender);
	void NotifyTransformedPlaceSaveChanged(GameModel *sender);
	void NotifyNotificationsChanged(GameModel * sender);
	void NotifyLogChanged(GameModel * sender, String entry);
	void NotifyToolTipChanged(GameModel * sender);
	void NotifyInfoTipChanged(GameModel * sender);
	void NotifyQuickOptionsChanged(GameModel * sender);
	void NotifyLastToolChanged(GameModel * sender);


	void ToolTip(ui::Point senderPosition, String toolTip) override;

	void OnMouseMove(int x, int y, int dx, int dy) override;
	void OnMouseDown(int x, int y, unsigned button) override;
	void OnMouseUp(int x, int y, unsigned button) override;
	void OnMouseWheel(int x, int y, int d) override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnTick() override;
	void OnSimTick() override;
	void OnDraw() override;
	void OnBlur() override;
	void OnFileDrop(ByteString filename) override;

	//Top-level handlers, for Lua interface
	void DoExit() override;
	void DoDraw() override;
	void DoMouseMove(int x, int y, int dx, int dy) override;
	void DoMouseDown(int x, int y, unsigned button) override;
	void DoMouseUp(int x, int y, unsigned button) override;
	void DoMouseWheel(int x, int y, int d) override;
	void DoTextInput(String text) override;
	void DoTextEditing(String text) override;
	void DoKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void DoKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;

	class OptionListener;

	void SkipIntroText();
	pixel GetPixelUnderMouse() const;

	const RendererFrame &GetRendererFrame() const
	{
		return *rendererFrame;
	}
	// Call this before accessing Renderer "out of turn", e.g. from RenderView or GameModel. This *does not*
	// include OptionsModel or Lua setting functions because they only access the RendererSettings
	// in GameModel, or Lua drawing functions because they only access Renderer in eventTraitSimGraphics
	// and *SimDraw events, and the renderer thread gets paused anyway if there are handlers
	// installed for such events.
	void PauseRendererThread();

	void RenderSimulation(const RenderableSimulation &sim, bool handleEvents);
	void AfterSimDraw(const RenderableSimulation &sim);

	void SetSimFpsLimit(SimFpsLimit newSimFpsLimit);
	SimFpsLimit GetSimFpsLimit() const
	{
		return simFpsLimit;
	}
};


=== src\gui\game\IntroText.h ===

#pragma once
#include "Config.h"
#include "SimulationConfig.h"
#include "common/String.h"

inline ByteString VersionInfo()
{
	ByteStringBuilder sb;
	sb << DISPLAY_VERSION[0] << "." << DISPLAY_VERSION[1];
	if constexpr (!SNAPSHOT)
	{
		sb << "." << APP_VERSION.build;
	}
	sb << " " << IDENT;
	if constexpr (MOD)
	{
		sb << " MOD " << MOD_ID << " UPSTREAM " << UPSTREAM_VERSION.build;
	}
	if constexpr (SNAPSHOT)
	{
		sb << " SNAPSHOT " << APP_VERSION.build;
	}
	if constexpr (LUACONSOLE)
	{
		sb << " LUACONSOLE";
	}
	if constexpr (LATENTHEAT)
	{
		sb << " LATENTHEAT";
	}
	if constexpr (NOHTTP)
	{
		sb << " NOHTTP";
	}
	else if constexpr (ENFORCE_HTTPS)
	{
		sb << " HTTPS";
	}
	if constexpr (DEBUG)
	{
		sb << " DEBUG";
	}
	return sb.Build();
}

inline ByteString IntroText()
{
	ByteStringBuilder sb;
	sb << "\bl\bU" << APPNAME << "\bU - Version " << DISPLAY_VERSION[0] << "." << DISPLAY_VERSION[1] << " - https://powdertoy.co.uk, irc.libera.chat #powder, https://tpt.io/discord\n"
	      "\n"
	      "\n"
	      "\bgControl+C/V/X are Copy, Paste and cut respectively.\n"
	      "\bgTo choose a material, hover over one of the icons on the right, it will show a selection of elements in that group.\n"
	      "\bgPick your material from the menu using mouse left/right buttons.\n"
	      "Draw freeform lines by dragging your mouse left/right button across the drawing area.\n"
	      "Shift+drag will create straight lines of particles.\n"
	      "Ctrl+drag will result in filled rectangles.\n"
	      "Ctrl+Shift+click will flood-fill a closed area.\n"
	      "Use the mouse scroll wheel, or '[' and ']', to change the tool size for particles.\n"
	      "Middle click or Alt+Click to \"sample\" the particles.\n"
	      "Ctrl+Z will act as Undo.\n"
	      "\n\boUse 'Z' for a zoom tool. Click to make the drawable zoom window stay around. Use the wheel to change the zoom strength.\n"
	      "The spacebar can be used to pause physics. Use 'F' to step ahead by one frame.\n"
	      "Use 'S' to save parts of the window as 'stamps'. 'L' loads the most recent stamp, 'K' shows a library of stamps you saved.\n"
	      "Use 'P' to take a screenshot and save it into the current directory.\n"
	      "Use 'H' to toggle the HUD. Use 'D' to toggle debug mode in the HUD.\n"
	      "\n";
	if constexpr (BETA)
	{
		sb << "\brThis is a BETA, you cannot save things publicly, nor open local saves and stamps made with it in older versions.\n"
		      "\brIf you are planning on publishing any saves, use the release version.\n";
	}
	else
	{
		sb << "\bgTo use online features such as saving, you need to register at: \br" << SERVER << "/Register.html\n";
	}
	sb << "\n\bt" << VersionInfo();
	return sb.Build();
}


=== src\gui\game\Menu.cpp ===

#include "Menu.h"

Menu::Menu(String::value_type icon_, String description_, int visible_):
	icon(icon_),
	description(description_),
	tools(std::vector<Tool*>()),
	visible(visible_ ? true : false)
{

}

Menu::~Menu()
{
	tools.clear();
}

void Menu::AddTool(Tool * tool_)
{
	tools.push_back(tool_);
}

void Menu::ClearTools()
{
	tools.clear();
}


=== src\gui\game\Menu.h ===

#pragma once
#include "common/String.h"

class Tool;
class Menu
{
	String::value_type icon;
	String description;
	std::vector<Tool*> tools;
	bool visible;
public:
	Menu(String::value_type icon_, String description_, int visible_);
	virtual ~Menu();

	std::vector<Tool*> GetToolList()
	{
		return tools;
	}

	String::value_type GetIcon()
	{
		return icon;
	}

	String GetDescription()
	{
		return description;
	}

	bool GetVisible()
	{
		return visible;
	}

	void AddTool(Tool * tool_);
	void ClearTools();
};



=== src\gui\game\MenuButton.h ===

#pragma once
#include "gui/interface/Button.h"

class MenuButton : public ui::Button
{
public:
	using ui::Button::Button;
	int menuID;
	bool needsClick;
};


=== src\gui\game\meson.build ===

powder_files += files(
	'BitmapBrush.cpp',
	'Brush.cpp',
	'Favorite.cpp',
	'GameController.cpp',
	'GameModel.cpp',
	'GameView.cpp',
	'Menu.cpp',
	'QuickOptions.cpp',
	'ToolButton.cpp',
)

subdir('tool')


=== src\gui\game\Notification.h ===

#pragma once
#include "common/String.h"

class Notification
{
public:
	Notification(String message) : Message(message) {}
	virtual ~Notification() {};
	String Message;

	virtual void Action() { }
};


=== src\gui\game\QuickOption.h ===

#pragma once
#include "common/String.h"
#include <vector>

class GameModel;
class QuickOption;
class QuickOptionListener
{
protected:
	QuickOptionListener() {}
public:
	virtual ~QuickOptionListener() {}
	virtual void OnValueChanged(QuickOption * sender) {}
};
class QuickOption
{
public:
	enum Type {
		Toggle, Multi
	};
protected:
	std::vector<QuickOptionListener*> listeners;
	GameModel * m;
	Type type;
	String icon;
	String description;
	QuickOption(String icon, String description, GameModel * m, Type type) :
		m(m),
		type(type),
		icon(icon),
		description(description)
	{

	}
	virtual void perform() {}
public:
	virtual ~QuickOption()
	{
		for(std::vector<QuickOptionListener*>::iterator iter = listeners.begin(), end = listeners.end(); iter != end; ++iter)
			delete *iter;
	}

	std::vector<QuickOptionListener*> GetListeners()
	{
		return listeners;
	}

	void AddListener(QuickOptionListener * listener)
	{
		listeners.push_back(listener);
	}

	Type GetType() { return type; }

	virtual bool GetToggle() { return true;}
	virtual int GetMutli() { return 0;}
	virtual int GetMultiCount() { return 0;}

	String GetIcon() { return icon; }
	void SetIcon(String icon) { this->icon = icon; }
	String GetDescription() { return description; }
	void SetDescription(String description) { this->description = description; }
	void Perform()
	{
		perform();
		for(std::vector<QuickOptionListener*>::iterator iter = listeners.begin(), end = listeners.end(); iter != end; ++iter)
			(*iter)->OnValueChanged(this);
	}
	void Update()
	{
		for(std::vector<QuickOptionListener*>::iterator iter = listeners.begin(), end = listeners.end(); iter != end; ++iter)
			(*iter)->OnValueChanged(this);
	}
};



=== src\gui\game\QuickOptions.cpp ===

#include "QuickOptions.h"

#include "GameModel.h"
#include "GameController.h"

#include "simulation/Simulation.h"

SandEffectOption::SandEffectOption(GameModel * m):
QuickOption("P", "Sand effect", m, Toggle)
{

}
bool SandEffectOption::GetToggle()
{
	return m->GetSimulation()->pretty_powder;
}
void SandEffectOption::perform()
{
	m->GetSimulation()->pretty_powder = !m->GetSimulation()->pretty_powder;
}



DrawGravOption::DrawGravOption(GameModel * m):
QuickOption("G", "Draw gravity field \bg(ctrl+g)", m, Toggle)
{

}
bool DrawGravOption::GetToggle()
{
	return m->GetGravityGrid();
}
void DrawGravOption::perform()
{
	m->ShowGravityGrid(!m->GetGravityGrid());
}



DecorationsOption::DecorationsOption(GameModel * m):
QuickOption("D", "Draw decorations \bg(ctrl+b)", m, Toggle)
{

}
bool DecorationsOption::GetToggle()
{
	return m->GetDecoration();
}
void DecorationsOption::perform()
{
	m->SetDecoration(!m->GetDecoration());
}



NGravityOption::NGravityOption(GameModel * m):
QuickOption("N", "Newtonian Gravity \bg(n)", m, Toggle)
{

}
bool NGravityOption::GetToggle()
{
	return m->GetNewtonianGrvity();
}
void NGravityOption::perform()
{
	m->SetNewtonianGravity(!m->GetNewtonianGrvity());
}



AHeatOption::AHeatOption(GameModel * m):
QuickOption("A", "Ambient heat \bg(u)", m, Toggle)
{

}
bool AHeatOption::GetToggle()
{
	return m->GetAHeatEnable();
}
void AHeatOption::perform()
{
	m->SetAHeatEnable(!m->GetAHeatEnable());
}



ConsoleShowOption::ConsoleShowOption(GameModel * m, GameController * c_):
QuickOption("C", "Show Console \bg(~)", m, Toggle)
{
	c = c_;
}
bool ConsoleShowOption::GetToggle()
{
	return 0;
}
void ConsoleShowOption::perform()
{
	c->ShowConsole();
}


=== src\gui\game\QuickOptions.h ===

#include "QuickOption.h"

class GameController;

class SandEffectOption: public QuickOption
{
public:
	SandEffectOption(GameModel * m);
	bool GetToggle() override;
	void perform() override;
};

class DrawGravOption: public QuickOption
{
public:
	DrawGravOption(GameModel * m);
	bool GetToggle() override;
	void perform() override;
};

class DecorationsOption: public QuickOption
{
public:
	DecorationsOption(GameModel * m);
	bool GetToggle() override;
	void perform() override;
};

class NGravityOption: public QuickOption
{
public:
	NGravityOption(GameModel * m);
	bool GetToggle() override;
	void perform() override;
};

class AHeatOption: public QuickOption
{
public:
	AHeatOption(GameModel * m);
	bool GetToggle() override;
	void perform() override;
};

class ConsoleShowOption: public QuickOption
{
	GameController * c;
public:
	ConsoleShowOption(GameModel * m, GameController * c_);
	bool GetToggle() override;
	void perform() override;
};


=== src\gui\game\RectangleBrush.h ===

#pragma once
#include "Brush.h"

class RectangleBrush: public Brush
{
public:
	virtual ~RectangleBrush() override = default;

	PlaneAdapter<std::vector<unsigned char>> GenerateBitmap() const override
	{
		auto size = GetSize();
		PlaneAdapter<std::vector<unsigned char>> bitmap(size, 0xFF);
		return bitmap;
	}

	std::unique_ptr<Brush> Clone() const override
	{
		return std::make_unique<RectangleBrush>(*this);
	}
};


=== src\gui\game\RenderPreset.h ===

#pragma once
#include "common/String.h"
#include "graphics/RendererSettings.h"
#include <cstdint>

struct RenderPreset
{
	String Name;
	uint32_t renderMode;
	uint32_t displayMode;
	uint32_t colorMode;
	HdispLimit wantHdispLimitMin = HdispLimitExplicit{ MIN_TEMP };
	HdispLimit wantHdispLimitMax = HdispLimitExplicit{ MAX_TEMP };
};


=== src\gui\game\ToolButton.cpp ===

#include "ToolButton.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include "Favorite.h"
#include <SDL.h>

ToolButton::ToolButton(ui::Point position, ui::Point size, String text, ByteString toolIdentifier, String toolTip):
	ui::Button(position, size, text, toolTip),
	toolIdentifier(toolIdentifier)
{
	SetSelectionState(-1);
	Appearance.BorderActive = ui::Colour(255, 0, 0);
	Appearance.BorderFavorite = ui::Colour(255, 255, 0);

	//don't use "..." on elements that have long names
	buttonDisplayText = ButtonText.Substr(0, 7);
	Component::TextPosition(buttonDisplayText);
}

void ToolButton::OnMouseDown(int x, int y, unsigned int button)
{
	if (MouseDownInside)
	{
		isButtonDown = true;
	}
}

void ToolButton::OnMouseClick(int x, int y, unsigned int button)
{
	if(isButtonDown)
	{
		isButtonDown = false;
		if(button == SDL_BUTTON_LEFT)
			SetSelectionState(0);
		if(button == SDL_BUTTON_RIGHT)
			SetSelectionState(1);
		if(button == SDL_BUTTON_MIDDLE)
			SetSelectionState(2);
		DoAction();
	}
}

void ToolButton::OnMouseUp(int x, int y, unsigned int button)
{
	// mouse was unclicked, reset variables in case the unclick happened outside
	isButtonDown = false;
}

void ToolButton::Draw(const ui::Point& screenPos)
{
	Graphics * g = GetGraphics();
	auto rect = ClipRect;
	if (ClipRect.size.X && ClipRect.size.Y)
		g->SwapClipRect(rect); // old cliprect is now in rect

	int totalColour = Appearance.BackgroundInactive.Blue + (3*Appearance.BackgroundInactive.Green) + (2*Appearance.BackgroundInactive.Red);

	if (Appearance.GetTexture())
	{
		auto *tex = Appearance.GetTexture();
		g->BlendImage(tex->Data(), 255, RectSized(screenPos + Vec2{ 2, 2 }, tex->Size()));
	}
	else
	{
		g->BlendFilledRect(RectSized(screenPos + Vec2{ 2, 2 }, Size - Vec2{ 4, 4 }), Appearance.BackgroundInactive);
	}

	if (isMouseInside && currentSelection == -1)
	{
		g->BlendRect(RectSized(screenPos, Size), Appearance.BorderActive);
	}
	else
	{
		g->BlendRect(RectSized(screenPos, Size), Appearance.BorderInactive);
	}
	if (Favorite::Ref().IsFavorite(toolIdentifier))
	{
		g->BlendText(screenPos, 0xE068, Appearance.BorderFavorite);
	}

	if (totalColour<544)
	{
		g->BlendText(screenPos + textPosition, buttonDisplayText, 0xFFFFFF_rgb .WithAlpha(255));
	}
	else
	{
		g->BlendText(screenPos + textPosition, buttonDisplayText, 0x000000_rgb .WithAlpha(255));
	}

	if (ClipRect.size.X && ClipRect.size.Y)
		g->SwapClipRect(rect); // apply old clip rect
}

void ToolButton::SetSelectionState(int state)
{
	currentSelection = state;
	switch(state)
	{
	case 0:
		Appearance.BorderInactive = ui::Colour(255, 0, 0);
		break;
	case 1:
		Appearance.BorderInactive = ui::Colour(0, 0, 255);
		break;
	case 2:
		Appearance.BorderInactive = ui::Colour(0, 255, 0);
		break;
	case 3:
		Appearance.BorderInactive = ui::Colour(0, 255, 255);
		break;
	default:
		Appearance.BorderInactive = ui::Colour(0, 0, 0);
		break;
	}
}

int ToolButton::GetSelectionState()
{
	return currentSelection;
}


=== src\gui\game\ToolButton.h ===

#pragma once
#include "gui/interface/Button.h"

class Tool;

class ToolButton: public ui::Button
{
	int currentSelection;
	ByteString toolIdentifier;
public:
	ToolButton(ui::Point position, ui::Point size, String text, ByteString toolIdentifier, String toolTip = String());
	void OnMouseDown(int x, int y, unsigned int button) override;
	void OnMouseUp(int x, int y, unsigned int button) override;
	void OnMouseClick(int x, int y, unsigned int button) override;
	void Draw(const ui::Point& screenPos) override;
	void SetSelectionState(int state);
	int GetSelectionState();
	Tool *tool;
	Rect<int> ClipRect = RectSized(Vec2<int>::Zero, Vec2<int>::Zero);
};


=== src\gui\game\TriangleBrush.h ===

#pragma once
#include "Brush.h"
#include <cmath>

class TriangleBrush: public Brush
{
public:
	virtual ~TriangleBrush() override = default;

	PlaneAdapter<std::vector<unsigned char>> GenerateBitmap() const override
	{
		ui::Point size = radius * 2 + Vec2{ 1, 1 };
		PlaneAdapter<std::vector<unsigned char>> bitmap(size);

		int rx = radius.X;
		int ry = radius.Y;
		for(int x = -rx; x <= rx; x++)
		{
			for(int y = -ry; y <= ry; y++)
			{
				if ((abs((rx+2*x)*ry+rx*y) + abs(2*rx*(y-ry)) + abs((rx-2*x)*ry+rx*y))<=(4*rx*ry))
				{
					bitmap[{ x+rx, y+ry }] = 255;
				}
				else
				{
					bitmap[{ x+rx, y+ry }] = 0;
				}
			}
		}
		return bitmap;
	}

	std::unique_ptr<Brush> Clone() const override
	{
		return std::make_unique<TriangleBrush>(*this);
	}
};


=== src\gui\game\tool\DecorationTool.cpp ===

#include "DecorationTool.h"
#include "graphics/Renderer.h"
#include "simulation/SimulationData.h"
#include "simulation/Simulation.h"
#include "gui/game/GameView.h"

std::unique_ptr<VideoBuffer> DecorationTool::GetIcon(int ToolID, Vec2<int> size)
{
	auto texture = std::make_unique<VideoBuffer>(size);

	if (ToolID == DECO_SMUDGE)
		for (auto pos : size.OriginRect())
			texture->DrawPixel(pos, RGB(0, 0xFF - 5 * pos.X, 5 * pos.X));
	else if (ToolID == DECO_DRAW || ToolID == DECO_CLEAR)
		texture->BlendFilledRect(size.OriginRect(), Colour);
	else
		texture->DrawFilledRect(size.OriginRect(), 0x323232_rgb);

	if (ToolID == DECO_CLEAR)
	{
		auto reverse = RGB(Colour.Red + 127, Colour.Green + 127, Colour.Blue + 127).WithAlpha(0xFF);
		texture->BlendChar(size / 2 - Vec2(4, 2), 0xE06C, reverse);
	}
	else
	{
		auto colour = Colour.NoAlpha().WithAlpha(0xFF);
		if (ToolID == DECO_ADD)
			texture->AddChar(Vec2(11, 4), '+', colour);
		else if (ToolID == DECO_SUBTRACT)
			texture->AddChar(Vec2(11, 4), '-', colour);
		else if (ToolID == DECO_MULTIPLY)
			texture->AddChar(Vec2(11, 3), 'x', colour);
		else if (ToolID == DECO_DIVIDE)
			texture->AddChar(Vec2(11, 4), '/', colour);
	}
	return texture;
}

void DecorationTool::Draw(Simulation * sim, Brush const &brush, ui::Point position)
{
	sim->ApplyDecorationPoint(position.X, position.Y, Colour.Red, Colour.Green, Colour.Blue, Colour.Alpha, ToolID, brush);
}

void DecorationTool::DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging)
{
	sim->ApplyDecorationLine(position1.X, position1.Y, position2.X, position2.Y, Colour.Red, Colour.Green, Colour.Blue, Colour.Alpha, ToolID, brush);
}

void DecorationTool::DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2)
{
	sim->ApplyDecorationBox(position1.X, position1.Y, position2.X, position2.Y, Colour.Red, Colour.Green, Colour.Blue, Colour.Alpha, ToolID);
}

void DecorationTool::DrawFill(Simulation * sim, Brush const &brush, ui::Point position)
{
	auto &rendererFrame = gameView->GetRendererFrame();
	if (!rendererFrame.Size().OriginRect().Contains(position))
	{
		return;
	}
	auto loc = RGB::Unpack(rendererFrame[position]);
	if (ToolID == DECO_CLEAR)
		// TODO: this is actually const-correct
		sim->ApplyDecorationFill(rendererFrame, position.X, position.Y, 0, 0, 0, 0, loc.Red, loc.Green, loc.Blue);
	else
		sim->ApplyDecorationFill(rendererFrame, position.X, position.Y, Colour.Red, Colour.Green, Colour.Blue, Colour.Alpha, loc.Red, loc.Green, loc.Blue);
}



=== src\gui\game\tool\DecorationTool.h ===

#pragma once
#include <memory>
#include "Tool.h"
#include "graphics/Graphics.h"
#include "graphics/RendererFrame.h"

class Renderer;
class GameView;
class DecorationTool: public Tool
{
public:
	RGBA Colour;
	GameView *gameView;

	std::unique_ptr<VideoBuffer> GetIcon(int toolID, Vec2<int> size);

	DecorationTool(GameView *newGameView, int decoMode, String name, String description, RGB colour, ByteString identifier):
		Tool(decoMode, name, description, colour, identifier),
		Colour(0x000000_rgb .WithAlpha(0x00)),
		gameView(newGameView)
	{
		MenuSection = SC_DECO;
	}

	void Draw(Simulation * sim, Brush const &brush, ui::Point position) override;
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override;
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override;
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override;
};


=== src\gui\game\tool\ElementTool.cpp ===

#include "ElementTool.h"
#include "simulation/Simulation.h"
#include "simulation/ElementCommon.h"
#include "gui/game/Brush.h"

void ElementTool::Draw(Simulation * sim, Brush const &brush, ui::Point position){
	sim->CreateParts(-2, position.X, position.Y, ToolID, brush, -1);
}
void ElementTool::DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) {
	sim->CreateLine(position1.X, position1.Y, position2.X, position2.Y, ToolID, brush, -1);
}
void ElementTool::DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) {
	sim->CreateBox(-2, position1.X, position1.Y, position2.X, position2.Y, ToolID, -1);
}
void ElementTool::DrawFill(Simulation * sim, Brush const &brush, ui::Point position) {
	sim->FloodParts(position.X, position.Y, ToolID, -1, -1);
}


void Element_LIGH_Tool::DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging)
{
	if (dragging)
		sim->CreateParts(-2, position1.X, position1.Y, brush.GetRadius().X, brush.GetRadius().Y, PT_LIGH, -1);
}


void Element_TESC_Tool::DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) {
	int radiusInfo = brush.GetRadius().X*4+brush.GetRadius().Y*4+7;
	sim->CreateBox(-2, position1.X, position1.Y, position2.X, position2.Y, ToolID | PMAPID(radiusInfo), -1);
}
void Element_TESC_Tool::DrawFill(Simulation * sim, Brush const &brush, ui::Point position) {
	int radiusInfo = brush.GetRadius().X*4+brush.GetRadius().Y*4+7;
	sim->FloodParts(position.X, position.Y, ToolID | PMAPID(radiusInfo), -1, -1);
}


void PlopTool::Click(Simulation * sim, Brush const &brush, ui::Point position)
{
	sim->create_part(-2, position.X, position.Y, TYP(ToolID), ID(ToolID));
}


=== src\gui\game\tool\ElementTool.h ===

#pragma once
#include "Tool.h"

class ElementTool: public Tool
{
public:
	ElementTool(int id, String name, String description,
		RGB colour, ByteString identifier, std::unique_ptr<VideoBuffer> (*textureGen)(int, Vec2<int>) = NULL):
		Tool(id, name, description, colour, identifier, textureGen)
	{}

	ElementTool(int id, ByteString identifier) : Tool(id, identifier)
	{}

	void Draw(Simulation * sim, Brush const &brush, ui::Point position) override;
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override;
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override;
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override;
};

class Element_LIGH_Tool: public ElementTool
{
public:
	Element_LIGH_Tool(int id, ByteString identifier) : ElementTool(id, identifier)
	{}

	void Click(Simulation * sim, Brush const &brush, ui::Point position) override { }
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override;
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override { }
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override { }
};

class Element_TESC_Tool: public ElementTool
{
public:
	Element_TESC_Tool(int id, ByteString identifier) : ElementTool(id, identifier)
	{}

	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override;
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override;
};

class PlopTool: public ElementTool
{
public:
	PlopTool(int id, ByteString identifier) : ElementTool(id, identifier)
	{}

	void Draw(Simulation * sim, Brush const &brush, ui::Point position) override { }
	void Click(Simulation * sim, Brush const &brush, ui::Point position) override;
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override { }
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override { }
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override { }
};


=== src\gui\game\tool\GOLTool.cpp ===

#include "GOLTool.h"
#include "prefs/GlobalPrefs.h"
#include "client/Client.h"
#include "common/tpt-rand.h"
#include "simulation/GOLString.h"
#include "simulation/SimulationData.h"
#include "gui/Style.h"
#include "gui/interface/Button.h"
#include "gui/interface/Label.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/Window.h"
#include "gui/colourpicker/ColourPickerActivity.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/game/GameModel.h"
#include "graphics/Graphics.h"

class GOLWindow: public ui::Window
{
	ui::Colour highColour, lowColour;
	ui::Button *highColourButton, *lowColourButton;
	ui::Textbox *nameField, *ruleField;
	GameModel &gameModel;
	int toolSelection;

	void updateGradient();
	void validate();

public:
	GOLWindow(GameModel &gameModel, int toolSelection, int rule, RGB colour1, RGB colour2);

	virtual ~GOLWindow()
	{}

	void OnDraw() override;
	void OnTryExit(ExitMethod method) override;
};

GOLWindow::GOLWindow(GameModel &gameModel_, int toolSelection, int rule, RGB colour1, RGB colour2):
	ui::Window(ui::Point(-1, -1), ui::Point(200, 108)),
	highColour(colour1.WithAlpha(0xFF)),
	lowColour(colour2.WithAlpha(0xFF)),
	gameModel(gameModel_),
	toolSelection(toolSelection)
{
	highColour.Alpha = 255;
	lowColour.Alpha = 255;
	ui::Label * messageLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 14), "Edit custom GOL type");
	messageLabel->SetTextColour(style::Colour::InformationTitle);
	messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	AddComponent(messageLabel);

	auto *okayButton = new ui::Button(ui::Point(0, Size.Y-17), ui::Point(Size.X, 17), "OK");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
	okayButton->SetActionCallback({ [this] {
		if (nameField->GetText().length() && ruleField->GetText().length())
		{
			CloseActiveWindow();
			validate();
			SelfDestruct();
		}
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);

	nameField = new ui::Textbox(ui::Point(8, 25), ui::Point(Size.X-16, 16), "", "[name]");
	nameField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	nameField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	nameField->SetLimit(7);
	AddComponent(nameField);
	FocusComponent(nameField);

	ruleField = new ui::Textbox(ui::Point(8, 46), ui::Point(Size.X-16, 16), "", "[rule]");
	ruleField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	ruleField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(ruleField);
	FocusComponent(ruleField);

	highColourButton = new ui::Button(ui::Point(8, 67), ui::Point(16, 16), "");
	highColourButton->SetActionCallback({ [this] {
		new ColourPickerActivity(highColour, [this](ui::Colour colour) {
			highColour = colour;
			updateGradient();
		});
	} });
	AddComponent(highColourButton);

	lowColourButton = new ui::Button(ui::Point(Size.X - 24, 67), ui::Point(16, 16), "");
	lowColourButton->SetActionCallback({ [this] {
		new ColourPickerActivity(lowColour, [this](ui::Colour colour) {
			lowColour = colour;
			updateGradient();
		});
	} });
	AddComponent(lowColourButton);

	if (rule)
	{
		ruleField->SetText(SerialiseGOLRule(rule));
		nameField->SetText("");
	}
	else
	{
		auto &prefs = GlobalPrefs::Ref();
		ruleField->SetText(prefs.Get("CustomGOL.Rule", String("B3/S23")));
		nameField->SetText(prefs.Get("CustomGOL.Name", String("CGOL")));
		highColour.Red = interfaceRng.between(0x80, 0xFF);
		highColour.Green = interfaceRng.between(0x80, 0xFF);
		highColour.Blue = interfaceRng.between(0x80, 0xFF);
		highColour.Alpha = 0xFF;
		lowColour.Red = interfaceRng.between(0x00, 0x7F);
		lowColour.Green = interfaceRng.between(0x00, 0x7F);
		lowColour.Blue = interfaceRng.between(0x00, 0x7F);
		lowColour.Alpha = 0xFF;
	}
	updateGradient();

	MakeActiveWindow();
}

void GOLWindow::updateGradient()
{
	highColourButton->Appearance.BackgroundInactive = highColour;
	highColourButton->Appearance.BackgroundHover = highColour;
	lowColourButton->Appearance.BackgroundInactive = lowColour;
	lowColourButton->Appearance.BackgroundHover = lowColour;
}

void GOLWindow::validate()
{
	auto &sd = SimulationData::CRef();
	auto nameString = nameField->GetText();
	auto ruleString = ruleField->GetText();
	if (!ValidateGOLName(nameString))
	{
		new ErrorMessage("Could not add GOL type", "Invalid name provided");
		return;
	}
	nameString = nameString.ToUpper();
	int rule = ParseGOLString(ruleString);
	if (rule == -1)
	{
		new ErrorMessage("Could not add GOL type", "Invalid rule provided");
		return;
	}
	if (sd.GetCustomGOLByRule(rule))
	{
		new ErrorMessage("Could not add GOL type", "This Custom GoL rule already exists");
		return;
	}
	ruleString = SerialiseGOLRule(rule); // * Make it canonical.

	{
		auto &prefs = GlobalPrefs::Ref();
		Prefs::DeferWrite dw(prefs);
		prefs.Set("CustomGOL.Name", nameString);
		prefs.Set("CustomGOL.Rule", ruleString);
	}

	if (!gameModel.AddCustomGol(ruleString, nameString, highColour.NoAlpha(), lowColour.NoAlpha()))
	{
		new ErrorMessage("Could not add GOL type", "Name already taken");
		return;
	}

	gameModel.SelectNextIdentifier = "DEFAULT_PT_LIFECUST_" + nameString.ToAscii();
	gameModel.SelectNextTool = toolSelection;
}

void GOLWindow::OnTryExit(ExitMethod method)
{
	CloseActiveWindow();
	SelfDestruct();
}

void GOLWindow::OnDraw()
{
	Graphics * g = GetGraphics();

	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);

	int width = Size.X - 60;
	for (int xx = 0; xx < width; ++xx)
	{
		auto f = xx / (float)width;
		for (int yy = 0; yy < 16; ++yy)
		{
			auto rr = int(highColour.Red * (1.f - f) + lowColour.Red * f);
			auto gg = int(highColour.Green * (1.f - f) + lowColour.Green * f);
			auto bb = int(highColour.Blue * (1.f - f) + lowColour.Blue * f);
			g->DrawPixel(Position + Vec2{ xx + 30, yy + 67 }, RGB(rr, gg, bb));
		}
	}
}

void GOLTool::OpenWindow(Simulation *sim, int toolSelection, int rule, RGB colour1, RGB colour2)
{
	new GOLWindow(gameModel, toolSelection, rule, colour1, colour2);
}

void GOLTool::Select(int toolSelection)
{
	OpenWindow(gameModel.GetSimulation(), toolSelection);
}


=== src\gui\game\tool\GOLTool.h ===

#pragma once
#include "Tool.h"

class GameModel;

class GOLTool: public Tool
{
	GameModel &gameModel;
public:
	GOLTool(GameModel &gameModel):
		Tool(0, "CUST", "Add a new custom GOL type. (Use ctrl+shift+rightclick to remove them)",
			0xFEA900_rgb, "DEFAULT_UI_ADDLIFE", NULL
		),
		gameModel(gameModel)
	{
		MenuSection = SC_LIFE;
	}

	void OpenWindow(Simulation *sim, int toolSelection, int rule = 0, RGB colour1 = 0x000000_rgb, RGB colour2 = 0x000000_rgb);
	void Click(Simulation * sim, Brush const &brush, ui::Point position) override { }
	void Draw(Simulation *sim, Brush const &brush, ui::Point position) override { };
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override { };
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override { };
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override { };

	void Select(int toolSelection) final override;
};


=== src\gui\game\tool\meson.build ===

powder_files += files(
	'DecorationTool.cpp',
	'ElementTool.cpp',
	'GOLTool.cpp',
	'PropertyTool.cpp',
	'SampleTool.cpp',
	'SignTool.cpp',
	'Tool.cpp',
	'WallTool.cpp',
)


=== src\gui\game\tool\PropertyTool.cpp ===

#include "PropertyTool.h"
#include "prefs/GlobalPrefs.h"
#include "gui/Style.h"
#include "gui/game/Brush.h"
#include "gui/game/GameModel.h"
#include "gui/game/GameController.h"
#include "gui/interface/Window.h"
#include "gui/interface/Button.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/DropDown.h"
#include "simulation/Simulation.h"
#include "simulation/SimulationData.h"
#include "graphics/Graphics.h"
#include "Format.h"
#include <SDL.h>

class PropertyWindow: public ui::Window
{
	void HandlePropertyChange();
	std::optional<std::pair<int, String>> TakePropertyFrom(const Simulation *sim, std::optional<int> i) const;

public:
	ui::DropDown * property;
	ui::Textbox * textField;
	PropertyTool * tool;
	Simulation *sim;
	std::optional<PropertyTool::Configuration> configuration;
	PropertyWindow(PropertyTool *tool_, Simulation *sim, std::optional<int> takePropertyFrom);
	void SetProperty();
	void Update();
	void OnDraw() override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnTryExit(ExitMethod method) override;
	virtual ~PropertyWindow() {}
};

PropertyWindow::PropertyWindow(PropertyTool * tool_, Simulation *sim_, std::optional<int> takePropertyFrom):
ui::Window(ui::Point(-1, -1), ui::Point(200, 87)),
tool(tool_),
sim(sim_)
{
	ui::Label * messageLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 14), "Edit property");
	messageLabel->SetTextColour(style::Colour::InformationTitle);
	messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	AddComponent(messageLabel);

	ui::Button * okayButton = new ui::Button(ui::Point(0, Size.Y-17), ui::Point(Size.X, 17), "OK");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
	okayButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		SetProperty();
		SelfDestruct();
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);

	property = new ui::DropDown(ui::Point(8, 25), ui::Point(Size.X-16, 16));
	property->SetActionCallback({ [this] {
		HandlePropertyChange();
	} });
	AddComponent(property);
	auto &properties = Particle::GetProperties();
	for (int i = 0; i < int(properties.size()); i++)
	{
		property->AddOption(std::pair<String, int>(properties[i].Name.FromAscii(), i));
	}

	textField = new ui::Textbox(ui::Point(8, 46), ui::Point(Size.X-16, 16), "", "[value]");
	textField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	textField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	textField->SetActionCallback({ [this]() {
		Update();
	} });
	AddComponent(textField);

	{
		auto &prefs = GlobalPrefs::Ref();
		auto propertyIndex = prefs.Get("Prop.Type", 0);
		auto valueString = prefs.Get("Prop.Value", String(""));
		auto taken = TakePropertyFrom(sim, takePropertyFrom);
		if (taken)
		{
			std::tie(propertyIndex, valueString) = *taken;
		}
		property->SetOption(propertyIndex);
		textField->SetText(valueString);
	}

	FocusComponent(textField);
	Update();

	MakeActiveWindow();
}

std::optional<std::pair<int, String>> PropertyWindow::TakePropertyFrom(const Simulation *sim, std::optional<int> i) const
{
	auto toolConfiguration = tool->GetConfiguration();
	if (!toolConfiguration || !i)
	{
		return std::nullopt;
	}
	auto value = toolConfiguration->changeProperty.Get(sim, *i);
	auto &prop = Particle::GetProperties()[toolConfiguration->changeProperty.propertyIndex];
	String valueString;
	if (prop.Name == "temp")
	{
		StringBuilder sb;
		format::RenderTemperature(sb, std::get<float>(value), GameController::Ref().GetTemperatureScale());
		valueString = sb.Build();
	}
	else
	{
		valueString = prop.ToString(value);
	}
	return std::pair{ toolConfiguration->changeProperty.propertyIndex, valueString };
}

void PropertyWindow::HandlePropertyChange()
{
	FocusComponent(textField);
	Update();
}

void PropertyWindow::Update()
{
	configuration.reset();
	try
	{
		configuration = PropertyTool::Configuration{
			AccessProperty::Parse(property->GetOption().second, textField->GetText()),
			textField->GetText(),
		};
	}
	catch (const AccessProperty::ParseError &ex)
	{
	}
	auto haveConfiguration = bool(configuration);
	okayButton->Enabled = haveConfiguration;
	textField->SetTextColour(haveConfiguration ? ui::Colour(255, 255, 255) : style::Colour::ErrorTitle);
}

void PropertyTool::SetConfiguration(std::optional<Configuration> newConfiguration)
{
	configuration = newConfiguration;
	if (configuration)
	{
		auto &prefs = GlobalPrefs::Ref();
		Prefs::DeferWrite dw(prefs);
		prefs.Set("Prop.Type", configuration->changeProperty.propertyIndex);
		prefs.Set("Prop.Value", configuration->propertyValueStr);
	}
}

void PropertyWindow::SetProperty()
{
	tool->SetConfiguration(configuration);
}

void PropertyWindow::OnTryExit(ExitMethod method)
{
	CloseActiveWindow();
	SelfDestruct();
}

void PropertyWindow::OnDraw()
{
	Graphics * g = GetGraphics();

	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);
}

void PropertyWindow::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (key == SDLK_UP)
	{
		property->SetOption(property->GetOption().second-1);
		HandlePropertyChange();
	}
	else if (key == SDLK_DOWN)
	{
		property->SetOption(property->GetOption().second+1);
		HandlePropertyChange();
	}
}

void PropertyTool::OpenWindow(Simulation *sim, std::optional<int> takePropertyFrom)
{
	new PropertyWindow(this, sim, takePropertyFrom);
}

void PropertyTool::SetProperty(Simulation *sim, ui::Point position)
{
	if(position.X<0 || position.X>XRES || position.Y<0 || position.Y>YRES || !configuration)
		return;
	int i = sim->pmap[position.Y][position.X];
	if(!i)
		i = sim->photons[position.Y][position.X];
	if(!i)
		return;
	configuration->changeProperty.Set(sim, ID(i));
}

void PropertyTool::Draw(Simulation *sim, Brush const &cBrush, ui::Point position)
{
	for (ui::Point off : cBrush)
	{
		ui::Point coords = position + off;
		if (coords.X >= 0 && coords.Y >= 0 && coords.X < XRES && coords.Y < YRES)
			SetProperty(sim, coords);
	}
}

void PropertyTool::DrawLine(Simulation *sim, Brush const &cBrush, ui::Point position, ui::Point position2, bool dragging)
{
	int x1 = position.X, y1 = position.Y, x2 = position2.X, y2 = position2.Y;
	bool reverseXY = abs(y2-y1) > abs(x2-x1);
	int x, y, dx, dy, sy, rx = cBrush.GetRadius().X, ry = cBrush.GetRadius().Y;
	float e = 0.0f, de;
	if (reverseXY)
	{
		y = x1;
		x1 = y1;
		y1 = y;
		y = x2;
		x2 = y2;
		y2 = y;
	}
	if (x1 > x2)
	{
		y = x1;
		x1 = x2;
		x2 = y;
		y = y1;
		y1 = y2;
		y2 = y;
	}
	dx = x2 - x1;
	dy = abs(y2 - y1);
	if (dx)
		de = dy/(float)dx;
	else
		de = 0.0f;
	y = y1;
	sy = (y1<y2) ? 1 : -1;
	for (x=x1; x<=x2; x++)
	{
		if (reverseXY)
			Draw(sim, cBrush, ui::Point(y, x));
		else
			Draw(sim, cBrush, ui::Point(x, y));
		e += de;
		if (e >= 0.5f)
		{
			y += sy;
			if (!(rx+ry) && ((y1<y2) ? (y<=y2) : (y>=y2)))
			{
				if (reverseXY)
					Draw(sim, cBrush, ui::Point(y, x));
				else
					Draw(sim, cBrush, ui::Point(x, y));
			}
			e -= 1.0f;
		}
	}
}

void PropertyTool::DrawRect(Simulation *sim, Brush const &cBrush, ui::Point position, ui::Point position2)
{
	int x1 = position.X, y1 = position.Y, x2 = position2.X, y2 = position2.Y;
	int i, j;
	if (x1>x2)
	{
		i = x2;
		x2 = x1;
		x1 = i;
	}
	if (y1>y2)
	{
		j = y2;
		y2 = y1;
		y1 = j;
	}
	for (j=y1; j<=y2; j++)
		for (i=x1; i<=x2; i++)
			SetProperty(sim, ui::Point(i, j));
}

void PropertyTool::DrawFill(Simulation *sim, Brush const &cBrush, ui::Point position)
{
	if (configuration)
		sim->flood_prop(position.X, position.Y, configuration->changeProperty);
}

void PropertyTool::Select(int toolSelection)
{
	OpenWindow(gameModel.GetSimulation(), std::nullopt);
}


=== src\gui\game\tool\PropertyTool.h ===

#pragma once
#include "simulation/AccessProperty.h"
#include "Tool.h"
#include <optional>

class GameModel;

class PropertyTool: public Tool
{
public:
	struct Configuration
	{
		AccessProperty changeProperty;
		String propertyValueStr;
	};

private:
	void SetProperty(Simulation *sim, ui::Point position);
	void SetConfiguration(std::optional<Configuration> newConfiguration);

	GameModel &gameModel;
	std::optional<Configuration> configuration;

	friend class PropertyWindow;

public:
	PropertyTool(GameModel &newGameModel):
		Tool(0, "PROP", "Property Drawing Tool. Use to alter the properties of elements in the field.",
			0xFEA900_rgb, "DEFAULT_UI_PROPERTY", NULL
		), gameModel(newGameModel)
	{}

	void OpenWindow(Simulation *sim, std::optional<int> takePropertyFrom);
	void Click(Simulation * sim, Brush const &brush, ui::Point position) override { }
	void Draw(Simulation *sim, Brush const &brush, ui::Point position) override;
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override;
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override;
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override;

	std::optional<Configuration> GetConfiguration() const
	{
		return configuration;
	}

	void Select(int toolSelection) final override;
};


=== src\gui\game\tool\SampleTool.cpp ===

#include "SampleTool.h"
#include "PropertyTool.h"
#include "GOLTool.h"
#include "graphics/Graphics.h"
#include "graphics/Renderer.h"
#include "gui/game/GameModel.h"
#include "gui/game/GameView.h"
#include "gui/interface/Colour.h"
#include "simulation/Simulation.h"
#include "simulation/ElementClasses.h"
#include "gui/game/Menu.h"

std::unique_ptr<VideoBuffer> SampleTool::GetIcon(int toolID, Vec2<int> size)
{
	auto texture = std::make_unique<VideoBuffer>(size);
	texture->DrawRect(size.OriginRect(), 0xA0A0A0_rgb);
	texture->BlendChar((size / 2) - Vec2(5, 5), 0xE066, 0xFFFFFF_rgb .WithAlpha(0xFF));
	texture->BlendChar((size / 2) - Vec2(5, 5), 0xE06B, 0x64B4FF_rgb .WithAlpha(0xFF));
	return texture;
}

void SampleTool::Draw(Simulation * sim, Brush const &brush, ui::Point position)
{
	if(gameModel.GetColourSelectorVisibility())
	{
		pixel colour = gameModel.GetView()->GetPixelUnderMouse();
		gameModel.SetColourSelectorColour(RGB::Unpack(colour).WithAlpha(0xFF));
	}
	else
	{
		int i = -1;
		if (sim->photons[position.Y][position.X])
		{
			i = ID(sim->photons[position.Y][position.X]);
		}
		else if (sim->pmap[position.Y][position.X])
		{
			i = ID(sim->pmap[position.Y][position.X]);
		}
		if (i != -1)
		{
			auto *part = &sim->parts[i];
			if (shiftBehaviour)
			{
				auto *propTool = static_cast<PropertyTool *>(gameModel.GetToolFromIdentifier("DEFAULT_UI_PROPERTY"));
				gameModel.SetActiveTool(0, propTool);
				propTool->OpenWindow(gameModel.GetSimulation(), i);
			}
			else if (part->type == PT_LIFE)
			{
				bool found = false;
				for (auto *elementTool : gameModel.GetMenuList()[SC_LIFE]->GetToolList())
				{
					if (elementTool && ID(elementTool->ToolID) == part->ctype)
					{
						gameModel.SetActiveTool(0, elementTool);
						found = true;
						break;
					}
				}
				if (!found)
				{
					static_cast<GOLTool *>(gameModel.GetToolFromIdentifier("DEFAULT_UI_ADDLIFE"))->OpenWindow(gameModel.GetSimulation(), 0, part->ctype, RGB::Unpack(part->dcolour & 0xFFFFFF), RGB::Unpack(part->tmp & 0xFFFFFF));
				}
			}
			else
			{
				auto &sd = SimulationData::Ref();
				auto &elements = sd.elements;
				gameModel.SetActiveTool(0, gameModel.GetToolFromIdentifier(elements[part->type].Identifier));
			}
		}
	}
}


=== src\gui\game\tool\SampleTool.h ===

#pragma once
#include "Tool.h"

class GameModel;

class SampleTool: public Tool
{
	GameModel &gameModel;

public:
	SampleTool(GameModel &model):
		Tool(0, "SMPL", "Sample an element on the screen.",
			0x000000_rgb, "DEFAULT_UI_SAMPLE", SampleTool::GetIcon
		),
		gameModel(model)
	{}

	static std::unique_ptr<VideoBuffer> GetIcon(int toolID, Vec2<int> size);
	void Click(Simulation * sim, Brush const &brush, ui::Point position) override { }
	void Draw(Simulation * sim, Brush const &brush, ui::Point position) override;
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override { }
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override { }
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override { }
};


=== src\gui\game\tool\SignTool.cpp ===

#include "SignTool.h"
#include "simulation/Simulation.h"
#include "gui/Style.h"
#include "gui/interface/Window.h"
#include "gui/interface/Button.h"
#include "gui/interface/Label.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/DropDown.h"
#include "gui/game/GameModel.h"
#include "graphics/Graphics.h"

class SignWindow: public ui::Window
{
public:
	ui::DropDown * justification;
	ui::Textbox * textField;
	SignTool * tool;
	sign * movingSign;
	bool signMoving;
	Simulation * sim;
	int signID;
	ui::Point signPosition;
	SignWindow(SignTool * tool_, Simulation * sim_, int signID_, ui::Point position_);
	void OnDraw() override;
	void DoDraw() override;
	void DoMouseMove(int x, int y, int dx, int dy) override;
	void DoMouseDown(int x, int y, unsigned button) override;
	void DoMouseUp(int x, int y, unsigned button) override
	{
		if(!signMoving)
			ui::Window::DoMouseUp(x, y, button);
	}
	void DoMouseWheel(int x, int y, int d) override
	{
		if(!signMoving)
			ui::Window::DoMouseWheel(x, y, d);
	}
	void DoKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override
	{
		if(!signMoving)
			ui::Window::DoKeyPress(key, scan, repeat, shift, ctrl, alt);
	}
	void DoKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override
	{
		if(!signMoving)
			ui::Window::DoKeyRelease(key, scan, repeat, shift, ctrl, alt);
	}
	virtual ~SignWindow() {}
	void OnTryExit(ui::Window::ExitMethod method) override;
};

SignWindow::SignWindow(SignTool * tool_, Simulation * sim_, int signID_, ui::Point position_):
	ui::Window(ui::Point(-1, -1), ui::Point(250, 87)),
	tool(tool_),
	movingSign(nullptr),
	signMoving(false),
	sim(sim_),
	signID(signID_),
	signPosition(position_)
{
	ui::Label * messageLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 15), "New sign");
	messageLabel->SetTextColour(style::Colour::InformationTitle);
	messageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	messageLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(messageLabel);

	ui::Button * okayButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point(Size.X, 16), "OK");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.BorderInactive = (ui::Colour(200, 200, 200));
	okayButton->SetActionCallback({ [this] {
		CloseActiveWindow();
		if(signID==-1 && textField->GetText().length())
		{
			sim->signs.push_back(sign(textField->GetText(), signPosition.X, signPosition.Y, (sign::Justification)justification->GetOption().second));
		}
		else if(signID!=-1 && textField->GetText().length())
		{
			sim->signs[signID] = sign(sign(textField->GetText(), signPosition.X, signPosition.Y, (sign::Justification)justification->GetOption().second));
		}
		SelfDestruct();
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);

	ui::Label * tempLabel = new ui::Label(ui::Point(8, 48), ui::Point(40, 15), "Pointer:");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(tempLabel);

	justification = new ui::DropDown(ui::Point(52, 48), ui::Point(55, 16));
	AddComponent(justification);
	justification->AddOption(std::pair<String, int>(0xE020 + String(" Left"), (int)sign::Left));
	justification->AddOption(std::pair<String, int>(0xE01E + String(" Middle"), (int)sign::Middle));
	justification->AddOption(std::pair<String, int>(0xE01F + String(" Right"), (int)sign::Right));
	justification->AddOption(std::pair<String, int>(0xE01D + String(" None"), (int)sign::None));
	justification->SetOption(1);
	justification->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;

	textField = new ui::Textbox(ui::Point(8, 25), ui::Point(Size.X-16, 17), "", "[message]");
	textField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	textField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	textField->SetLimit(45);
	textField->SetActionCallback({ [this] {
		if (signID!=-1)
		{
			sim->signs[signID].text = textField->GetText();
			sim->signs[signID].ju = (sign::Justification)justification->GetOption().second;
		}
	} });
	AddComponent(textField);
	FocusComponent(textField);

	if(signID!=-1)
	{
		messageLabel->SetText("Edit sign");

		textField->SetText(sim->signs[signID].text);
		justification->SetOption(sim->signs[signID].ju);

		ui::Point position = ui::Point(justification->Position.X+justification->Size.X+3, 48);
		ui::Button * moveButton = new ui::Button(position, ui::Point(((Size.X-position.X-8)/2)-2, 16), "Move");
		moveButton->SetActionCallback({ [this] {
			if (signID!=-1)
			{
				movingSign = &sim->signs[signID];
				sim->signs[signID].ju = (sign::Justification)justification->GetOption().second;
				signMoving = true;
			}
		} });
		AddComponent(moveButton);

		position = ui::Point(justification->Position.X+justification->Size.X+3, 48)+ui::Point(moveButton->Size.X+3, 0);
		ui::Button * deleteButton = new ui::Button(position, ui::Point((Size.X-position.X-8)-1, 16), "Delete");
		//deleteButton->SetIcon(IconDelete);
		deleteButton->SetActionCallback({ [this] {
			CloseActiveWindow();
			if (signID!=-1)
			{
				sim->signs.erase(sim->signs.begin() + signID);
			}
			SelfDestruct();
		} });

		signPosition.X = sim->signs[signID].x;
		signPosition.Y = sim->signs[signID].y;

		AddComponent(deleteButton);
	}

	MakeActiveWindow();
}

void SignWindow::OnTryExit(ui::Window::ExitMethod method)
{
	CloseActiveWindow();
	SelfDestruct();
}

void SignWindow::DoDraw()
{
	for (auto &currentSign : sim->signs)
	{
		int x, y, w, h, dx, dy;
		Graphics * g = GetGraphics();

		String text = currentSign.getDisplayText(sim, x, y, w, h);
		g->DrawFilledRect(RectSized(Vec2{ x + 1, y + 1 }, Vec2{ w, h - 1 }), 0x000000_rgb);
		g->DrawRect(RectSized(Vec2{ x, y }, Vec2{ w+1, h }), 0xC0C0C0_rgb);
		g->BlendText({ x+3, y+4 }, text, 0xFFFFFF_rgb .WithAlpha(255));

		if (currentSign.ju != sign::None)
		{
			x = currentSign.x;
			y = currentSign.y;
			dx = 1 - currentSign.ju;
			dy = (currentSign.y > 18) ? -1 : 1;
			for (int j=0; j<4; j++)
			{
				g->DrawPixel({ x, y }, 0xC0C0C0_rgb);
				x+=dx;
				y+=dy;
			}
		}
	}
	if(!signMoving)
	{
		ui::Window::DoDraw();
	}
}

void SignWindow::DoMouseMove(int x, int y, int dx, int dy) {
	if(!signMoving)
		ui::Window::DoMouseMove(x, y, dx, dy);
	else
	{
		ui::Point pos = tool->gameModel.AdjustZoomCoords(ui::Point(x, y));
		if(pos.X < XRES && pos.Y < YRES)
		{
			movingSign->x = pos.X;
			movingSign->y = pos.Y;
			signPosition.X = pos.X;
			signPosition.Y = pos.Y;
		}
	}
}

void SignWindow::DoMouseDown(int x, int y, unsigned button)
{
	if(!signMoving)
		ui::Window::DoMouseDown(x, y, button);
	else
	{
		signMoving = false;
	}
}

void SignWindow::OnDraw()
{
	Graphics * g = GetGraphics();

	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);
}

std::unique_ptr<VideoBuffer> SignTool::GetIcon(int toolID, Vec2<int> size)
{
	auto texture = std::make_unique<VideoBuffer>(size);
	texture->DrawRect(size.OriginRect(), 0xA0A0A0_rgb);
	texture->BlendChar((size / 2) - Vec2(5, 5), 0xE021, 0x204080_rgb .WithAlpha(0xFF));
	texture->BlendChar((size / 2) - Vec2(5, 5), 0xE020, 0xFFFFFF_rgb .WithAlpha(0xFF));
	return texture;
}

void SignTool::Click(Simulation * sim, Brush const &brush, ui::Point position)
{
	int signX, signY, signW, signH, signIndex = -1;
	for (size_t i = 0; i < sim->signs.size(); i++)
	{
		sim->signs[i].getDisplayText(sim, signX, signY, signW, signH);
		if (position.X > signX && position.X < signX+signW && position.Y > signY && position.Y < signY+signH)
		{
			signIndex = i;
			break;
		}
	}
	if (signIndex != -1 || sim->signs.size() < MAXSIGNS)
		new SignWindow(this, sim, signIndex, position);
}


=== src\gui\game\tool\SignTool.h ===

#pragma once
#include "Tool.h"

class GameModel;

class SignTool: public Tool
{
	GameModel &gameModel;

	friend class SignWindow;

public:
	SignTool(GameModel &model):
		Tool(0, "SIGN", "Sign. Displays text. Click on a sign to edit it or anywhere else to place a new one.",
			0x000000_rgb, "DEFAULT_UI_SIGN", SignTool::GetIcon
		),
		gameModel(model)
	{}

	static std::unique_ptr<VideoBuffer> GetIcon(int toolID, Vec2<int> size);
	void Click(Simulation * sim, Brush const &brush, ui::Point position) override;
	void Draw(Simulation * sim, Brush const &brush, ui::Point position) override { }
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override { }
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override { }
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override { }
};


=== src\gui\game\tool\Tool.cpp ===

#include "Tool.h"

std::unique_ptr<VideoBuffer> Tool::GetTexture(Vec2<int> size)
{
	return textureGen ? textureGen(ToolID, size) : nullptr;
}

void Tool::Click(Simulation * sim, Brush const &brush, ui::Point position) { }
void Tool::Draw(Simulation * sim, Brush const &brush, ui::Point position) {}
void Tool::DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) {}
void Tool::DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) {}
void Tool::DrawFill(Simulation * sim, Brush const &brush, ui::Point position) {}


=== src\gui\game\tool\Tool.h ===

#pragma once
#include "common/String.h"
#include "common/Vec2.h"
#include "graphics/Pixel.h"
#include "graphics/VideoBuffer.h"
#include "gui/interface/Point.h"
#include "simulation/StructProperty.h"
#include "simulation/MenuSection.h"
#include <memory>
#include <optional>

class Simulation;
class Brush;
struct Particle;

class Tool
{
public:
	std::unique_ptr<VideoBuffer> (*textureGen)(int, Vec2<int>) = nullptr;

	int ToolID = 0;
	String Name = "NULL";
	String Description = "NULL Tool, does NOTHING";
	ByteString Identifier = "DEFAULT_TOOL_INVALID";
	RGB Colour = 0xFFFFFF_rgb;
	bool Blocky = false;
	float Strength = 1.0f;
	bool shiftBehaviour = false;
	bool ctrlBehaviour = false;
	bool altBehaviour = false;
	int MenuSection = SC_TOOL;
	bool MenuVisible = true;

	Tool() = default;

	Tool(int id, String name, String description,
		RGB colour, ByteString identifier, std::unique_ptr<VideoBuffer> (*textureGen)(int, Vec2<int>) = NULL, bool blocky = false
	):
		textureGen(textureGen),
		ToolID(id),
		Name(name),
		Description(description),
		Identifier(identifier),
		Colour(colour),
		Blocky(blocky)
	{}

	Tool(int id, ByteString identifier) : ToolID(id), Identifier(identifier)
	{}

	virtual ~Tool()
	{}

	std::unique_ptr<VideoBuffer> GetTexture(Vec2<int>);
	virtual void Click(Simulation * sim, Brush const &brush, ui::Point position);
	virtual void Draw(Simulation * sim, Brush const &brush, ui::Point position);
	virtual void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging);
	virtual void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2);
	virtual void DrawFill(Simulation * sim, Brush const &brush, ui::Point position);

	virtual void Drag(Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2)
	{
	}

	virtual void Select(int toolSelection)
	{
	}
};


=== src\gui\game\tool\WallTool.cpp ===

#include "WallTool.h"
#include "simulation/Simulation.h"
#include "simulation/SimulationData.h"

void WallTool::Draw(Simulation * sim, Brush const &brush, ui::Point position) {
	sim->CreateWalls(position.X, position.Y, 1, 1, ToolID, &brush);
}
void WallTool::DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) {
	int wallX = position1.X/CELL;
	int wallY = position1.Y/CELL;
	if(dragging == false && ToolID == WL_FAN && sim->bmap[wallY][wallX]==WL_FAN)
	{
		float newFanVelX = (position2.X-position1.X)*0.005f;
		newFanVelX *= Strength;
		float newFanVelY = (position2.Y-position1.Y)*0.005f;
		newFanVelY *= Strength;
		sim->FloodWalls(position1.X, position1.Y, WL_FLOODHELPER, WL_FAN);
		for (int j = 0; j < YCELLS; j++)
			for (int i = 0; i < XCELLS; i++)
				if (sim->bmap[j][i] == WL_FLOODHELPER)
				{
					sim->fvx[j][i] = newFanVelX;
					sim->fvy[j][i] = newFanVelY;
					sim->bmap[j][i] = WL_FAN;
				}
	}
	else
	{
		sim->CreateWallLine(position1.X, position1.Y, position2.X, position2.Y, 1, 1, ToolID, &brush);
	}
}
void WallTool::DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) {
	sim->CreateWallBox(position1.X, position1.Y, position2.X, position2.Y, ToolID);
}
void WallTool::DrawFill(Simulation * sim, Brush const &brush, ui::Point position) {
	if (ToolID != WL_STREAM)
		sim->FloodWalls(position.X, position.Y, ToolID, -1);
}


=== src\gui\game\tool\WallTool.h ===

#pragma once
#include "Tool.h"

class WallTool: public Tool
{
public:
	WallTool(int id, String description,
		RGB colour, ByteString identifier, std::unique_ptr<VideoBuffer> (*textureGen)(int, Vec2<int>) = NULL):
		Tool(id, "", description, colour, identifier, textureGen, true)
	{
	}

	void Draw(Simulation * sim, Brush const &brush, ui::Point position) override;
	void DrawLine(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging) override;
	void DrawRect(Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2) override;
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override;
};


=== src\gui\interface\Appearance.cpp ===

#include "Appearance.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include <iostream>

namespace ui
{
	Appearance::Appearance():
		texture(nullptr),

		VerticalAlign(AlignMiddle),
		HorizontalAlign(AlignCentre),

		BackgroundHover(0x141414_rgb .WithAlpha(0xFF)),
		BackgroundInactive(0x000000_rgb .WithAlpha(0xFF)),
		BackgroundActive(0xFFFFFF_rgb .WithAlpha(0xFF)),
		BackgroundDisabled(0x0A0A0A_rgb .WithAlpha(0xFF)),

		TextHover(0xFFFFFF_rgb .WithAlpha(0xFF)),
		TextInactive(0xFFFFFF_rgb .WithAlpha(0xFF)),
		TextActive(0x000000_rgb .WithAlpha(0xFF)),
		TextDisabled(0x646464_rgb .WithAlpha(0xFF)),

		BorderHover(0xFFFFFF_rgb .WithAlpha(0xFF)),
		BorderInactive(0xC8C8C8_rgb .WithAlpha(0xFF)),
		BorderActive(0xEBEBEB_rgb .WithAlpha(0xFF)),
		BorderFavorite(0xFFFF00_rgb .WithAlpha(0xFF)),
		BorderDisabled(0x646464_rgb .WithAlpha(0xFF)),

		Margin(1, 4),
		Border(1),

		icon(NoIcon)
	{}

	VideoBuffer const *Appearance::GetTexture()
	{
		return texture.get();
	}

	void Appearance::SetTexture(std::unique_ptr<VideoBuffer> texture)
	{
		this->texture = std::move(texture);
	}
}


=== src\gui\interface\Appearance.h ===

#pragma once
#include <memory>
#include "Border.h"
#include "Colour.h"
#include "graphics/Icons.h"

class VideoBuffer;
namespace ui
{
	class Appearance
	{
	private:
		std::shared_ptr<VideoBuffer> texture;

	public:
		enum HorizontalAlignment
		{
			AlignLeft, AlignCentre, AlignRight
		};

		enum VerticalAlignment
		{
			AlignTop, AlignMiddle, AlignBottom
		};

		VerticalAlignment VerticalAlign;
		HorizontalAlignment HorizontalAlign;

		ui::Colour BackgroundHover;
		ui::Colour BackgroundInactive;
		ui::Colour BackgroundActive;
		ui::Colour BackgroundDisabled;
		bool BackgroundPulse = false;

		ui::Colour TextHover;
		ui::Colour TextInactive;
		ui::Colour TextActive;
		ui::Colour TextDisabled;

		ui::Colour BorderHover;
		ui::Colour BorderInactive;
		ui::Colour BorderActive;
		ui::Colour BorderFavorite;
		ui::Colour BorderDisabled;

		ui::Border Margin;

		ui::Border Border;

		Icon icon;

		VideoBuffer const *GetTexture();
		void SetTexture(std::unique_ptr<VideoBuffer> texture);

		Appearance();
	};
}


=== src\gui\interface\AvatarButton.cpp ===

#include "Button.h"
#include "AvatarButton.h"
#include "Format.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include "ContextMenu.h"
#include "Config.h"
#include <iostream>
#include <SDL.h>

namespace ui {

AvatarButton::AvatarButton(Point position, Point size, ByteString username, int avatarSize):
	Component(position, size),
	name(username),
	avatarSize(avatarSize),
	tried(false)
{

}

void AvatarButton::Tick()
{
	if (!avatar && !tried && name.size() > 0)
	{
		tried = true;
		ByteStringBuilder urlBuilder;
		urlBuilder << STATICSERVER << "/avatars/" << name;
		if (avatarSize)
		{
			urlBuilder << "." << avatarSize;
		}
		urlBuilder << ".png";
		imageRequest = std::make_unique<http::ImageRequest>(urlBuilder.Build(), Size);
		imageRequest->Start();
	}

	if (imageRequest && imageRequest->CheckDone())
	{
		try
		{
			avatar = imageRequest->Finish();
		}
		catch (const http::RequestError &ex)
		{
			// Nothing, oh well.
		}
		imageRequest.reset();
	}
}

void AvatarButton::Draw(const Point& screenPos)
{
	Graphics * g = GetGraphics();

	if (avatar)
	{
		auto *tex = avatar.get();
		g->BlendImage(tex->Data(), 255, RectSized(screenPos, tex->Size()));
	}
}

void AvatarButton::OnMouseClick(int x, int y, unsigned int button)
{
	if(button != 1)
	{
		return; //left click only!
	}

	if(isButtonDown)
	{
		isButtonDown = false;
		DoAction();
	}
}

void AvatarButton::OnContextMenuAction(int item)
{
	//Do nothing
}

void AvatarButton::OnMouseDown(int x, int y, unsigned int button)
{
	if (MouseDownInside)
	{
		if(button == SDL_BUTTON_RIGHT)
		{
			if(menu)
				menu->Show(GetContainerPos() + ui::Point(x, y));
		}
		else
		{
			isButtonDown = true;
		}
	}
}

void AvatarButton::OnMouseEnter(int x, int y)
{
	isMouseInside = true;
}

void AvatarButton::OnMouseLeave(int x, int y)
{
	isMouseInside = false;
}

void AvatarButton::DoAction()
{
	if( actionCallback.action)
		actionCallback.action();
}

} /* namespace ui */


=== src\gui\interface\AvatarButton.h ===

#pragma once
#include "common/String.h"

#include "Component.h"
#include "graphics/Graphics.h"
#include "client/http/ImageRequest.h"

#include <memory>
#include <functional>

namespace ui
{
class AvatarButton : public Component
{
	std::unique_ptr<VideoBuffer> avatar;
	ByteString name;
	int avatarSize;
	bool tried;

	struct AvatarButtonAction
	{
		std::function<void ()> action;
	};
	AvatarButtonAction actionCallback;

	std::unique_ptr<http::ImageRequest> imageRequest;

public:
	AvatarButton(Point position, Point size, ByteString username, int avatarSize = 0);
	virtual ~AvatarButton() = default;

	void OnMouseClick(int x, int y, unsigned int button) override;
	void OnMouseDown(int x, int y, unsigned int button) override;

	void OnMouseEnter(int x, int y) override;
	void OnMouseLeave(int x, int y) override;

	void OnContextMenuAction(int item) override;

	void Draw(const Point& screenPos) override;
	void Tick() override;

	void DoAction();

	void SetUsername(ByteString username) { name = username; }
	ByteString GetUsername() { return name; }
	inline void SetActionCallback(AvatarButtonAction const &action) { actionCallback = action; };
protected:
	bool isMouseInside = false, isButtonDown = false;
};
}


=== src\gui\interface\Border.h ===

#pragma once

namespace ui
{

	struct Border
	{
		using BORDER_T = int;

		BORDER_T Top;
		BORDER_T Right;
		BORDER_T Bottom;
		BORDER_T Left;

		Border(BORDER_T all):
		Top(all),
		Right(all),
		Bottom(all),
		Left(all)
		{
		}

		Border(BORDER_T v, BORDER_T h):
		Top(v),
		Right(h),
		Bottom(v),
		Left(h)
		{
		}

		Border(BORDER_T top, BORDER_T right, BORDER_T bottom, BORDER_T left):
		Top(top),
		Right(right),
		Bottom(bottom),
		Left(left)
		{
		}

		inline bool operator == (const int& v) const
		{
			return (Top == v && Right == v && Bottom == v && Left == v);
		}

		inline bool operator == (const Border& v) const
		{
			return (Top == v.Top && Right == v.Right && Bottom == v.Bottom && Left == v.Left);
		}

		inline bool operator != (const Border& v) const
		{
			return (Top != v.Top || Right != v.Right || Bottom != v.Bottom || Left != v.Left);
		}

		inline void operator = (const Border& v)
		{
			Top = v.Top;
			Right = v.Right;
			Bottom = v.Bottom;
			Left = v.Left;
		}

	};

}


=== src\gui\interface\Button.cpp ===

#include "gui/interface/Button.h"
#include "gui/interface/Window.h"
#include "gui/interface/Engine.h"
#include "graphics/Graphics.h"
#include "Misc.h"
#include "Colour.h"
#include <cmath>
#include <numbers>

namespace ui {

Button::Button(Point position, Point size, String buttonText, String toolTip):
	Component(position, size),
	ButtonText(buttonText),
	toolTip(toolTip),
	isButtonDown(false),
	isMouseInside(false),
	isTogglable(false),
	toggle(false)
{
	TextPosition(ButtonText);
}

void Button::TextPosition(String ButtonText)
{
	buttonDisplayText = ButtonText;
	if(buttonDisplayText.length())
	{
		if (Graphics::TextSize(buttonDisplayText).X - 1 > Size.X - (Appearance.icon ? 22 : 0))
		{
			auto it = Graphics::TextFit(buttonDisplayText, Size.X - (Appearance.icon ? 38 : 22));
			buttonDisplayText.erase(it, buttonDisplayText.end());
			buttonDisplayText += "...";
		}
	}

	Component::TextPosition(buttonDisplayText);
}

void Button::SetIcon(Icon icon)
{
	Appearance.icon = icon;
	TextPosition(ButtonText);
}

void Button::SetText(String buttonText)
{
	ButtonText = buttonText;
	TextPosition(ButtonText);
}

void Button::SetTogglable(bool togglable)
{
	toggle = false;
	isTogglable = togglable;
}

bool Button::GetTogglable()
{
	return isTogglable;
}

bool Button::GetToggleState()
{
	return toggle;
}

void Button::SetToggleState(bool state)
{
	toggle = state;
}

void Button::Draw(const Point& screenPos)
{
	if(!drawn)
	{
		TextPosition(ButtonText);
		drawn = true;
	}
	Graphics * g = GetGraphics();
	Point Position = screenPos;
	ui::Colour bgColour(0, 0, 0);

	ui::Colour textColour = Appearance.TextInactive;
	ui::Colour borderColour = Appearance.BorderInactive;
	ui::Colour backgroundColour = Appearance.BackgroundInactive;

	if (Enabled)
	{
		if ((isButtonDown && MouseDownInside) || (isTogglable && toggle))
		{
			textColour = Appearance.TextActive;
			borderColour = Appearance.BorderActive;
			backgroundColour = Appearance.BackgroundActive;
		}
		else if (isMouseInside)
		{
			textColour = Appearance.TextHover;
			borderColour = Appearance.BorderHover;
			backgroundColour = Appearance.BackgroundHover;
		}
		else
		{
			textColour = Appearance.TextInactive;
			borderColour = Appearance.BorderInactive;
			backgroundColour = Appearance.BackgroundInactive;
		}
	}
	else
	{
		textColour = Appearance.TextDisabled;
		borderColour = Appearance.BorderDisabled;
		backgroundColour = Appearance.BackgroundDisabled;
	}

	bgColour = Appearance.BackgroundInactive;
	if (Appearance.BackgroundPulse)
	{
		backgroundColour.Alpha = uint8_t(backgroundColour.Alpha * ((std::sin(Engine::Ref().LastTick() / 1000 * std::numbers::pi * 2) + 1) / 2));
	}
	g->BlendFilledRect(RectSized(Position + Vec2{ 1, 1 }, Size - Vec2{ 2, 2 }), backgroundColour);
	if(Appearance.Border == 1)
		g->BlendRect(RectSized(Position, Size), borderColour);
	else
	{
		if(Appearance.Border.Top)
			g->BlendLine(Position + Vec2{       0 ,        0 }, Position + Vec2{ Size.X-1,        0 }, borderColour);
		if(Appearance.Border.Bottom)
			g->BlendLine(Position + Vec2{       0 , Size.Y-1 }, Position + Vec2{ Size.X-1, Size.Y-1 }, borderColour);
		if(Appearance.Border.Left)
			g->BlendLine(Position + Vec2{       0 ,        0 }, Position + Vec2{        0, Size.Y-1 }, borderColour);
		if(Appearance.Border.Right)
			g->BlendLine(Position + Vec2{ Size.X-1,        0 }, Position + Vec2{ Size.X-1, Size.Y-1 }, borderColour);
	}
	g->BlendText(Position + textPosition, buttonDisplayText, textColour);

	bool iconInvert = (backgroundColour.Blue + (3*backgroundColour.Green) + (2*backgroundColour.Red))>544?true:false;

	if(Appearance.icon)
	{
		if(Enabled)
			g->draw_icon(Position.X+iconPosition.X, Position.Y+iconPosition.Y, Appearance.icon, 255, iconInvert);
		else
			g->draw_icon(Position.X+iconPosition.X, Position.Y+iconPosition.Y, Appearance.icon, 180, iconInvert);
	}
}

void Button::OnMouseClick(int x, int y, unsigned int button)
{
	if(button == 1)
	{
		if(isButtonDown)
		{
			if(isTogglable)
			{
				toggle = !toggle;
			}
			isButtonDown = false;
			DoAction();
		}
	}
	else if(button == 3)
	{
		if(isAltButtonDown)
		{
			isAltButtonDown = false;
			DoAltAction();
		}
	}
}

void Button::OnMouseUp(int x, int y, unsigned int button)
{
	// mouse was unclicked, reset variables in case the unclick happened outside
	isButtonDown = false;
	isAltButtonDown = false;
}

void Button::OnMouseDown(int x, int y, unsigned int button)
{
	if (MouseDownInside)
	{
		if(!Enabled)
			return;
		if(button == 1)
		{
			isButtonDown = true;
		}
		else if(button == 3)
		{
			isAltButtonDown = true;
		}
	}
}

void Button::OnMouseEnter(int x, int y)
{
	isMouseInside = true;
	if(!Enabled)
		return;
	if (actionCallback.mouseEnter)
		actionCallback.mouseEnter();
}

void Button::OnMouseHover(int x, int y)
{
	if(Enabled && toolTip.length()>0 && GetParentWindow())
	{
		GetParentWindow()->ToolTip(Position, toolTip);
	}
}

void Button::OnMouseLeave(int x, int y)
{
	isMouseInside = false;
	isButtonDown = false;
}

void Button::DoAction()
{
	if(!Enabled)
		return;
	if (actionCallback.action)
		actionCallback.action();
}

void Button::DoAltAction()
{
	if(!Enabled)
		return;
	if (actionCallback.altAction)
		actionCallback.altAction();
}

} /* namespace ui */


=== src\gui\interface\Button.h ===

#pragma once
#include "common/String.h"
#include "Component.h"
#include <functional>

namespace ui
{

class Button : public Component
{
	struct ButtonAction
	{
		std::function<void ()> action, altAction, mouseEnter;
	};
	
public:
	Button(Point position = Point(0, 0), Point size = Point(0, 0), String buttonText = String(), String toolTip = String());
	virtual ~Button() = default;

	void OnMouseClick(int x, int y, unsigned int button) override;
	void OnMouseDown(int x, int y, unsigned int button) override;
	void OnMouseUp(int x, int y, unsigned int button) override;

	void OnMouseEnter(int x, int y) override;
	void OnMouseHover(int x, int y) override;
	void OnMouseLeave(int x, int y) override;

	void Draw(const Point& screenPos) override;

	void TextPosition(String) override;
	inline bool GetState() { return state; }
	void DoAction(); //action of button what ever it may be
	void DoAltAction(); //action of button what ever it may be
	void SetTogglable(bool isTogglable);
	bool GetTogglable();
	bool GetToggleState();
	void SetToggleState(bool state);
	inline void SetActionCallback(ButtonAction const &action) { actionCallback = action; }
	// inline ButtonAction const &GetActionCallback() const { return actionCallback; }
	void SetText(String buttonText);
	void SetIcon(Icon icon);
	inline String GetText() { return ButtonText; }
	void SetToolTip(String newToolTip) { toolTip = newToolTip; }

protected:
	String ButtonText;
	String toolTip;
	String buttonDisplayText;

	bool isButtonDown, isAltButtonDown, state, isMouseInside, isTogglable, toggle;
	ButtonAction actionCallback;
};
}


=== src\gui\interface\Checkbox.cpp ===

#include "Checkbox.h"

#include "graphics/Graphics.h"

#include "gui/interface/Window.h"

using namespace ui;

Checkbox::Checkbox(ui::Point position, ui::Point size, String text, String toolTip):
	Component(position, size),
	text(text),
	toolTip(toolTip),
	checked(false),
	isMouseOver(false)
{

}

void Checkbox::SetText(String text)
{
	this->text = text;
}

String Checkbox::GetText()
{
	return text;
}

void Checkbox::SetIcon(Icon icon)
{
	Appearance.icon = icon;
	iconPosition.X = 16;
	iconPosition.Y = 3;
}

void Checkbox::OnMouseClick(int x, int y, unsigned int button)
{
	if(checked)
	{
		checked = false;
	}
	else
	{
		checked = true;
	}
	if (actionCallback.action)
		actionCallback.action();
}

void Checkbox::OnMouseUp(int x, int y, unsigned int button)
{

}


void Checkbox::OnMouseEnter(int x, int y)
{
	isMouseOver = true;
}

void Checkbox::OnMouseHover(int x, int y)
{
	if(toolTip.length()>0 && GetParentWindow())
	{
		GetParentWindow()->ToolTip(Position, toolTip);
	}
}

void Checkbox::OnMouseLeave(int x, int y)
{
	isMouseOver = false;
}

void Checkbox::Draw(const Point& screenPos)
{
	Graphics * g = GetGraphics();
	if(checked)
	{
		g->DrawFilledRect(RectSized(screenPos + Vec2{ 5, 5 }, Vec2{ 6, 6 }), 0xFFFFFF_rgb);
	}
	if(isMouseOver)
	{
		g->DrawRect(RectSized(screenPos + Vec2{ 2, 2 }, Vec2{ 12, 12 }), 0xFFFFFF_rgb);
		g->BlendFilledRect(RectSized(screenPos + Vec2{ 5, 5 }, Vec2{ 6, 6 }), 0xFFFFFF_rgb .WithAlpha(170));
		if (!Appearance.icon)
			g->BlendText(screenPos + Vec2{ 18, 4 }, text, 0xFFFFFF_rgb .WithAlpha(255));
		else
			g->draw_icon(screenPos.X+iconPosition.X, screenPos.Y+iconPosition.Y, Appearance.icon, 255);
	}
	else
	{
		g->BlendRect(RectSized(screenPos + Vec2{ 2, 2 }, Vec2{ 12, 12 }), 0xFFFFFF_rgb .WithAlpha(200));
		if (!Appearance.icon)
			g->BlendText(screenPos + Vec2{ 18, 4 }, text, 0xFFFFFF_rgb .WithAlpha(200));
		else
			g->draw_icon(screenPos.X+iconPosition.X, screenPos.Y+iconPosition.Y, Appearance.icon, 200);
	}
}


=== src\gui\interface\Checkbox.h ===

#pragma once
#include "common/String.h"
#include "Component.h"
#include <functional>

namespace ui
{
class Checkbox: public ui::Component {
	String text;
	String toolTip;
	bool checked;
	bool isMouseOver;
	struct CheckboxAction
	{
		std::function<void ()> action;
	};
	CheckboxAction actionCallback;

public:
	Checkbox(ui::Point position, ui::Point size, String text, String toolTip);
	virtual ~Checkbox() = default;
	
	void SetText(String text);
	String GetText();
	void SetIcon(Icon icon);
	void Draw(const Point& screenPos) override;
	void OnMouseEnter(int x, int y) override;
	void OnMouseHover(int x, int y) override;
	void OnMouseLeave(int x, int y) override;
	void OnMouseClick(int x, int y, unsigned int button) override;
	void OnMouseUp(int x, int y, unsigned int button) override;
	inline void SetActionCallback(CheckboxAction const &action) { actionCallback = action; }
	inline CheckboxAction const &GetActionCallback() const { return actionCallback; }
	bool GetChecked() { return checked; }
	void SetChecked(bool checked_) { checked = checked_; }
};
}


=== src\gui\interface\Colour.h ===

#pragma once

#include "graphics/Pixel.h"

namespace ui
{
	using Colour = RGBA;
}


=== src\gui\interface\Component.cpp ===

#include "gui/interface/Component.h"

#include "graphics/Graphics.h"
#include "gui/interface/Point.h"
#include "gui/interface/Window.h"
#include "gui/interface/Panel.h"
#include "gui/interface/ContextMenu.h"

using namespace ui;

Component::Component(Point position, Point size):
	parentstate_(nullptr),
	_parent(nullptr),
	drawn(false),
	textPosition(0, 0),
	textSize(0, 0),
	iconPosition(0, 0),
	menu(nullptr),
	Position(position),
	Size(size),
	Enabled(true),
	Visible(true),
	DoesTextInput(false)
{

}

void Component::Refresh()
{
	drawn = false;
}

void Component::TextPosition(String displayText)
{

	textPosition = ui::Point(0, 0);

	textSize = Graphics::TextSize(displayText);
	int textWidth = textSize.X, textHeight = textSize.Y;
	textHeight-=3;
	textWidth-=1;
	if(Appearance.icon)
	{
		textWidth += 13;
	}

	int textAreaWidth = Size.X-(Appearance.Margin.Right+Appearance.Margin.Left);
	int textAreaHeight = Size.Y-(Appearance.Margin.Top+Appearance.Margin.Bottom);

	switch(Appearance.VerticalAlign)
	{
		case ui::Appearance::AlignTop:
			textPosition.Y = Appearance.Margin.Top+2;
			break;
		case ui::Appearance::AlignMiddle:
			textPosition.Y = Appearance.Margin.Top+((textAreaHeight-textHeight)/2);
			break;
		case ui::Appearance::AlignBottom:
			textPosition.Y = Size.Y-(textHeight+Appearance.Margin.Bottom);
			break;
	}

	switch(Appearance.HorizontalAlign)
	{
		case ui::Appearance::AlignLeft:
			textPosition.X = Appearance.Margin.Left;
			break;
		case ui::Appearance::AlignCentre:
			textPosition.X = Appearance.Margin.Left+((textAreaWidth-textWidth)/2);
			break;
		case ui::Appearance::AlignRight:
			textPosition.X = Size.X-(textWidth+Appearance.Margin.Right);
			break;
	}
	if(Appearance.icon)
	{
		iconPosition = textPosition-ui::Point(0, 1);
		textPosition.X += 15;
	}
}

bool Component::IsFocused() const
{
	if(parentstate_)
		return parentstate_->IsFocused(this);
	return false;
}

void Component::SetParentWindow(Window* window)
{
	parentstate_ = window;
}

void Component::SetParent(Panel* new_parent)
{
	if(new_parent == nullptr)
	{
		if(_parent != nullptr)
		{
			// remove from current parent and send component to parent state
			for(int i = 0; i < _parent->GetChildCount(); ++i)
			{
				if(_parent->GetChild(i) == this)
				{
					// remove ourself from parent component
					_parent->RemoveChild(i, false);

					// add ourself to the parent state
					GetParentWindow()->AddComponent(this);

					//done in this loop.
					break;
				}
			}
		}
	}
	else
	{
		// remove from parent state (if in parent state) and place in new parent
		if(GetParentWindow())
			GetParentWindow()->RemoveComponent(this);
		new_parent->children.push_back(this);
	}
	this->_parent = new_parent;
}

Point Component::GetContainerPos()
{
	Point newPos(0,0);
	if(GetParentWindow())
		newPos += GetParentWindow()->Position;
	if(GetParent())
		newPos += GetParent()->Position + GetParent()->ViewportPosition;
	return newPos;
}

Point Component::GetScreenPos()
{
	return GetContainerPos() + Position;
}

Graphics * Component::GetGraphics()
{
	return parentstate_->GetGraphics();
}

// ***** OVERRIDEABLES *****
// Kept empty.

void Component::OnContextMenuAction(int item)
{

}

void Component::Draw(const Point& screenPos)
{
	drawn = true;
}

void Component::Tick()
{
}

void Component::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
}

void Component::OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
}

void Component::OnTextInput(String text)
{
}

void Component::OnTextEditing(String text)
{
}

void Component::OnMouseClick(int localx, int localy, unsigned button)
{
}

void Component::OnMouseDown(int x, int y, unsigned button)
{
}

void Component::OnMouseHover(int localx, int localy)
{
}

void Component::OnMouseMoved(int localx, int localy)
{
}

void Component::OnMouseEnter(int localx, int localy)
{
}

void Component::OnMouseLeave(int localx, int localy)
{
}

void Component::OnMouseUp(int x, int y, unsigned button)
{
}

void Component::OnMouseWheel(int localx, int localy, int d)
{
}

void Component::OnMouseWheelInside(int localx, int localy, int d)
{
}

void Component::OnFocus()
{

}

void Component::OnDefocus()
{

}

Component::~Component()
{
	delete menu;
}


=== src\gui\interface\Component.h ===

#pragma once
#include "common/String.h"
#include "Appearance.h"
#include "Point.h"

class Graphics;
namespace ui
{
	class ContextMenu;
	class Window;
	class Panel;

	/* class Component
	 *
	 * An interactive UI component that can be added to a state or an XComponent*.
	 * *See sys::XComponent
	 */
	class Component
	{
	private:
		Window* parentstate_;
		Panel* _parent;
	protected:
		bool drawn;
		ui::Point textPosition;
		ui::Point textSize;
		ui::Point iconPosition;
		ui::ContextMenu * menu;
		Graphics * GetGraphics();

	public:
		Component(Point position, Point size);
		virtual ~Component();

		void* UserData;
		inline Window* const GetParentWindow() const { return parentstate_; }
		bool IsFocused() const;

		void Invalidate() { drawn = false; }

		Point Position;
		Point Size;
		bool Enabled;
		bool Visible;
		bool DoesTextInput;
		bool MouseInside;
		bool MouseDownInside;

		ui::Appearance Appearance;
		//virtual void SetAppearance(ui::Appearance);
		//ui::Appearance GetAppearance();
		virtual void TextPosition(String);

		void Refresh();

		Point GetContainerPos();
		Point GetScreenPos();

		/* See the parent of this component.
		 * If new_parent is NULL, this component will have no parent. (THIS DOES NOT delete THE COMPONENT. See XComponent::RemoveChild)
		 */
		void SetParentWindow(Window* window);
		void SetParent(Panel* new_parent);

		//Get the parent component.
		inline Panel* const GetParent() const { return _parent; }

		virtual void OnContextMenuAction(int item);

		///
		// Called: Every tick.
		///
		virtual void Tick();

		///
		// Called: When ready to draw.
		// Params:
		// 	None
		///
		virtual void Draw(const Point& screenPos);




		///
		// Called: When the mouse is currently hovering over the item. (Called every tick)
		// Params:
		//	localx: Local mouse X position.
		//	localy: Local mouse Y position.
		///
		virtual void OnMouseHover(int localx, int localy);

		///
		// Called: When the mouse moves.
		// Params:
		//	localx: Local mouse X position.
		//	localy: Local mouse Y position.
		///
		virtual void OnMouseMoved(int localx, int localy);

		///
		// Called: When the mouse moves on top of the item.
		// Params:
		//	localx: Local mouse X position.
		//	localy: Local mouse Y position.
		// 	dx: Mouse X delta.
		// 	dy: Mouse Y delta.
		///
		virtual void OnMouseEnter(int localx, int localy);

		///
		// Called: When the mouse leaves the item.
		// Params:
		//	localx: Local mouse X position.
		//	localy: Local mouse Y position.
		///
		virtual void OnMouseLeave(int localx, int localy);

		///
		// Called: When a mouse button is pressed.
		// Params:
		// 	x: X position of the mouse.
		// 	y: Y position of the mouse.
		// 	button: The button that is being held down.
		///
		virtual void OnMouseDown(int x, int y, unsigned button);

		///
		// Called: When a mouse button is released.
		// Params:
		// 	x: X position of the mouse.
		// 	y: Y position of the mouse.
		// 	button: The button that is being released.
		///
		virtual void OnMouseUp(int x, int y, unsigned button);

		///
		// Called: When a mouse button is pressed and then released on top of the item.
		// Params:
		// 	x: X position of the mouse.
		// 	y: Y position of the mouse.
		// 	button: The button that is being held down.
		///
		virtual void OnMouseClick(int localx, int localy, unsigned button);

		///
		// Called: When the mouse wheel moves/changes.
		// Params:
		//	localx: Local mouse X position.
		//	localy: Local mouse Y position.
		// 	d: The vertical scroll offset
		///
		virtual void OnMouseWheel(int localx, int localy, int d);

		///
		// Called: When the mouse wheel moves/changes on top of the item.
		// Params:
		//	localx: Local mouse X position.
		//	localy: Local mouse Y position.
		// 	d: The vertical scroll offset
		///
		virtual void OnMouseWheelInside(int localx, int localy, int d);

		///
		// Called: When a key is pressed.
		// Params:
		// 	key: The value of the key that is being pressed.
		// 	shift: Shift key is down.
		// 	ctrl: Control key is down.
		// 	alt: Alternate key is down.
		///
		virtual void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);

		///
		// Called: When a key is released.
		// Params:
		// 	key: The value of the key that is being released.
		// 	shift: Shift key is released.
		// 	ctrl: Control key is released.
		// 	alt: Alternate key is released.
		///
		virtual void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);

		virtual void OnTextInput(String text);
		virtual void OnTextEditing(String text);

		virtual void OnFocus();
		virtual void OnDefocus();
	};
}


=== src\gui\interface\ContextMenu.cpp ===

#include "ContextMenu.h"
#include "graphics/Graphics.h"
#include "SimulationConfig.h"
#include <algorithm>

using namespace ui;

ContextMenu::ContextMenu(Component * source):
		Window(ui::Point(0, 0), ui::Point(0, 0)),
		source(source),
		Appearance(source->Appearance)
{
}

void ContextMenu::Show(ui::Point position)
{
	for (size_t i = 0; i < buttons.size(); i++)
	{
		RemoveComponent(buttons[i]);
		delete buttons[i];
	}
	buttons.clear();

	Size.X = 100;
	Size.Y = items.size()*16-1;

	if(position.X+Size.X > WINDOWW)
		position.X -= std::min(position.X, Size.X);
	if(position.Y+Size.Y > YRES+MENUSIZE)
		position.Y -= std::min(position.Y, Size.Y);
	Position = position;

	int currentY = 1;
	for (size_t i = 0; i < items.size(); i++)
	{
		Button * tempButton = new Button(Point(1, currentY), Point(Size.X-2, 16), items[i].Text);
		tempButton->Appearance = Appearance;
		tempButton->Enabled = items[i].Enabled;
		auto item = items[i].ID;
		tempButton->SetActionCallback({ [this, item, tempButton] {
			ActionCallbackItem(tempButton, item);
		} });
		buttons.push_back(tempButton);
		AddComponent(tempButton);
		currentY += 15;
	}

	MakeActiveWindow();
}

void ContextMenu::ActionCallbackItem(ui::Button *sender, int item)
{
	CloseActiveWindow();
	Halt();
	source->OnContextMenuAction(item);
}

void ContextMenu::OnMouseDown(int x, int y, unsigned button)
{
	// Clicked outside window
	if (!(x > Position.X && y > Position.Y && y < Position.Y+Size.Y && x < Position.X+Size.X))
		CloseActiveWindow();
}

void ContextMenu::SetItem(int id, String text)
{
	for (size_t i = 0; i < items.size(); i++)
	{
		if (items[i].ID == id)
		{
			items[i].Text = text;
			break;
		}
	}
}

void ContextMenu::RemoveItem(int id)
{
	for (size_t i = 0; i < items.size(); i++)
	{
		if (items[i].ID == id)
		{
			items.erase(items.begin()+i);
			break;
		}
	}
}

void ContextMenu::AddItem(ContextMenuItem item)
{
	items.push_back(item);
}

void ContextMenu::OnDraw()
{
	Graphics * g = GetGraphics();
	g->DrawFilledRect(RectSized(Position, Size), 0x646464_rgb);
	g->BlendRect(RectSized(Position, Size), Appearance.BackgroundInactive);
}


=== src\gui\interface\ContextMenu.h ===

#pragma once
#include "Window.h"
#include "Appearance.h"
#include "Button.h"

namespace ui
{
	class Button;
	
class ContextMenuItem
{
public:
	int ID;
	String Text;
	bool Enabled;
	ContextMenuItem(String text, int id, bool enabled) : ID(id), Text(text), Enabled(enabled) {}
};

class ContextMenu: public ui::Window {
	std::vector<Button*> buttons;
	std::vector<ContextMenuItem> items;
	ui::Component * source;
public:
	ui::Appearance Appearance;
	ContextMenu(Component * source);
	virtual ~ContextMenu() = default;
	
	void ActionCallbackItem(ui::Button *sender, int item);
	void AddItem(ContextMenuItem item);
	void RemoveItem(int id);
	void SetItem(int id, String text);
	void Show(ui::Point position);
	void OnDraw() override;
	void OnMouseDown(int x, int y, unsigned button) override;
};
}


=== src\gui\interface\CopyTextButton.cpp ===

#include "CopyTextButton.h"

#include "Colour.h"
#include "gui/Style.h"
#include "Label.h"

#include "PowderToySDL.h"

namespace ui
{
	CopyTextButton::CopyTextButton(Point position, Point size, String buttonText, Label *copyTextLabel_):
		Button(position, size, buttonText)
	{
		copyTextLabel = copyTextLabel_;
		Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
		Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		Appearance.TextInactive = ui::Colour(150, 150, 150);
		Appearance.TextActive = ui::Colour(230, 255, 230);
		Appearance.BorderActive = ui::Colour(230, 255, 230);
		Appearance.BackgroundActive = style::Colour::InactiveBackground;
	}

	void CopyTextButton::OnMouseClick(int x, int y, unsigned int button)
	{
		ui::Button::OnMouseClick(x, y, button);
		ClipboardPush(ButtonText.ToUtf8());

		copyTextLabel->SetText("Copied!");

		Appearance.TextInactive = ui::Colour(180, 230, 180);
		Appearance.TextHover = ui::Colour(180, 230, 180);
		Appearance.BorderInactive = ui::Colour(180, 230, 180);
		Appearance.BorderHover = ui::Colour(180, 230, 180);
	}

	void CopyTextButton::OnMouseEnter(int x, int y)
	{
		ui::Button::OnMouseEnter(x, y);
		copyTextLabel->SetTextColour(ui::Colour(230, 230, 230));
	}

	void CopyTextButton::OnMouseLeave(int x, int y)
	{
		ui::Button::OnMouseLeave(x, y);
		copyTextLabel->SetTextColour(ui::Colour(150, 150, 150));
	}
} /* namespace ui */


=== src\gui\interface\CopyTextButton.h ===

#pragma once
#include "Button.h"

namespace ui
{
	class Label;
class CopyTextButton : public Button
{
	ui::Label *copyTextLabel;
public:
	CopyTextButton(Point position, Point size, String buttonText, Label *copyTextLabel_);

	void OnMouseClick(int x, int y, unsigned int button) override;

	void OnMouseEnter(int x, int y) override;
	void OnMouseLeave(int x, int y) override;
};
}


=== src\gui\interface\DirectionSelector.cpp ===

#include "DirectionSelector.h"

namespace ui {

DirectionSelector::DirectionSelector(ui::Point position, float scale, int radius, int handleRadius, int snapPointRadius, int snapPointEffectRadius):
	ui::Component(position, ui::Point(radius * 5 / 2, radius * 5 / 2)),
	scale(scale),
	radius(radius),
	handleRadius(handleRadius),
	useSnapPoints(false),
	snapPointRadius(snapPointRadius),
	snapPointEffectRadius(snapPointEffectRadius),
	autoReturn(false),
	backgroundColor(ui::Colour(0, 0, 0, 63)),
	foregroundColor(ui::Colour(63, 63, 63, 127)),
	borderColor(ui::Colour(255, 255, 255)),
	snapPointColor(ui::Colour(63, 63, 63, 127)),
	updateCallback(nullptr),
	changeCallback(nullptr),
	mouseDown(false),
	mouseHover(false),
	altDown(false),
	value({ { 0, 0 }, 0, 0 })
{
}

void DirectionSelector::CheckHovering(int x, int y)
{
	mouseHover = std::hypot((value.offset.X + radius) - x, (value.offset.Y + radius) - y) < handleRadius;
}

DirectionSelector::Value DirectionSelector::GravityValueToValue(float x, float y)
{
	return { { int(x / scale), int(y / scale) }, x, y };
}

DirectionSelector::Value DirectionSelector::PositionToValue(ui::Point position)
{
	auto length = std::hypot(float(position.X), float(position.Y));
	if (length > radius)
	{
		position.X = int(position.X / length * radius);
		position.Y = int(position.Y / length * radius);
	}
	return { position, position.X * scale, position.Y * scale };
}

void DirectionSelector::SetSnapPoints(int newSnapPointEffectRadius, int points, float maxMagnitude)
{
	snapPointEffectRadius = newSnapPointEffectRadius;
	snapPoints.clear();
	snapPoints.push_back(GravityValueToValue(0, 0));
	for (int i = 1; i < points; i++)
	{
		auto dist = i / float(points - 1) * maxMagnitude;
		snapPoints.push_back(GravityValueToValue( dist,     0));
		snapPoints.push_back(GravityValueToValue(    0,  dist));
		snapPoints.push_back(GravityValueToValue(-dist,     0));
		snapPoints.push_back(GravityValueToValue(    0, -dist));
	}
	useSnapPoints = true;
}

void DirectionSelector::ClearSnapPoints()
{
	useSnapPoints = false;
	snapPoints.clear();
}

float DirectionSelector::GetXValue()
{
	return value.xValue;
}

float DirectionSelector::GetYValue()
{
	return value.yValue;
}

void DirectionSelector::SetPositionAbs(ui::Point position)
{
	SetPosition(position - ui::Point{ radius + handleRadius, radius + handleRadius });
}

void DirectionSelector::SetPosition(ui::Point position)
{
	value = PositionToValue(position);

	if (useSnapPoints && !altDown)
	{
		for (auto &point : snapPoints)
		{
			if (std::hypot(point.offset.X - position.X, point.offset.Y - position.Y) <= snapPointEffectRadius)
			{
				value = point;
			}
		}
	}
	if (updateCallback)
	{
		updateCallback(GetXValue(), GetYValue());
	}
}

void DirectionSelector::SetValues(float x, float y)
{
	value.xValue = x;
	value.yValue = y;
	SetPosition(GravityValueToValue(x, y).offset);
}

void DirectionSelector::Draw(const ui::Point& screenPos)
{
	Graphics * g = GetGraphics();
	auto handleTrackRadius = radius + handleRadius;
	ui::Point center = screenPos + Vec2{ handleTrackRadius, handleTrackRadius };

	g->BlendFilledEllipse(center, { handleTrackRadius, handleTrackRadius }, backgroundColor);
	g->BlendEllipse(center, { handleTrackRadius, handleTrackRadius }, borderColor);

	for (auto &point : snapPoints)
	{
		g->BlendFilledRect(
			RectBetween(
				center + point.offset - Vec2{ snapPointRadius, snapPointRadius },
				center + point.offset + Vec2{ snapPointRadius, snapPointRadius }
			),
			snapPointColor.NoAlpha().WithAlpha(altDown ? (int)(snapPointColor.Alpha / 2) : snapPointColor.Alpha)
		);
	}

	g->BlendFilledEllipse(center + value.offset, { handleRadius, handleRadius }, foregroundColor.NoAlpha().WithAlpha((mouseHover || mouseDown) ? std::min(int(foregroundColor.Alpha * 1.5f), 255) : foregroundColor.Alpha));
	g->BlendEllipse(center + value.offset, { handleRadius, handleRadius }, borderColor);
}

void DirectionSelector::OnMouseMoved(int x, int y)
{
	if (mouseDown)
	{
		SetPositionAbs({ x, y });
	}
	CheckHovering(x, y);
}

void DirectionSelector::OnMouseDown(int x, int y, unsigned button)
{
	if (MouseDownInside)
	{
		mouseDown = true;
		SetPositionAbs({ x - Position.X, y - Position.Y });
		CheckHovering(x - Position.X, y - Position.Y);
	}
}

void DirectionSelector::OnMouseUp(int x, int y, unsigned button)
{
	mouseDown = false;
	if (autoReturn)
	{
		SetPosition({ 0, 0 });
	}
	CheckHovering(x - Position.X, y - Position.Y);

	if (changeCallback)
	{
		changeCallback(GetXValue(), GetYValue());
	}
}

}


=== src\gui\interface\DirectionSelector.h ===

#pragma once
#include "Component.h"
#include "Colour.h"
#include "graphics/Graphics.h"
#include <iostream>
#include <cmath>
#include <vector>
#include <functional>

namespace ui {

class DirectionSelector : public ui::Component
{
	const float scale;
	const int radius;
	const int handleRadius;

	bool useSnapPoints;
	int snapPointRadius;
	int snapPointEffectRadius;

	struct Value
	{
		ui::Point offset;
		float xValue;
		float yValue;
	};
	std::vector<Value> snapPoints;

	bool autoReturn;

	ui::Colour backgroundColor;
	ui::Colour foregroundColor;
	ui::Colour borderColor;
	ui::Colour snapPointColor;

public:
	using DirectionSelectorCallback = std::function<void(float x, float y)>;

private:
	DirectionSelectorCallback updateCallback;
	DirectionSelectorCallback changeCallback;

	bool mouseDown;
	bool mouseHover;
	bool altDown;

	Value value;

	void CheckHovering(int x, int y);

	Value GravityValueToValue(float x, float y);
	Value PositionToValue(ui::Point position);

public:
	DirectionSelector(ui::Point position, float scale, int radius, int handleRadius, int snapPointRadius, int snapPointEffectRadius);
	virtual ~DirectionSelector() = default;

	void SetSnapPoints(int newSnapPointEffectRadius, int points, float maxMagnitude);
	void ClearSnapPoints();

	inline void EnableSnapPoints() { useSnapPoints = true; }
	inline void DisableSnapPoints() { useSnapPoints = false; }

	inline void EnableAutoReturn() { autoReturn = true; }
	inline void DisableAutoReturn() { autoReturn = false; }

	inline void SetBackgroundColor(ui::Colour color) { backgroundColor = color; }
	inline void SetForegroundColor(ui::Colour color) { foregroundColor = color; }
	inline void SetBorderColor(ui::Colour color) { borderColor = color; }
	inline void SetSnapPointColor(ui::Colour color) { snapPointColor = color; }

	float GetXValue();
	float GetYValue();

	void SetPositionAbs(ui::Point position);
	void SetPosition(ui::Point position);
	void SetValues(float x, float y);

	void Draw(const ui::Point& screenPos) override;
	void OnMouseMoved(int x, int y) override;
	void OnMouseDown(int x, int y, unsigned int button) override;
	void OnMouseUp(int x, int y, unsigned button) override;
	inline void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override { altDown = alt; }
	inline void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override { altDown = alt; }

	inline void SetUpdateCallback(DirectionSelectorCallback callback) { updateCallback = callback; }
	inline void SetChangeCallback(DirectionSelectorCallback callback) { changeCallback = callback; }
};

} /* namespace ui */


=== src\gui\interface\DropDown.cpp ===

#include "DropDown.h"

#include "graphics/Graphics.h"
#include "gui/Style.h"
#include "Button.h"
#include "gui/interface/Window.h"

namespace ui {

class DropDownWindow : public ui::Window
{
	DropDown * dropDown;
	Appearance appearance;
	std::vector<Button> buttons;

public:
	DropDownWindow(DropDown * dropDown):
		Window(dropDown->GetScreenPos() + ui::Point(-1, -1 - (dropDown->optionIndex*16 < dropDown->GetScreenPos().Y ? dropDown->optionIndex*16 : 0)),
						  ui::Point(dropDown->Size.X+2, 2+dropDown->options.size()*16)),
		dropDown(dropDown),
		appearance(dropDown->Appearance)
	{
		int currentY = 1;
		for (size_t i = 0; i < dropDown->options.size(); i++)
		{
			Button * tempButton = new Button(Point(1, currentY), Point(Size.X-2, 16), dropDown->options[i].first);
			tempButton->Appearance = appearance;
			if (i)
				tempButton->Appearance.Border = ui::Border(0, 1, 1, 1);
			auto option = dropDown->options[i].first;
			tempButton->SetActionCallback({ [this, option] {
				CloseActiveWindow();
				setOption(option);
				SelfDestruct();
			} });
			AddComponent(tempButton);
			currentY += 16;
		}
	}
	void OnDraw() override
	{
		Graphics * g = GetGraphics();
		g->DrawFilledRect(RectSized(Position, Size), 0x000000_rgb);
	}
	void setOption(String option)
	{
		dropDown->SetOption(option);
		if (dropDown->actionCallback.change)
		{
			dropDown->actionCallback.change();
		}
	}
	void OnTryExit(ExitMethod method) override
	{
		CloseActiveWindow();
		SelfDestruct();
	}
	virtual ~DropDownWindow() {}
};

DropDown::DropDown(Point position, Point size):
	Component(position, size),
	isMouseInside(false),
	optionIndex(-1)
{
}

void DropDown::OnMouseClick(int x, int y, unsigned int button)
{
	DropDownWindow * newWindow = new DropDownWindow(this);
	newWindow->MakeActiveWindow();
}

void DropDown::Draw(const Point& screenPos)
{
	if(!drawn)
	{
		if(optionIndex!=-1)
			TextPosition(options[optionIndex].first);
		drawn = true;
	}
	Graphics * g = GetGraphics();
	Point Position = screenPos;

	ui::Colour textColour = Appearance.TextInactive;
	ui::Colour borderColour = Appearance.BorderInactive;
	ui::Colour backgroundColour = Appearance.BackgroundInactive;

	if (isMouseInside)
	{
		textColour = Appearance.TextHover;
		borderColour = Appearance.BorderHover;
		backgroundColour = Appearance.BackgroundHover;
	}
	else
	{
		textColour = Appearance.TextInactive;
		borderColour = Appearance.BorderInactive;
		backgroundColour = Appearance.BackgroundInactive;
	}

	g->BlendFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), backgroundColour);
	g->BlendRect(RectSized(Position, Size), borderColour);
	if(optionIndex!=-1)
		g->BlendText(Position + textPosition, options[optionIndex].first, textColour);
}

void DropDown::OnMouseEnter(int x, int y)
{
	isMouseInside = true;
}

void DropDown::OnMouseLeave(int x, int y)
{
	isMouseInside = false;
}

std::pair<String, int> DropDown::GetOption()
{
	if(optionIndex!=-1)
	{
		return options[optionIndex];
	}
	return std::pair<String, int>("", -1);
}

void DropDown::SetOption(String option)
{
	for (size_t i = 0; i < options.size(); i++)
	{
		if (options[i].first == option)
		{
			optionIndex = i;
			TextPosition(options[optionIndex].first);
			return;
		}
	}
}

void DropDown::SetOption(int option)
{
	for (size_t i = 0; i < options.size(); i++)
	{
		if (options[i].second == option)
		{
			optionIndex = i;
			TextPosition(options[optionIndex].first);
			return;
		}
	}
}

void DropDown::AddOption(std::pair<String, int> option)
{
	for (size_t i = 0; i < options.size(); i++)
	{
		if (options[i] == option)
			return;
	}
	options.push_back(option);
}

void DropDown::RemoveOption(String option)
{
start:
	for (size_t i = 0; i < options.size(); i++)
	{
		if (options[i].first == option)
		{
			if ((int)i == optionIndex)
				optionIndex = -1;
			options.erase(options.begin()+i);
			goto start;
		}
	}
}

void DropDown::SetOptions(std::vector<std::pair<String, int> > options)
{
	this->options = options;
}

} /* namespace ui */


=== src\gui\interface\DropDown.h ===

#pragma once
#include "Component.h"
#include <utility>
#include <functional>

namespace ui {

class DropDownWindow;

class DropDown : public ui::Component
{
	friend class DropDownWindow;
	bool isMouseInside;
	int optionIndex;

	struct DropDownAction
	{
		std::function<void ()> change;
	};
	DropDownAction actionCallback;

	std::vector<std::pair<String, int> > options;
	
public:
	DropDown(Point position, Point size);
	virtual ~DropDown() = default;

	std::pair<String, int> GetOption();
	void SetOption(int option);
	void SetOption(String option);
	void AddOption(std::pair<String, int> option);
	void RemoveOption(String option);
	void SetOptions(std::vector<std::pair<String, int> > options);
	inline void SetActionCallback(DropDownAction action) { actionCallback = action; }
	void Draw(const Point& screenPos) override;
	void OnMouseClick(int x, int y, unsigned int button) override;
	void OnMouseEnter(int x, int y) override;
	void OnMouseLeave(int x, int y) override;
};

} /* namespace ui */


=== src\gui\interface\Engine.cpp ===

#include "Engine.h"
#include "Config.h"
#include "PowderToySDL.h"
#include "Window.h"
#include "common/platform/Platform.h"
#include "graphics/Graphics.h"
#include "gui/dialogues/ConfirmPrompt.h"
#include <cmath>
#include <cstring>

using namespace ui;

Engine::Engine():
	drawingFrequencyLimit(DrawLimitDisplay{}),
	FrameIndex(0),
	state_(nullptr),
	windowTargetPosition(0, 0),
	FastQuit(1),
	GlobalQuit(true),
	lastTick(Platform::GetTime()),
	mouseb_(0),
	mousex_(0),
	mousey_(0),
	mousexp_(0),
	mouseyp_(0)
{
}

Engine::~Engine()
{
	delete state_;
	//Dispose of any Windows.
	while (!windows.empty())
	{
		delete windows.back();
		windows.pop_back();
	}
}

void Engine::ApplyFpsLimit()
{
	::ApplyFpsLimit();
}

void Engine::Begin()
{
	//engine is now ready
	running_ = true;
}

void Engine::Exit()
{
	onClose();
	running_ = false;
}

void Engine::ConfirmExit()
{
	if (!confirmingExit)
	{
		confirmingExit = true;
		new ConfirmPrompt("You are about to quit", "Are you sure you want to exit the game?", { [] {
			ui::Engine::Ref().Exit();
		}, [this] {
			confirmingExit = false;
		} });
	}
}

void Engine::ShowWindow(Window * window)
{
	CloseWindowAndEverythingAbove(window);
	if (state_)
		ignoreEvents = true;
	if(window->Position.X==-1)
	{
		window->Position.X = (g->Size().X - window->Size.X) / 2;
	}
	if(window->Position.Y==-1)
	{
		window->Position.Y = (g->Size().Y - window->Size.Y) / 2;
	}
	window->Size = window->Size.Min(g->Size());
	window->Position = window->Position.Clamp(RectBetween<int>({0, 0}, g->Size()));
	/*if(window->Position.Y > 0)
	{
		windowTargetPosition = window->Position;
		window->Position = Point(windowTargetPosition.X, height_);
	}*/
	if(state_)
	{
		frozenGraphics.emplace(FrozenGraphics{0, std::make_unique<pixel []>(g->Size().X * g->Size().Y)});
		std::copy_n(g->Data(), g->Size().X * g->Size().Y, frozenGraphics.top().screen.get());

		windows.push_back(state_);
		mousePositions.push(ui::Point(mousex_, mousey_));
	}
	if(state_)
		state_->DoBlur();

	state_ = window;
	ApplyFpsLimit();
}

void Engine::CloseWindowAndEverythingAbove(Window *window)
{
	if (window == state_)
	{
		CloseWindow();
		return;
	}
	auto it = std::find(windows.begin(), windows.end(), window);
	if (it != windows.end())
	{
		auto toPop = int(windows.end() - it) + 1; // including state_
		for (int i = 0; i < toPop; ++i)
		{
			CloseWindow();
		}
	}
}

int Engine::CloseWindow()
{
	if(!windows.empty())
	{
		frozenGraphics.pop();
		state_ = windows.back();
		windows.pop_back();

		if(state_)
			state_->DoFocus();

		ui::Point mouseState = mousePositions.top();
		mousePositions.pop();
		if(state_)
		{
			mousexp_ = mouseState.X;
			mouseyp_ = mouseState.Y;
			state_->DoMouseMove(mousex_, mousey_, mousex_ - mousexp_, mousey_ - mouseyp_);
			mousexp_ = mousex_;
			mouseyp_ = mousey_;
		}
		ignoreEvents = true;
		ApplyFpsLimit();
		return 0;
	}
	else
	{
		state_ = nullptr;
		ApplyFpsLimit();
		return 1;
	}
}

/*void Engine::SetState(State * state)
{
	if(state_) //queue if currently in a state
		statequeued_ = state;
	else
	{
		state_ = state;
		if(state_)
			state_->DoInitialized();
	}
}*/


void Engine::Tick()
{
	if(state_ != nullptr)
	{
		state_->DoTick();
	}


	lastTick = Platform::GetTime();

	ignoreEvents = false;
	/*if(statequeued_ != NULL)
	{
		if(state_ != NULL)
		{
			state_->DoExit();
			delete state_;
			state_ = NULL;
		}
		state_ = statequeued_;
		statequeued_ = NULL;

		if(state_ != NULL)
			state_->DoInitialized();
	}*/
}

void Engine::SimTick()
{
	if (state_)
	{
		state_->DoSimTick();
	}
}

void Engine::Draw()
{
	if (!frozenGraphics.empty() && !(state_ && RectSized(state_->Position, state_->Size) == g->Size().OriginRect()))
	{
		auto &frozen = frozenGraphics.top();
		std::copy_n(frozen.screen.get(), g->Size().X * g->Size().Y, g->Data());
		if (frozen.fadeTicks <= maxFadeTicks)
		{
			// from 0x00 at 0 to about 0x54 at 20
			auto alpha = uint8_t((1 - std::pow(0.98, frozen.fadeTicks)) * 0xFF);
			g->BlendFilledRect(g->Size().OriginRect(), 0x000000_rgb .WithAlpha(alpha));
		}
		// If this is the last frame in the fade, save what the faded image looks like
		if (frozen.fadeTicks == maxFadeTicks)
			std::copy_n(g->Data(), g->Size().X * g->Size().Y, frozen.screen.get());
		if (frozen.fadeTicks <= maxFadeTicks)
			frozen.fadeTicks++;
	}
	else
	{
		g->Clear();
	}
	if(state_)
		state_->DoDraw();

	g->Finalise();
	FrameIndex++;
	FrameIndex %= 7200;
}

void Engine::onKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (state_ && !ignoreEvents)
		state_->DoKeyPress(key, scan, repeat, shift, ctrl, alt);
}

void Engine::onKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (state_ && !ignoreEvents)
		state_->DoKeyRelease(key, scan, repeat, shift, ctrl, alt);
}

void Engine::onTextInput(String text)
{
	if (textInput)
	{
		if (state_ && !ignoreEvents)
			state_->DoTextInput(text);
	}
}

void Engine::onTextEditing(String text, int start)
{
	if (textInput)
	{
		// * SDL sends the candidate string in packets of some arbitrary size,
		//   leaving it up to the user to assemble these packets into the
		//   complete candidate string. The start parameter tells us which
		//   portion of the candidate string the current packet spans.
		// * Sadly, there's no documented way to tell the first or last packet
		//   apart from the rest. While there's also no documented guarantee
		//   that the packets come in order and that there are no gaps or
		//   overlaps between them, the implementation on the SDL side seems to
		//   ensure this. So what we do is just append whatever packet we get
		//   to a buffer, which we reset every time a "first-y looking" packet
		//   arrives. We also forward a textediting event on every packet,
		//   which is redundant, but should be okay, as textediting events are
		//   not supposed to have an effect on the actual text being edited.
		// * We define a first-y looking packet as one with a start parameter
		//   lower than or equal to the start parameter of the previous packet.
		//   This is general enough that it seems to work around the bugs
		//   of all SDL input method backends.
		if (start <= lastTextEditingStart)
		{
			textEditingBuf.clear();
		}
		lastTextEditingStart = start;
		textEditingBuf.append(text);
		if (state_ && !ignoreEvents)
			state_->DoTextEditing(textEditingBuf);
	}
}

void Engine::onMouseDown(int x, int y, unsigned button)
{
	mouseb_ |= button;
	if (state_ && !ignoreEvents)
		state_->DoMouseDown(x, y, button);
}

void Engine::onMouseUp(int x, int y, unsigned button)
{
	mouseb_ &= ~button;
	if (state_ && !ignoreEvents)
		state_->DoMouseUp(x, y, button);
}

void Engine::initialMouse(int x, int y)
{
	mousexp_ = x;
	mouseyp_ = y;
}

void Engine::onMouseMove(int x, int y)
{
	mousex_ = x;
	mousey_ = y;
	if (state_ && !ignoreEvents)
	{
		state_->DoMouseMove(x, y, mousex_ - mousexp_, mousey_ - mouseyp_);
	}
	mousexp_ = x;
	mouseyp_ = y;
}

void Engine::onMouseWheel(int x, int y, int delta)
{
	if (state_ && !ignoreEvents)
		state_->DoMouseWheel(x, y, delta);
}

void Engine::onClose()
{
	if (state_)
		state_->DoExit();
}

void Engine::onFileDrop(ByteString filename)
{
	if (state_)
		state_->DoFileDrop(filename);
}

void Engine::StartTextInput()
{
	if (textInput)
	{
		return;
	}
	textInput = true;
	::StartTextInput();
}

void Engine::StopTextInput()
{
	if (!textInput)
	{
		return;
	}
	::StopTextInput();
	textInput = false;
}

void Engine::TextInputRect(Point position, Point size)
{
	::SetTextInputRect(position.X, position.Y, size.X, size.Y);
}

std::optional<int> Engine::GetEffectiveDrawCap() const
{
	auto drawLimit = GetDrawingFrequencyLimit();
	std::optional<int> effectiveDrawCap;
	if (auto *drawLimitExplicit = std::get_if<DrawLimitExplicit>(&drawLimit))
	{
		effectiveDrawCap = drawLimitExplicit->value;
	}
	if (std::get_if<DrawLimitDisplay>(&drawLimit))
	{
		effectiveDrawCap = std::visit([](auto &&refreshRate) {
			return refreshRate.value;
		}, GetRefreshRate());
	}
	return effectiveDrawCap;
}

void Engine::SetFps(float newFps)
{
	if (state_)
	{
		return state_->SetFps(newFps);
	}
}

float Engine::GetFps() const
{
	if (state_)
	{
		return state_->GetFps();
	}
	return 1;
}

FpsLimit Engine::GetFpsLimit() const
{
	if (state_)
	{
		return state_->GetFpsLimit();
	}
	return FpsLimitNone{};
}

bool Engine::GetContributesToFps() const
{
	if (state_)
	{
		return state_->contributesToFps;
	}
	return false;
}


=== src\gui\interface\Engine.h ===

#pragma once
#include <memory>
#include <optional>
#include <stack>
#include <variant>
#include "common/String.h"
#include "common/ExplicitSingleton.h"
#include "graphics/Pixel.h"
#include "gui/interface/Point.h"
#include "gui/WindowFrameOps.h"
#include <climits>
#include "FpsLimit.h"

struct RefreshRateDefault
{
	int value = 60;
};
struct RefreshRateQueried
{
	int value;
};
using RefreshRate = std::variant<RefreshRateDefault, RefreshRateQueried>;

class Graphics;
namespace ui
{
	class Window;

	/* class Engine
	 *
	 * Controls the User Interface.
	 * Send user inputs to the Engine and the appropriate controls and components will interact.
	 */
	class Engine: public ExplicitSingleton<Engine>
	{
	public:
		Engine();
		~Engine();

		void ShowWindow(Window * window);
		int CloseWindow();
		void CloseWindowAndEverythingAbove(Window *window);

		void initialMouse(int x, int y);
		void onMouseMove(int x, int y);
		void onMouseDown(int x, int y, unsigned button);
		void onMouseUp(int x, int y, unsigned button);
		void onMouseWheel(int x, int y, int delta);
		void onKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
		void onKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
		void onTextInput(String text);
		void onTextEditing(String text, int start);
		void onClose();
		void onFileDrop(ByteString filename);

		void Begin();
		inline bool Running() { return running_; }
		inline long unsigned int LastTick() { return lastTick; }
		void Exit();
		void ConfirmExit();

		void SetDrawingFrequencyLimit(DrawLimit limit) {drawingFrequencyLimit = limit;}
		inline DrawLimit GetDrawingFrequencyLimit() const {return drawingFrequencyLimit;}
		std::optional<int> GetEffectiveDrawCap() const;
		void SetFastQuit(bool fastquit) { FastQuit = fastquit; }
		inline bool GetFastQuit() {return FastQuit; }
		void SetGlobalQuit(bool newGlobalQuit) { GlobalQuit = newGlobalQuit; }
		inline bool GetGlobalQuit() {return GlobalQuit; }

		void Tick();
		void SimTick();
		void Draw();

		void SetFps(float newFps);
		float GetFps() const;

		inline int GetMouseButton() { return mouseb_; }
		inline int GetMouseX() { return mousex_; }
		inline int GetMouseY() { return mousey_; }

		void StartTextInput();
		void StopTextInput();
		void TextInputRect(Point position, Point size);

		//void SetState(Window* state);
		//inline State* GetState() { return state_; }
		inline Window* GetWindow() { return state_; }

		FpsLimit GetFpsLimit() const;
		bool GetContributesToFps() const;

		DrawLimit drawingFrequencyLimit;
		Graphics * g;
		bool GraveExitsConsole;

		bool confirmingExit = false;

		unsigned int FrameIndex;
	private:

		bool textInput = false;
		int lastTextEditingStart = INT_MAX;

		void ApplyFpsLimit();
		std::deque<Window*> windows;
		std::stack<Point> mousePositions;
		//Window* statequeued_;
		Window* state_;
		Point windowTargetPosition;
		bool ignoreEvents = false;
		RefreshRate refreshRate;

		// saved appearances of windows that are in the backround and
		// thus are not currently being redrawn
		struct FrozenGraphics
		{
			int fadeTicks;
			std::unique_ptr<pixel []> screen;
		};
		constexpr static int maxFadeTicks = 20;
		std::stack<FrozenGraphics> frozenGraphics;

		bool running_;
		bool FastQuit;
		bool GlobalQuit;

		long unsigned int lastTick;
		int mouseb_;
		int mousex_;
		int mousey_;
		int mousexp_;
		int mouseyp_;

		String textEditingBuf;

	public:
		bool MomentumScroll = true;
		bool ShowAvatars = true;
		bool TouchUI = false;
		WindowFrameOps windowFrameOps;

		void SetScale              (int newScale               ) { windowFrameOps.scale               = newScale;               }
		void SetFullscreen         (bool newFullscreen         ) { windowFrameOps.fullscreen          = newFullscreen;          }
		void SetChangeResolution   (bool setChangeResolution   ) { windowFrameOps.changeResolution    = setChangeResolution;    }
		void SetForceIntegerScaling(bool newForceIntegerScaling) { windowFrameOps.forceIntegerScaling = newForceIntegerScaling; }
		void SetResizable          (bool newResizable          ) { windowFrameOps.resizable           = newResizable;           }
		void SetBlurryScaling      (bool newBlurryScaling      ) { windowFrameOps.blurryScaling       = newBlurryScaling;       }
		int  GetScale              () const { return windowFrameOps.scale;               }
		bool GetFullscreen         () const { return windowFrameOps.fullscreen;          }
		bool GetChangeResolution   () const { return windowFrameOps.changeResolution;    }
		bool GetForceIntegerScaling() const { return windowFrameOps.forceIntegerScaling; }
		bool GetResizable          () const { return windowFrameOps.resizable;           }
		bool GetBlurryScaling      () const { return windowFrameOps.blurryScaling;       }

		RefreshRate GetRefreshRate() const
		{
			return refreshRate;
		}

		void SetRefreshRate(RefreshRate newRefreshRate)
		{
			refreshRate = newRefreshRate;
		}
	};
}


=== src\gui\interface\Fade.cpp ===

#include "Fade.h"
#include "Engine.h"

namespace ui
{
	void Fade::SetTarget(float newTarget)
	{
		if (target == newTarget)
		{
			return;
		}
		auto value = GetValue();
		target = newTarget;
		SetValue(value);
	}

	void Fade::SetProfile(Profile newProfile)
	{
		profile = newProfile;
	}

	void Fade::SetValue(float newValue)
	{
		referenceTick = int64_t(Engine::Ref().LastTick());
		referenceValue = newValue;
	}

	float Fade::GetValue() const
	{
		constexpr auto tickBias = 1000.f;
		auto nowTick = int64_t(Engine::Ref().LastTick());
		auto diffTick = nowTick - referenceTick;
		if (auto *linearProfile = std::get_if<LinearProfile>(&profile))
		{
			auto change = linearProfile->change;
			if (target < referenceValue)
			{
				if (linearProfile->changeDownward.has_value())
				{
					change = *linearProfile->changeDownward;
				}
				change = -change;
			}
			auto maxDiffTick = int64_t((target - referenceValue) / change * tickBias);
			if (diffTick >= maxDiffTick)
			{
				return target;
			}
			return referenceValue + diffTick * change / tickBias;
		}
		if (auto *exponentialProfile = std::get_if<ExponentialProfile>(&profile))
		{
			auto maxDiffTick = int64_t(std::log(exponentialProfile->margin / std::abs(referenceValue - target)) / std::log(exponentialProfile->decay) * tickBias);
			if (diffTick >= maxDiffTick)
			{
				return target;
			}
			return target + (referenceValue - target) * std::pow(exponentialProfile->decay, diffTick / tickBias);
		}
		return 0.f;
	}
}


=== src\gui\interface\Fade.h ===

#pragma once
#include <cstdint>
#include <variant>
#include <optional>

namespace ui
{
	class Fade
	{
	public:
		struct LinearProfile
		{
			float change; // per second
			std::optional<float> changeDownward; // per second, ::change is upward change if set
		};
		struct ExponentialProfile
		{
			float decay; // per second
			float margin; // unit
		};
		using Profile = std::variant<
			LinearProfile,
			ExponentialProfile
		>;

	private:
		float target = 0;
		int64_t referenceTick = 0;
		float referenceValue = 0;
		Profile profile;

	public:
		Fade(Profile newProfile, float newTarget = 0.f)
		{
			SetProfile(newProfile);
			SetTarget(newTarget);
			SetValue(newTarget);
		}

		Fade(Profile newProfile, float newTarget, float newValue)
		{
			SetProfile(newProfile);
			SetTarget(newTarget);
			SetValue(newValue);
		}

		void SetTarget(float newTarget);
		void SetProfile(Profile newProfile);
		void SetValue(float newValue);
		float GetValue() const;

		operator int() const
		{
			return int(GetValue());
		}

		Fade &operator =(int newValue)
		{
			SetValue(float(newValue));
			return *this;
		}

		static constexpr ExponentialProfile BasicDimensionProfile{ 1.532496e-06f, 0.5f };
	};
}


=== src\gui\interface\Label.cpp ===

#include "Label.h"
#include "Format.h"
#include "Point.h"
#include "PowderToySDL.h"
#include "ContextMenu.h"
#include "graphics/Graphics.h"
#include "graphics/FontReader.h"
#include <SDL.h>

using namespace ui;

Label::Label(Point position, Point size, String labelText):
	Component(position, size),
	textColour(255, 255, 255),
	selectionIndexL(textWrapper.IndexBegin()),
	selectionIndexH(textWrapper.IndexBegin()),
	multiline(false),
	selecting(false),
	autoHeight(size.Y==-1?true:false)
{
	if (labelText.size()) // Don't call virtual function in ctor unless absolutely necessary. Deriveds set labelText to "".
	{
		SetText(labelText);
	}

	menu = new ContextMenu(this);
	menu->AddItem(ContextMenuItem("Copy", 0, true));
}

Label::~Label()
{
}

void Label::SetMultiline(bool status)
{
	multiline = status;
	updateTextWrapper();
	updateSelection();
	TextPosition(displayTextWrapper.WrappedText());
}

void Label::SetText(String newText)
{
	this->text = newText;
	updateTextWrapper();
	updateSelection();
	TextPosition(displayTextWrapper.WrappedText());
}

void Label::AutoHeight()
{
	bool oldAH = autoHeight;
	autoHeight = true;
	updateTextWrapper();
	autoHeight = oldAH;
}

void Label::updateTextWrapper()
{
	int lines = textWrapper.Update(
		text,
		multiline,
		Size.X - Appearance.Margin.Left - Appearance.Margin.Right
	);
	displayTextWrapper.Update(
		displayText.size() ? displayText : text,
		multiline,
		Size.X - Appearance.Margin.Left - Appearance.Margin.Right
	);
	if (autoHeight)
	{
		Size.Y = lines * FONT_H + 3;
	}
}

String Label::GetText()
{
	return this->text;
}

void Label::OnContextMenuAction(int item)
{
	switch(item)
	{
	case 0:
		copySelection();
		break;
	}
}

void Label::OnMouseDown(int x, int y, unsigned button)
{
	if (MouseDownInside)
	{
		if(button == SDL_BUTTON_RIGHT)
		{
			if (menu)
			{
				menu->Show(GetContainerPos() + ui::Point(x, y));
			}
		}
		else
		{
			selecting = true;
			auto tp = textPosition - Vec2{ scrollX, 0 };
			selectionIndex0 = textWrapper.Point2Index(x - Position.X - tp.X, y - Position.Y - tp.Y);
			selectionIndexL = selectionIndex0;
			selectionIndexH = selectionIndex0;

			updateSelection();
		}
	}
}

void Label::copySelection()
{
	if (HasSelection())
	{
		ClipboardPush(format::CleanString(text.Between(selectionIndexL.raw_index, selectionIndexH.raw_index), false, true, false).ToUtf8());
	}
	else
	{
		ClipboardPush(format::CleanString(text, false, true, false).ToUtf8());
	}
}

void Label::OnMouseUp(int x, int y, unsigned button)
{
	selecting = false;
}

void Label::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
	{
		return;
	}
	if (ctrl && scan == SDL_SCANCODE_C)
	{
		copySelection();
	}
	if (ctrl && scan == SDL_SCANCODE_A)
	{
		selectAll();
		return;
	}
}

void Label::OnMouseMoved(int localx, int localy)
{
	if (selecting)
	{
		auto tp = textPosition - Vec2{ scrollX, 0 };
		selectionIndex1 = textWrapper.Point2Index(localx - tp.X, localy - tp.Y);
		if (selectionIndex1.raw_index < selectionIndex0.raw_index)
		{
			selectionIndexL = selectionIndex1;
			selectionIndexH = selectionIndex0;
		}
		else
		{
			selectionIndexL = selectionIndex0;
			selectionIndexH = selectionIndex1;
		}
		updateSelection();
	}
}

void Label::Tick()
{
	if (multiline)
	{
		scrollX = 0;
	}
	if (!this->IsFocused() && (HasSelection() || selecting))
	{
		ClearSelection();
	}
}

int Label::getLowerSelectionBound()
{
	return selectionIndexL.raw_index;
}

int Label::getHigherSelectionBound()
{
	return selectionIndexH.raw_index;
}

bool Label::HasSelection()
{
	return selectionIndexH.raw_index > selectionIndexL.raw_index;
}

void Label::ClearSelection()
{
	selecting = false;
	selectionIndexL = textWrapper.IndexBegin();
	selectionIndexH = textWrapper.IndexBegin();
	updateSelection();
}

void Label::selectAll()
{
	selectionIndexL = textWrapper.IndexBegin();
	selectionIndexH = textWrapper.IndexEnd();
	updateSelection();
}

void Label::updateSelection()
{
	if (selectionIndexL.raw_index <                  0) selectionIndexL = textWrapper.IndexBegin();
	if (selectionIndexL.raw_index > (int)text.length()) selectionIndexL = textWrapper.IndexEnd();
	if (selectionIndexH.raw_index <                  0) selectionIndexH = textWrapper.IndexBegin();
	if (selectionIndexH.raw_index > (int)text.length()) selectionIndexH = textWrapper.IndexEnd();

	displayTextWithSelection = displayTextWrapper.WrappedText();
	if (HasSelection())
	{
		auto indexL = displayTextWrapper.Clear2Index(selectionIndexL.clear_index);
		auto indexH = displayTextWrapper.Clear2Index(selectionIndexH.clear_index);
		displayTextWithSelection.Insert(indexL.wrapped_index    , "\x01");
		displayTextWithSelection.Insert(indexH.wrapped_index + 1, "\x01");
	}
}

void Label::SetDisplayText(String newText)
{
	displayText = newText;
	ClearSelection();
	updateTextWrapper();
	updateSelection();
	TextPosition(displayTextWrapper.WrappedText());
}

void Label::Draw(const Point& screenPos)
{
	if (!drawn)
	{
		TextPosition(displayTextWrapper.WrappedText());
		updateTextWrapper();
		updateSelection();
		drawn = true;
	}
	Graphics *g = GetGraphics();

	auto indexL = displayTextWrapper.Clear2Index(selectionIndexL.clear_index);
	auto indexH = displayTextWrapper.Clear2Index(selectionIndexH.clear_index);
		
	int selectionXL;
	int selectionYL;
	int selectionLineL = displayTextWrapper.Index2Point(indexL, selectionXL, selectionYL);

	int selectionXH;
	int selectionYH;
	int selectionLineH = displayTextWrapper.Index2Point(indexH, selectionXH, selectionYH);

	auto clip = RectSized(screenPos + Vec2{ 1, 1 }, Size - Vec2{ 2, 2 }) & g->GetClipRect();
	g->SwapClipRect(clip);
	auto tp = textPosition - Vec2{ scrollX, 0 };
	if (HasSelection())
	{
		if (selectionLineH == selectionLineL)
		{
			g->DrawFilledRect(
				RectSized(
					screenPos + tp + Vec2{ selectionXL - 1, selectionYL - 2 },
					Vec2{ selectionXH - selectionXL + 1, FONT_H }
				),
				0xFFFFFF_rgb
			);
		}
		else
		{
			g->DrawFilledRect(
				RectSized(
					screenPos + tp + Vec2{ selectionXL - 1, selectionYL - 2 },
					Vec2{ textSize.X - selectionXL + 1, FONT_H }
				),
				0xFFFFFF_rgb
			);
			for (int i = 1; i < selectionLineH - selectionLineL; ++i)
			{
				g->DrawFilledRect(
					RectSized(
						screenPos + tp + Vec2{ -1, selectionYL - 2 + i * FONT_H },
						Vec2{ textSize.X + 1, FONT_H }
					),
					0xFFFFFF_rgb
				);
			}
			g->DrawFilledRect(
				RectSized(
					screenPos + tp + Vec2{ -1, selectionYH - 2 },
					Vec2{ selectionXH + 1, FONT_H }
				),
				0xFFFFFF_rgb
			);
		}
	}
	g->BlendText(
		screenPos + tp,
		displayTextWithSelection,
		textColour.NoAlpha().WithAlpha(255)
	);
	g->SwapClipRect(clip);
}



=== src\gui\interface\Label.h ===

#pragma once
#include "common/String.h"

#include "Component.h"
#include "Colour.h"
#include "TextWrapper.h"

namespace ui
{
	class Label : public Component
	{
	protected:
		String textFragments;
		String displayTextWithSelection;

		String text;
		TextWrapper textWrapper;

		String displayText;
		TextWrapper displayTextWrapper;

		Colour textColour;
		TextWrapper::Index selectionIndex0;
		TextWrapper::Index selectionIndex1;
		TextWrapper::Index selectionIndexL;
		TextWrapper::Index selectionIndexH;

		bool multiline;
		bool selecting;
		bool autoHeight;

		void updateTextWrapper();
		void updateSelection();

		int getLowerSelectionBound();
		int getHigherSelectionBound();

		int scrollX = 0;

		void copySelection();
	public:
		//Label(Window* parent_state, String labelText);
		Label(Point position, Point size, String labelText);
		//Label(String labelText);
		virtual ~Label();

		void SetMultiline(bool status);

		virtual void SetText(String text);
		virtual void SetDisplayText(String text);
		virtual String GetText();

		bool HasSelection();
		void ClearSelection();
		void selectAll();
		void AutoHeight();

		void SetTextColour(Colour textColour) { this->textColour = textColour; }

		void OnContextMenuAction(int item) override;
		virtual void OnMouseDown(int x, int y, unsigned button) override;
		void OnMouseUp(int x, int y, unsigned button) override;
		void OnMouseMoved(int localx, int localy) override;
		void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
		void Draw(const Point& screenPos) override;
		void Tick() override;
	};
}


=== src\gui\interface\meson.build ===

gui_files += files(
	'Appearance.cpp',
	'Button.cpp',
	'Checkbox.cpp',
	'Component.cpp',
	'ContextMenu.cpp',
	'CopyTextButton.cpp',
	'DirectionSelector.cpp',
	'DropDown.cpp',
	'Fade.cpp',
	'Engine.cpp',
	'Label.cpp',
	'Panel.cpp',
	'ProgressBar.cpp',
	'ScrollPanel.cpp',
	'Slider.cpp',
	'Spinner.cpp',
	'Textbox.cpp',
	'TextWrapper.cpp',
	'Window.cpp',
)

powder_files += files(
	'AvatarButton.cpp',
	'RichLabel.cpp',
	'SaveButton.cpp',
	'Separator.cpp',
)


=== src\gui\interface\Panel.cpp ===

#include "gui/interface/Panel.h"

#include "gui/interface/Engine.h"
#include "gui/interface/Window.h"

#include "graphics/Graphics.h"

using namespace ui;

Panel::Panel(Point position, Point size):
	Component(position, size),
	InnerSize(size),
	ViewportPosition(0, 0)
{
}

Panel::~Panel()
{
	for(unsigned i = 0; i < children.size(); ++i)
	{
		delete children[i];
	}
}

void Panel::AddChild(Component* c)
{
	c->SetParent(this);
	c->SetParentWindow(this->GetParentWindow());
	c->MouseInside = false;
	c->MouseDownInside = false;
}

int Panel::GetChildCount()
{
	return children.size();
}

Component* Panel::GetChild(unsigned idx)
{
	return children[idx];
}

void Panel::RemoveChild(Component* c)
{
	for (size_t i = 0; i < children.size(); ++i)
	{
		if (children[i] == c)
		{
			//remove child from parent. Does not free memory
			children.erase(children.begin() + i);
			if (this->GetParentWindow()->IsFocused(c))
				this->GetParentWindow()->FocusComponent(nullptr);
			break;
		}
	}
}

void Panel::RemoveChild(unsigned idx, bool freeMem)
{
	if(freeMem)
		delete children[idx];

	children.erase(children.begin() + idx);
}

void Panel::Draw(const Point& screenPos)
{
	// draw ourself first
	XDraw(screenPos);

	auto clip = RectSized(screenPos, Size);
	GetGraphics()->SwapClipRect(clip);

	// attempt to draw all children
	for (auto const child : children)
		// the component must be visible
		if (child->Visible)
		{
			auto rect = RectSized(child->Position + ViewportPosition, child->Size);
			//check if the component is in the screen, draw if it is
			if (rect & Size.OriginRect())
			{
				child->Draw(screenPos + rect.pos);
			}
		}

	GetGraphics()->SwapClipRect(clip); // apply old cliprect
}

void Panel::Tick()
{
	// tick ourself first
	XTick();

	// tick our children
	for(unsigned i = 0; i < children.size(); ++i)
		children[i]->Tick();
}

void Panel::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	XOnKeyPress(key, scan, repeat, shift, ctrl, alt);
}

void Panel::OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	XOnKeyRelease(key, scan, repeat, shift, ctrl, alt);
}

void Panel::OnMouseClick(int localx, int localy, unsigned button)
{
	XOnMouseClick(localx, localy, button);
}

void Panel::OnMouseDown(int x, int y, unsigned button)
{
	if (MouseDownInside)
	{
		auto localx = x - Position.X;
		auto localy = y - Position.Y;
		//check if clicked a child
		for(int i = children.size()-1; i >= 0 ; --i)
		{
			//child must be enabled
			if(children[i]->Enabled)
			{
				//is mouse inside?
				if( localx >= children[i]->Position.X + ViewportPosition.X &&
					localy >= children[i]->Position.Y + ViewportPosition.Y &&
					localx < children[i]->Position.X + ViewportPosition.X + children[i]->Size.X &&
					localy < children[i]->Position.Y + ViewportPosition.Y + children[i]->Size.Y )
				{
					GetParentWindow()->FocusComponent(children[i]);
					children[i]->MouseDownInside = true;
					break;
				}
			}
		}

		XOnMouseDown(x, y, button);
		for (size_t i = 0; i < children.size(); ++i)
		{
			if(children[i]->Enabled)
				children[i]->OnMouseDown(x - Position.X - ViewportPosition.X, y - Position.Y - ViewportPosition.Y, button);
		}
	}
}

void Panel::OnMouseHover(int localx, int localy)
{
	// check if hovering on children
	for (int i = children.size() - 1; i >= 0; --i)
	{
		if (children[i]->Enabled)
		{
			auto px = children[i]->Position.X + ViewportPosition.X;
			auto py = children[i]->Position.Y + ViewportPosition.Y;
			if( localx >= px &&
				localy >= py &&
				localx < px + children[i]->Size.X &&
				localy < py + children[i]->Size.Y )
			{
				children[i]->OnMouseHover(localx - px, localy - py);
				break;
			}
		}
	}

	// always allow hover on parent (?)
	XOnMouseHover(localx, localy);
}

void Panel::OnMouseMoved(int localx, int localy)
{
	PropagateMouseMove();
	XOnMouseMoved(localx, localy);
	for (size_t i = 0; i < children.size(); ++i)
	{
		if(children[i]->Enabled)
			children[i]->OnMouseMoved(localx - children[i]->Position.X - ViewportPosition.X, localy - children[i]->Position.Y - ViewportPosition.Y);
	}
}

void Panel::PropagateMouseMove()
{
	auto localx = ui::Engine::Ref().GetMouseX() - GetScreenPos().X;
	auto localy = ui::Engine::Ref().GetMouseY() - GetScreenPos().Y;
	for (size_t i = 0; i < children.size(); ++i)
	{
		if (children[i]->Enabled)
		{
			Point local	(localx - children[i]->Position.X - ViewportPosition.X, localy - children[i]->Position.Y - ViewportPosition.Y);

			// mouse currently inside?
			if( local.X >= 0 &&
				local.Y >= 0 &&
				local.X < children[i]->Size.X &&
				local.Y < children[i]->Size.Y )
			{
				children[i]->OnMouseMoved(localx - children[i]->Position.X - ViewportPosition.X, localy - children[i]->Position.Y - ViewportPosition.Y);

				// was the mouse outside?
				if (!children[i]->MouseInside)
				{
					children[i]->MouseInside = true;
					children[i]->OnMouseEnter(local.X, local.Y);
				}
			}
			// if not currently inside
			else
			{
				// was the mouse inside?
				if (children[i]->MouseInside)
				{
					children[i]->MouseInside = false;
					children[i]->OnMouseLeave(local.X, local.Y);
				}

			}
		}
	}
}

void Panel::OnMouseEnter(int localx, int localy)
{
	XOnMouseEnter(localx, localy);
}

void Panel::OnMouseLeave(int localx, int localy)
{
	XOnMouseLeave(localx, localy);
}

void Panel::OnMouseUp(int x, int y, unsigned button)
{
	auto localx = x - Position.X;
	auto localy = y - Position.Y;
	//check if clicked a child
	for(int i = children.size()-1; i >= 0 ; --i)
	{
		//child must be enabled
		if(children[i]->Enabled)
		{
			//is mouse inside?
			if( children[i]->MouseDownInside &&
				localx >= children[i]->Position.X + ViewportPosition.X &&
				localy >= children[i]->Position.Y + ViewportPosition.Y &&
				localx < children[i]->Position.X + ViewportPosition.X + children[i]->Size.X &&
				localy < children[i]->Position.Y + ViewportPosition.Y + children[i]->Size.Y )
			{
				children[i]->OnMouseClick(localx - children[i]->Position.X - ViewportPosition.X, localy - children[i]->Position.Y - ViewportPosition.Y, button);
				break;
			}
		}
	}
	for (auto *child : children)
	{
		child->MouseDownInside = false;
	}

	XOnMouseUp(x, y, button);
	for (size_t i = 0; i < children.size(); ++i)
	{
		if (children[i]->Enabled)
			children[i]->OnMouseUp(x - Position.X - ViewportPosition.X, y - Position.Y - ViewportPosition.Y, button);
	}
}

void Panel::OnMouseWheel(int localx, int localy, int d)
{
	XOnMouseWheel(localx, localy, d);
	for (size_t i = 0; i < children.size(); ++i)
	{
		if (children[i]->Enabled)
			children[i]->OnMouseWheel(localx - children[i]->Position.X - ViewportPosition.X, localy - children[i]->Position.Y - ViewportPosition.Y, d);
	}
}

void Panel::OnMouseWheelInside(int localx, int localy, int d)
{
	XOnMouseWheelInside(localx, localy, d);
	//check if clicked a child
	for (int i = children.size()-1; i >= 0 ; --i)
	{
		//child must be unlocked
		if (children[i]->Enabled)
		{
			//is mouse inside?
			if (localx >= children[i]->Position.X + ViewportPosition.X &&
				localy >= children[i]->Position.Y + ViewportPosition.Y &&
				localx < children[i]->Position.X + ViewportPosition.X + children[i]->Size.X &&
				localy < children[i]->Position.Y + ViewportPosition.Y + children[i]->Size.Y )
			{
				children[i]->OnMouseWheelInside(localx - children[i]->Position.X - ViewportPosition.X, localy - children[i]->Position.Y - ViewportPosition.Y, d);
				break;
			}
		}
	}
}

// ***** OVERRIDEABLES *****
// Kept empty.

void Panel::XDraw(const Point& screenPos)
{
}

void Panel::XTick()
{
}

void Panel::XOnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
}

void Panel::XOnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
}

void Panel::XOnMouseClick(int localx, int localy, unsigned button)
{
}

void Panel::XOnMouseDown(int x, int y, unsigned button)
{
}

void Panel::XOnMouseHover(int localx, int localy)
{
}

void Panel::XOnMouseMoved(int localx, int localy)
{
}

void Panel::XOnMouseEnter(int localx, int localy)
{
}

void Panel::XOnMouseLeave(int localx, int localy)
{
}

void Panel::XOnMouseUp(int x, int y, unsigned button)
{
}

void Panel::XOnMouseWheel(int localx, int localy, int d)
{
}

void Panel::XOnMouseWheelInside(int localx, int localy, int d)
{
}


=== src\gui\interface\Panel.h ===

#pragma once
#include "graphics/Pixel.h"
#include "gui/interface/Point.h"
#include "gui/interface/Component.h"
#include <vector>

class Graphics;
namespace ui
{
	/* class XComponent
	 *
	 * An eXtension of the Component class.
	 * Adds the ability to have child components.
	 *
	 * See sys::Component
	 */

	class Component;

	class Panel : public Component
	{
	public:
		friend class Component;

		ui::Point InnerSize;
		ui::Point ViewportPosition;

		Panel(Point position, Point size);
		virtual ~Panel();

		/* Add a child component.
		 * Similar to XComponent::SetParent
		 *
		 * If the component is already parented, then this will become the new parent.
		 */
		void AddChild(Component* c);

		// Remove child from component. This DOES NOT free the component from memory.
		void RemoveChild(Component* c);

		// Remove child from component. This WILL free the component from memory unless told otherwise.
		void RemoveChild(unsigned idx, bool freeMem = true);

		//Grab the number of children this component owns.
		int GetChildCount();

		//Get child of this component by index.
		Component* GetChild(unsigned idx);

		void Tick() override;
		void Draw(const Point& screenPos) override;

		void OnMouseHover(int localx, int localy) override;
		void OnMouseMoved(int localx, int localy) override;
		void OnMouseEnter(int localx, int localy) override;
		void OnMouseLeave(int localx, int localy) override;
		void OnMouseDown(int x, int y, unsigned button) override;
		void OnMouseUp(int x, int y, unsigned button) override;
		void OnMouseClick(int localx, int localy, unsigned button) override;
		void OnMouseWheel(int localx, int localy, int d) override;
		void OnMouseWheelInside(int localx, int localy, int d) override;
		void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
		void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;

	protected:
		// child components
		std::vector<ui::Component*> children;

		// Overridable. Called by XComponent::Tick()
		virtual void XTick();

		// Overridable. Called by XComponent::Draw()
		virtual void XDraw(const Point& screenPos);


		// Overridable. Called by XComponent::XOnMouseHover()
		virtual void XOnMouseHover(int localx, int localy);

		// Overridable. Called by XComponent::OnMouseMoved()
		virtual void XOnMouseMoved(int localx, int localy);

		// Overridable. Called by XComponent::OnMouseEnter()
		virtual void XOnMouseEnter(int localx, int localy);

		// Overridable. Called by XComponent::OnMouseLeave()
		virtual void XOnMouseLeave(int localx, int localy);

		// Overridable. Called by XComponent::OnMouseDown()
		virtual void XOnMouseDown(int x, int y, unsigned button);

		// Overridable. Called by XComponent::OnMouseUp()
		virtual void XOnMouseUp(int x, int y, unsigned button);

		// Overridable. Called by XComponent::OnMouseClick()
		virtual void XOnMouseClick(int localx, int localy, unsigned button);

		// Overridable. Called by XComponent::OnMouseWheel()
		virtual void XOnMouseWheel(int localx, int localy, int d);

		// Overridable. Called by XComponent::OnMouseWheelInside()
		virtual void XOnMouseWheelInside(int localx, int localy, int d);

		// Overridable. Called by XComponent::OnKeyPress()
		virtual void XOnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);

		// Overridable. Called by XComponent::OnKeyRelease()
		virtual void XOnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
		
		void PropagateMouseMove();
	};

}


=== src\gui\interface\Point.h ===

#pragma once

#include "common/Vec2.h"

namespace ui
{
	using Point = Vec2<int>;
}


=== src\gui\interface\ProgressBar.cpp ===

#include "ProgressBar.h"

#include "graphics/Graphics.h"

#include "gui/Style.h"
#include "gui/interface/Engine.h"

#include <algorithm>

using namespace ui;

ProgressBar::ProgressBar(Point position, Point size, int startProgress, String startStatus):
	Component(position, size),
	progress(0),
	intermediatePos(0.0f),
	progressStatus("")
{
	SetStatus(startStatus);
	SetProgress(startProgress);
}

void ProgressBar::SetProgress(int progress)
{
	this->progress = progress;
	if(this->progress > 100)
		this->progress = 100;
}

int ProgressBar::GetProgress()
{
	return progress;
}

void ProgressBar::SetStatus(String status)
{
	progressStatus = status;
}

String ProgressBar::GetStatus()
{
	return progressStatus;
}

void ProgressBar::Draw(const Point &screenPos)
{
	Graphics *g = GetGraphics();
	g->DrawRect(RectSized(screenPos, Size), 0xFFFFFF_rgb);
	auto inner = RectSized(screenPos + Vec2{ 2, 2 }, Size - Vec2{ 4, 4 });
	auto drawContent = [this, screenPos, g, inner](int beginX, int endX, ui::Colour bgColour, ui::Colour textColour) {
		auto clip = RectSized(inner.pos + Vec2{ beginX, 0 }, Vec2{ endX - beginX, inner.size.Y }) & g->GetClipRect();
		g->SwapClipRect(clip);
		if (bgColour.Alpha)
		{
			g->DrawFilledRect(inner, bgColour.NoAlpha());
		}
		g->BlendText(screenPos + Vec2{
			(Size.X - (Graphics::TextSize(progressStatus).X - 1)) / 2,
			(Size.Y - 8) / 2
		}, progressStatus, textColour);
		g->SwapClipRect(clip);
	};
	drawContent(0, inner.size.X, 0x000000_rgb .WithAlpha(0), 0xFFFFFF_rgb .WithAlpha(255));
	if (progress == -1)
	{
		constexpr auto size = 40;
		auto pos = int(inner.size.X * intermediatePos / 100);
		drawContent(pos, pos + size, style::Colour::WarningTitle, 0x000000_rgb .WithAlpha(255));
		pos -= inner.size.X;
		drawContent(pos, pos + size, style::Colour::WarningTitle, 0x000000_rgb .WithAlpha(255));
	}
	else
	{
		drawContent(0, inner.size.X * progress / 100, style::Colour::WarningTitle, 0x000000_rgb .WithAlpha(255));
	}
}

void ProgressBar::Tick()
{
	intermediatePos = float(std::fmod(ui::Engine::Ref().LastTick() * 0.06, 100.0));
}


=== src\gui\interface\ProgressBar.h ===

#pragma once

#include "Component.h"

namespace ui
{
	class ProgressBar: public Component
	{
		int progress;
		float intermediatePos;
		String progressStatus;
	public:
	ProgressBar(Point position, Point size, int startProgress = 0, String startStatus = String());
		void SetProgress(int progress);
		int GetProgress();
		void SetStatus(String status);
		String GetStatus();
		void Draw(const Point & screenPos) override;
		void Tick() override;
	};
}


=== src\gui\interface\RichLabel.cpp ===

#include "RichLabel.h"
#include "common/platform/Platform.h"
#include "Format.h"

using namespace ui;

RichLabel::RichLabel(Point position, Point size, String text) : Label(position, size, "")
{
	SetText(text);
}

void RichLabel::SetText(String newText)
{
	Label::SetText(newText);
	std::vector<RichTextRegion> newRegions;
	StringBuilder sb;
	auto it = newText.begin();
	while (it != newText.end())
	{
		auto find = [&newText](auto it, String::value_type ch) {
			while (it != newText.end())
			{
				if (*it == ch)
				{
					break;
				}
				++it;
			}
			return it;
		};
		auto beginRegionIt = find(it, '{');
		auto beginDataIt = find(beginRegionIt, ':');
		auto beginTextIt = find(beginDataIt, '|');
		auto endRegionIt = find(beginTextIt, '}');
		if (endRegionIt == newText.end())
		{
			break;
		}
		auto action = String(beginRegionIt + 1, beginDataIt);
		auto data = String(beginDataIt + 1, beginTextIt);
		auto text = String(beginTextIt + 1, endRegionIt);
		sb << String(it, beginRegionIt);
		auto good = false;
		if (action == "a" && data.size() && text.size())
		{
			RichTextRegion region;
			region.begin = sb.Size();
			sb << text;
			region.end = sb.Size();
			region.action = RichTextRegion::LinkAction{ data.ToUtf8() };
			newRegions.push_back(region);
			good = true;
		}
		if (!good)
		{
			sb << String(beginRegionIt, endRegionIt + 1);
		}
		it = endRegionIt + 1;
	}
	sb << String(it, newText.end());
	auto newDisplayText = sb.Build();
	Label::SetText(format::CleanString(newDisplayText, false, true, false));
	Label::SetDisplayText(newDisplayText);
	regions = newRegions;
}

void RichLabel::OnMouseDown(int x, int y, unsigned button)
{
	if (MouseDownInside)
	{
		int cursorPosition = displayTextWrapper.Point2Index(x - Position.X - textPosition.X, y - Position.Y - textPosition.Y).raw_index;
		for (auto const &region : regions)
		{
			if (region.begin <= cursorPosition && region.end > cursorPosition)
			{
				if (auto *linkAction = std::get_if<RichTextRegion::LinkAction>(&region.action))
				{
					Platform::OpenURI(linkAction->uri);
					return;
				}
			}
		}
	}
	Label::OnMouseDown(x, y, button);
}


=== src\gui\interface\RichLabel.h ===

#pragma once
#include "Label.h"
#include <vector>
#include <variant>

namespace ui
{
	class RichLabel : public Label
	{
		struct RichTextRegion
		{
			int begin;
			int end;
			struct LinkAction
			{
				ByteString uri;
			};
			using Action = std::variant<LinkAction>;
			Action action;
		};
		std::vector<RichTextRegion> regions;

	public:
		RichLabel(Point position, Point size, String text);

		void SetText(String newText) override;
		void OnMouseDown(int x, int y, unsigned button) override;
	};
}


=== src\gui\interface\SaveButton.cpp ===

#include "SaveButton.h"

#include "ContextMenu.h"
#include "Format.h"

#include "client/Client.h"
#include "client/ThumbnailRendererTask.h"
#include "client/SaveFile.h"
#include "client/SaveInfo.h"

#include "gui/dialogues/ErrorMessage.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"

#include "SimulationConfig.h"
#include <SDL.h>

namespace ui {

SaveButton::SaveButton(Point position, Point size) :
	Component(position, size),
	wantsDraw(false),
	triedThumbnail(false),
	isMouseInsideAuthor(false),
	isMouseInsideHistory(false),
	showVotes(false),
	thumbnailRenderer(nullptr),
	isButtonDown(false),
	isMouseInside(false),
	selected(false),
	selectable(false)
{
}

SaveButton::SaveButton(Point position, Point size, SaveInfo *newSave /* non-owning */) : SaveButton(position, size)
{
	save = newSave;
	if(save)
	{
		name = save->name;
		if (Graphics::TextSize(name).X - 1 > Size.X)
		{
			auto it = Graphics::TextFit(name, Size.X - (Appearance.icon ? 38 : 22));
			name.erase(it, name.end());
			name += "...";
		}

		String votes, icon;

		votes = String::Build(save->GetVotesUp()-save->GetVotesDown());
		icon += 0xE03B;
		for (size_t j = 1; j < votes.length(); j++)
			icon += 0xE03C;
		icon += 0xE039;
		icon += 0xE03A;

		votesBackground = icon;

		for (String::iterator iter = icon.begin(), end = icon.end(); iter != end; ++iter)
			*iter -= 14; // 0xE039 -> 0xE02B

		votesBackground2 = icon;

		for (String::iterator iter = votes.begin(), end = votes.end(); iter != end; ++iter)
			if(*iter != '-')
				*iter += 0xDFFF; // 0x30 -> 0xE02F

		votesString = votes;

		int voteMax = std::max(save->GetVotesUp(),save->GetVotesDown());
		if (voteMax)
		{
			if (voteMax < 34)
			{
				float ry = 33.0f/voteMax;
				if (voteMax<8)
					ry =  ry/(8-voteMax);
				voteBarHeightUp = (int)(save->GetVotesUp()*ry)-1;
				voteBarHeightDown = (int)(save->GetVotesDown()*ry)-1;
			}
			else
			{
				float ry = voteMax/33.0f;
				voteBarHeightUp = (int)(save->GetVotesUp()/ry)-1;
				voteBarHeightDown = (int)(save->GetVotesDown()/ry)-1;
			}
		}
		else
		{
			voteBarHeightUp = 0;
			voteBarHeightDown = 0;
		}
	}
}

SaveButton::SaveButton(Point position, Point size, SaveFile *newFile /* non-owning */) : SaveButton(position, size)
{
	file = newFile;
	if(file)
	{
		name = file->GetDisplayName();
		if (Graphics::TextSize(name).X - 1 > Size.X)
		{
			auto it = Graphics::TextFit(name, Size.X - (Appearance.icon ? 38 : 22));
			name.erase(it, name.end());
			name += "...";
		}
	}
}

SaveButton::~SaveButton()
{
	if (thumbnailRenderer)
	{
		thumbnailRenderer->Abandon();
	}
}

void SaveButton::Tick()
{
	if (!thumbnail)
	{
		if (!triedThumbnail && wantsDraw && ThumbnailRendererTask::QueueSize() < 10)
		{
			float scaleFactor = (Size.Y-25)/((float)YRES);
			ui::Point thumbBoxSize = ui::Point(int(XRES*scaleFactor), int(YRES*scaleFactor));
			if (save)
			{
				if(save->GetGameSave())
				{
					thumbnailRenderer = new ThumbnailRendererTask(*save->GetGameSave(), thumbBoxSize, RendererSettings::decorationEnabled, true);
					thumbnailRenderer->Start();
					triedThumbnail = true;
				}
				else if (save->GetID())
				{
					thumbnailRequest = std::make_unique<http::ThumbnailRequest>(save->GetID(), save->GetVersion(), thumbBoxSize);
					thumbnailRequest->Start();
					triedThumbnail = true;
				}
			}
			else if (file && file->GetGameSave())
			{
				thumbnailRenderer = new ThumbnailRendererTask(*file->GetGameSave(), thumbBoxSize, RendererSettings::decorationEnabled, false);
				thumbnailRenderer->Start();
				triedThumbnail = true;
			}
		}

		if (thumbnailRequest && thumbnailRequest->CheckDone())
		{
			try
			{
				thumbnail = thumbnailRequest->Finish();
			}
			catch (const http::RequestError &ex)
			{
				// TODO: handle
			}
			thumbnailRequest.reset();
		}

		if (thumbnailRenderer)
		{
			thumbnailRenderer->Poll();
			if (thumbnailRenderer->GetDone())
			{
				thumbnail = thumbnailRenderer->Finish();
				thumbnailRenderer = nullptr;
			}
		}

		if (thumbnail && file)
		{
			thumbSize = thumbnail->Size();
		}
	}
	if (file && !wantsDraw && !thumbnailRenderer)
	{
		file->LazyUnload();
	}
	wantsDraw = false;
}

void SaveButton::Draw(const Point& screenPos)
{
	Graphics * g = GetGraphics();
	float scaleFactor = (Size.Y-25)/((float)YRES);
	ui::Point thumbBoxSize = ui::Point(int(XRES*scaleFactor), int(YRES*scaleFactor));

	wantsDraw = true;

	if(selected && selectable)
	{
		g->BlendFilledRect(RectSized(screenPos, Size), 0x64AAFF_rgb .WithAlpha(100));
	}

	if (thumbnail)
	{
		//thumbBoxSize = ui::Point(thumbnail->Width, thumbnail->Height);
		auto *tex = thumbnail.get();
		auto space = Size - Vec2{ 0, 21 };
		g->BlendImage(tex->Data(), 255, RectSized(screenPos + ((save && save->id) ? ((space - thumbBoxSize) / 2 - Vec2{ 3, 0 }) : (space - thumbSize) / 2), tex->Size()));
	}
	else if (file && !file->LazyGetGameSave())
		g->BlendText(screenPos + Vec2{ (Size.X-(Graphics::TextSize("Error loading save").X - 1))/2, (Size.Y-28)/2 }, "Error loading save", 0xB4B4B4_rgb .WithAlpha(255));
	if(save)
	{
		if(save->id)
		{
			g->DrawRect(RectSized(screenPos + Vec2{                - 3, 0 } + (Size - thumbBoxSize - Vec2{ 0, 21 }) / 2,              thumbBoxSize), isMouseInside ? 0xD2E6FF_rgb : 0xB4B4B4_rgb);
			g->DrawRect(RectSized(screenPos + Vec2{ thumbBoxSize.X - 4, 0 } + (Size - thumbBoxSize - Vec2{ 0, 21 }) / 2, Vec2{ 7, thumbBoxSize.Y }), isMouseInside ? 0xD2E6FF_rgb : 0xB4B4B4_rgb);

			g->DrawFilledRect(RectSized(screenPos + Vec2{ -3+thumbBoxSize.X+(Size.X-thumbBoxSize.X)/2, 1+(Size.Y-20-thumbBoxSize.Y)/2 }, Vec2{ 5, (thumbBoxSize.Y+1)/2-1 }), 0x006B0A_rgb);
			g->DrawFilledRect(RectSized(screenPos + Vec2{ -3+thumbBoxSize.X+(Size.X-thumbBoxSize.X)/2, (Size.Y-20)/2 }, Vec2{ 5, thumbBoxSize.Y/2-1 }), 0x6B0A00_rgb);

			g->DrawFilledRect(RectSized(screenPos + Vec2{ -2+thumbBoxSize.X+(Size.X-thumbBoxSize.X)/2, (Size.Y-20)/2-voteBarHeightUp }, Vec2{ 3, voteBarHeightUp }), 0x39BB39_rgb); //green
			g->DrawFilledRect(RectSized(screenPos + Vec2{ -2+thumbBoxSize.X+(Size.X-thumbBoxSize.X)/2, (Size.Y-20)/2 }, Vec2{ 3, voteBarHeightDown }), 0xBB3939_rgb); //red
		}
		else
		{
			g->DrawRect(RectSized(screenPos + (Size - thumbBoxSize - Vec2{ 0, 21 }) / 2, thumbBoxSize), isMouseInside ? 0xD2E6FF_rgb : 0xB4B4B4_rgb);
		}

		g->BlendText(screenPos + Vec2{ (Size.X-(Graphics::TextSize(name).X - 1))/2, Size.Y - 21 }, name, (isMouseInside && !isMouseInsideAuthor) ? 0xFFFFFF_rgb .WithAlpha(255) : 0xB4B4B4_rgb .WithAlpha(255));
		g->BlendText(screenPos + Vec2{ (Size.X-(Graphics::TextSize(save->userName.FromUtf8()).X - 1))/2, Size.Y - 10 }, save->userName.FromUtf8(), isMouseInsideAuthor ? 0xC8E6FF_rgb .WithAlpha(255) : 0x6482A0_rgb .WithAlpha(255));
		if (showVotes)// && !isMouseInside)
		{
			int x = screenPos.X-7+(Size.X-thumbBoxSize.X)/2+thumbBoxSize.X-(Graphics::TextSize(votesBackground).X - 1);
			int y = screenPos.Y-23+(Size.Y-thumbBoxSize.Y)/2+thumbBoxSize.Y;
			g->BlendText({ x, y }, votesBackground, 0x104810_rgb .WithAlpha(255));
			g->BlendText({ x, y }, votesBackground2, 0xC0C0C0_rgb .WithAlpha(255));
			g->BlendText({ x+3, y }, votesString, 0xFFFFFF_rgb .WithAlpha(255));
		}
		if (isMouseInside)
		{
			int x = screenPos.X;
			int y = screenPos.Y-15+(Size.Y-thumbBoxSize.Y)/2+thumbBoxSize.Y;
			g->DrawFilledRect(RectSized(Vec2{ x+1, y+1 }, Vec2{ 7, 8 }), 0xFFFFFF_rgb);
			g->BlendText({ x, y }, 0xE026, isMouseInsideHistory ? 0xC86450_rgb .WithAlpha(255) : 0xA04632_rgb .WithAlpha(255));
		}
		if (!save->GetPublished())
		{
			g->BlendText(screenPos - Vec2{ 0, 2 }, 0xE04D, 0xFFFFFF_rgb .WithAlpha(255));
			g->BlendText(screenPos - Vec2{ 0, 2 }, 0xE04E, 0xD49751_rgb .WithAlpha(255));
		}
	}
	else if (file)
	{
		g->DrawRect(RectSized(screenPos + (Size - thumbBoxSize- Vec2{ 0, 21 }) / 2, thumbBoxSize), isMouseInside ? 0xD2E6FF_rgb : 0xB4B4B4_rgb);
		if (thumbSize.X)
			g->XorDottedRect(RectSized(screenPos + (Size - thumbSize - Vec2{ 0, 21 }) / 2, thumbSize));

		g->BlendText(screenPos + Vec2{ (Size.X-(Graphics::TextSize(name).X - 1))/2, Size.Y - 21 }, name, isMouseInside ? 0xFFFFFF_rgb .WithAlpha(255) : 0xB4B4B4_rgb .WithAlpha(255));
	}

	if(isMouseInside && selectable)
	{
		g->DrawFilledRect(RectSized(screenPos + Vec2{ Size.X - 19, 7 }, Vec2{ 13, 13 }), 0x000000_rgb);
		g->DrawRect(RectSized(screenPos + Vec2{ Size.X-20, 6 }, Vec2{ 14, 14 }), 0xFFFFFF_rgb);
		if(selected)
			g->DrawFilledRect(RectSized(screenPos + Vec2{ Size.X-18, 8 }, Vec2{ 10, 10 }), 0xFFFFFF_rgb);
	}
}

void SaveButton::OnMouseClick(int x, int y, unsigned int button)
{
	if(button != 1)
	{
		return; //left click only!
	}
	if (file && !file->LazyGetGameSave())
	{
		new ErrorMessage("Error loading save", file->GetError());
		return;
	}

	if(x>=Size.X-20 && y>=6 && y<=20 && x<=Size.X-6 && selectable)
	{
		selected = !selected;
		DoSelection();
		return;
	}

	if(isButtonDown)
	{
		isButtonDown = false;
		if(isMouseInsideHistory)
			DoAltAction();
		else if(isMouseInsideAuthor)
			DoAltAction2();
		else
			DoAction();
	}
}

void SaveButton::AddContextMenu(int menuType)
{
	if (menuType == 0) //Save browser
	{
		menu = new ContextMenu(this);
		menu->AddItem(ContextMenuItem("Open", 0, true));
		if (Client::Ref().GetAuthUser().UserID)
			menu->AddItem(ContextMenuItem("Select", 1, true));
		menu->AddItem(ContextMenuItem("View History", 2, true));
		menu->AddItem(ContextMenuItem("More by this user", 3, true));
	}
	else if (menuType == 1) //Local save browser
	{
		menu = new ContextMenu(this);
		menu->AddItem(ContextMenuItem("Open", 0, true));
		menu->AddItem(ContextMenuItem("Rename", 2, true));
		menu->AddItem(ContextMenuItem("Delete", 3, true));
	}
}

void SaveButton::OnContextMenuAction(int item)
{
	switch(item)
	{
	case 0:
		DoAction();
		break;
	case 1:
		selected = !selected;
		DoSelection();
		break;
	case 2:
		DoAltAction();
		break;
	case 3:
		DoAltAction2();
		break;
	}
}

void SaveButton::OnMouseDown(int x, int y, unsigned int button)
{
	if (MouseDownInside)
	{
		if(button == SDL_BUTTON_RIGHT)
		{
			if(menu)
				menu->Show(GetContainerPos() + ui::Point(x, y));
		}
		else
		{
			isButtonDown = true;
			if(button !=1 && selectable)
			{
				selected = !selected;
				DoSelection();
			}

		}
	}
}

void SaveButton::OnMouseMoved(int x, int y)
{
	isMouseInsideAuthor = false;
	isMouseInsideHistory = false;
	if (MouseInside)
	{
		if (y > Size.Y-11)
			isMouseInsideAuthor = true;

		if (y > Size.Y-29 && y < Size.Y - 18 && x > 0 && x < 9)
			isMouseInsideHistory = true;
	}
}

void SaveButton::OnMouseEnter(int x, int y)
{
	isMouseInside = true;
}

void SaveButton::OnMouseLeave(int x, int y)
{
	isMouseInside = false;
	isMouseInsideAuthor = false;
	isMouseInsideHistory = false;
}

void SaveButton::DoAltAction()
{
	if (actionCallback.altAction)
		actionCallback.altAction();
}

void SaveButton::DoAltAction2()
{
	if (actionCallback.altAltAction)
		actionCallback.altAltAction();
}

void SaveButton::DoAction()
{
	if (actionCallback.action)
		actionCallback.action();
}

void SaveButton::DoSelection()
{
	if(menu)
	{
		if(selected)
			menu->SetItem(1, "Deselect");
		else
			menu->SetItem(1, "Select");
	}
	if (selectable && actionCallback.selected)
		actionCallback.selected();
}

std::unique_ptr<VideoBuffer> SaveButton::CloneThumbnail() const
{
	if (thumbnail)
	{
		return std::make_unique<VideoBuffer>(*thumbnail);
	}
	return nullptr;
}

} /* namespace ui */


=== src\gui\interface\SaveButton.h ===

#pragma once
#include "common/String.h"

#include "Component.h"
#include "client/http/ThumbnailRequest.h"

#include <memory>
#include <functional>

class VideoBuffer;
class SaveFile;
class SaveInfo;
class ThumbnailRendererTask;
namespace ui
{
class SaveButton : public Component
{
	SaveFile *file = nullptr; // non-owning
	SaveInfo *save = nullptr; // non-owning
	std::unique_ptr<VideoBuffer> thumbnail;
	ui::Point thumbSize = ui::Point(0, 0);
	String name;
	String votesString;
	String votesBackground;
	String votesBackground2;
	int voteBarHeightUp;
	int voteBarHeightDown;
	bool wantsDraw;
	bool triedThumbnail;
	bool isMouseInsideAuthor;
	bool isMouseInsideHistory;
	bool showVotes;
	ThumbnailRendererTask *thumbnailRenderer;

	std::unique_ptr<http::ThumbnailRequest> thumbnailRequest;

	struct SaveButtonAction
	{
		std::function<void ()> action, altAction, altAltAction, selected;
	};
	SaveButtonAction actionCallback;

	SaveButton(Point position, Point size);

public:
	SaveButton(Point position, Point size, SaveInfo *newSave /* non-owning */);
	SaveButton(Point position, Point size, SaveFile *newFile /* non-owning */);
	virtual ~SaveButton();

	void OnMouseClick(int x, int y, unsigned int button) override;
	void OnMouseDown(int x, int y, unsigned int button) override;

	void OnMouseEnter(int x, int y) override;
	void OnMouseLeave(int x, int y) override;

	void OnMouseMoved(int x, int y) override;

	void AddContextMenu(int menuType);
	void OnContextMenuAction(int item) override;

	void Draw(const Point& screenPos) override;
	void Tick() override;

	void SetSelected(bool selected_) { selected = selected_; }
	bool GetSelected() { return selected; }
	void SetSelectable(bool selectable_) { selectable = selectable_; }
	bool GetSelectable() { return selectable; }
	void SetShowVotes(bool showVotes_) { showVotes = showVotes_; }

	const SaveInfo *GetSave() const { return save; }
	const SaveFile *GetSaveFile() const { return file; }
	inline bool GetState() { return state; }
	void DoAction();
	void DoAltAction();
	void DoAltAction2();
	void DoSelection();
	inline void SetActionCallback(SaveButtonAction action) { actionCallback = action; }

	// TODO: clone the request instead because sometimes the user of CloneThumbnail might end up
	// with a nullptr even though the thumbnail for the SaveButton will eventually arrive.
	std::unique_ptr<VideoBuffer> CloneThumbnail() const;

protected:
	bool isButtonDown, state, isMouseInside, selected, selectable;
};
}


=== src\gui\interface\ScrollPanel.cpp ===

#include "ScrollPanel.h"
#include "Engine.h"
#include "graphics/Graphics.h"
#include "Misc.h"
#include "PowderToySDL.h"
#include "Window.h"
#include <algorithm>

using namespace ui;

ScrollPanel::ScrollPanel(Point position, Point size):
	Panel(position, size),
	scrollBarWidth(0),
	maxOffset(0, 0),
	offsetX(0),
	offsetY(0),
	isMouseInsideScrollbar(false),
	isMouseInsideScrollbarArea(false),
	scrollbarSelected(false),
	scrollbarInitialYOffset(0),
	scrollbarInitialYClick(0),
	scrollbarClickLocation(0),
	scrollLastTick(int64_t(Engine::Ref().LastTick()))
{
}

int ScrollPanel::GetScrollLimit()
{
	if (ViewportPosition.Y == 0)
		return -1;
	else if (maxOffset.Y == -ViewportPosition.Y)
		return 1;
	return 0;
}

void ScrollPanel::SetScrollPosition(int position)
{
	offsetY = float(position);
	ViewportPosition.Y = -position;
}

void ScrollPanel::XOnMouseWheelInside(int localx, int localy, int d)
{
	if (!d)
		return;
	if (ui::Engine::Ref().MomentumScroll)
		yScrollVel.SetValue(yScrollVel.GetValue() - d * 2);
	else
		yScrollVel.SetValue(yScrollVel.GetValue() - d * 20);
}

void ScrollPanel::Draw(const Point& screenPos)
{
	Panel::Draw(screenPos);

	Graphics * g = GetGraphics();

	//Vertical scroll bar
	if (maxOffset.Y>0 && InnerSize.Y>0)
	{
		float scrollHeight = float(Size.Y)*(float(Size.Y)/float(InnerSize.Y));
		float scrollPos = 0;
		if (-ViewportPosition.Y>0)
		{
			scrollPos = float(Size.Y-scrollHeight)*(float(offsetY)/float(maxOffset.Y));
		}

		g->BlendFilledRect(RectSized(screenPos + Vec2{ Size.X - scrollBarWidth, 0 }, { scrollBarWidth, Size.Y }), 0x7D7D7D_rgb .WithAlpha(100));
		g->DrawFilledRect(RectSized(screenPos + Vec2{ Size.X - scrollBarWidth, int(scrollPos) }, { scrollBarWidth, int(scrollHeight)+1 }), 0xFFFFFF_rgb);
	}
}

void ScrollPanel::XOnMouseDown(int x, int y, unsigned int button)
{
	if (MouseDownInside)
	{
		CancelPanning();
		if (isMouseInsideScrollbar)
		{
			scrollbarSelected = true;
			scrollbarInitialYOffset = int(offsetY);
		}
		initialOffsetY = int(offsetY);
		scrollbarInitialYClick = y - Position.Y;
		scrollbarClickLocation = 100;
	}
}

void ScrollPanel::CancelPanning()
{
	panning = false;
	panHistory = {};
	yScrollVel = 0;
}

void ScrollPanel::XOnMouseUp(int x, int y, unsigned int button)
{
	scrollbarSelected = false;
	auto oldPanHistory = panHistory;
	CancelPanning();
	{
		auto it = oldPanHistory.end();
		while (it != oldPanHistory.begin() && *(it - 1))
		{
			--it;
		}
		if (it < oldPanHistory.end())
		{
			auto offsetYDiff = oldPanHistory.back()->offsetY - (*it)->offsetY;
			auto tickDiff = oldPanHistory.back()->ticks - (*it)->ticks;
			yScrollVel.SetValue(yScrollVel.GetValue() + offsetYDiff / tickDiff * (1000.f / Engine::Ref().GetFps()));
		}
	}
	isMouseInsideScrollbarArea = false;
	scrollbarClickLocation = 0;
}

void ScrollPanel::XOnMouseMoved(int x, int y)
{
	if(maxOffset.Y>0 && InnerSize.Y>0)
	{
		auto oldViewportPositionY = ViewportPosition.Y;
		float scrollHeight = float(Size.Y)*(float(Size.Y)/float(InnerSize.Y));
		float scrollPos = 0;
		if (-ViewportPosition.Y>0)
		{
			scrollPos = float(Size.Y-scrollHeight)*(float(offsetY)/float(maxOffset.Y));
		}

		if (scrollbarSelected)
		{
			if (x > 0)
			{
				auto scrollY = int(float(y-scrollbarInitialYClick)/float(Size.Y)*float(InnerSize.Y)+scrollbarInitialYOffset);
				ViewportPosition.Y = -scrollY;
				offsetY = float(scrollY);
			}
			else
			{
				ViewportPosition.Y = -scrollbarInitialYOffset;
				offsetY = float(scrollbarInitialYOffset);
			}
		}
		else if (MouseDownInside)
		{
			Vec2<int> mouseAt{ x, y };
			if (Engine::Ref().TouchUI && iabs(scrollbarInitialYClick - mouseAt.Y) > PanOffsetThreshold)
			{
				panning = true;
				for (auto *child : children)
				{
					child->MouseDownInside = false;
				}
				GetParentWindow()->FocusComponent(nullptr);
			}
		}

		if (x > (Size.X-scrollBarWidth) && x < Size.X)
		{
			isMouseInsideScrollbar = y > scrollPos && y < scrollPos+scrollHeight;
			isMouseInsideScrollbarArea = true;
		}
		else
			isMouseInsideScrollbar = isMouseInsideScrollbarArea = false;

		if (oldViewportPositionY != ViewportPosition.Y)
		{
			PropagateMouseMove();
		}
	}
}

void ScrollPanel::XTick()
{
	auto oldViewportPositionY = ViewportPosition.Y;

	if (panning)
	{
		auto scrollY = initialOffsetY + scrollbarInitialYClick - (Engine::Ref().GetMouseY() - GetScreenPos().Y);
		ViewportPosition.Y = -scrollY;
		offsetY = float(scrollY);
		PanPoint p{ offsetY, GetTicks() };
		if (!(panHistory.back() && panHistory.back()->ticks == p.ticks))
		{
			std::copy(panHistory.begin() + 1, panHistory.end(), panHistory.begin());
			panHistory.back() = p;
		}
	}

	if (xScrollVel > 7.0f) xScrollVel = 7.0f;
	if (xScrollVel < -7.0f) xScrollVel = -7.0f;
	if (xScrollVel > -0.5f && xScrollVel < 0.5)
		xScrollVel = 0;

	maxOffset = InnerSize-Size;
	maxOffset.Y = std::max(0, maxOffset.Y);
	maxOffset.X = std::max(0, maxOffset.X);

	auto oldOffsetY = int(offsetY);
	{
		// the correct way to do this would be to add another profile to ui::Fade that analytically
		// integrates the value of the fade and assign that here; way too much hassle for now though
		auto now = int64_t(Engine::Ref().LastTick());
		auto diff = now - scrollLastTick;
		scrollLastTick = now;
		offsetY += yScrollVel * diff * 0.06f;
		offsetX += xScrollVel * diff * 0.06f;
	}


	if (!ui::Engine::Ref().MomentumScroll)
	{
		yScrollVel = 0.0f;
		xScrollVel = 0.0f;
	}


	if (oldOffsetY!=int(offsetY))
	{
		if (offsetY<0)
		{
			offsetY = 0;
			yScrollVel = 0;
		}
		else if (offsetY>maxOffset.Y)
		{
			offsetY = float(maxOffset.Y);
			yScrollVel = 0;
		}
		ViewportPosition.Y = -int(offsetY);
	}
	else
	{
		if (offsetY<0)
		{
			offsetY = 0;
			yScrollVel = 0;
			ViewportPosition.Y = -int(offsetY);
		}
		else if (offsetY>maxOffset.Y)
		{
			offsetY = float(maxOffset.Y);
			ViewportPosition.Y = -int(offsetY);
		}
	}

	if (MouseInside && scrollBarWidth < 6)
		scrollBarWidth++;
	else if (!MouseInside && scrollBarWidth > 0 && !scrollbarSelected)
		scrollBarWidth--;

	if (isMouseInsideScrollbarArea && scrollbarClickLocation && !scrollbarSelected)
	{
		float scrollHeight = float(Size.Y)*(float(Size.Y)/float(InnerSize.Y));
		float scrollPos = 0;
		if (-ViewportPosition.Y > 0)
			scrollPos = float(Size.Y-scrollHeight)*(float(offsetY)/float(maxOffset.Y));

		if (scrollbarInitialYClick <= scrollPos)
			scrollbarClickLocation = -1;
		else if (scrollbarInitialYClick >= scrollPos+scrollHeight)
			scrollbarClickLocation = 1;
		else
			scrollbarClickLocation = 0;

		offsetY += scrollbarClickLocation*scrollHeight/10;
		ViewportPosition.Y -= int(scrollbarClickLocation*scrollHeight/10);
	}

	if (oldViewportPositionY != ViewportPosition.Y)
	{
		PropagateMouseMove();
	}
}


=== src\gui\interface\ScrollPanel.h ===

#pragma once
#include "Panel.h"
#include "Fade.h"
#include <optional>
#include <array>

namespace ui
{
	class ScrollPanel: public Panel
	{
		void CancelPanning();

	protected:
		int scrollBarWidth;
		Point maxOffset;
		float offsetX;
		float offsetY;
		ui::Fade yScrollVel{ ui::Fade::ExponentialProfile{ 0.297553f, 0.5f }, 0, 0 };
		ui::Fade xScrollVel{ ui::Fade::ExponentialProfile{ 0.297553f, 0.5f }, 0, 0 };
		bool isMouseInsideScrollbar;
		bool isMouseInsideScrollbarArea;
		bool scrollbarSelected;
		int scrollbarInitialYOffset;
		int scrollbarInitialYClick;
		int scrollbarClickLocation;
		int64_t scrollLastTick;
		int initialOffsetY;
		bool panning = false;
		static constexpr int PanOffsetThreshold = 10;
		static constexpr int PanHistorySize = 5;
		struct PanPoint
		{
			float offsetY;
			unsigned int ticks;
		};
		std::array<std::optional<PanPoint>, PanHistorySize> panHistory;
	public:
		ScrollPanel(Point position, Point size);

		int GetScrollLimit();
		void SetScrollPosition(int position);

		void Draw(const Point& screenPos) override;
		void XTick() override;
		void XOnMouseWheelInside(int localx, int localy, int d) override;
		void XOnMouseDown(int localx, int localy, unsigned int button) override;
		void XOnMouseUp(int x, int y, unsigned int button) override;
		void XOnMouseMoved(int localx, int localy) override;
	};
}


=== src\gui\interface\Separator.cpp ===

#include "Separator.h"
#include "graphics/Graphics.h"

namespace ui
{

void Separator::Draw(const ui::Point& screenPos)
{
	GetGraphics()->BlendRect(RectSized(screenPos, Size), 0xFFFFFF_rgb .WithAlpha(180));
}

}

=== src\gui\interface\Separator.h ===

#pragma once
#include "Component.h"

namespace ui
{

class Separator : public Component
{
public:
	Separator(ui::Point position, ui::Point size) : Component(position, size)
	{ }

	void Draw(const ui::Point& screenPos) override;
};

}

=== src\gui\interface\Slider.cpp ===

#include "Slider.h"
#include "graphics/Graphics.h"
#include "graphics/Gradient.h"

namespace ui {

Slider::Slider(Point position, Point size, int steps):
		Component(position, size),
		sliderSteps(steps),
		sliderPosition(0),
		isMouseDown(false),
		col1(0, 0, 0, 0),
		col2(0, 0, 0, 0)
{

}

void Slider::updatePosition(int position)
{
	if(position < 3)
		position = 3;
	if(position > Size.X-3)
		position = Size.X-3;

	auto fPosition = float(position-3);
	auto fSize = float(Size.X-6);

	float fSliderPosition = (fPosition/fSize)*sliderSteps;//position;//((x-3)/(Size.X-6))*sliderSteps;

	auto newSliderPosition = int(fSliderPosition);

	if(newSliderPosition == sliderPosition)
		return;

	sliderPosition = newSliderPosition;

	if (actionCallback.change)
	{
		actionCallback.change();
	}
}

void Slider::OnMouseMoved(int x, int y)
{
	if(isMouseDown)
	{
		updatePosition(x);
	}
}

void Slider::OnMouseDown(int x, int y, unsigned button)
{
	if (MouseDownInside)
	{
		isMouseDown = true;
		updatePosition(x - Position.X);
	}
}

void Slider::OnMouseUp(int x, int y, unsigned button)
{
	if(isMouseDown)
	{
		isMouseDown = false;
	}
}


void Slider::SetColour(Colour col1, Colour col2)
{
	this->col1 = col1;
	this->col2 = col2;
	bgGradient = Gradient({
		{ col1.NoAlpha(), 0.f },
		{ col2.NoAlpha(), 1.f },
	}, Size.X-7);
}

int Slider::GetValue()
{
	return sliderPosition;
}

void Slider::SetValue(int value)
{
	if(value < 0)
		value = 0;
	if(value > sliderSteps)
		value = sliderSteps;
	sliderPosition = value;
}

int Slider::GetSteps()
{
	return sliderSteps;
}

void Slider::SetSteps(int steps)
{
	if(steps < 0)
		steps = 0;
	if(steps < sliderPosition)
		sliderPosition = steps;
	sliderSteps = steps;
}

void Slider::Draw(const Point& screenPos)
{
	Graphics * g = GetGraphics();

	if (bgGradient.size())
	{
		for (int j = 3; j < Size.Y-7; j++)
		{
			for (int i = 3; i < Size.X-7; i++)
			{
				g->DrawPixel(screenPos + Vec2{ i + 2, j + 2 }, bgGradient[i - 3]);
			}
		}
	}

	g->DrawRect(RectSized(screenPos + Vec2{ 3, 3 }, Size - Vec2{ 6, 6 }), 0xFFFFFF_rgb);

	auto fPosition = float(sliderPosition);
	auto fSize = float(Size.X-6);
	auto fSteps = float(sliderSteps);

	auto fSliderX = (fSize/fSteps)*fPosition;//sliderPosition;//((Size.X-6)/sliderSteps)*sliderPosition;
	auto sliderX = int(fSliderX);
	sliderX += 3;

	g->DrawFilledRect(RectSized(screenPos + Vec2{ sliderX-2, 1 }, Vec2{ 4, Size.Y-2 }), 0x141414_rgb);
	g->DrawRect(RectSized(screenPos + Vec2{ sliderX-2, 1 }, Vec2{ 4, Size.Y-2 }), 0xC8C8C8_rgb);
}

} /* namespace ui */


=== src\gui\interface\Slider.h ===

#pragma once
#include "Component.h"
#include "Colour.h"
#include "graphics/Pixel.h"
#include <functional>

namespace ui {
class Slider : public ui::Component
{
	int sliderSteps;
	int sliderPosition;
	bool isMouseDown;
	std::vector<RGB> bgGradient;

	struct SliderAction
	{
		std::function<void ()> change;
	};
	SliderAction actionCallback;

	Colour col1, col2;
	void updatePosition(int position);
public:
	Slider(Point position, Point size, int steps);
	virtual ~Slider() = default;

	void OnMouseMoved(int x, int y) override;
	void OnMouseDown(int x, int y, unsigned button) override;
	void OnMouseUp(int x, int y, unsigned button) override;
	void Draw(const Point& screenPos) override;
	void SetColour(Colour col1, Colour col2);
	inline void SetActionCallback(SliderAction action) { actionCallback = action; }
	int GetValue();
	void SetValue(int value);
	int GetSteps();
	void SetSteps(int steps);
};

} /* namespace ui */


=== src\gui\interface\Spinner.cpp ===

#include "Spinner.h"
#include "graphics/Graphics.h"
#include "Engine.h"
#include <cmath>

using namespace ui;

Spinner::Spinner(Point position, Point size):
	Component(position, size)
{
}
void Spinner::Draw(const Point& screenPos)
{
	Graphics * g = GetGraphics();
	int baseX = screenPos.X+(Size.X/2);
	int baseY = screenPos.Y+(Size.Y/2);
	int lineInner = (Size.X/2);
	int lineOuter = (Size.X/2)+3;
	auto cValue = std::floor(ui::Engine::Ref().LastTick() * 0.015) * 0.25;
	for(double t = 0.0; t < 6.0; t+=0.25)
	{
		g->DrawLine(
			{ int(baseX+(std::sin(cValue+t)*lineInner)), int(baseY+(std::cos(cValue+t)*lineInner)) },
			{ int(baseX+(std::sin(cValue+t)*lineOuter)), int(baseY+(std::cos(cValue+t)*lineOuter)) },
			RGB(int((t/6)*255), int((t/6)*255), int((t/6)*255)));
	}
}
Spinner::~Spinner()
{

}


=== src\gui\interface\Spinner.h ===

#pragma once
#include "Component.h"

namespace ui
{

class Spinner: public Component
{
public:
	Spinner(Point position, Point size);
	void Draw(const Point& screenPos) override;
	virtual ~Spinner();
};

}



=== src\gui\interface\Textbox.cpp ===

#include "Textbox.h"
#include "Format.h"
#include "PowderToySDL.h"
#include "common/platform/Platform.h"
#include "graphics/FontReader.h"
#include "graphics/Graphics.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Point.h"
#include "ContextMenu.h"
#include <SDL.h>

using namespace ui;

Textbox::Textbox(Point position, Point size, String textboxText, String textboxPlaceholder):
	Label(position, size, ""),
	ReadOnly(false),
	inputType(All),
	limit(String::npos),
	keyDown(0),
	characterDown(0),
	mouseDown(false),
	masked(false),
	border(true),
	inputRectPosition(0, 0),
	textEditing(false)
{
	DoesTextInput = true;
	placeHolder = textboxPlaceholder;

	SetText(textboxText);
	cursor = text.length();

	menu->RemoveItem(0);
	menu->AddItem(ContextMenuItem("Cut", 1, true));
	menu->AddItem(ContextMenuItem("Copy", 0, true));
	menu->AddItem(ContextMenuItem("Paste", 2, true));
}

void Textbox::SetHidden(bool hidden)
{
	menu->RemoveItem(0);
	menu->RemoveItem(1);
	menu->RemoveItem(2);
	menu->AddItem(ContextMenuItem("Cut", 1, !hidden));
	menu->AddItem(ContextMenuItem("Copy", 0, !hidden));
	menu->AddItem(ContextMenuItem("Paste", 2, true));

	masked = hidden;
}

void Textbox::SetPlaceholder(String text)
{
	placeHolder = text;
}

void Textbox::SetText(String newText)
{
	StopTextEditing();

	backingText = newText;

	if(masked)
	{
		String maskedText = newText;
		std::fill(maskedText.begin(), maskedText.end(), 0xE00D);
		Label::SetText(maskedText);
	}
	else
		Label::SetText(newText);

	cursor = newText.length();

	resetCursorPosition();
}

Textbox::ValidInput Textbox::GetInputType()
{
	return inputType;
}

void Textbox::SetInputType(ValidInput input)
{
	inputType = input;
}

void Textbox::SetLimit(size_t limit)
{
	this->limit = limit;
}

size_t Textbox::GetLimit()
{
	return limit;
}

String Textbox::GetText()
{
	return backingText;
}

void Textbox::OnContextMenuAction(int item)
{
	StopTextEditing();

	switch(item)
	{
	case 0:
		copySelection();
		break;
	case 1:
		cutSelection();
		break;
	case 2:
		pasteIntoSelection();
		break;
	}
}

void Textbox::resetCursorPosition()
{
	if(cursor)
	{
		textWrapper.Index2Point(textWrapper.Clear2Index(cursor), cursorPositionX, cursorPositionY);
	}
	else
	{
		cursorPositionY = cursorPositionX = 0;
	}
}

void Textbox::TabFocus()
{
	GetParentWindow()->FocusComponent(this);
	selectAll();
}

void Textbox::cutSelection()
{
	StopTextEditing();

	if (HasSelection())
	{
		if (getLowerSelectionBound() < 0 || getHigherSelectionBound() > (int)backingText.length())
			return;
		String toCopy = backingText.Between(getLowerSelectionBound(), getHigherSelectionBound());
		ClipboardPush(format::CleanString(toCopy, false, true, false).ToUtf8());
		backingText.erase(backingText.begin()+getLowerSelectionBound(), backingText.begin()+getHigherSelectionBound());
		cursor = getLowerSelectionBound();
	}
	else
	{
		if (!backingText.length())
			return;
		ClipboardPush(format::CleanString(backingText, false, true, false).ToUtf8());
		backingText.clear();
		cursor = 0;
	}
	ClearSelection();

	if(masked)
	{
		String maskedText = backingText;
		std::fill(maskedText.begin(), maskedText.end(), 0xE00D);
		Label::SetText(maskedText);
	}
	else
	{
		text = backingText;
	}

	updateTextWrapper();
	updateSelection();
	TextPosition(displayTextWrapper.WrappedText());

	resetCursorPosition();
	if (actionCallback.change)
		actionCallback.change();
}

void Textbox::pasteIntoSelection()
{
	StopTextEditing();

	String newText = format::CleanString(ClipboardPull().FromUtf8(), false, true, inputType != Multiline, inputType == Number || inputType == Numeric);
	if (HasSelection())
	{
		if (getLowerSelectionBound() < 0 || getHigherSelectionBound() > (int)backingText.length())
			return;
		backingText.EraseBetween(getLowerSelectionBound(), getHigherSelectionBound());
		cursor = getLowerSelectionBound();
	}

	if (limit != String::npos)
	{
		newText = newText.Substr(0, limit-backingText.length());
	}

	backingText.Insert(cursor, newText);
	cursor = cursor+newText.length();
	ClearSelection();

	if(masked)
	{
		String maskedText = backingText;
		std::fill(maskedText.begin(), maskedText.end(), 0xE00D);
		Label::SetText(maskedText);
	}
	else
	{
		text = backingText;
	}

	updateTextWrapper();
	updateSelection();
	TextPosition(displayTextWrapper.WrappedText());

	resetCursorPosition();
	if (actionCallback.change)
		actionCallback.change();
}

bool Textbox::CharacterValid(int character)
{
	switch(inputType)
	{
		case Numeric:
			if (character == '-' && cursor == 0 && backingText[0] != '-')
				return true;
		case Number:
			return (character >= '0' && character <= '9');
		case Multiline:
			if (character == '\n')
				return true;
		case All:
		default:
			return character >= ' ' && character <= 0x10FFFF && !(character >= 0xD800 && character <= 0xDFFF) && !(character >= 0xFDD0 && character <= 0xFDEF) && !((character & 0xFFFF) >= 0xFFFE);
	}
	return false;
}

// TODO: proper unicode validation
bool Textbox::StringValid(String text)
{
	for (String::value_type c : text)
		if (!CharacterValid(c))
			return false;
	return true;
}

void Textbox::Tick()
{
	Label::Tick();
	auto tp = textPosition - Vec2{ scrollX, 0 };
	if (GetParentWindow() && Visible && Enabled && IsFocused())
	{
		ui::Engine::Ref().TextInputRect(GetScreenPos() + tp + inputRectPosition - Point(1, 3), Point(Size.X - tp.X - inputRectPosition.X, FONT_H + 2));
	}
	if (!IsFocused())
	{
		keyDown = 0;
		characterDown = 0;
	}
	unsigned long time_pls = Platform::GetTime();
	if ((keyDown || characterDown) && repeatTime <= time_pls)
	{
		//OnVKeyPress(keyDown, characterDown, false, false, false);
		repeatTime = Platform::GetTime()+30;
	}
	if (!multiline)
	{
		int regionWidth = Size.X;
		if (Appearance.icon)
		{
			regionWidth -= 13;
		}
		regionWidth -= Appearance.Margin.Left;
		regionWidth -= Appearance.Margin.Right;
		if (scrollX > displayTextWrapper.WrappedWidth() - regionWidth)
		{
			scrollX = displayTextWrapper.WrappedWidth() - regionWidth;
		}
		if (scrollX < cursorPositionX - regionWidth)
		{
			scrollX = cursorPositionX - regionWidth;
		}
		if (scrollX > cursorPositionX)
		{
			scrollX = cursorPositionX;
		}
		if (scrollX < 0)
		{
			scrollX = 0;
		}
	}
}

void Textbox::OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	keyDown = 0;
	characterDown = 0;
}

void Textbox::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	characterDown = scan;
	keyDown = key;
	repeatTime = Platform::GetTime()+300;
	OnVKeyPress(key, scan, repeat, shift, ctrl, alt);
}

void Textbox::OnVKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	bool changed = false;
	if (ctrl && scan == SDL_SCANCODE_C && !masked && !repeat)
	{
		copySelection();
		return;
	}
	if (ctrl && scan == SDL_SCANCODE_V && !ReadOnly)
	{
		pasteIntoSelection();
		return;
	}
	if (ctrl && scan == SDL_SCANCODE_X && !masked && !repeat && !ReadOnly)
	{
		cutSelection();
		return;
	}
	if (ctrl && scan == SDL_SCANCODE_A)
	{
		selectAll();
		return;
	}

	try
	{
		switch(key)
		{
		case SDLK_HOME:
			StopTextEditing();
			cursor = 0;
			ClearSelection();
			break;
		case SDLK_END:
			StopTextEditing();
			cursor = backingText.length();
			ClearSelection();
			break;
		case SDLK_LEFT:
			StopTextEditing();
			if(cursor > 0)
				cursor--;
			ClearSelection();
			break;
		case SDLK_RIGHT:
			StopTextEditing();
			if (cursor < (int)backingText.length())
				cursor++;
			ClearSelection();
			break;
		case SDLK_DELETE:
			if(ReadOnly)
				break;
			StopTextEditing();
			if (HasSelection())
			{
				int lowerBound = getLowerSelectionBound(), higherBound = getHigherSelectionBound();
				if (lowerBound < 0 || higherBound > (int)backingText.length())
					return;
				backingText.Erase(lowerBound, higherBound - lowerBound);
				cursor = lowerBound;
				changed = true;
			}
			else if (backingText.length() && cursor < (int)backingText.length())
			{
				if (ctrl)
				{
					size_t stopChar;
					stopChar = backingText.SplitByNot(" .,!?\n", cursor).PositionBefore();
					stopChar = backingText.SplitByAny(" .,!?\n", stopChar).PositionBefore();
					backingText.EraseBetween(cursor, stopChar);
				}
				else
					backingText.erase(cursor, 1);
				changed = true;
			}
			ClearSelection();
			break;
		case SDLK_BACKSPACE:
			if (ReadOnly)
				break;
			StopTextEditing();
			if (HasSelection())
			{
				int lowerBound = getLowerSelectionBound(), higherBound = getHigherSelectionBound();
				if (lowerBound < 0 || higherBound > (int)backingText.length())
					return;
				backingText.Erase(lowerBound, higherBound - lowerBound);
				cursor = lowerBound;
				changed = true;
			}
			else if (backingText.length() && cursor > 0)
			{
				if (ctrl)
				{
					size_t stopChar;
					stopChar = backingText.SplitFromEndByNot(" .,!?\n", cursor).PositionBefore();
					if (stopChar == backingText.npos)
						stopChar = -1;
					else
						stopChar = backingText.SplitFromEndByAny(" .,!?\n", stopChar).PositionBefore();
					backingText.EraseBetween(stopChar+1, cursor);
					cursor = stopChar+1;
				}
				else
				{
					backingText.erase(cursor-1, 1);
					cursor--;
				}
				changed = true;
			}
			ClearSelection();
			break;
		case SDLK_RETURN:
			OnTextInput("\n");
			break;
		}
	}
	catch (std::out_of_range &e)
	{
		cursor = 0;
		backingText = "";
	}
	AfterTextChange(changed);
}

void Textbox::AfterTextChange(bool changed)
{
	if (cursor > (int)backingText.length())
		cursor = backingText.length();

	if (changed)
	{
		if (inputType == Number)
		{
			//Remove extra preceding 0's
			while(backingText[0] == '0' && backingText.length()>1)
				backingText.erase(backingText.begin());
		}

		if (masked)
		{
			String maskedText = backingText;
			std::fill(maskedText.begin(), maskedText.end(), 0xE00D);
			Label::SetText(maskedText);
		}
		else
		{
			text = backingText;
		}
	}

	updateTextWrapper();
	updateSelection();
	TextPosition(displayTextWrapper.WrappedText());

	resetCursorPosition();
	if (changed && actionCallback.change)
		actionCallback.change();
}

void Textbox::OnTextInput(String text)
{
	StopTextEditing();
	InsertText(text);
}

void Textbox::InsertText(String text)
{
	if (StringValid(text) && !ReadOnly)
	{
		if (HasSelection())
		{
			if (getLowerSelectionBound() < 0 || getHigherSelectionBound() > (int)backingText.length())
				return;
			backingText.erase(backingText.begin()+getLowerSelectionBound(), backingText.begin()+getHigherSelectionBound());
			cursor = getLowerSelectionBound();
		}

		if (limit==String::npos || backingText.length() < limit)
		{
			if (cursor == (int)backingText.length())
			{
				backingText += text;
			}
			else
			{
				backingText.Insert(cursor, text);
			}
			cursor += text.length();
		}
		ClearSelection();
		AfterTextChange(true);
	}
}

void Textbox::StartTextEditing()
{
	if (ReadOnly || textEditing)
	{
		return;
	}
	textEditing = true;
	selectionIndexLSave1 = selectionIndexL.clear_index;
	selectionIndexHSave1 = selectionIndexH.clear_index;
	backingTextSave1 = backingText;
	cursorSave1 = cursor;
	InsertText(String(""));
	selectionIndexLSave2 = selectionIndexL.clear_index;
	selectionIndexHSave2 = selectionIndexH.clear_index;
	backingTextSave2 = backingText;
	cursorSave2 = cursor;
	inputRectPosition.X = cursorPositionX;
	inputRectPosition.Y = cursorPositionY;
}

void Textbox::StopTextEditing()
{
	if (ReadOnly || !textEditing)
	{
		return;
	}
	textEditing = false;
	backingText = backingTextSave1;
	AfterTextChange(true);
	selectionIndexL = textWrapper.Clear2Index(selectionIndexLSave1);
	selectionIndexH = textWrapper.Clear2Index(selectionIndexHSave1);
	selectionIndex0 = selectionIndexL;
	selectionIndex1 = selectionIndexH;
	cursor = cursorSave1;
	updateSelection();
}

void Textbox::OnTextEditing(String text)
{
	if (!StringValid(text) || ReadOnly)
	{
		return;
	}
	if (!text.size())
	{
		StopTextEditing();
		return;
	}
	StartTextEditing();
	backingText = backingTextSave2;
	AfterTextChange(true);
	selectionIndexL = textWrapper.Clear2Index(selectionIndexLSave2);
	selectionIndexH = textWrapper.Clear2Index(selectionIndexHSave2);
	selectionIndex0 = selectionIndexL;
	selectionIndex1 = selectionIndexH;
	cursor = cursorSave2;
	updateSelection();
	InsertText(text);
	selectionIndex1 = textWrapper.Clear2Index(cursor);
	selectionIndex0 = textWrapper.Clear2Index(cursor - int(text.size()));
	selectionIndexL = selectionIndex0;
	selectionIndexH = selectionIndex1;
	updateSelection();
}

void Textbox::OnMouseDown(int x, int y, unsigned button)
{
	if (MouseDownInside)
	{
		if (button != SDL_BUTTON_RIGHT)
		{
			StopTextEditing();
			mouseDown = true;
			auto tp = textPosition - Vec2{ scrollX, 0 };
			auto index = textWrapper.Point2Index(x-Position.X-tp.X, y-Position.Y-tp.Y);
			cursor = index.raw_index;
			resetCursorPosition();
		}
	}
	Label::OnMouseDown(x, y, button);
}

void Textbox::OnMouseUp(int x, int y, unsigned button)
{
	mouseDown = false;
	Label::OnMouseUp(x, y, button);
}

void Textbox::OnMouseMoved(int localx, int localy)
{
	if(mouseDown)
	{
		auto tp = textPosition - Vec2{ scrollX, 0 };
		auto index = textWrapper.Point2Index(localx-tp.X, localy-tp.Y);
		cursor = index.raw_index;
		resetCursorPosition();
	}
	Label::OnMouseMoved(localx, localy);
}

void Textbox::OnDefocus()
{
	if (defocusCallback.callback)
		defocusCallback.callback();
}

void Textbox::Draw(const Point& screenPos)
{
	Label::Draw(screenPos);

	Graphics * g = GetGraphics();
	auto clip = RectSized(screenPos + Vec2{ 1, 1 }, Size - Vec2{ 2, 2 }) & g->GetClipRect();
	g->SwapClipRect(clip);
	auto tp = textPosition - Vec2{ scrollX, 0 };
	if(IsFocused())
	{
		g->DrawLine(
			screenPos + tp + Vec2{ cursorPositionX, cursorPositionY-2 },
			screenPos + tp + Vec2{ cursorPositionX, cursorPositionY+9 },
			0xFFFFFF_rgb);
	}
	if(!text.length())
	{
		g->BlendText(screenPos + tp + Vec2{ 3, 0 }, placeHolder, textColour.NoAlpha().WithAlpha(170));
	}
	if(Appearance.icon)
		g->draw_icon(screenPos.X+iconPosition.X, screenPos.Y+iconPosition.Y, Appearance.icon);
	g->SwapClipRect(clip);
	if(border)
		g->DrawRect(RectSized(screenPos, Size), IsFocused() ? 0xFFFFFF_rgb : 0xA0A0A0_rgb);
}


=== src\gui\interface\Textbox.h ===

#pragma once
#include "Label.h"

#include <functional>

namespace ui
{
struct TextboxAction
{
	std::function<void ()> change;
};

struct TextboxDefocusAction
{
	std::function<void ()> callback;
};

class Textbox : public Label
{
	void AfterTextChange(bool changed);
	void InsertText(String text);
	void StartTextEditing();
	void StopTextEditing();

public:
	bool ReadOnly;
	enum ValidInput { All, Multiline, Numeric, Number }; // Numeric doesn't delete trailing 0's
	Textbox(Point position, Point size, String textboxText = String(), String textboxPlaceholder = String());
	virtual ~Textbox() = default;

	void SetText(String text) override;
	String GetText() override;

	virtual void SetPlaceholder(String text);

	void SetBorder(bool border) { this->border = border; }
	void SetHidden(bool hidden);
	bool GetHidden() { return masked; }
	void SetActionCallback(TextboxAction action) { actionCallback = action; }
	void SetDefocusCallback(TextboxDefocusAction action) { defocusCallback = action; }

	void SetLimit(size_t limit);
	size_t GetLimit();

	ValidInput GetInputType();
	void SetInputType(ValidInput input);

	void resetCursorPosition();
	void TabFocus();
	//Determines if the given character is valid given the input type
	bool CharacterValid(int character);
	bool StringValid(String text);

	void Tick() override;
	void OnContextMenuAction(int item) override;
	void OnMouseDown(int x, int y, unsigned button) override;
	void OnMouseUp(int x, int y, unsigned button) override;
	void OnMouseMoved(int localx, int localy) override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnVKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
	void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnTextInput(String text) override;
	void OnTextEditing(String text) override;
	void OnDefocus() override;
	void Draw(const Point& screenPos) override;

protected:
	ValidInput inputType;
	size_t limit;
	unsigned long repeatTime;
	int keyDown;
	unsigned short characterDown;
	bool mouseDown;
	bool masked, border;
	int cursor, cursorPositionX, cursorPositionY;
	TextboxAction actionCallback;
	TextboxDefocusAction defocusCallback;
	String backingText;
	String placeHolder;

	// * Cursor state to reset to before inserting actual input in StopTextEditing.
	int selectionIndexLSave1;
	int selectionIndexHSave1;
	String backingTextSave1;
	int cursorSave1;

	// * Cursor state to reset to before inserting a candidate string in OnTextEditing.
	int selectionIndexLSave2;
	int selectionIndexHSave2;
	String backingTextSave2;
	int cursorSave2;

	Point inputRectPosition;
	bool textEditing;

	virtual void cutSelection();
	virtual void pasteIntoSelection();
};

}



=== src\gui\interface\TextWrapper.cpp ===

#include "TextWrapper.h"

#include "graphics/Graphics.h"
#include "graphics/FontReader.h"

#include <algorithm>
#include <vector>
#include <iterator>

namespace ui
{
	int TextWrapper::Update(String const &text, bool do_wrapping, int max_width)
	{
		raw_text_size = (int)text.size();

		struct wrap_record
		{
			String::value_type character;
			int width;
			int raw_index;
			int clear_index;
			bool wraps;
			bool may_eat_space;
		};
		int line_width = 0;
		std::vector<wrap_record> records;

		int word_begins_at = -1; // this is a pointer into records; we're not currently in a word
		int word_width = 0;
		int lines = 0;
		int char_width;
		int clear_count = 0;

		wrappedWidth = 0;
		auto resetLine = [&]() {
			wrappedWidth = std::max(wrappedWidth, line_width);
			line_width = 0;
			lines += 1;
		};

		auto wrap_if_needed = [&](int width_to_consider) -> bool {
			if (do_wrapping && width_to_consider + char_width > max_width)
			{
				records.push_back(wrap_record{
					'\n', // character; makes the line wrap when rendered
					0, // width; fools the clickmap generator into not seeing this newline
					0, // position; the clickmap generator is fooled, this can be anything
					0,
					true, // signal the end of the line to the clickmap generator
					true // allow record to eat the following space
				});
				resetLine();
				return true;
			}
			return false;
		};

		for (auto it = text.begin(); it != text.end(); ++it)
		{
			char_width = Graphics::CharWidth(*it);

			int sequence_length = 0;
			switch (*it) // set sequence_length if *it starts a sequence that should be forwarded as-is
			{
			case   '\b': sequence_length = 2; break;
			case '\x0e': sequence_length = 1; break;
			case '\x0f': sequence_length = 4; break;
			}
			
			switch (*it)
			{
			// add more supported spaces here
			case ' ':
				wrap_if_needed(line_width);
				if (records.size() && records.back().may_eat_space)
				{
					records.back().may_eat_space = false;
				}
				else
				{
					// this is pushed only if the previous record isn't a wrapping one
					// to make spaces immediately following newline characters inserted
					// by the wrapper disappear
					records.push_back(wrap_record{
						*it,
						char_width,
						(int)(it - text.begin()),
						clear_count,
						false,
						false
					});
					line_width += char_width;
				}
				word_begins_at = -1; // reset word state
				++clear_count;
				break;

			// add more supported linebreaks here
			case '\n':
				records.push_back(wrap_record{
					*it, // character; makes the line wrap when rendered
					max_width - line_width, // width; make it span all the way to the end
					(int)(it - text.begin()), // position; so the clickmap generator knows where *it is
					clear_count,
					true, // signal the end of the line to the clickmap generator
					false
				});
				resetLine();
				word_begins_at = -1; // reset word state
				++clear_count;
				break;

			default:
				if (sequence_length) // *it starts a sequence such as \b? or \x0f???
				{
					if (text.end() - it < sequence_length)
					{
						it = text.end() - 1;
						continue; // text is broken, we might as well skip the whole thing
					}
					for (auto skip = it + sequence_length; it != skip; ++it)
					{
						records.push_back(wrap_record{
							*it, // character; forward the sequence to the output
							0, // width; fools the clickmap generator into not seeing this sequence
							0, // position; the clickmap generator is fooled, this can be anything
							0,
							false, // signal nothing to the clickmap generator
							false
						});
					}
					--it;
				}
				else
				{
					if (word_begins_at == -1)
					{
						word_begins_at = records.size();
						word_width = 0;
					}

					if (wrap_if_needed(word_width))
					{
						word_begins_at = records.size();
						word_width = 0;
					}
					if (wrap_if_needed(line_width))
					{
						// if we get in here, we skipped the previous block (since line_width
						// would have been set to 0 (unless of course (char_width > max_width) which
						// is dumb)). since (word_width + char_width) <= (line_width + char_width) always
						// holds and we are in this block, we can be sure that word_width < line_width,
						// so breaking the line by the preceding space is sure to decrease line_width.

						// now of course there's this problem that wrap_if_needed appends the
						// newline character to the end of records, and we want it before
						// the record at position word_begins_at (0-based)
						std::rotate(
							records.begin() + word_begins_at,
							records.end() - 1,
							records.end()
						);
						word_begins_at += 1;
						line_width = word_width;
					}

					records.push_back(wrap_record{
						*it, // character; make the line wrap with *it
						char_width, // width; make it span all the way to the end
						(int)(it - text.begin()), // position; so the clickmap generator knows where *it is
						clear_count,
						false, // signal nothing to the clickmap generator
						false
					});
					word_width += char_width;
					line_width += char_width;
					++clear_count;

					switch (*it)
					{
					// add more supported non-spaces here that break the word
					case '?':
					case ';':
					case ',':
					case ':':
					case '.':
					case '-':
					case '!':
						word_begins_at = -1; // reset word state
						break;
					}
				}
				break;
			}
		}

		regions.clear();
		wrapped_text.clear();
		int x = 0;
		int l = 0;
		int counter = 0;
		for (auto const &record : records)
		{
			regions.push_back(clickmap_region{ x, l * FONT_H, record.width, l + 1, Index{ record.raw_index, counter, record.clear_index } });
			++counter;
			x += record.width;
			if (record.wraps)
			{
				x = 0;
				l += 1;
			}
			wrapped_text.append(1, record.character);
		}

		resetLine();
		clear_text_size = clear_count;
		wrapped_lines = lines;
		return lines;
	}

	TextWrapper::Index TextWrapper::Point2Index(int x, int y) const
	{
		if (y < 0)
		{
			return IndexBegin();
		}
		if (regions.size())
		{
			auto curr = regions.begin();
			auto end = regions.end();

			auto find_next_nonempty = [end](decltype(end) it) {
				++it;
				while (it != end && !it->width)
				{
					++it;
				}
				return it;
			};

			while (true)
			{
				if (curr->pos_y + FONT_H > y)
				{
					if (curr->pos_x + curr->width / 2 > x)
					{
						// if x is to the left of the vertical bisector of the current region,
						// return this one; really we should have returned 'the next one' in
						// the previous iteration
						return curr->index;
					}
				}
				auto next = find_next_nonempty(curr);
				if (next == end)
				{
					break;
				}
				if (curr->pos_y + FONT_H > y)
				{
					if (curr->pos_x + curr->width / 2 <= x && next->pos_x + next->width / 2 > x)
					{
						// if x is to the right of the vertical bisector of the current region
						// but to the left of the next one's, return the next one
						return next->index;
					}
					if (curr->pos_x + curr->width / 2 <= x && next->pos_y > curr->pos_y)
					{
						// nominate the next region if x is to the right of the vertical bisector of
						// the current region and the next one is on a new line
						return next->index;
					}
				}
				curr = next;
			}
		}
		return IndexEnd();
	}

	int TextWrapper::Index2Point(Index index, int &x, int &y) const
	{
		if (index.wrapped_index < 0 || index.wrapped_index > (int)regions.size() || !regions.size())
		{
			return -1;
		}
		if (index.wrapped_index == (int)regions.size())
		{
			x = regions[index.wrapped_index - 1].pos_x + regions[index.wrapped_index - 1].width;
			y = regions[index.wrapped_index - 1].pos_y;
			return regions[index.wrapped_index - 1].pos_line;
		}
		x = regions[index.wrapped_index].pos_x;
		y = regions[index.wrapped_index].pos_y;
		return regions[index.wrapped_index].pos_line;
	}

	TextWrapper::Index TextWrapper::Clear2Index(int clear_index) const
	{
		if (clear_index < 0)
		{
			return IndexBegin();
		}
		for (auto const &region : regions)
		{
			if (region.index.clear_index >= clear_index)
			{
				return region.index;
			}
		}
		return IndexEnd();
	}
}


=== src\gui\interface\TextWrapper.h ===

#pragma once

#include "common/String.h"
#include "Point.h"

#include <vector>

namespace ui
{
	class TextWrapper
	{
	public:
		struct Index
		{
			int raw_index;
			int wrapped_index;
			int clear_index;
		};

	private:
		int raw_text_size;
		int clear_text_size;
		String wrapped_text;
		struct clickmap_region
		{
			int pos_x, pos_y, width, pos_line;
			Index index;
		};
		int wrapped_lines;
		int wrappedWidth;
		std::vector<clickmap_region> regions;

	public:
		int Update(String const &text, bool do_wrapping, int max_width);
		Index Clear2Index(int clear_index) const;
		Index Point2Index(int x, int y) const;
		int Index2Point(Index index, int &x, int &y) const;

		String const &WrappedText() const
		{
			return wrapped_text;
		}

		int WrappedLines() const
		{
			return wrapped_lines;
		}

		Index IndexBegin() const
		{
			return Index{ 0, 0, 0 };
		}

		Index IndexEnd() const
		{
			return Index{ raw_text_size, (int)wrapped_text.size(), clear_text_size };
		}

		int WrappedWidth() const
		{
			return wrappedWidth;
		}
	};
}


=== src\gui\interface\Window.cpp ===

#include "Window.h"

#include "Engine.h"
#include "Component.h"
#include "gui/interface/Button.h"

#include "graphics/Graphics.h"

#include "Config.h"
#include "SimulationConfig.h"
#include <SDL.h>

using namespace ui;

Window::Window(Point _position, Point _size):
	Position(_position),
	Size(_size),
	AllowExclusiveDrawing(true),
	DoesTextInput(false),
	okayButton(nullptr),
	cancelButton(nullptr),
	focusedComponent_(nullptr),
	hoverComponent(nullptr),
	debugMode(false),
	halt(false),
	destruct(false),
	stop(false)
{
	SetFps(1);
}

Window::~Window()
{
	for (unsigned i = 0, sz = Components.size(); i < sz; ++i)
		if (Components[i])
		{
			delete Components[i];
		}
	Components.clear();
}

void Window::AddComponent(Component* c)
{
	if (c->GetParentWindow() == nullptr)
	{
		c->SetParentWindow(this);
		c->MouseInside = false;
		c->MouseDownInside = false;
		Components.push_back(c);

		if (Engine::Ref().GetMouseX() > Position.X + c->Position.X && Engine::Ref().GetMouseX() < Position.X + c->Position.X + c->Size.X &&
			Engine::Ref().GetMouseY() > Position.Y + c->Position.Y && Engine::Ref().GetMouseY() < Position.Y + c->Position.Y + c->Size.Y)
		{
			c->MouseInside = true;
			c->OnMouseEnter(Engine::Ref().GetMouseX() - (Position.X + c->Position.X), Engine::Ref().GetMouseY() - (Position.Y + c->Position.Y));
		}
	}
	else
	{
		//Component already in a window
	}
}

unsigned Window::GetComponentCount()
{
	return Components.size();
}

Component* Window::GetComponent(unsigned idx)
{
	return Components[idx];
}

void Window::RemoveComponent(Component* c)
{
	// remove component WITHOUT freeing it.
	for (unsigned i = 0; i < Components.size(); ++i)
	{
		// find the appropriate component index
		if (Components[i] == c)
		{
			//Make sure any events don't continue
			halt = true;
			if (Components[i] == focusedComponent_)
				focusedComponent_ = nullptr;
			if (Components[i] == hoverComponent)
				hoverComponent = nullptr;

			Components.erase(Components.begin() + i);

			// we're done
			c->SetParentWindow(nullptr);
			return;
		}
	}
}

void Window::OnTryExit(ExitMethod method)
{
	if (cancelButton && method != MouseOutside)
		cancelButton->DoAction();
}

void Window::OnTryOkay(OkayMethod method)
{
	if (okayButton)
		okayButton->DoAction();
}

void Window::RemoveComponent(unsigned idx)
{
	halt = true;
	// free component and remove it.
	if (Components[idx] == focusedComponent_)
		focusedComponent_ = nullptr;
	if (Components[idx] == hoverComponent)
		hoverComponent = nullptr;
	delete Components[idx];
	Components.erase(Components.begin() + idx);
}

bool Window::IsFocused(const Component* c) const
{
	return c == focusedComponent_;
}

void Window::FocusComponent(Component* c)
{
	if (focusedComponent_ != c)
	{
		if (focusedComponent_)
			focusedComponent_->OnDefocus();
		this->focusedComponent_ = c;
		if (c)
			c->OnFocus();
	}
}

void Window::MakeActiveWindow()
{
	if (Engine::Ref().GetWindow() != this)
		Engine::Ref().ShowWindow(this);
}

void Window::CloseActiveWindow()
{
	Engine::Ref().CloseWindowAndEverythingAbove(this);
}

Graphics * Window::GetGraphics()
{
	return Engine::Ref().g;
}

void Window::DoExit()
{
	OnExit();
}

void Window::DoInitialized()
{
	OnInitialized();
}

void Window::DoBlur()
{
	OnBlur();
}

void Window::DoFocus()
{
	OnFocus();
}

void Window::DoFileDrop(ByteString filename)
{
	OnFileDrop(filename);
}

void Window::DoDraw()
{
	OnDraw();
	auto drawChild = [this](Component *child) {
		if (child->Visible)
		{
			auto rect = RectSized(Position + child->Position, child->Size);
			if (AllowExclusiveDrawing || bool(rect & GetGraphics()->Size().OriginRect()))
				child->Draw(rect.pos);
		}
	};
	for (auto child : Components)
		if ((child != focusedComponent_ && child != hoverComponent) || child->GetParent())
		{
			drawChild(child);

			if (debugMode)
				GetGraphics()->BlendFilledRect(RectSized(Position + child->Position, child->Size),
					(focusedComponent_ == child ? 0x00FF00_rgb : 0xFF0000_rgb).WithAlpha(0x5A));
		}
	// the component the mouse is hovering over and the focused component are always drawn last
	if (hoverComponent && hoverComponent->GetParent() == nullptr)
		drawChild(hoverComponent);
	if (focusedComponent_ && focusedComponent_ != hoverComponent && focusedComponent_->GetParent() == nullptr)
		drawChild(focusedComponent_);
	if (debugMode && focusedComponent_)
	{
		Graphics *g = ui::Engine::Ref().g;

		auto invPos = Size - (focusedComponent_->Position + focusedComponent_->Size);
		String posText = String::Build(
			"Position: L ", focusedComponent_->Position.X,
			", R ", invPos.X,
			", T: ", focusedComponent_->Position.Y,
			", B: ", invPos.Y
		);
		String sizeText = String::Build(
			"Size: ", focusedComponent_->Size.X,
			", ", focusedComponent_->Size.Y
		);

		auto pos = focusedComponent_->Position + Position + Vec2(focusedComponent_->Size.X + 5, 0);
		pos.X = std::min(pos.X, g->Size().X - (Graphics::TextSize(posText).X - 1) - 5);
		pos.X = std::min(pos.X, g->Size().X - (Graphics::TextSize(sizeText).X - 1) - 5);

		g->BlendText(pos + Vec2(0, 1), posText, 0x000000_rgb .WithAlpha(0xC8));
		g->BlendText(pos + Vec2(0, 0), posText, 0xFFFFFF_rgb .WithAlpha(0xFF));
		g->BlendText(pos + Vec2(0, 13), sizeText, 0x000000_rgb .WithAlpha(0xC8));
		g->BlendText(pos + Vec2(0, 12), sizeText, 0xFFFFFF_rgb .WithAlpha(0xFF));
	}
}

void Window::DoTick()
{
	if (debugMode)
		return;

	if (DoesTextInput || (focusedComponent_ && focusedComponent_->Visible && focusedComponent_->Enabled && focusedComponent_->DoesTextInput))
	{
		ui::Engine::Ref().StartTextInput();
	}
	else
	{
		ui::Engine::Ref().StopTextInput();
	}

	//on mouse hover
	for (int i = Components.size() - 1; i >= 0 && !halt; --i)
	{
		if (Components[i]->Enabled &&
			ui::Engine::Ref().GetMouseX() >= Components[i]->Position.X+Position.X &&
			ui::Engine::Ref().GetMouseY() >= Components[i]->Position.Y+Position.Y &&
			ui::Engine::Ref().GetMouseX() < Components[i]->Position.X+Position.X + Components[i]->Size.X &&
			ui::Engine::Ref().GetMouseY() < Components[i]->Position.Y+Position.Y + Components[i]->Size.Y )
		{
			Components[i]->OnMouseHover(ui::Engine::Ref().GetMouseX() - (Components[i]->Position.X + Position.X), ui::Engine::Ref().GetMouseY() - (Components[i]->Position.Y + Position.Y));
			break;
		}
	}

	//tick
	for (int i = 0, sz = Components.size(); i < sz && !halt; ++i)
	{
		Components[i]->Tick();
	}

	halt = false;
	stop = false;

	OnTick();

	if (destruct)
		finalise();
}

void Window::DoSimTick()
{
	OnSimTick();
}

void Window::DoKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (DEBUG && key == SDLK_TAB && ctrl)
		debugMode = !debugMode;
	if (debugMode)
	{
		if (focusedComponent_!=nullptr)
		{
			if (shift)
			{
				if (key == SDLK_UP)
					focusedComponent_->Size.Y--;
				if (key == SDLK_DOWN)
					focusedComponent_->Size.Y++;
				if (key == SDLK_LEFT)
					focusedComponent_->Size.X--;
				if (key == SDLK_RIGHT)
					focusedComponent_->Size.X++;
			}
			if (ctrl)
			{
				if (key == SDLK_UP)
					focusedComponent_->Size.Y++;
				if (key == SDLK_DOWN)
					focusedComponent_->Size.Y--;
				if (key == SDLK_LEFT)
					focusedComponent_->Size.X++;
				if (key == SDLK_RIGHT)
					focusedComponent_->Size.X--;
			}
			if (!shift)
			{
				if (key == SDLK_UP)
					focusedComponent_->Position.Y--;
				if (key == SDLK_DOWN)
					focusedComponent_->Position.Y++;
				if (key == SDLK_LEFT)
					focusedComponent_->Position.X--;
				if (key == SDLK_RIGHT)
					focusedComponent_->Position.X++;
			}
			if (key == SDLK_DELETE)
			{
				RemoveComponent(focusedComponent_);
				halt = false;
			}
		}
		else
		{
			if (shift)
			{
				if (key == SDLK_UP)
					Size.Y--;
				if (key == SDLK_DOWN)
					Size.Y++;
				if (key == SDLK_LEFT)
					Size.X--;
				if (key == SDLK_RIGHT)
					Size.X++;
			}
			if (ctrl)
			{
				if (key == SDLK_UP)
					Size.Y++;
				if (key == SDLK_DOWN)
					Size.Y--;
				if (key == SDLK_LEFT)
					Size.X++;
				if (key == SDLK_RIGHT)
					Size.X--;
			}
			if (!shift)
			{
				if (key == SDLK_UP)
					Position.Y--;
				if (key == SDLK_DOWN)
					Position.Y++;
				if( key == SDLK_LEFT)
					Position.X--;
				if (key == SDLK_RIGHT)
					Position.X++;
			}
		}
		return;
	}
	//on key press
	if (focusedComponent_ != nullptr)
	{
		if (focusedComponent_->Enabled && focusedComponent_->Visible)
			focusedComponent_->OnKeyPress(key, scan, repeat, shift, ctrl, alt);
	}

	if (!stop)
		OnKeyPress(key, scan, repeat, shift, ctrl, alt);

	if (key == SDLK_ESCAPE || key == SDLK_AC_BACK)
		OnTryExit(Escape);

	if (key == SDLK_KP_ENTER || key == SDLK_RETURN)
		OnTryOkay(Enter);

	if (destruct)
		finalise();
}

void Window::DoKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if(debugMode)
		return;
	//on key unpress
	if (focusedComponent_ != nullptr)
	{
		if (focusedComponent_->Enabled && focusedComponent_->Visible)
			focusedComponent_->OnKeyRelease(key, scan, repeat, shift, ctrl, alt);
	}

	if (!stop)
		OnKeyRelease(key, scan, repeat, shift, ctrl, alt);
	if (destruct)
		finalise();
}

void Window::DoTextInput(String text)
{
	if (debugMode)
		return;
	//on key unpress
	if (focusedComponent_ != nullptr)
	{
		if (focusedComponent_->Enabled && focusedComponent_->Visible)
			focusedComponent_->OnTextInput(text);
	}

	if (!stop)
		OnTextInput(text);
	if (destruct)
		finalise();
}

void Window::DoTextEditing(String text)
{
	if (focusedComponent_ != nullptr)
	{
		if (focusedComponent_->Enabled && focusedComponent_->Visible)
			focusedComponent_->OnTextEditing(text);
	}

	if (!stop)
		OnTextEditing(text);
	if (destruct)
		finalise();
}


void Window::DoMouseDown(int x_, int y_, unsigned button)
{
	//on mouse click
	int x = x_ - Position.X;
	int y = y_ - Position.Y;
	bool clickState = false;
	for (int i = Components.size() - 1; i > -1 && !halt; --i)
	{
		if (Components[i]->Enabled && Components[i]->Visible)
		{
			if (x >= Components[i]->Position.X && y >= Components[i]->Position.Y && x < Components[i]->Position.X + Components[i]->Size.X && y < Components[i]->Position.Y + Components[i]->Size.Y)
			{
				FocusComponent(Components[i]);
				if (!DEBUG || !debugMode)
				{
					Components[i]->MouseDownInside = true;
				}
				clickState = true;
				break;
			}
		}
	}

	if (!clickState)
		FocusComponent(nullptr);

	if (debugMode)
		return;

	//on mouse down
	for (int i = Components.size() - 1; i > -1 && !halt; --i)
	{
		if (Components[i]->Enabled && Components[i]->Visible)
			Components[i]->OnMouseDown(x, y, button);
	}

	if (!stop)
		OnMouseDown(x_, y_, button);

	if (!clickState && (x_ < Position.X || y_ < Position.Y || x_ > Position.X+Size.X || y_ > Position.Y+Size.Y))
		OnTryExit(MouseOutside);

	if (destruct)
		finalise();
}

void Window::DoMouseMove(int x_, int y_, int dx, int dy)
{
	//on mouse move (if true, and inside)
	int x = x_ - Position.X;
	int y = y_ - Position.Y;
	if (debugMode)
		return;
	for (int i = Components.size() - 1; i > -1  && !halt; --i)
	{
		if (Components[i]->Enabled && Components[i]->Visible)
		{
			Point local(x - Components[i]->Position.X, y - Components[i]->Position.Y);
			Point a(local.X - dx, local.Y - dy);

			Components[i]->OnMouseMoved(local.X, local.Y);

			if (local.X >= 0 &&
			    local.Y >= 0 &&
			    local.X < Components[i]->Size.X &&
			    local.Y < Components[i]->Size.Y && !halt)
			{
				// entering?
				if (!Components[i]->MouseInside)
				{
					Components[i]->MouseInside = true;
					Components[i]->OnMouseEnter(local.X, local.Y);
				}
				if (Components[i]->Enabled)
					hoverComponent = Components[i];
			}
			else if (!halt)
			{
				// leaving?
				if (Components[i]->MouseInside)
				{
					Components[i]->MouseInside = false;
					Components[i]->OnMouseLeave(local.X, local.Y);
				}

			}
		}
	}

	if (!stop)
		OnMouseMove(x_, y_, dx, dy);
	if (destruct)
		finalise();
}

void Window::DoMouseUp(int x_, int y_, unsigned button)
{
	int x = x_ - Position.X;
	int y = y_ - Position.Y;
	if (debugMode)
		return;
	//on mouse unclick
	for (int i = Components.size() - 1; i >= 0  && !halt; --i)
	{
		if (Components[i]->Enabled && Components[i]->Visible)
		{
			if (Components[i]->MouseDownInside && x >= Components[i]->Position.X && y >= Components[i]->Position.Y && x < Components[i]->Position.X + Components[i]->Size.X && y < Components[i]->Position.Y + Components[i]->Size.Y)
			{
				Components[i]->OnMouseClick(x - Components[i]->Position.X, y - Components[i]->Position.Y, button);
				break;
			}
		}
	}
	for (auto *component : Components)
	{
		component->MouseDownInside = false;
	}

	//on mouse up
	for (int i = Components.size() - 1; i >= 0 && !halt; --i)
	{
		if (Components[i]->Enabled && Components[i]->Visible)
			Components[i]->OnMouseUp(x, y, button);
	}

	if (!stop)
		OnMouseUp(x_, y_, button);
	if (destruct)
		finalise();
}

void Window::DoMouseWheel(int x_, int y_, int d)
{
	int x = x_ - Position.X;
	int y = y_ - Position.Y;
	if (debugMode)
		return;
	//on mouse wheel focused
	for (int i = Components.size() - 1; i >= 0  && !halt; --i)
	{
		if (x >= Components[i]->Position.X && y >= Components[i]->Position.Y && x < Components[i]->Position.X + Components[i]->Size.X && y < Components[i]->Position.Y + Components[i]->Size.Y)
		{
			if (Components[i]->Enabled && Components[i]->Visible)
				Components[i]->OnMouseWheelInside(x - Components[i]->Position.X, y - Components[i]->Position.Y, d);
			break;
		}
	}

	//on mouse wheel
	for (int i = Components.size() - 1; i >= 0  && !halt; --i)
	{
		if (Components[i]->Enabled && Components[i]->Visible)
			Components[i]->OnMouseWheel(x - Components[i]->Position.X, y - Components[i]->Position.Y, d);
	}

	if (!stop)
		OnMouseWheel(x_, y_, d);

	if (destruct)
		finalise();
}

void Window::finalise()
{
	delete this;
}

void Window::SelfDestruct()
{
	destruct = true;
	halt = true;
	stop = true;
}

void Window::Halt()
{
	stop = true;
	halt = true;
}

void Window::SetFps(float newFps)
{
	fps = newFps;
}

void Window::SetFpsLimit(FpsLimit newFpsLimit)
{
	fpsLimit = newFpsLimit;
}


=== src\gui\interface\Window.h ===

#pragma once
#include "common/String.h"
#include "gui/interface/Point.h"
#include "FpsLimit.h"
#include <vector>

class Graphics;
namespace ui
{

	enum ChromeStyle
	{
		None, Title, Resizable
	};

	class Engine;
	class Component;
	class Button;

	/* class Window
	 *
	 * A UI state. Contains all components.
	 */
	class Window
	{
	public:
		bool contributesToFps = false;
		Point Position;
		Point Size;

		Window(Point _position, Point _size);
		virtual ~Window();

		void SetOkayButton(ui::Button * button) { okayButton = button; }
		void SetCancelButton(ui::Button * button) { cancelButton = button; }

		bool AllowExclusiveDrawing; //false will not call draw on objects outside of bounds
		bool DoesTextInput;

		// Add Component to window
		void AddComponent(Component* c);

		// Get the number of components this window has.
		unsigned GetComponentCount();

		// Get component by index. (See GetComponentCount())
		Component* GetComponent(unsigned idx);

		// Remove a component from window. NOTE: This DOES NOT free component from memory.
		void RemoveComponent(Component* c);

		// Remove a component from window. NOTE: This WILL free component from memory.
		void RemoveComponent(unsigned idx);

		virtual void ToolTip(ui::Point senderPosition, String toolTip) {}

		virtual void DoInitialized();
		virtual void DoExit();
		virtual void DoTick();
		virtual void DoSimTick();
		virtual void DoDraw();
		virtual void DoFocus();
		virtual void DoBlur();
		virtual void DoFileDrop(ByteString filename);

		virtual void DoMouseMove(int x, int y, int dx, int dy);
		virtual void DoMouseDown(int x, int y, unsigned button);
		virtual void DoMouseUp(int x, int y, unsigned button);
		virtual void DoMouseWheel(int x, int y, int d);
		virtual void DoKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
		virtual void DoKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
		virtual void DoTextInput(String text);
		virtual void DoTextEditing(String text);

		// Sets halt and destroy, this causes the Windows to stop sending events and remove itself.
		void SelfDestruct();
		void Halt();

		bool IsFocused(const Component* c) const;
		void FocusComponent(Component* c);

		void* UserData;

		enum OkayMethod { Enter, OkayButton };
		enum ExitMethod { MouseOutside, Escape, ExitButton };

		void MakeActiveWindow();
		void CloseActiveWindow();
		Graphics * GetGraphics();
		void SetFps(float newFps);
		float GetFps() const
		{
			return fps;
		}
		void SetFpsLimit(FpsLimit newFpsLimit);
		FpsLimit GetFpsLimit() const
		{
			return fpsLimit;
		}

	protected:
		ui::Button * okayButton;
		ui::Button * cancelButton;

		virtual void OnInitialized() {}
		virtual void OnExit() {}
		virtual void OnTick() {}
		virtual void OnSimTick() {}
		virtual void OnDraw() {}
		virtual void OnFocus() {}
		virtual void OnBlur() {}
		virtual void OnFileDrop(ByteString filename) {}

		virtual void OnTryExit(ExitMethod);
		virtual void OnTryOkay(OkayMethod);

		virtual void OnMouseMove(int x, int y, int dx, int dy) {}
		virtual void OnMouseDown(int x, int y, unsigned button) {}
		virtual void OnMouseUp(int x, int y, unsigned button) {}
		virtual void OnMouseWheel(int x, int y, int d) {}
		virtual void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) {}
		virtual void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) {}
		virtual void OnTextInput(String text) {}
		virtual void OnTextEditing(String text) {}
		std::vector<Component*> Components;
		Component *focusedComponent_;
		Component *hoverComponent;
		ChromeStyle chrome;

		bool debugMode;
		//These controls allow a component to call the destruction of the Window inside an event (called by the Window)
		void finalise();
		bool halt;
		bool destruct;
		bool stop;

		float fps;
		FpsLimit fpsLimit = FpsLimitFollowDraw{};
	};
}


=== src\gui\localbrowser\LocalBrowserController.cpp ===

#include "LocalBrowserController.h"

#include "LocalBrowserModel.h"
#include "LocalBrowserView.h"

#include "client/Client.h"
#include "client/GameSave.h"
#include "client/SaveFile.h"
#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/dialogues/TextPrompt.h"
#include "gui/dialogues/ErrorMessage.h"
#include "tasks/TaskWindow.h"
#include "tasks/Task.h"

#include "Controller.h"

#include <algorithm>

LocalBrowserController::LocalBrowserController(std::function<void ()> onDone_):
	HasDone(false)
{
	browserModel = new LocalBrowserModel();
	browserView = new LocalBrowserView();
	browserView->AttachController(this);
	browserModel->AddObserver(browserView);

	onDone = onDone_;

	browserModel->UpdateSavesList(0);
}

void LocalBrowserController::OpenSave(int index)
{
	browserModel->OpenSave(index);
}

std::unique_ptr<SaveFile> LocalBrowserController::TakeSave()
{
	return browserModel->TakeSave();
}

void LocalBrowserController::RemoveSelected()
{
	StringBuilder desc;
	desc << "Are you sure you want to delete " << browserModel->GetSelected().size() << " stamp";
	if(browserModel->GetSelected().size()>1)
		desc << "s";
	desc << "?";
	new ConfirmPrompt("Delete stamps", desc.Build(), { [this] { removeSelectedC(); } });
}

void LocalBrowserController::removeSelectedC()
{
	class RemoveSavesTask : public Task
	{
		std::vector<ByteString> saves;
		LocalBrowserController * c;
	public:
		RemoveSavesTask(LocalBrowserController * c, std::vector<ByteString> saves_) : c(c) { saves = saves_; }
		bool doWork() override
		{
			for (size_t i = 0; i < saves.size(); i++)
			{
				notifyStatus(String::Build("Deleting stamp [", saves[i].FromUtf8(), "] ..."));
				Client::Ref().DeleteStamp(saves[i]);
				notifyProgress((i + 1) * 100 / saves.size());
			}
			return true;
		}
		void after() override
		{
			c->RefreshSavesList();
		}
	};

	std::vector<ByteString> selected = browserModel->GetSelected();
	new TaskWindow("Removing stamps", new RemoveSavesTask(this, selected));
}

void LocalBrowserController::RenameSelected()
{
	ByteString save = browserModel->GetSelected()[0];

	new TextPrompt("Rename stamp", "Enter a new name for the stamp:", "", "[new name]", false, { [this, save](const String &newName) {
		if (newName.length() == 0)
		{
			new ErrorMessage("Error renaming stamp", "You have to specify the filename.");
			return;
		}

		Client::Ref().RenameStamp(save, newName.ToUtf8());

		RefreshSavesList();
	} });
}

void LocalBrowserController::RescanStamps()
{
	browserModel->RescanStamps();
	browserModel->UpdateSavesList(browserModel->GetPageNum());
}

void LocalBrowserController::RefreshSavesList()
{
	ClearSelection();
	browserModel->UpdateSavesList(browserModel->GetPageNum());
}

void LocalBrowserController::ClearSelection()
{
	browserModel->ClearSelected();
}

void LocalBrowserController::SetPage(int page)
{
	if (page != browserModel->GetPageNum() && page >= 0 && page < browserModel->GetPageCount())
		browserModel->UpdateSavesList(page);
}

void LocalBrowserController::SetPageRelative(int offset)
{
	int page = std::max(std::min(browserModel->GetPageNum() + offset, browserModel->GetPageCount() - 1), 0);
	if (page != browserModel->GetPageNum())
		browserModel->UpdateSavesList(page);
}

void LocalBrowserController::Update()
{
	if (browserModel->GetSave())
	{
		Exit();
	}
}

void LocalBrowserController::Selected(ByteString saveName, bool selected)
{
	if(selected)
		browserModel->SelectSave(saveName);
	else
		browserModel->DeselectSave(saveName);
}

bool LocalBrowserController::GetMoveToFront()
{
	return browserModel->GetMoveToFront();
}

void LocalBrowserController::SetMoveToFront(bool move)
{
	browserModel->SetMoveToFront(move);
}

void LocalBrowserController::Exit()
{
	browserView->CloseActiveWindow();
	if (onDone)
		onDone();
	HasDone = true;
}

LocalBrowserController::~LocalBrowserController()
{
	delete browserModel;
	browserView->CloseActiveWindow();
	delete browserView;
}



=== src\gui\localbrowser\LocalBrowserController.h ===

#pragma once
#include "common/String.h"
#include <functional>
#include <memory>

class SaveFile;
class LocalBrowserView;
class LocalBrowserModel;
class LocalBrowserController {
	LocalBrowserView * browserView;
	LocalBrowserModel * browserModel;
	std::function<void ()> onDone;
public:
	bool HasDone;
	LocalBrowserController(std::function<void ()> onDone = nullptr);
	LocalBrowserView * GetView() {return browserView;}
	std::unique_ptr<SaveFile> TakeSave();
	void RemoveSelected();
	void removeSelectedC();
	void RenameSelected();
	void ClearSelection();
	void Selected(ByteString stampID, bool selected);
	void RescanStamps();
	void RefreshSavesList();
	void OpenSave(int index);
	bool GetMoveToFront();
	void SetMoveToFront(bool move);
	void SetPage(int page);
	void SetPageRelative(int offset);
	void Update();
	void Exit();
	virtual ~LocalBrowserController();
};


=== src\gui\localbrowser\LocalBrowserModel.cpp ===

#include "LocalBrowserModel.h"
#include "LocalBrowserView.h"
#include "client/Client.h"
#include "client/SaveFile.h"
#include "client/GameSave.h"
#include <algorithm>

constexpr auto pageSize = 20;

LocalBrowserModel::LocalBrowserModel()
{
	stampIDs = Client::Ref().GetStamps();
}

std::vector<SaveFile *> LocalBrowserModel::GetSavesList() // non-owning
{
	std::vector<SaveFile *> nonOwningSaveList;
	std::transform(savesList.begin(), savesList.end(), std::back_inserter(nonOwningSaveList), [](auto &ptr) {
		return ptr.get();
	});
	return nonOwningSaveList;
}

void LocalBrowserModel::AddObserver(LocalBrowserView * observer)
{
	observers.push_back(observer);
	observer->NotifySavesListChanged(this);
	observer->NotifyPageChanged(this);
}

void LocalBrowserModel::notifySavesListChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifySavesListChanged(this);
		observers[i]->NotifyPageChanged(this);
	}
}

void LocalBrowserModel::notifyPageChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyPageChanged(this);
	}
}

const SaveFile *LocalBrowserModel::GetSave()
{
	return stamp.get();
}

std::unique_ptr<SaveFile> LocalBrowserModel::TakeSave()
{
	return std::move(stamp);
}

void LocalBrowserModel::OpenSave(int index)
{
	stamp = std::move(savesList[index]);
	savesList.clear();
	notifyPageChanged();
	notifySavesListChanged();
}

bool LocalBrowserModel::GetMoveToFront()
{
	return stampToFront;
}

void LocalBrowserModel::SetMoveToFront(bool move)
{
	stampToFront = move;
}

void LocalBrowserModel::UpdateSavesList(int pageNumber)
{
	ClearSelected();
	savesList.clear();
	currentPage = pageNumber;

	stampIDs = Client::Ref().GetStamps();
	auto size = int(stampIDs.size());
	for (int i = currentPage * pageSize; i < size && i < (currentPage + 1) * pageSize; i++)
	{
		auto tempSave = Client::Ref().GetStamp(stampIDs[i]);
		if (tempSave)
		{
			savesList.push_back(std::move(tempSave));
		}
	}
	notifyPageChanged();
	notifySavesListChanged();
}

void LocalBrowserModel::RescanStamps()
{
	Client::Ref().RescanStamps();
}

int LocalBrowserModel::GetPageCount()
{
	auto size = int(stampIDs.size());
	auto count = size / pageSize + ((size % pageSize) ? 1 : 0);
	return count ? count : 1; // there is always at least one page; there may not be anything on it though
}

void LocalBrowserModel::SelectSave(ByteString stampID)
{
	if (std::find(selected.begin(), selected.end(), stampID) != selected.end())
	{
		return;
	}
	selected.push_back(stampID);
	notifySelectedChanged();
}

void LocalBrowserModel::DeselectSave(ByteString stampID)
{
	auto it = std::remove(selected.begin(), selected.end(), stampID);
	if (it != selected.end())
	{
		selected.erase(it, selected.end());
		notifySelectedChanged();
	}
}

void LocalBrowserModel::notifySelectedChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		LocalBrowserView* cObserver = observers[i];
		cObserver->NotifySelectedChanged(this);
	}
}


=== src\gui\localbrowser\LocalBrowserModel.h ===

#pragma once
#include "common/String.h"
#include <vector>
#include <memory>

class SaveFile;

class LocalBrowserView;
class LocalBrowserModel {
	std::vector<ByteString> selected;
	std::unique_ptr<SaveFile> stamp;
	std::vector<ByteString> stampIDs;
	std::vector<std::unique_ptr<SaveFile>> savesList;
	std::vector<LocalBrowserView*> observers;
	int currentPage = 0;
	bool stampToFront = true;
	void notifySavesListChanged();
	void notifyPageChanged();
	void notifySelectedChanged();
public:
	LocalBrowserModel();
	int GetPageCount();
	int GetPageNum() { return currentPage; }
	void AddObserver(LocalBrowserView * observer);
	std::vector<SaveFile *> GetSavesList(); // non-owning
	void UpdateSavesList(int pageNumber);
	void RescanStamps();
	const SaveFile *GetSave();
	std::unique_ptr<SaveFile> TakeSave();
	void OpenSave(int index);
	bool GetMoveToFront();
	void SetMoveToFront(bool move);
	std::vector<ByteString> GetSelected() { return selected; }
	void ClearSelected() { selected.clear(); notifySelectedChanged(); }
	void SelectSave(ByteString stampID);
	void DeselectSave(ByteString stampID);
};


=== src\gui\localbrowser\LocalBrowserModelException.h ===

#pragma once
#include "common/String.h"
#include <exception>

class LocalBrowserModelException : std::exception
{
	ByteString message;
public:
	LocalBrowserModelException(String message_): message(message_.ToUtf8()) {};
	const char * what() const throw() { return message.c_str(); };
	~LocalBrowserModelException() throw() {};
};


=== src\gui\localbrowser\LocalBrowserView.cpp ===

#include "LocalBrowserView.h"
#include "LocalBrowserController.h"
#include "LocalBrowserModel.h"
#include "gui/interface/Button.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/Label.h"
#include "gui/interface/SaveButton.h"
#include "PowderToySDL.h"
#include "client/SaveFile.h"
#include "graphics/Graphics.h"
#include "SimulationConfig.h"
#include <SDL.h>

LocalBrowserView::LocalBrowserView():
	ui::Window(ui::Point(0, 0), ui::Point(WINDOWW, WINDOWH)),
	changed(false),
	lastChanged(0),
	pageCount(0)
{
	nextButton = new ui::Button(ui::Point(WINDOWW-52, WINDOWH-18), ui::Point(50, 16), String("Next ") + 0xE015);
	previousButton = new ui::Button(ui::Point(2, WINDOWH-18), ui::Point(50, 16), 0xE016 + String(" Prev"));
	undeleteButton = new ui::Button(ui::Point(WINDOWW-122, WINDOWH-18), ui::Point(60, 16), "Rescan");
	AddComponent(nextButton);
	AddComponent(previousButton);
	AddComponent(undeleteButton);

	pageTextbox = new ui::Textbox(ui::Point(283, WINDOWH-18), ui::Point(41, 16), "");
	pageTextbox->SetActionCallback({ [this] { textChanged(); } });
	pageTextbox->SetInputType(ui::Textbox::Number);
	pageLabel = new ui::Label(ui::Point(0, WINDOWH-18), ui::Point(30, 16), "Page"); //page [TEXTBOX] of y
	pageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignRight;
	pageCountLabel = new ui::Label(ui::Point(WINDOWW/2+6, WINDOWH-18), ui::Point(50, 16), "");
	pageCountLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	AddComponent(pageLabel);
	AddComponent(pageCountLabel);
	AddComponent(pageTextbox);

	nextButton->SetActionCallback({ [this] { c->SetPageRelative(1); } });
	nextButton->Appearance.HorizontalAlign = ui::Appearance::AlignRight;
	nextButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;

	previousButton->SetActionCallback({ [this] { c->SetPageRelative(-1); } });
	previousButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	previousButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;

	undeleteButton->SetActionCallback({ [this] { c->RescanStamps(); } });

	removeSelected = new ui::Button(ui::Point(((WINDOWW-100)/2), WINDOWH-18), ui::Point(100, 16), "Delete");
	removeSelected->Visible = false;
	removeSelected->SetActionCallback({ [this] { c->RemoveSelected(); } });

	renameSelected = new ui::Button(ui::Point(((WINDOWW - 100) / 2 + 52), WINDOWH - 18), ui::Point(100, 16), "Rename");
	renameSelected->Visible = false;
	renameSelected->SetActionCallback({ [this] { c->RenameSelected(); } });

	AddComponent(removeSelected);
	AddComponent(renameSelected);
}

void LocalBrowserView::textChanged()
{
	int num = pageTextbox->GetText().ToNumber<int>(true);
	if (num < 0) //0 is allowed so that you can backspace the 1
		pageTextbox->SetText("1");
	else if (num > pageCount)
		pageTextbox->SetText(String::Build(pageCount));
	changed = true;
	lastChanged = GetTicks()+600;
}

void LocalBrowserView::OnTick()
{
	c->Update();
	if (changed && lastChanged < GetTicks())
	{
		changed = false;
		c->SetPage(std::max(pageTextbox->GetText().ToNumber<int>(true) - 1, 0));
	}
}

void LocalBrowserView::NotifyPageChanged(LocalBrowserModel * sender)
{
	pageCount = sender->GetPageCount();
	if (!sender->GetSavesList().size()) //no saves
	{
		pageLabel->Visible = pageCountLabel->Visible = pageTextbox->Visible = false;
	}
	else
	{
		String pageInfo = String::Build("of ", pageCount);
		pageCountLabel->SetText(pageInfo);
		int width = Graphics::TextSize(pageInfo).X - 1;

		pageLabel->Position.X = WINDOWW/2-width-20;
		pageTextbox->Position.X = WINDOWW/2-width+11;
		pageTextbox->Size.X = width-4;
		//pageCountLabel->Position.X = WINDOWW/2+6;
		pageLabel->Visible = pageCountLabel->Visible = pageTextbox->Visible = true;

		pageTextbox->SetText(String::Build(sender->GetPageNum() + 1));
	}

	if(sender->GetPageNum() == 0)
	{
		previousButton->Visible = false;
	}
	else
	{
		previousButton->Visible = true;
	}
	if(sender->GetPageNum() == sender->GetPageCount() - 1)
	{
		nextButton->Visible = false;
	}
	else
	{
		nextButton->Visible = true;
	}
}

void LocalBrowserView::NotifySavesListChanged(LocalBrowserModel * sender)
{
	int buttonWidth, buttonHeight, saveX = 0, saveY = 0, savesX = 5, savesY = 4, buttonPadding = 2;
	int buttonAreaWidth, buttonAreaHeight, buttonXOffset, buttonYOffset;

	auto saves = sender->GetSavesList(); // non-owning
	for (size_t i = 0; i < stampButtons.size(); i++)
	{
		RemoveComponent(stampButtons[i]);
		delete stampButtons[i];
	}
	stampButtons.clear();
	buttonXOffset = 0;
	buttonYOffset = 50;
	buttonAreaWidth = Size.X;
	buttonAreaHeight = Size.Y - buttonYOffset - 18;
	buttonWidth = (buttonAreaWidth/savesX) - buttonPadding*2;
	buttonHeight = (buttonAreaHeight/savesY) - buttonPadding*2;
	for (auto i = 0; i < int(saves.size()); i++)
	{
		if(saveX == savesX)
		{
			if(saveY == savesY-1)
				break;
			saveX = 0;
			saveY++;
		}
		ui::SaveButton * saveButton;
		saveButton = new ui::SaveButton(
					ui::Point(
						buttonXOffset + buttonPadding + saveX*(buttonWidth+buttonPadding*2),
						buttonYOffset + buttonPadding + saveY*(buttonHeight+buttonPadding*2)
						),
					ui::Point(buttonWidth, buttonHeight),
					saves[i]);
		saveButton->SetSelectable(true);
		saveButton->SetActionCallback({
			[this, saveButton, i] {
				if (saveButton->GetSaveFile())
					c->OpenSave(i);
			},
			nullptr,
			nullptr,
			[this, saveButton] {
				if (saveButton->GetSaveFile())
					c->Selected(saveButton->GetSaveFile()->GetDisplayName().ToUtf8(), saveButton->GetSelected());
			}
		});
		stampButtons.push_back(saveButton);
		AddComponent(saveButton);
		saveX++;
	}
}

void LocalBrowserView::NotifySelectedChanged(LocalBrowserModel * sender)
{
	std::vector<ByteString> selected = sender->GetSelected();
	for (size_t j = 0; j < stampButtons.size(); j++)
	{
		stampButtons[j]->SetSelected(false);
		for (size_t i = 0; i < selected.size(); i++)
		{
			if (stampButtons[j]->GetSaveFile()->GetDisplayName().ToUtf8() == selected[i])
				stampButtons[j]->SetSelected(true);
		}
	}

	removeSelected->Visible = selected.size() > 0;
	renameSelected->Visible = selected.size() == 1;
	removeSelected->Position.X = (WINDOWW - 100) / 2;
	if (renameSelected->Visible)
	{
		removeSelected->Position.X -= 52;
	}

	auto showPagination = !removeSelected->Visible;
	pageLabel->Visible = showPagination;
	pageCountLabel->Visible = showPagination;
	pageTextbox->Visible = showPagination;
}

void LocalBrowserView::OnMouseWheel(int x, int y, int d)
{
	if (d)
		c->SetPageRelative(-d);
}

void LocalBrowserView::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	if (key == SDLK_ESCAPE || key == SDLK_AC_BACK)
		c->Exit();
	else if (key == SDLK_LCTRL || key == SDLK_RCTRL)
		c->SetMoveToFront(false);
}

void LocalBrowserView::OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	if (key == SDLK_LCTRL || key == SDLK_RCTRL)
		c->SetMoveToFront(true);
}

LocalBrowserView::~LocalBrowserView() { }


=== src\gui\localbrowser\LocalBrowserView.h ===

#pragma once
#include "gui/interface/Window.h"
#include <vector>

namespace ui
{
	class Label;
	class Textbox;
	class Button;
	class SaveButton;
}

class LocalBrowserController;
class LocalBrowserModel;
class LocalBrowserView: public ui::Window {
	LocalBrowserController * c;
	std::vector<ui::SaveButton*> stampButtons;
	ui::Button * undeleteButton;
	ui::Button * previousButton;
	ui::Button * nextButton;
	ui::Label * pageLabel;
	ui::Label * pageCountLabel;
	ui::Textbox * pageTextbox;
	ui::Button * removeSelected;
	ui::Button *renameSelected;

	void textChanged();
	bool changed;
	unsigned int lastChanged;
	int pageCount;
public:
	LocalBrowserView();
	//virtual void OnDraw();
	void OnTick() override;
	void AttachController(LocalBrowserController * c_) { c = c_; }
	void NotifyPageChanged(LocalBrowserModel * sender);
	void NotifySavesListChanged(LocalBrowserModel * sender);
	void NotifySelectedChanged(LocalBrowserModel * sender);
	void OnMouseWheel(int x, int y, int d) override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	virtual ~LocalBrowserView();
};


=== src\gui\localbrowser\meson.build ===

powder_files += files(
	'LocalBrowserController.cpp',
	'LocalBrowserModel.cpp',
	'LocalBrowserView.cpp',
)


=== src\gui\login\LoginController.cpp ===

#include "LoginController.h"
#include "client/Client.h"
#include "client/http/LoginRequest.h"
#include "client/http/LogoutRequest.h"
#include "LoginView.h"
#include "LoginModel.h"
#include "Controller.h"

LoginController::LoginController(std::function<void ()> onDone_):
	HasExited(false)
{
	loginView = new LoginView();
	loginModel = new LoginModel();

	loginView->AttachController(this);
	loginModel->AddObserver(loginView);

	onDone = onDone_;
}

void LoginController::Login(ByteString username, ByteString password)
{
	loginModel->Login(username, password);
}

void LoginController::Logout()
{
	loginModel->Logout();
}

void LoginController::Tick()
{
	loginModel->Tick();
}

void LoginController::Exit()
{
	loginView->CloseActiveWindow();
	if (onDone)
		onDone();
	HasExited = true;
}

LoginController::~LoginController()
{
	delete loginModel;
	loginView->CloseActiveWindow();
	delete loginView;
}



=== src\gui\login\LoginController.h ===

#pragma once
#include "common/String.h"
#include "client/User.h"
#include <functional>

class LoginView;
class LoginModel;
class LoginController
{
	LoginView * loginView;
	LoginModel * loginModel;
	std::function<void ()> onDone;
public:
	bool HasExited;
	LoginController(std::function<void ()> onDone = nullptr);
	void Login(ByteString username, ByteString password);
	void Logout();
	void Tick();
	void Exit();
	LoginView * GetView() { return loginView; }
	~LoginController();
};


=== src\gui\login\LoginModel.cpp ===

#include "LoginModel.h"
#include "LoginView.h"
#include "Config.h"
#include "client/Client.h"
#include "client/http/LoginRequest.h"
#include "client/http/LogoutRequest.h"

void LoginModel::Login(ByteString username, ByteString password)
{
	if (username.Contains("@"))
	{
		statusText = String::Build("Use your Powder Toy account to log in, not your email. If you don't have a Powder Toy account, you can create one at ", SERVER, "/Register.html");
		loginStatus = loginIdle;
		notifyStatusChanged();
		return;
	}
	statusText = "Logging in...";
	loginStatus = loginWorking;
	notifyStatusChanged();
	loginRequest = std::make_unique<http::LoginRequest>(username, password);
	loginRequest->Start();
}

void LoginModel::Logout()
{
	statusText = "Logging out...";
	loginStatus = loginWorking;
	notifyStatusChanged();
	logoutRequest = std::make_unique<http::LogoutRequest>();
	logoutRequest->Start();
}

void LoginModel::AddObserver(LoginView * observer)
{
	observers.push_back(observer);
	notifyStatusChanged();
}

String LoginModel::GetStatusText()
{
	return statusText;
}

void LoginModel::Tick()
{
	if (loginRequest && loginRequest->CheckDone())
	{
		try
		{
			auto info = loginRequest->Finish();
			auto &client = Client::Ref();
			client.SetAuthUser(info.user);
			for (auto &item : info.notifications)
			{
				client.AddServerNotification(item);
			}
			statusText = "Logged in";
			loginStatus = loginSucceeded;
		}
		catch (const http::RequestError &ex)
		{
			statusText = ByteString(ex.what()).FromUtf8();
			loginStatus = loginIdle;
		}
		notifyStatusChanged();
		loginRequest.reset();
	}
	if (logoutRequest && logoutRequest->CheckDone())
	{
		try
		{
			logoutRequest->Finish();
			auto &client = Client::Ref();
			client.SetAuthUser(User(0, ""));
			statusText = "Logged out";
		}
		catch (const http::RequestError &ex)
		{
			statusText = ByteString(ex.what()).FromUtf8();
		}
		loginStatus = loginIdle;
		notifyStatusChanged();
		logoutRequest.reset();
	}
}

void LoginModel::notifyStatusChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyStatusChanged(this);
	}
}

LoginModel::~LoginModel()
{
	// Satisfy std::unique_ptr
}


=== src\gui\login\LoginModel.h ===

#pragma once
#include "common/String.h"
#include "client/User.h"
#include <vector>
#include <memory>

namespace http
{
	class LoginRequest;
	class LogoutRequest;
}

enum LoginStatus
{
	loginIdle,
	loginWorking,
	loginSucceeded,
};

class LoginView;
class LoginModel
{
	std::unique_ptr<http::LoginRequest> loginRequest;
	std::unique_ptr<http::LogoutRequest> logoutRequest;
	std::vector<LoginView*> observers;
	String statusText;
	LoginStatus loginStatus = loginIdle;
	void notifyStatusChanged();

public:
	void Login(ByteString username, ByteString password);
	void Logout();
	void AddObserver(LoginView * observer);
	String GetStatusText();
	LoginStatus GetStatus() const
	{
		return loginStatus;
	}
	void Tick();
	User GetUser();
	~LoginModel();
};


=== src\gui\login\LoginView.cpp ===

#include "LoginView.h"
#include "Config.h"
#include "LoginModel.h"
#include "LoginController.h"
#include "graphics/Graphics.h"
#include "gui/interface/Button.h"
#include "gui/interface/Label.h"
#include "gui/interface/RichLabel.h"
#include "gui/interface/Textbox.h"
#include "gui/Style.h"
#include "client/Client.h"
#include "Misc.h"
#include <SDL.h>

constexpr auto defaultSize = ui::Point(200, 87);

LoginView::LoginView():
	ui::Window(ui::Point(-1, -1), defaultSize),
	loginButton(new ui::Button(ui::Point(200-100, 87-17), ui::Point(100, 17), "Sign in")),
	cancelButton(new ui::Button(ui::Point(0, 87-17), ui::Point(101, 17), "Sign Out")),
	titleLabel(new ui::Label(ui::Point(4, 5), ui::Point(200-16, 16), "Server login")),
	infoLabel(new ui::RichLabel(ui::Point(6, 67), ui::Point(200-12, 16), "")),
	usernameField(new ui::Textbox(ui::Point(8, 25), ui::Point(200-16, 17), Client::Ref().GetAuthUser().Username.FromUtf8(), "[username]")),
	passwordField(new ui::Textbox(ui::Point(8, 46), ui::Point(200-16, 17), "", "[password]"))
{
	targetSize.SetTarget(Size.Y);
	targetSize.SetValue(Size.Y);
	FocusComponent(usernameField);

	infoLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	infoLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	infoLabel->SetMultiline(true);
	infoLabel->Visible = false;
	AddComponent(infoLabel);

	AddComponent(loginButton);
	SetOkayButton(loginButton);
	loginButton->Appearance.HorizontalAlign = ui::Appearance::AlignRight;
	loginButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	loginButton->Appearance.TextInactive = style::Colour::ConfirmButton;
	loginButton->SetActionCallback({ [this] {
		c->Login(usernameField->GetText().ToUtf8(), passwordField->GetText().ToUtf8());
	} });
	AddComponent(cancelButton);
	cancelButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	cancelButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	cancelButton->SetActionCallback({ [this] {
		c->Logout();
	} });
	AddComponent(titleLabel);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;

	AddComponent(usernameField);
	usernameField->Appearance.icon = IconUsername;
	usernameField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	usernameField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(passwordField);
	passwordField->Appearance.icon = IconPassword;
	passwordField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	passwordField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	passwordField->SetHidden(true);
}

void LoginView::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	switch(key)
	{
	case SDLK_TAB:
		if(IsFocused(usernameField))
			FocusComponent(passwordField);
		else
			FocusComponent(usernameField);
		break;
	}
}

void LoginView::OnTryExit(ExitMethod method)
{
	CloseActiveWindow();
}

void LoginView::NotifyStatusChanged(LoginModel * sender)
{
	auto statusText = sender->GetStatusText();
	auto notWorking = sender->GetStatus() != loginWorking;
	auto userID = Client::Ref().GetAuthUser().UserID;
	if (!statusText.size() && !userID && notWorking)
	{
		statusText = String::Build("Don't have an account? {a:", SERVER, "/Register.html", "|\btRegister here\x0E}.");
	}
	infoLabel->Visible = statusText.size();
	infoLabel->SetText(statusText);
	infoLabel->AutoHeight();
	loginButton->Enabled = notWorking;
	cancelButton->Enabled = notWorking && userID;
	usernameField->Enabled = notWorking;
	passwordField->Enabled = notWorking;
	if (infoLabel->Visible)
	{
		targetSize.SetTarget(defaultSize.Y + infoLabel->Size.Y);
	}
	else
	{
		targetSize.SetTarget(defaultSize.Y);
	}
	if (sender->GetStatus() == loginSucceeded)
	{
		c->Exit();
	}
}

void LoginView::OnTick()
{
	c->Tick();
	Size.Y = targetSize.GetValue();
	loginButton->Position.Y = Size.Y-17;
	cancelButton->Position.Y = Size.Y-17;
}

void LoginView::OnDraw()
{
	Graphics * g = GetGraphics();
	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);
}


=== src\gui\login\LoginView.h ===

#pragma once
#include "gui/interface/Window.h"
#include "gui/interface/Fade.h"

namespace ui
{
	class Textbox;
	class Button;
	class Label;
}

class LoginController;
class LoginModel;
class LoginView: public ui::Window
{
	LoginController *c{};
	ui::Button *loginButton{};
	ui::Button *cancelButton{};
	ui::Label *titleLabel{};
	ui::Label *infoLabel{};
	ui::Textbox *usernameField{};
	ui::Textbox *passwordField{};
	ui::Fade targetSize{ ui::Fade::BasicDimensionProfile };
public:
	LoginView();
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnTryExit(ExitMethod method) override;
	void AttachController(LoginController * c_) { c = c_; }
	void NotifyStatusChanged(LoginModel * sender);
	void OnDraw() override;
	void OnTick() override;
};


=== src\gui\login\meson.build ===

powder_files += files(
	'LoginController.cpp',
	'LoginModel.cpp',
	'LoginView.cpp',
)


=== src\gui\options\meson.build ===

powder_files += files(
	'OptionsController.cpp',
	'OptionsModel.cpp',
	'OptionsView.cpp',
)


=== src\gui\options\OptionsController.cpp ===

#include "OptionsController.h"

#include "OptionsView.h"
#include "OptionsModel.h"

#include "Controller.h"

OptionsController::OptionsController(GameModel * gModel_, std::function<void ()> onDone_):
	gModel(gModel_),
	onDone(onDone_),
	HasExited(false)
{
	view = new OptionsView();
	model = new OptionsModel(gModel);
	model->AddObserver(view);

	view->AttachController(this);
}

void OptionsController::SetHeatSimulation(bool state)
{
	model->SetHeatSimulation(state);
}

void OptionsController::SetAmbientHeatSimulation(bool state)
{
	model->SetAmbientHeatSimulation(state);
}

void OptionsController::SetNewtonianGravity(bool state)
{
	model->SetNewtonianGravity(state);
}

void OptionsController::SetWaterEqualisation(bool state)
{
	model->SetWaterEqualisation(state);
}

void OptionsController::SetGravityMode(int gravityMode)
{
	model->SetGravityMode(gravityMode);
}

void OptionsController::SetCustomGravityX(float x)
{
	model->SetCustomGravityX(x);
}

void OptionsController::SetCustomGravityY(float y)
{
	model->SetCustomGravityY(y);
}

void OptionsController::SetAirMode(int airMode)
{
	model->SetAirMode(airMode);
}

void OptionsController::SetAmbientAirTemperature(float ambientAirTemp)
{
	model->SetAmbientAirTemperature(ambientAirTemp);
}

void OptionsController::SetEdgeMode(int edgeMode)
{
	model->SetEdgeMode(edgeMode);
}

void OptionsController::SetTemperatureScale(int temperatureScale)
{
	model->SetTemperatureScale(temperatureScale);
}

void OptionsController::SetThreadedRendering(bool newThreadedRendering)
{
	model->SetThreadedRendering(newThreadedRendering);
}

void OptionsController::SetFullscreen(bool fullscreen)
{
	model->SetFullscreen(fullscreen);
}

void OptionsController::SetChangeResolution(bool newChangeResolution)
{
	model->SetChangeResolution(newChangeResolution);
}

void OptionsController::SetForceIntegerScaling(bool forceIntegerScaling)
{
	model->SetForceIntegerScaling(forceIntegerScaling);
}

void OptionsController::SetBlurryScaling(bool newBlurryScaling)
{
	model->SetBlurryScaling(newBlurryScaling);
}

void OptionsController::SetShowAvatars(bool showAvatars)
{
	model->SetShowAvatars(showAvatars);
}

void OptionsController::SetScale(int scale)
{
	model->SetScale(scale);
}

void OptionsController::SetGraveExitsConsole(bool graveExitsConsole)
{
	model->SetGraveExitsConsole(graveExitsConsole);
}

void OptionsController::SetNativeClipoard(bool nativeClipoard)
{
	model->SetNativeClipoard(nativeClipoard);
}

void OptionsController::SetResizable(bool resizable)
{
	model->SetResizable(resizable);
}

void OptionsController::SetFastQuit(bool fastquit)
{
	model->SetFastQuit(fastquit);
}

void OptionsController::SetGlobalQuit(bool newGlobalQuit)
{
	model->SetGlobalQuit(newGlobalQuit);
}

void OptionsController::SetDecoSpace(int decoSpace)
{
	model->SetDecoSpace(decoSpace);
}

OptionsView * OptionsController::GetView()
{
	return view;
}

void OptionsController::SetMouseClickrequired(bool mouseClickRequired)
{
	model->SetMouseClickRequired(mouseClickRequired);
}

void OptionsController::SetIncludePressure(bool includePressure)
{
	model->SetIncludePressure(includePressure);
}

void OptionsController::SetPerfectCircle(bool perfectCircle)
{
	model->SetPerfectCircle(perfectCircle);
}

void OptionsController::SetMomentumScroll(bool momentumScroll)
{
	model->SetMomentumScroll(momentumScroll);
}

void OptionsController::SetRedirectStd(bool newRedirectStd)
{
	model->SetRedirectStd(newRedirectStd);
}

void OptionsController::SetAutoStartupRequest(bool newAutoStartupRequest)
{
	model->SetAutoStartupRequest(newAutoStartupRequest);
}

void OptionsController::Exit()
{
	view->CloseActiveWindow();

	if (onDone)
		onDone();
	HasExited = true;
}


OptionsController::~OptionsController()
{
	delete model;
	view->CloseActiveWindow();
	delete view;
}



=== src\gui\options\OptionsController.h ===

#pragma once
#include <functional>

class GameModel;
class OptionsModel;
class OptionsView;
class OptionsController
{
	GameModel * gModel;
	OptionsView * view;
	OptionsModel * model;
	std::function<void ()> onDone;
public:
	bool HasExited;
	OptionsController(GameModel * gModel_, std::function<void ()> onDone = nullptr);
	void SetHeatSimulation(bool state);
	void SetAmbientHeatSimulation(bool state);
	void SetNewtonianGravity(bool state);
	void SetWaterEqualisation(bool state);
	void SetGravityMode(int gravityMode);
	void SetCustomGravityX(float x);
	void SetCustomGravityY(float y);
	void SetAirMode(int airMode);
	void SetAmbientAirTemperature(float ambientAirTemp);
	void SetEdgeMode(int edgeMode);
	void SetTemperatureScale(int temperatureScale);
	void SetThreadedRendering(bool newThreadedRendering);
	void SetFullscreen(bool fullscreen);
	void SetChangeResolution(bool newChangeResolution);
	void SetForceIntegerScaling(bool forceIntegerScaling);
	void SetBlurryScaling(bool newBlurryScaling);
	void SetScale(int scale);
	void SetGraveExitsConsole(bool graveExitsConsole);
	void SetNativeClipoard(bool nativeClipoard);
	void SetResizable(bool resizable);
	void SetFastQuit(bool fastquit);
	void SetGlobalQuit(bool newGlobalQuit);
	void SetDecoSpace(int decoSpace);
	void SetShowAvatars(bool showAvatars);
	void SetMouseClickrequired(bool mouseClickRequired);
	void SetIncludePressure(bool includePressure);
	void SetPerfectCircle(bool perfectCircle);
	void SetMomentumScroll(bool momentumScroll);
	void SetRedirectStd(bool newRedirectStd);
	void SetAutoStartupRequest(bool newAutoStartupRequest);
	
	void Exit();
	OptionsView * GetView();
	virtual ~OptionsController();
};


=== src\gui\options\OptionsModel.cpp ===

#include "OptionsModel.h"
#include "OptionsView.h"
#include "simulation/Simulation.h"
#include "simulation/Air.h"
#include "simulation/gravity/Gravity.h"
#include "prefs/GlobalPrefs.h"
#include "common/clipboard/Clipboard.h"
#include "gui/interface/Engine.h"
#include "gui/game/GameModel.h"
#include "client/Client.h"

OptionsModel::OptionsModel(GameModel * gModel_) {
	gModel = gModel_;
	sim = gModel->GetSimulation();
}

void OptionsModel::AddObserver(OptionsView* view)
{
	observers.push_back(view);
	view->NotifySettingsChanged(this);
}

bool OptionsModel::GetHeatSimulation()
{
	return sim->legacy_enable?false:true;
}

void OptionsModel::SetHeatSimulation(bool state)
{
	sim->legacy_enable = state?0:1;
	notifySettingsChanged();
}

bool OptionsModel::GetAmbientHeatSimulation()
{
	return sim->aheat_enable?true:false;
}

void OptionsModel::SetAmbientHeatSimulation(bool state)
{
	sim->aheat_enable = state?1:0;
	notifySettingsChanged();
}

bool OptionsModel::GetNewtonianGravity()
{
	return bool(sim->grav);
}

void OptionsModel::SetNewtonianGravity(bool state)
{
	sim->EnableNewtonianGravity(state);
	notifySettingsChanged();
}

bool OptionsModel::GetWaterEqualisation()
{
	return sim->water_equal_test?true:false;
}

void OptionsModel::SetWaterEqualisation(bool state)
{
	sim->water_equal_test = state?1:0;
	notifySettingsChanged();
}

int OptionsModel::GetAirMode()
{
	return sim->air->airMode;
}
void OptionsModel::SetAirMode(int airMode)
{
	sim->air->airMode = airMode;
	notifySettingsChanged();
}

int OptionsModel::GetEdgeMode()
{
	return gModel->GetSimulation()->edgeMode;
}
void OptionsModel::SetEdgeMode(int edgeMode)
{
	GlobalPrefs::Ref().Set("Simulation.EdgeMode", edgeMode);
	gModel->SetEdgeMode(edgeMode);
	notifySettingsChanged();
}

int OptionsModel::GetTemperatureScale()
{
	return gModel->GetTemperatureScale();
}
void OptionsModel::SetTemperatureScale(int temperatureScale)
{
	GlobalPrefs::Ref().Set("Renderer.TemperatureScale", temperatureScale);
	gModel->SetTemperatureScale(temperatureScale);
	notifySettingsChanged();
}

int OptionsModel::GetThreadedRendering()
{
	return gModel->GetThreadedRendering();
}

void OptionsModel::SetThreadedRendering(bool newThreadedRendering)
{
	GlobalPrefs::Ref().Set("Renderer.SeparateThread", newThreadedRendering);
	gModel->SetThreadedRendering(newThreadedRendering);
	notifySettingsChanged();
}

float OptionsModel::GetAmbientAirTemperature()
{
	return gModel->GetSimulation()->air->ambientAirTemp;
}
void OptionsModel::SetAmbientAirTemperature(float ambientAirTemp)
{
	GlobalPrefs::Ref().Set("Simulation.AmbientAirTemp", ambientAirTemp);
	gModel->SetAmbientAirTemperature(ambientAirTemp);
	notifySettingsChanged();
}

int OptionsModel::GetGravityMode()
{
	return sim->gravityMode;
}
void OptionsModel::SetGravityMode(int gravityMode)
{
	sim->gravityMode = gravityMode;
	notifySettingsChanged();
}

float OptionsModel::GetCustomGravityX()
{
	return sim->customGravityX;
}

void OptionsModel::SetCustomGravityX(float x)
{
	sim->customGravityX = x;
	notifySettingsChanged();
}

float OptionsModel::GetCustomGravityY()
{
	return sim->customGravityY;
}

void OptionsModel::SetCustomGravityY(float y)
{
	sim->customGravityY = y;
	notifySettingsChanged();
}

int OptionsModel::GetScale()
{
	return ui::Engine::Ref().GetScale();
}

void OptionsModel::SetScale(int scale)
{
	ui::Engine::Ref().SetScale(scale);
	GlobalPrefs::Ref().Set("Scale", int(scale));
	notifySettingsChanged();
}

bool OptionsModel::GetGraveExitsConsole()
{
	return ui::Engine::Ref().GraveExitsConsole;
}

void OptionsModel::SetGraveExitsConsole(bool graveExitsConsole)
{
	ui::Engine::Ref().GraveExitsConsole = graveExitsConsole;
	GlobalPrefs::Ref().Set("GraveExitsConsole", graveExitsConsole);
	notifySettingsChanged();
}

bool OptionsModel::GetNativeClipoard()
{
	return Clipboard::GetEnabled();
}

void OptionsModel::SetNativeClipoard(bool nativeClipoard)
{
	Clipboard::SetEnabled(nativeClipoard);
	GlobalPrefs::Ref().Set("NativeClipboard.Enabled", nativeClipoard);
	notifySettingsChanged();
}

bool OptionsModel::GetResizable()
{
	return ui::Engine::Ref().GetResizable();
}

void OptionsModel::SetResizable(bool resizable)
{
	ui::Engine::Ref().SetResizable(resizable);
	GlobalPrefs::Ref().Set("Resizable", resizable);
	notifySettingsChanged();
}

bool OptionsModel::GetFullscreen()
{
	return ui::Engine::Ref().GetFullscreen();
}
void OptionsModel::SetFullscreen(bool fullscreen)
{
	ui::Engine::Ref().SetFullscreen(fullscreen);
	GlobalPrefs::Ref().Set("Fullscreen", fullscreen);
	notifySettingsChanged();
}

bool OptionsModel::GetChangeResolution()
{
	return ui::Engine::Ref().GetChangeResolution();
}

void OptionsModel::SetChangeResolution(bool newChangeResolution)
{
	ui::Engine::Ref().SetChangeResolution(newChangeResolution);
	GlobalPrefs::Ref().Set("AltFullscreen", newChangeResolution);
	notifySettingsChanged();
}

bool OptionsModel::GetForceIntegerScaling()
{
	return ui::Engine::Ref().GetForceIntegerScaling();
}

void OptionsModel::SetForceIntegerScaling(bool forceIntegerScaling)
{
	ui::Engine::Ref().SetForceIntegerScaling(forceIntegerScaling);
	GlobalPrefs::Ref().Set("ForceIntegerScaling", forceIntegerScaling);
	notifySettingsChanged();
}

bool OptionsModel::GetBlurryScaling()
{
	return ui::Engine::Ref().GetBlurryScaling();
}

void OptionsModel::SetBlurryScaling(bool newBlurryScaling)
{
	ui::Engine::Ref().SetBlurryScaling(newBlurryScaling);
	GlobalPrefs::Ref().Set("BlurryScaling", newBlurryScaling);
	notifySettingsChanged();
}

bool OptionsModel::GetFastQuit()
{
	return ui::Engine::Ref().GetFastQuit();
}
void OptionsModel::SetFastQuit(bool fastquit)
{
	ui::Engine::Ref().SetFastQuit(fastquit);
	GlobalPrefs::Ref().Set("FastQuit", bool(fastquit));
	notifySettingsChanged();
}

bool OptionsModel::GetGlobalQuit()
{
	return ui::Engine::Ref().GetGlobalQuit();
}
void OptionsModel::SetGlobalQuit(bool newGlobalQuit)
{
	ui::Engine::Ref().SetGlobalQuit(newGlobalQuit);
	GlobalPrefs::Ref().Set("GlobalQuit", newGlobalQuit);
	notifySettingsChanged();
}

int OptionsModel::GetDecoSpace()
{
	return gModel->GetDecoSpace();
}
void OptionsModel::SetDecoSpace(int decoSpace)
{
	GlobalPrefs::Ref().Set("Simulation.DecoSpace", decoSpace);
	gModel->SetDecoSpace(decoSpace);
	notifySettingsChanged();
}

bool OptionsModel::GetShowAvatars()
{
	return ui::Engine::Ref().ShowAvatars;
}

void OptionsModel::SetShowAvatars(bool state)
{
	ui::Engine::Ref().ShowAvatars = state;
	GlobalPrefs::Ref().Set("ShowAvatars", state);
	notifySettingsChanged();
}

bool OptionsModel::GetMouseClickRequired()
{
	return gModel->GetMouseClickRequired();
}

void OptionsModel::SetMouseClickRequired(bool mouseClickRequired)
{
	GlobalPrefs::Ref().Set("MouseClickRequired", mouseClickRequired);
	gModel->SetMouseClickRequired(mouseClickRequired);
	notifySettingsChanged();
}

bool OptionsModel::GetIncludePressure()
{
	return gModel->GetIncludePressure();
}

void OptionsModel::SetIncludePressure(bool includePressure)
{
	GlobalPrefs::Ref().Set("Simulation.IncludePressure", includePressure);
	gModel->SetIncludePressure(includePressure);
	notifySettingsChanged();
}

bool OptionsModel::GetPerfectCircle()
{
	return gModel->GetPerfectCircle();
}

void OptionsModel::SetPerfectCircle(bool perfectCircle)
{
	GlobalPrefs::Ref().Set("PerfectCircleBrush", perfectCircle);
	gModel->SetPerfectCircle(perfectCircle);
	notifySettingsChanged();
}

bool OptionsModel::GetMomentumScroll()
{
	return ui::Engine::Ref().MomentumScroll;
}

void OptionsModel::SetMomentumScroll(bool state)
{
	GlobalPrefs::Ref().Set("MomentumScroll", state);
	ui::Engine::Ref().MomentumScroll = state;
	notifySettingsChanged();
}

bool OptionsModel::GetRedirectStd()
{
	return Client::Ref().GetRedirectStd();
}

void OptionsModel::SetRedirectStd(bool newRedirectStd)
{
	GlobalPrefs::Ref().Set("RedirectStd", newRedirectStd);
	Client::Ref().SetRedirectStd(newRedirectStd);
	notifySettingsChanged();
}
bool OptionsModel::GetAutoStartupRequest()
{
	return Client::Ref().GetAutoStartupRequest();
}

void OptionsModel::SetAutoStartupRequest(bool newAutoStartupRequest)
{
	GlobalPrefs::Ref().Set("AutoStartupRequest", newAutoStartupRequest);
	Client::Ref().SetAutoStartupRequest(newAutoStartupRequest);
	notifySettingsChanged();
}

void OptionsModel::notifySettingsChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifySettingsChanged(this);
	}
}

OptionsModel::~OptionsModel() {
}



=== src\gui\options\OptionsModel.h ===

#pragma once
#include <vector>

class GameModel;
class Simulation;
class OptionsView;
class OptionsModel
{
	GameModel * gModel;
	Simulation * sim;
	std::vector<OptionsView*> observers;
	void notifySettingsChanged();
public:
	OptionsModel(GameModel * gModel);
	void AddObserver(OptionsView* view);
	bool GetHeatSimulation();
	void SetHeatSimulation(bool state);
	bool GetAmbientHeatSimulation();
	void SetAmbientHeatSimulation(bool state);
	bool GetNewtonianGravity();
	void SetNewtonianGravity(bool state);
	bool GetWaterEqualisation();
	void SetWaterEqualisation(bool state);
	bool GetShowAvatars();
	void SetShowAvatars(bool state);
	int GetAirMode();
	void SetAirMode(int airMode);
	float GetAmbientAirTemperature();
	void SetAmbientAirTemperature(float ambientAirTemp);
	int GetEdgeMode();
	void SetEdgeMode(int edgeMode);
	int GetTemperatureScale();
	void SetTemperatureScale(int temperatureScale);
	int GetThreadedRendering();
	void SetThreadedRendering(bool newThreadedRendering);
	int GetGravityMode();
	void SetGravityMode(int gravityMode);
	float GetCustomGravityX();
	void SetCustomGravityX(float x);
	float GetCustomGravityY();
	void SetCustomGravityY(float y);
	int GetScale();
	void SetScale(int scale);
	bool GetGraveExitsConsole();
	void SetGraveExitsConsole(bool graveExitsConsole);
	bool GetNativeClipoard();
	void SetNativeClipoard(bool nativeClipoard);
	bool GetResizable();
	void SetResizable(bool resizable);
	bool GetFullscreen();
	void SetFullscreen(bool fullscreen);
	bool GetChangeResolution();
	void SetChangeResolution(bool newChangeResolution);
	bool GetForceIntegerScaling();
	void SetForceIntegerScaling(bool forceIntegerScaling);
	bool GetBlurryScaling();
	void SetBlurryScaling(bool newBlurryScaling);
	bool GetFastQuit();
	void SetFastQuit(bool fastquit);
	bool GetGlobalQuit();
	void SetGlobalQuit(bool newGlobalQuit);
	int GetDecoSpace();
	void SetDecoSpace(int decoSpace);
	bool GetMouseClickRequired();
	void SetMouseClickRequired(bool mouseClickRequired);
	bool GetIncludePressure();
	void SetIncludePressure(bool includePressure);
	bool GetPerfectCircle();
	void SetPerfectCircle(bool perfectCircle);
	bool GetMomentumScroll();
	void SetMomentumScroll(bool momentumScroll);
	bool GetRedirectStd();
	void SetRedirectStd(bool newRedirectStd);
	bool GetAutoStartupRequest();
	void SetAutoStartupRequest(bool newAutoStartupRequest);
	virtual ~OptionsModel();
};


=== src\gui\options\OptionsView.cpp ===

#include "OptionsView.h"
#include "Format.h"
#include "OptionsController.h"
#include "OptionsModel.h"
#include "common/clipboard/Clipboard.h"
#include "common/platform/Platform.h"
#include "graphics/Graphics.h"
#include "graphics/Renderer.h"
#include "gui/Style.h"
#include "simulation/ElementDefs.h"
#include "simulation/SimulationSettings.h"
#include "client/Client.h"
#include "gui/credits/Credits.h"
#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/dialogues/InformationMessage.h"
#include "gui/interface/Button.h"
#include "gui/interface/Checkbox.h"
#include "gui/interface/DropDown.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Label.h"
#include "gui/interface/Separator.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/DirectionSelector.h"
#include "PowderToySDL.h"
#include "Config.h"
#include <cstdio>
#include <cstring>
#include <cmath>
#include <SDL.h>

OptionsView::OptionsView() : ui::Window(ui::Point(-1, -1), ui::Point(320, 340))
{
	auto autoWidth = [this](ui::Component *c, int extra) {
		c->Size.X = Size.X - c->Position.X - 12 - extra;
	};
	
	{
		auto *label = new ui::Label(ui::Point(4, 1), ui::Point(Size.X-8, 22), "Settings");
		label->SetTextColour(style::Colour::InformationTitle);
		label->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		label->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		autoWidth(label, 0);
		AddComponent(label);
	}

	auto *tmpSeparator = new ui::Separator(ui::Point(0, 22), ui::Point(Size.X, 1));
	AddComponent(tmpSeparator);

	scrollPanel = new ui::ScrollPanel(ui::Point(1, 23), ui::Point(Size.X-2, Size.Y-39));
	
	AddComponent(scrollPanel);

	int currentY = 8;
	auto addLabel = [this, &currentY, &autoWidth](int indent, String text) {
		auto *label = new ui::Label(ui::Point(22 + indent * 15, currentY), ui::Point(1, 16), "");
		autoWidth(label, 0);
		label->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		label->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		label->SetMultiline(true);
		label->SetText("\bg" + text); // stupid hack because autoWidth just changes Size.X and that doesn't update the text wrapper
		label->AutoHeight();
		scrollPanel->AddChild(label);
		currentY += label->Size.Y - 1;
		return label;
	};
	auto addCheckbox = [this, &currentY, &autoWidth, &addLabel](int indent, String text, String info, std::function<void ()> action) {
		auto *checkbox = new ui::Checkbox(ui::Point(8 + indent * 15, currentY), ui::Point(1, 16), text, "");
		autoWidth(checkbox, 0);
		checkbox->SetActionCallback({ action });
		currentY += 14;
		if (info.size())
		{
			addLabel(indent, info);
		}
		currentY += 4;
		scrollPanel->AddChild(checkbox);
		return checkbox;
	};
	auto addDropDown = [this, &currentY, &autoWidth](String info, std::vector<std::pair<String, int>> options, std::function<void ()> action) {
		auto *dropDown = new ui::DropDown(ui::Point(Size.X - 95, currentY), ui::Point(80, 16));
		scrollPanel->AddChild(dropDown);
		for (auto &option : options)
		{
			dropDown->AddOption(option);
		}
		dropDown->SetActionCallback({ action });
		auto *label = new ui::Label(ui::Point(8, currentY), ui::Point(Size.X - 96, 16), info);
		label->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		label->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		scrollPanel->AddChild(label);
		autoWidth(label, 85);
		currentY += 20;
		return dropDown;
	};
	auto addSeparator = [this, &currentY]() {
		currentY += 6;
		auto *separator = new ui::Separator(ui::Point(0, currentY), ui::Point(Size.X, 1));
		scrollPanel->AddChild(separator);
		currentY += 11;
	};

	heatSimulation = addCheckbox(0, "Heat simulation \bgIntroduced in version 34", "Can cause odd behaviour when disabled", [this] {
		c->SetHeatSimulation(heatSimulation->GetChecked());
	});
	newtonianGravity = addCheckbox(0, "Newtonian gravity \bgIntroduced in version 48", "May cause poor performance on older computers", [this] {
		c->SetNewtonianGravity(newtonianGravity->GetChecked());
	});
	ambientHeatSimulation = addCheckbox(0, "Ambient heat simulation \bgIntroduced in version 50", "Can cause odd / broken behaviour with many saves", [this] {
		c->SetAmbientHeatSimulation(ambientHeatSimulation->GetChecked());
	});
	waterEqualisation = addCheckbox(0, "Water equalisation \bgIntroduced in version 61", "May cause poor performance with a lot of water", [this] {
		c->SetWaterEqualisation(waterEqualisation->GetChecked());
	});
	airMode = addDropDown("Air simulation mode", {
		{ "On", AIR_ON },
		{ "Pressure off", AIR_PRESSUREOFF },
		{ "Velocity off", AIR_VELOCITYOFF },
		{ "Off", AIR_OFF },
		{ "No update", AIR_NOUPDATE },
	}, [this] {
		c->SetAirMode(airMode->GetOption().second);
	});
	{
		ambientAirTemp = new ui::Textbox(ui::Point(Size.X-95, currentY), ui::Point(60, 16));
		ambientAirTemp->SetActionCallback({ [this] {
			UpdateAirTemp(ambientAirTemp->GetText(), false);
		} });
		ambientAirTemp->SetDefocusCallback({ [this] {
			UpdateAirTemp(ambientAirTemp->GetText(), true);
		}});
		ambientAirTemp->SetLimit(9);
		scrollPanel->AddChild(ambientAirTemp);
		ambientAirTempPreview = new ui::Button(ui::Point(Size.X-31, currentY), ui::Point(16, 16), "", "Preview");
		scrollPanel->AddChild(ambientAirTempPreview);
		auto *label = new ui::Label(ui::Point(8, currentY), ui::Point(Size.X-105, 16), "Ambient air temperature");
		label->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		label->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
		scrollPanel->AddChild(label);
		currentY += 20;
	}
	class GravityWindow : public ui::Window
	{
		void OnTryExit(ExitMethod method) override
		{
			CloseActiveWindow();
			SelfDestruct();
		}

		void OnDraw() override
		{
			Graphics * g = GetGraphics();

			g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
			g->DrawRect(RectSized(Position, Size), 0xC8C8C8_rgb);
		}

		ui::DirectionSelector * gravityDirection;
		ui::Label * labelValues;

		OptionsController * c;

	public:
		GravityWindow(ui::Point position, float scale, int radius, float x, float y, OptionsController * c_):
			ui::Window(position, ui::Point((radius * 5 / 2) + 20, (radius * 5 / 2) + 75)),
			gravityDirection(new ui::DirectionSelector(ui::Point(10, 32), scale, radius, radius / 4, 2, 5)),
			c(c_)
			{
				ui::Label * tempLabel = new ui::Label(ui::Point(4, 1), ui::Point(Size.X - 8, 22), "Custom Gravity");
				tempLabel->SetTextColour(style::Colour::InformationTitle);
				tempLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
				tempLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
				AddComponent(tempLabel);

				auto * tempSeparator = new ui::Separator(ui::Point(0, 22), ui::Point(Size.X, 1));
				AddComponent(tempSeparator);

				labelValues = new ui::Label(ui::Point(0, (radius * 5 / 2) + 37), ui::Point(Size.X, 16), String::Build(Format::Precision(1), "X:", x, " Y:", y, " Total:", std::hypot(x, y)));
				labelValues->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
				labelValues->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
				AddComponent(labelValues);

				gravityDirection->SetValues(x, y);
				gravityDirection->SetUpdateCallback([this](float x, float y) {
					labelValues->SetText(String::Build(Format::Precision(1), "X:", x, " Y:", y, " Total:", std::hypot(x, y)));
				});
				gravityDirection->SetSnapPoints(5, 5, 2);
				AddComponent(gravityDirection);

				ui::Button * okayButton = new ui::Button(ui::Point(0, Size.Y - 17), ui::Point(Size.X, 17), "OK");
				okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
				okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
				okayButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
				okayButton->SetActionCallback({ [this] {
					c->SetCustomGravityX(gravityDirection->GetXValue());
					c->SetCustomGravityY(gravityDirection->GetYValue());
					CloseActiveWindow();
					SelfDestruct();
				} });
				AddComponent(okayButton);
				SetOkayButton(okayButton);

				MakeActiveWindow();
			}
	};
	gravityMode = addDropDown("Gravity simulation mode", {
		{ "Vertical", GRAV_VERTICAL },
		{ "Off", GRAV_OFF },
		{ "Radial", GRAV_RADIAL },
		{ "Custom", GRAV_CUSTOM },
	}, [this] {
		c->SetGravityMode(gravityMode->GetOption().second);
		if (gravityMode->GetOption().second == 3)
		{
			new GravityWindow(ui::Point(-1, -1), 0.05f, 40, customGravityX, customGravityY, c);
		}
	});
	edgeMode = addDropDown("Edge mode", {
		{ "Void", EDGE_VOID },
		{ "Solid", EDGE_SOLID },
		{ "Loop", EDGE_LOOP },
	}, [this] {
		c->SetEdgeMode(edgeMode->GetOption().second);
	});
	temperatureScale = addDropDown("Temperature scale", {
		{ "Kelvin", 0 },
		{ "Celsius", 1 },
		{ "Fahrenheit", 2 },
	}, [this] {
		c->SetTemperatureScale(temperatureScale->GetOption().second);
	});
	if (FORCE_WINDOW_FRAME_OPS != forceWindowFrameOpsHandheld)
	{
		addSeparator();
		std::vector<std::pair<String, int>> options;
		int currentScale = ui::Engine::Ref().GetScale();
		int scaleIndex = 1;
		bool currentScaleValid = false;
		do
		{
			if (currentScale == scaleIndex)
			{
				currentScaleValid = true;
			}
			options.push_back({ String::Build(scaleIndex), scaleIndex });
			scaleIndex += 1;
		}
		while (desktopWidth >= GetGraphics()->Size().X * scaleIndex && desktopHeight >= GetGraphics()->Size().Y * scaleIndex);
		if (!currentScaleValid)
		{
			options.push_back({ "current", currentScale });
		}
		scale = addDropDown("Window scale factor for larger screens", options, [this] {
			c->SetScale(scale->GetOption().second);
		});
	}
	if (FORCE_WINDOW_FRAME_OPS == forceWindowFrameOpsNone)
	{
		resizable = addCheckbox(0, "Resizable \bg- allow resizing and maximizing window", "", [this] {
			c->SetResizable(resizable->GetChecked());
		});
		fullscreen = addCheckbox(0, "Fullscreen \bg- fill the entire screen", "", [this] {
			c->SetFullscreen(fullscreen->GetChecked());
		});
		changeResolution = addCheckbox(1, "Set optimal screen resolution", "", [this] {
			c->SetChangeResolution(changeResolution->GetChecked());
		});
		forceIntegerScaling = addCheckbox(1, "Force integer scaling \bg- less blurry", "", [this] {
			c->SetForceIntegerScaling(forceIntegerScaling->GetChecked());
		});
	}
	blurryScaling = addCheckbox(0, "Blurry scaling \bg- more blurry, better on very big screens", "", [this] {
		c->SetBlurryScaling(blurryScaling->GetChecked());
	});
	addSeparator();
	if (ALLOW_QUIT)
	{
		fastquit = addCheckbox(0, "Fast quit", "Always exit completely when hitting close", [this] {
			c->SetFastQuit(fastquit->GetChecked());
		});
		globalQuit = addCheckbox(0, "Global quit shortcut", "Ctrl+q works everywhere", [this] {
			c->SetGlobalQuit(globalQuit->GetChecked());
		});
	}
	showAvatars = addCheckbox(0, "Show avatars", "Disable if you have a slow connection", [this] {
		c->SetShowAvatars(showAvatars->GetChecked());
	});
	momentumScroll = addCheckbox(0, "Momentum (old) scrolling", "Accelerating instead of step scroll", [this] {
		c->SetMomentumScroll(momentumScroll->GetChecked());
	});
	mouseClickRequired = addCheckbox(0, "Sticky categories", "Switch between categories by clicking", [this] {
		c->SetMouseClickrequired(mouseClickRequired->GetChecked());
	});
	includePressure = addCheckbox(0, "Include pressure", "When saving, copying, stamping, etc.", [this] {
		c->SetIncludePressure(includePressure->GetChecked());
	});
	perfectCircle = addCheckbox(0, "Perfect circle brush", "Better circle brush, without incorrect points on edges", [this] {
		c->SetPerfectCircle(perfectCircle->GetChecked());
	});
	graveExitsConsole = addCheckbox(0, "Key under Esc exits console", "Disable if that key is 0 on your keyboard", [this] {
		c->SetGraveExitsConsole(graveExitsConsole->GetChecked());
	});
	if constexpr (PLATFORM_CLIPBOARD)
	{
		auto indent = 0;
		nativeClipoard = addCheckbox(indent, "Use platform clipboard", "Allows copying and pasting across TPT instances", [this] {
			c->SetNativeClipoard(nativeClipoard->GetChecked());
		});
		currentY -= 4; // temporarily undo the currentY += 4 at the end of addCheckbox
		if (auto extra = Clipboard::Explanation())
		{
			addLabel(indent, "\bg" + *extra);
		}
		currentY += 4; // and then undo the undo
	}
	threadedRendering = addCheckbox(0, "Separate rendering thread", "May increase framerate when fancy effects are in use", [this] {
		c->SetThreadedRendering(threadedRendering->GetChecked());
	});
	decoSpace = addDropDown("Colour space used by decoration tools", {
		{ "sRGB", DECOSPACE_SRGB },
		{ "Linear", DECOSPACE_LINEAR },
		{ "Gamma 2.2", DECOSPACE_GAMMA22 },
		{ "Gamma 1.8", DECOSPACE_GAMMA18 },
	}, [this] {
		c->SetDecoSpace(decoSpace->GetOption().second);
	});

	currentY += 4;
	if constexpr (ALLOW_DATA_FOLDER)
	{
		auto *dataFolderButton = new ui::Button(ui::Point(10, currentY), ui::Point(90, 16), "Open data folder");
		dataFolderButton->SetActionCallback({ [] {
			ByteString cwd = Platform::GetCwd();
			if (!cwd.empty())
			{
				Platform::OpenURI(cwd);
			}
			else
			{
				std::cerr << "Cannot open data folder: Platform::GetCwd(...) failed" << std::endl;
			}
		} });
		scrollPanel->AddChild(dataFolderButton);
		if constexpr (SHARED_DATA_FOLDER)
		{
			auto *migrationButton = new ui::Button(ui::Point(Size.X - 178, currentY), ui::Point(163, 16), "Migrate to shared data directory");
			migrationButton->SetActionCallback({ [] {
				ByteString from = Platform::originalCwd;
				ByteString to = Platform::sharedCwd;
				new ConfirmPrompt("Do Migration?", "This will migrate all stamps, saves, and scripts from\n\bt" + from.FromUtf8() + "\bw\nto the shared data directory at\n\bt" + to.FromUtf8() + "\bw\n\n" + "Files that already exist will not be overwritten.", { [from, to]() {
					String ret = Client::Ref().DoMigration(from, to);
					new InformationMessage("Migration Complete", ret, false);
				} });
			} });
			scrollPanel->AddChild(migrationButton);
		}
		currentY += 26;
	}
	String autoStartupRequestNote = "Done once at startup";
	if (!IGNORE_UPDATES)
	{
		autoStartupRequestNote += ", also checks for updates";
	}
	autoStartupRequest = addCheckbox(0, "Fetch the message of the day and notifications", autoStartupRequestNote, [this] {
		auto checked = autoStartupRequest->GetChecked();
		if (checked)
		{
			Client::Ref().BeginStartupRequest();
		}
		c->SetAutoStartupRequest(checked);
	});
	auto *doStartupRequest = new ui::Button(ui::Point(10, currentY), ui::Point(90, 16), "Fetch them now");
	doStartupRequest->SetActionCallback({ [] {
		Client::Ref().BeginStartupRequest();
	} });
	scrollPanel->AddChild(doStartupRequest);
	startupRequestStatus = addLabel(5, "");
	UpdateStartupRequestStatus();
	currentY += 13;
	redirectStd = addCheckbox(0, "Save errors and other messages to a file", "Developers may ask for this when trying to fix problems", [this] {
		c->SetRedirectStd(redirectStd->GetChecked());
	});

	{
		addSeparator();

		auto *creditsButton = new ui::Button(ui::Point(10, currentY), ui::Point(90, 16), "Credits");
		creditsButton->SetActionCallback({ [] {
			auto *credits = new Credits();
			ui::Engine::Ref().ShowWindow(credits);
		} });
		scrollPanel->AddChild(creditsButton);

		addLabel(5, " - Find out who contributed to TPT");
		currentY += 13;
	}


	{
		ui::Button *ok = new ui::Button(ui::Point(0, Size.Y-16), ui::Point(Size.X, 16), "OK");
		ok->SetActionCallback({ [this] {
			c->Exit();
		} });
		AddComponent(ok);
		SetCancelButton(ok);
		SetOkayButton(ok);
	}
	scrollPanel->InnerSize = ui::Point(Size.X, currentY);
}

void OptionsView::UpdateAmbientAirTempPreview(float airTemp, bool isValid)
{
	if (isValid)
	{
		ambientAirTempPreview->Appearance.BackgroundInactive = RGB::Unpack(HeatToColour(airTemp, MIN_TEMP, MAX_TEMP)).WithAlpha(0xFF);
		ambientAirTempPreview->SetText("");
	}
	else
	{
		ambientAirTempPreview->Appearance.BackgroundInactive = ui::Colour(0, 0, 0);
		ambientAirTempPreview->SetText("?");
	}
	ambientAirTempPreview->Appearance.BackgroundHover = ambientAirTempPreview->Appearance.BackgroundInactive;
}

void OptionsView::AmbientAirTempToTextBox(float airTemp)
{
	StringBuilder sb;
	sb << Format::Precision(2);
	format::RenderTemperature(sb, airTemp, temperatureScale->GetOption().second);
	ambientAirTemp->SetText(sb.Build());
}

void OptionsView::UpdateStartupRequestStatus()
{
	switch (Client::Ref().GetStartupRequestStatus())
	{
	case Client::StartupRequestStatus::notYetDone:
		startupRequestStatus->SetText("\bg - Not yet fetched");
		break;

	case Client::StartupRequestStatus::inProgress:
		startupRequestStatus->SetText("\bg - In progress...");
		break;

	case Client::StartupRequestStatus::succeeded:
		startupRequestStatus->SetText(String::Build("\bg - OK, ", Client::Ref().GetServerNotifications().size(), " notifications fetched"));
		break;

	case Client::StartupRequestStatus::failed:
		{
			auto error = Client::Ref().GetStartupRequestError();
			if (!error)
			{
				error = "???";
			}
			startupRequestStatus->SetText("\bg - Failed: " + error->FromUtf8());
		}
		break;
	}
}

void OptionsView::UpdateAirTemp(String temp, bool isDefocus)
{
	// Parse air temp and determine validity
	float airTemp = 0;
	bool isValid;
	try
	{
		airTemp = format::StringToTemperature(temp, temperatureScale->GetOption().second);
		isValid = true;
	}
	catch (const std::exception &ex)
	{
		isValid = false;
	}

	// While defocusing, correct out of range temperatures and empty textboxes
	if (isDefocus)
	{
		if (temp.empty())
		{
			isValid = true;
			airTemp = float(R_TEMP) + 273.15f;
		}
		else if (!isValid)
			return;
		else if (airTemp < MIN_TEMP)
			airTemp = MIN_TEMP;
		else if (airTemp > MAX_TEMP)
			airTemp = MAX_TEMP;

		AmbientAirTempToTextBox(airTemp);
	}
	// Out of range temperatures are invalid, preview should go away
	else if (isValid && (airTemp < MIN_TEMP || airTemp > MAX_TEMP))
		isValid = false;

	// If valid, set temp
	if (isValid)
		c->SetAmbientAirTemperature(airTemp);

	UpdateAmbientAirTempPreview(airTemp, isValid);
}

void OptionsView::NotifySettingsChanged(OptionsModel * sender)
{
	temperatureScale->SetOption(sender->GetTemperatureScale()); // has to happen before AmbientAirTempToTextBox is called
	heatSimulation->SetChecked(sender->GetHeatSimulation());
	ambientHeatSimulation->SetChecked(sender->GetAmbientHeatSimulation());
	newtonianGravity->SetChecked(sender->GetNewtonianGravity());
	waterEqualisation->SetChecked(sender->GetWaterEqualisation());
	airMode->SetOption(sender->GetAirMode());
	// Initialize air temp and preview only when the options menu is opened, and not when user is actively editing the textbox
	if (!ambientAirTemp->IsFocused())
	{
		float airTemp = sender->GetAmbientAirTemperature();
		UpdateAmbientAirTempPreview(airTemp, true);
		AmbientAirTempToTextBox(airTemp);
	}
	gravityMode->SetOption(sender->GetGravityMode());
	customGravityX = sender->GetCustomGravityX();
	customGravityY = sender->GetCustomGravityY();
	decoSpace->SetOption(sender->GetDecoSpace());
	edgeMode->SetOption(sender->GetEdgeMode());
	if (scale)
	{
		scale->SetOption(sender->GetScale());
	}
	if (resizable)
	{
		resizable->SetChecked(sender->GetResizable());
	}
	if (fullscreen)
	{
		fullscreen->SetChecked(sender->GetFullscreen());
	}
	if (changeResolution)
	{
		changeResolution->SetChecked(sender->GetChangeResolution());
	}
	if (forceIntegerScaling)
	{
		forceIntegerScaling->SetChecked(sender->GetForceIntegerScaling());
	}
	if (blurryScaling)
	{
		blurryScaling->SetChecked(sender->GetBlurryScaling());
	}
	if (fastquit)
	{
		fastquit->SetChecked(sender->GetFastQuit());
	}
	if (globalQuit)
	{
		globalQuit->SetChecked(sender->GetGlobalQuit());
	}
	if (nativeClipoard)
	{
		nativeClipoard->SetChecked(sender->GetNativeClipoard());
	}
	showAvatars->SetChecked(sender->GetShowAvatars());
	mouseClickRequired->SetChecked(sender->GetMouseClickRequired());
	includePressure->SetChecked(sender->GetIncludePressure());
	perfectCircle->SetChecked(sender->GetPerfectCircle());
	graveExitsConsole->SetChecked(sender->GetGraveExitsConsole());
	threadedRendering->SetChecked(sender->GetThreadedRendering());
	momentumScroll->SetChecked(sender->GetMomentumScroll());
	redirectStd->SetChecked(sender->GetRedirectStd());
	autoStartupRequest->SetChecked(sender->GetAutoStartupRequest());
}

void OptionsView::AttachController(OptionsController * c_)
{
	c = c_;
}

void OptionsView::OnTick()
{
	UpdateStartupRequestStatus();
}

void OptionsView::OnDraw()
{
	Graphics * g = GetGraphics();
	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);
}

void OptionsView::OnTryExit(ExitMethod method)
{
	c->Exit();
}


=== src\gui\options\OptionsView.h ===

#pragma once
#include "common/String.h"
#include "gui/interface/Window.h"
#include "gui/interface/ScrollPanel.h"

namespace ui
{
	class Checkbox;
	class DropDown;
	class Textbox;
	class Button;
	class Label;
}

class OptionsModel;
class OptionsController;
class OptionsView: public ui::Window
{
	OptionsController *c{};
	ui::Checkbox *heatSimulation{};
	ui::Checkbox *ambientHeatSimulation{};
	ui::Checkbox *newtonianGravity{};
	ui::Checkbox *waterEqualisation{};
	ui::DropDown *airMode{};
	ui::Textbox *ambientAirTemp{};
	ui::Button *ambientAirTempPreview{};
	ui::DropDown *gravityMode{};
	ui::DropDown *edgeMode{};
	ui::DropDown *temperatureScale{};
	ui::DropDown *scale{};
	ui::Checkbox *resizable{};
	ui::Checkbox *fullscreen{};
	ui::Checkbox *changeResolution{};
	ui::Checkbox *forceIntegerScaling{};
	ui::Checkbox *blurryScaling{};
	ui::Checkbox *fastquit{};
	ui::Checkbox *globalQuit{};
	ui::DropDown *decoSpace{};
	ui::Checkbox *showAvatars{};
	ui::Checkbox *momentumScroll{};
	ui::Checkbox *mouseClickRequired{};
	ui::Checkbox *includePressure{};
	ui::Checkbox *perfectCircle{};
	ui::Checkbox *graveExitsConsole{};
	ui::Checkbox *nativeClipoard{};
	ui::Checkbox *threadedRendering{};
	ui::Checkbox *redirectStd{};
	ui::Checkbox *autoStartupRequest{};
	ui::Label *startupRequestStatus{};
	ui::ScrollPanel *scrollPanel{};
	float customGravityX, customGravityY;
	void UpdateAmbientAirTempPreview(float airTemp, bool isValid);
	void AmbientAirTempToTextBox(float airTemp);
	void UpdateAirTemp(String temp, bool isDefocus);
	void UpdateStartupRequestStatus();
public:
	OptionsView();
	void NotifySettingsChanged(OptionsModel * sender);
	void AttachController(OptionsController * c_);
	void OnDraw() override;
	void OnTick() final override;
	void OnTryExit(ExitMethod method) override;
};


=== src\gui\preview\meson.build ===

powder_files += files(
	'PreviewController.cpp',
	'PreviewModel.cpp',
	'PreviewView.cpp',
)


=== src\gui\preview\PreviewController.cpp ===

#include "PreviewController.h"
#include "Controller.h"
#include "PreviewModel.h"
#include "PreviewView.h"
#include "client/Client.h"
#include "client/SaveInfo.h"
#include "client/GameSave.h"
#include "client/http/GetSaveRequest.h"
#include "client/http/GetSaveDataRequest.h"
#include "client/http/GetCommentsRequest.h"
#include "client/http/FavouriteSaveRequest.h"
#include "common/platform/Platform.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/dialogues/InformationMessage.h"
#include "gui/login/LoginController.h"
#include "gui/login/LoginView.h"
#include "Config.h"

PreviewController::PreviewController(int saveID, int saveDate, SavePreviewType savePreviewType, std::function<void ()> onDone_, std::unique_ptr<VideoBuffer> thumbnail):
	saveId(saveID),
	loginWindow(nullptr),
	HasExited(false)
{
	previewModel = new PreviewModel();
	previewView = new PreviewView(std::move(thumbnail));
	previewModel->AddObserver(previewView);
	previewView->AttachController(this);
	previewModel->SetDoOpen(savePreviewType != savePreviewNormal);
	previewModel->SetFromUrl(savePreviewType == savePreviewUrl);

	previewModel->UpdateSave(saveID, saveDate);

	if(Client::Ref().GetAuthUser().UserID)
	{
		previewModel->SetCommentBoxEnabled(true);
	}

	Client::Ref().AddListener(this);

	onDone = onDone_;
}

void PreviewController::Update()
{
	previewModel->Update();
	if (loginWindow && loginWindow->HasExited == true)
	{
		delete loginWindow;
		loginWindow = nullptr;
	}
	if (previewModel->GetDoOpen() && previewModel->GetSaveInfo() && previewModel->GetSaveInfo()->GetGameSave())
	{
		Platform::MarkPresentable();
		Exit();
	}
}

void PreviewController::ShowLogin()
{
	loginWindow = new LoginController();
	loginWindow->GetView()->MakeActiveWindow();
}

void PreviewController::NotifyAuthUserChanged(Client * sender)
{
	previewModel->SetCommentBoxEnabled(sender->GetAuthUser().UserID);
}

const SaveInfo *PreviewController::GetSaveInfo() const
{
	return previewModel->GetSaveInfo();
}

std::unique_ptr<SaveInfo> PreviewController::TakeSaveInfo()
{
	return previewModel->TakeSaveInfo();
}

bool PreviewController::GetDoOpen()
{
	return previewModel->GetDoOpen();
}

bool PreviewController::GetFromUrl()
{
	return previewModel->GetFromUrl();
}

void PreviewController::DoOpen()
{
	previewModel->SetDoOpen(true);
}

void PreviewController::FavouriteSave()
{
	if (previewModel->GetSaveInfo() && Client::Ref().GetAuthUser().UserID)
	{
		previewModel->SetFavourite(!previewModel->GetSaveInfo()->Favourite);
	}
}

void PreviewController::OpenInBrowser()
{
	ByteString uri = ByteString::Build(SERVER, "/Browse/View.html?ID=", saveId);
	Platform::OpenURI(uri);
}

bool PreviewController::NextCommentPage()
{
	if(previewModel->GetCommentsPageNum() < previewModel->GetCommentsPageCount() && previewModel->GetCommentsLoaded() && !previewModel->GetDoOpen())
	{
		previewModel->UpdateComments(previewModel->GetCommentsPageNum()+1);
		return true;
	}
	return false;
}

bool PreviewController::PrevCommentPage()
{
	if(previewModel->GetCommentsPageNum() > 1 && previewModel->GetCommentsLoaded() && !previewModel->GetDoOpen())
	{
		previewModel->UpdateComments(previewModel->GetCommentsPageNum()-1);
		return true;
	}
	return false;
}

void PreviewController::RefreshComments()
{
	previewModel->UpdateComments(1);
}

void PreviewController::CommentAdded()
{
	previewModel->CommentAdded();
	RefreshComments();
}

void PreviewController::Exit()
{
	previewView->CloseActiveWindow();
	HasExited = true;
	if (onDone)
		onDone();
}

PreviewController::~PreviewController()
{
	Client::Ref().RemoveListener(this);
	delete previewModel;
	previewView->CloseActiveWindow();
	delete previewView;
}


=== src\gui\preview\PreviewController.h ===

#pragma once
#include "client/ClientListener.h"
#include "gui/SavePreviewType.h"
#include <functional>
#include <memory>

class VideoBuffer;
class SaveInfo;
class LoginController;
class PreviewModel;
class PreviewView;
class PreviewController: public ClientListener {
	int saveId;
	PreviewModel * previewModel;
	PreviewView * previewView;
	LoginController * loginWindow;
	std::function<void ()> onDone;
public:
	void NotifyAuthUserChanged(Client * sender) override;
	inline int SaveID() { return saveId; }

	bool HasExited;
	PreviewController(int saveID, int saveDate, SavePreviewType savePreviewType, std::function<void ()> onDone, std::unique_ptr<VideoBuffer> thumbnail);
	void Exit();
	void DoOpen();
	void OpenInBrowser();
	void ShowLogin();
	bool GetDoOpen();
	bool GetFromUrl();
	const SaveInfo *GetSaveInfo() const;
	std::unique_ptr<SaveInfo> TakeSaveInfo();
	PreviewView * GetView() { return previewView; }
	void Update();
	void FavouriteSave();

	bool NextCommentPage();
	bool PrevCommentPage();
	void RefreshComments();
	void CommentAdded();

	virtual ~PreviewController();
};


=== src\gui\preview\PreviewModel.cpp ===

#include "PreviewModel.h"
#include "client/http/GetSaveDataRequest.h"
#include "client/http/GetSaveRequest.h"
#include "client/http/GetCommentsRequest.h"
#include "client/http/FavouriteSaveRequest.h"
#include "Format.h"
#include "Misc.h"
#include "client/Client.h"
#include "client/GameSave.h"
#include "client/SaveInfo.h"
#include "gui/dialogues/ErrorMessage.h"
#include "PreviewView.h"
#include "Config.h"
#include <cmath>
#include <iostream>

constexpr auto commentsPerPage = 20;

void PreviewModel::SetFavourite(bool favourite)
{
	if (saveInfo)
	{
		queuedFavourite = favourite;
	}
}

bool PreviewModel::GetCommentBoxEnabled()
{
	return commentBoxEnabled;
}

void PreviewModel::SetCommentBoxEnabled(bool enabledState)
{
	if(enabledState != commentBoxEnabled)
	{
		commentBoxEnabled = enabledState;
		notifyCommentBoxEnabledChanged();
	}
}

void PreviewModel::UpdateSave(int saveID, int saveDate)
{
	this->saveID = saveID;
	this->saveDate = saveDate;

	saveInfo.reset();
	saveData.reset();
	saveComments.reset();
	notifySaveChanged();
	notifySaveCommentsChanged();

	saveDataDownload = std::make_unique<http::GetSaveDataRequest>(saveID, saveDate);
	saveDataDownload->Start();

	saveInfoDownload = std::make_unique<http::GetSaveRequest>(saveID, saveDate);
	saveInfoDownload->Start();

	if (!GetDoOpen())
	{
		commentsLoaded = false;

		commentsDownload = std::make_unique<http::GetCommentsRequest>(saveID, (commentsPageNumber - 1) * commentsPerPage, commentsPerPage);
		commentsDownload->Start();
	}
}

void PreviewModel::SetDoOpen(bool doOpen)
{
	this->doOpen = doOpen;
}

bool PreviewModel::GetDoOpen()
{
	return doOpen;
}

void PreviewModel::SetFromUrl(bool fromUrl)
{
	this->fromUrl = fromUrl;
}

bool PreviewModel::GetFromUrl()
{
	return fromUrl;
}

bool PreviewModel::GetCanOpen()
{
	return canOpen;
}

const SaveInfo *PreviewModel::GetSaveInfo() const
{
	return saveInfo.get();
}

std::unique_ptr<SaveInfo> PreviewModel::TakeSaveInfo()
{
	return std::move(saveInfo);
}

int PreviewModel::GetCommentsPageNum()
{
	return commentsPageNumber;
}

int PreviewModel::GetCommentsPageCount()
{
	return std::max(1, ceilDiv(commentsTotal, commentsPerPage).first);
}

bool PreviewModel::GetCommentsLoaded()
{
	return commentsLoaded;
}

void PreviewModel::UpdateComments(int pageNumber)
{
	if (commentsLoaded)
	{
		commentsLoaded = false;
		saveComments.reset();

		commentsPageNumber = pageNumber;
		if (!GetDoOpen())
		{
			commentsDownload = std::make_unique<http::GetCommentsRequest>(saveID, (commentsPageNumber - 1) * commentsPerPage, commentsPerPage);
			commentsDownload->Start();
		}

		notifySaveCommentsChanged();
		notifyCommentsPageChanged();
	}
}

void PreviewModel::CommentAdded()
{
	if (saveInfo)
		saveInfo->Comments++;
	commentsTotal++;
}

void PreviewModel::OnSaveReady()
{
	commentsTotal = saveInfo->Comments;
	try
	{
		auto gameSave = std::make_unique<GameSave>(*saveData);
		if (gameSave->fromNewerVersion)
			new ErrorMessage("This save is from a newer version", String::Build("Please update TPT in game or at ", SERVER));
		saveInfo->SetGameSave(std::move(gameSave));
	}
	catch(ParseException &e)
	{
		new ErrorMessage("Error", ByteString(e.what()).FromUtf8());
		canOpen = false;
	}
	notifySaveChanged();
	notifyCommentsPageChanged();
	//make sure author name comments are red
	if (commentsLoaded)
		notifySaveCommentsChanged();
}

void PreviewModel::Update()
{
	auto triggerOnSaveReady = false;
	if (saveDataDownload && saveDataDownload->CheckDone())
	{
		try
		{
			saveData = saveDataDownload->Finish();
			triggerOnSaveReady = true;
		}
		catch (const http::RequestError &ex)
		{
			auto why = ByteString(ex.what()).FromUtf8();
			for (size_t i = 0; i < observers.size(); i++)
			{
				observers[i]->SaveLoadingError(why);
			}
		}
		saveDataDownload.reset();
	}
	if (saveInfoDownload && saveInfoDownload->CheckDone())
	{
		try
		{
			saveInfo = saveInfoDownload->Finish();
			triggerOnSaveReady = true;
			// This is a workaround for a bug on the TPT server where the wrong 404 save is returned
			// Redownload the .cps file for a fixed version of the 404 save
			if (saveInfo->GetID() == 404 && saveID != 404)
			{
				saveData.reset();
				saveDataDownload = std::make_unique<http::GetSaveDataRequest>(2157797, 0);
				saveDataDownload->Start();
			}
		}
		catch (const http::RequestError &ex)
		{
			auto why = ByteString(ex.what()).FromUtf8();
			for (size_t i = 0; i < observers.size(); i++)
			{
				observers[i]->SaveLoadingError(why);
			}
		}
		saveInfoDownload.reset();
	}
	if (triggerOnSaveReady && saveInfo && saveData)
	{
		OnSaveReady();
	}

	if (commentsDownload && commentsDownload->CheckDone())
	{
		try
		{
			saveComments = commentsDownload->Finish();
		}
		catch (const http::RequestError &ex)
		{
			// TODO: handle
		}
		commentsLoaded = true;
		notifySaveCommentsChanged();
		notifyCommentsPageChanged();
		commentsDownload.reset();
	}

	if (favouriteSaveRequest && favouriteSaveRequest->CheckDone())
	{
		try
		{
			favouriteSaveRequest->Finish();
			if (saveInfo)
			{
				saveInfo->Favourite = favouriteSaveRequest->Favourite();
				notifySaveChanged();
			}
		}
		catch (const http::RequestError &ex)
		{
			if (favouriteSaveRequest->Favourite())
			{
				new ErrorMessage("Error", "Could not favourite the save: " + ByteString(ex.what()).FromUtf8());
			}
			else
			{
				new ErrorMessage("Error", "Could not unfavourite the save: " + ByteString(ex.what()).FromUtf8());
			}
		}
		favouriteSaveRequest.reset();
	}
	if (!favouriteSaveRequest && queuedFavourite)
	{
		if (saveInfo)
		{
			favouriteSaveRequest = std::make_unique<http::FavouriteSaveRequest>(saveInfo->id, *queuedFavourite);
			favouriteSaveRequest->Start();
		}
		queuedFavourite.reset();
	}
}

void PreviewModel::notifySaveChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifySaveChanged(this);
	}
}

void PreviewModel::notifyCommentBoxEnabledChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyCommentBoxEnabledChanged(this);
	}
}

void PreviewModel::notifyCommentsPageChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyCommentsPageChanged(this);
	}
}

void PreviewModel::notifySaveCommentsChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyCommentsChanged(this);
	}
}

void PreviewModel::AddObserver(PreviewView * observer)
{
	observers.push_back(observer);
	observer->NotifySaveChanged(this);
	observer->NotifyCommentsChanged(this);
	observer->NotifyCommentsPageChanged(this);
	observer->NotifyCommentBoxEnabledChanged(this);
}


=== src\gui\preview\PreviewModel.h ===

#pragma once
#include "common/String.h"
#include "client/Comment.h"
#include <vector>
#include <memory>
#include <optional>

namespace http
{
	class GetSaveDataRequest;
	class GetSaveRequest;
	class GetCommentsRequest;
	class FavouriteSaveRequest;
}

class PreviewView;
class SaveInfo;
class PreviewModel
{
	bool doOpen = false;
	bool fromUrl = false;
	bool canOpen = true;
	std::vector<PreviewView*> observers;
	std::unique_ptr<SaveInfo> saveInfo;
	std::optional<std::vector<char>> saveData;
	std::optional<std::vector<Comment>> saveComments;
	void notifySaveChanged();
	void notifySaveCommentsChanged();
	void notifyCommentsPageChanged();
	void notifyCommentBoxEnabledChanged();

	std::unique_ptr<http::GetSaveDataRequest> saveDataDownload;
	std::unique_ptr<http::GetSaveRequest> saveInfoDownload;
	std::unique_ptr<http::GetCommentsRequest> commentsDownload;
	std::unique_ptr<http::FavouriteSaveRequest> favouriteSaveRequest;
	int saveID;
	int saveDate;

	bool commentBoxEnabled = false;
	bool commentsLoaded = false;
	int commentsTotal = 0;
	int commentsPageNumber = 1;

	std::optional<bool> queuedFavourite;

public:
	const SaveInfo *GetSaveInfo() const;
	std::unique_ptr<SaveInfo> TakeSaveInfo();
	const std::vector<Comment> *GetComments() const
	{
		return saveComments ? &*saveComments : nullptr;
	}

	bool GetCommentBoxEnabled();
	void SetCommentBoxEnabled(bool enabledState);

	bool GetCommentsLoaded();
	int GetCommentsPageNum();
	int GetCommentsPageCount();
	void UpdateComments(int pageNumber);
	void CommentAdded();

	void AddObserver(PreviewView * observer);
	void UpdateSave(int saveID, int saveDate);
	void SetFavourite(bool favourite);
	bool GetDoOpen();
	bool GetFromUrl();
	bool GetCanOpen();
	void SetDoOpen(bool doOpen);
	void SetFromUrl(bool fromUrl);
	void Update();
	void OnSaveReady();
	bool ParseSaveInfo(ByteString &saveInfoResponse);
	bool ParseComments(ByteString &commentsResponse);
};


=== src\gui\preview\PreviewView.cpp ===

#include "PreviewView.h"

#include "simulation/SaveRenderer.h"

#include "client/Client.h"
#include "client/SaveInfo.h"
#include "client/GameSave.h"
#include "client/http/AddCommentRequest.h"
#include "client/http/ReportSaveRequest.h"

#include "gui/dialogues/TextPrompt.h"
#include "gui/profile/ProfileActivity.h"
#include "gui/interface/ScrollPanel.h"
#include "gui/interface/AvatarButton.h"
#include "gui/preview/PreviewController.h"
#include "gui/preview/PreviewModel.h"
#include "gui/interface/Button.h"
#include "gui/interface/CopyTextButton.h"
#include "gui/interface/Label.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/Engine.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/dialogues/InformationMessage.h"
#include "gui/interface/Point.h"
#include "gui/interface/Window.h"
#include "gui/Style.h"

#include "common/tpt-rand.h"
#include "common/platform/Platform.h"
#include "Format.h"
#include "Misc.h"

#include "graphics/VideoBuffer.h"
#include "SimulationConfig.h"
#include <SDL.h>

PreviewView::PreviewView(std::unique_ptr<VideoBuffer> newSavePreview):
	ui::Window(ui::Point(-1, -1), ui::Point((XRES/2)+210, (YRES/2)+150)),
	submitCommentButton(nullptr),
	addCommentBox(nullptr),
	commentWarningLabel(nullptr),
	userIsAuthor(false),
	doOpen(false),
	doError(false),
	doErrorMessage(""),
	showAvatars(true),
	prevPage(false),
	commentBoxHeight(20),
	commentHelpText(false)
{
	if (newSavePreview)
	{
		newSavePreview->Resize(RES / 2, true);
		savePreview = std::move(newSavePreview);
	}
	showAvatars = ui::Engine::Ref().ShowAvatars;

	favButton = new ui::Button(ui::Point(50, Size.Y-19), ui::Point(51, 19), "Fav");
	favButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	favButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	favButton->SetTogglable(true);
	favButton->SetIcon(IconFavourite);
	favButton->SetActionCallback({ [this] {
		favButton->SetToggleState(true);
		favButton->Appearance.BackgroundPulse = true;
		c->FavouriteSave();
	} });
	favButton->Enabled = Client::Ref().GetAuthUser().UserID?true:false;
	AddComponent(favButton);

	reportButton = new ui::Button(ui::Point(100, Size.Y-19), ui::Point(51, 19), "Report");
	reportButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	reportButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	reportButton->SetIcon(IconReport);
	reportButton->SetActionCallback({ [this] {
		new TextPrompt("Report Save", "Things to consider when reporting:\n\bw1)\bg When reporting stolen saves, please include the ID of the original save.\n\bw2)\bg Do not ask for saves to be removed from front page unless they break the rules.\n\bw3)\bg You may report saves for comments or tags too (including your own saves)", "", "[reason]", true, { [this](String const &resultText) {
			if (reportSaveRequest)
			{
				return;
			}
			reportSaveRequest = std::make_unique<http::ReportSaveRequest>(c->SaveID(), resultText);
			reportSaveRequest->Start();
		} });
	} });
	reportButton->Enabled = Client::Ref().GetAuthUser().UserID?true:false;
	AddComponent(reportButton);

	openButton = new ui::Button(ui::Point(0, Size.Y-19), ui::Point(51, 19), "Open");
	openButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	openButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	openButton->SetIcon(IconOpen);
	openButton->SetActionCallback({ [this] { c->DoOpen(); } });
	AddComponent(openButton);

	browserOpenButton = new ui::Button(ui::Point((XRES/2)-107, Size.Y-19), ui::Point(108, 19), "Open in browser");
	browserOpenButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	browserOpenButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	browserOpenButton->SetIcon(IconOpen);
	browserOpenButton->SetActionCallback({ [this] { c->OpenInBrowser(); } });
	AddComponent(browserOpenButton);

	loadErrorButton = new ui::Button({ 0, 0 }, ui::Point(148, 19), "Error loading save");
	loadErrorButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	loadErrorButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	loadErrorButton->SetIcon(IconDelete);
	loadErrorButton->SetActionCallback({ [this] { ShowLoadError(); } });
	loadErrorButton->Visible = false;
	AddComponent(loadErrorButton);

	missingElementsButton = new ui::Button({ 0, 0 }, ui::Point(148, 19), "Missing custom elements");
	missingElementsButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	missingElementsButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	missingElementsButton->SetIcon(IconReport);
	missingElementsButton->SetActionCallback({ [this] { ShowMissingCustomElements(); } });
	missingElementsButton->Visible = false;
	AddComponent(missingElementsButton);

	if(showAvatars)
		saveNameLabel = new ui::Label(ui::Point(39, (YRES/2)+4), ui::Point(265, 16), "");
	else
		saveNameLabel = new ui::Label(ui::Point(5, (YRES/2)+4), ui::Point(300, 16), "");
	saveNameLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	saveNameLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(saveNameLabel);

	if(showAvatars)
		saveDescriptionLabel = new ui::Label(ui::Point(5, (YRES/2)+4+15+21), ui::Point((XRES/2)-10, Size.Y-((YRES/2)+4+15+17)-25), "");
	else
		saveDescriptionLabel = new ui::Label(ui::Point(5, (YRES/2)+4+15+19), ui::Point((XRES/2)-10, Size.Y-((YRES/2)+4+15+17)-23), "");
	saveDescriptionLabel->SetMultiline(true);
	saveDescriptionLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	saveDescriptionLabel->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	saveDescriptionLabel->SetTextColour(ui::Colour(180, 180, 180));
	AddComponent(saveDescriptionLabel);

	if(showAvatars)
		authorDateLabel = new ui::Label(ui::Point(39, (YRES/2)+4+15), ui::Point(200, 16), "");
	else
		authorDateLabel = new ui::Label(ui::Point(5, (YRES/2)+4+15), ui::Point(220, 16), "");
	authorDateLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	authorDateLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(authorDateLabel);

	if(showAvatars)
	{
		avatarButton = new ui::AvatarButton(ui::Point(4, (YRES/2)+4), ui::Point(34, 34), "");
		avatarButton->SetActionCallback({ [this] {
			if (avatarButton->GetUsername().size() > 0)
			{
				new ProfileActivity(avatarButton->GetUsername());
			}
		} });
		AddComponent(avatarButton);
	}

	viewsLabel = new ui::Label(ui::Point((XRES/2)-88, (YRES/2)+4+15), ui::Point(88, 16), "");
	viewsLabel->Appearance.HorizontalAlign = ui::Appearance::AlignRight;
	viewsLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(viewsLabel);

	pageInfo = new ui::Label(ui::Point((XRES/2) + 85, Size.Y+1), ui::Point(70, 16), "Page 1 of 1");
	pageInfo->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	AddComponent(pageInfo);

	commentsPanel = new ui::ScrollPanel(ui::Point((XRES/2)+1, 1), ui::Point((Size.X-(XRES/2))-2, Size.Y-commentBoxHeight));
	AddComponent(commentsPanel);

	swearWords.insert("fuck");
	swearWords.insert("bitch");
	swearWords.insert("shit ");
	swearWords.insert("asshole");
	swearWords.insert("dick");
	swearWords.insert("cunt");
	swearWords.insert(" nigger");
	swearWords.insert("faggot");
	swearWords.insert("dumbass");
}

void PreviewView::AttachController(PreviewController * controller)
{
	c = controller;

	int textWidth = Graphics::TextSize("Click the box below to copy the save ID").X - 1;
	saveIDLabel = new ui::Label(ui::Point((Size.X-textWidth-20)/2, Size.Y+5), ui::Point(textWidth+20, 16), "Click the box below to copy the save ID");
	saveIDLabel->SetTextColour(ui::Colour(150, 150, 150));
	saveIDLabel->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	AddComponent(saveIDLabel);

	textWidth = Graphics::TextSize(String::Build(c->SaveID())).X - 1;
	saveIDLabel2 = new ui::Label(ui::Point((Size.X-textWidth-20)/2-37, Size.Y+22), ui::Point(40, 16), "Save ID:");
	AddComponent(saveIDLabel2);

	saveIDButton = new ui::CopyTextButton(ui::Point((Size.X-textWidth-10)/2, Size.Y+20), ui::Point(textWidth+10, 18), String::Build(c->SaveID()), saveIDLabel);
	AddComponent(saveIDButton);
}

void PreviewView::commentBoxAutoHeight()
{
	if(!addCommentBox)
		return;
	int textWidth = Graphics::TextSize(addCommentBox->GetText().c_str()).X - 1;
	if (commentHelpText || textWidth+15 > Size.X-(XRES/2)-48)
	{
		addCommentBox->Appearance.VerticalAlign = ui::Appearance::AlignTop;

		int oldSize = addCommentBox->Size.Y;
		addCommentBox->AutoHeight();
		int newSize = addCommentBox->Size.Y+2;
		addCommentBox->Size.Y = oldSize;

		commentBoxHeight = newSize+22;
		commentBoxPositionX.SetTarget((XRES/2)+4);
		commentBoxPositionY.SetTarget(float(Size.Y-(newSize+21)));
		commentBoxSizeX.SetTarget(float(Size.X-(XRES/2)-8));
		commentBoxSizeY.SetTarget(float(newSize));

		if (commentWarningLabel && commentHelpText && !commentWarningLabel->Visible && addCommentBox->Position.Y+addCommentBox->Size.Y < Size.Y-14)
		{
			commentWarningLabel->Visible = true;
		}
	}
	else
	{
		commentBoxHeight = 20;
		addCommentBox->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;

		commentBoxPositionX.SetTarget((XRES/2)+4);
		commentBoxPositionY.SetTarget(float(Size.Y-19));
		commentBoxSizeX.SetTarget(float(Size.X-(XRES/2)-48));
		commentBoxSizeY.SetTarget(17);

		if (commentWarningLabel && commentWarningLabel->Visible)
		{
			commentWarningLabel->Visible = false;
		}
	}
}

bool PreviewView::CheckSwearing(String text)
{
	for (std::set<String>::iterator iter = swearWords.begin(), end = swearWords.end(); iter != end; iter++)
		if (text.Contains(*iter))
			return true;
	return false;
}

void PreviewView::CheckComment()
{
	if (!commentWarningLabel)
		return;
	String text = addCommentBox->GetText().ToLower();
	if (addCommentRequest)
	{
		commentWarningLabel->SetText("Submitting comment...");
		commentHelpText = true;
	}
	else if (!userIsAuthor && (text.Contains("stolen") || text.Contains("copied")))
	{
		if (!commentHelpText)
		{
			if (interfaceRng()%2)
				commentWarningLabel->SetText("Stolen? Report the save instead");
			else
				commentWarningLabel->SetText("Please report stolen saves");
			commentHelpText = true;
		}
	}
	else if (userIsAuthor && text.Contains("vote"))
	{
		commentWarningLabel->SetText("Do not ask for votes");
		commentHelpText = true;
	}
	else if (CheckSwearing(text))
	{
		if (!commentHelpText)
		{
			if (interfaceRng()%2)
				commentWarningLabel->SetText("Please do not swear");
			else
				commentWarningLabel->SetText("Bad language may be deleted");
			commentHelpText = true;
		}
	}
	else
	{
		commentHelpText = false;
		commentWarningLabel->Visible = false;
	}
}

void PreviewView::DoDraw()
{
	Graphics * g = GetGraphics();
	if (!c->GetFromUrl())
	{
		Window::DoDraw();
		for (size_t i = 0; i < commentTextComponents.size(); i++)
		{
			int linePos = commentTextComponents[i]->Position.Y+commentsPanel->ViewportPosition.Y+commentTextComponents[i]->Size.Y+4;
			if (linePos > 0 && linePos < Size.Y-commentBoxHeight)
			g->BlendLine(
					Position + Vec2{ 1+XRES/2, linePos },
					Position + Vec2{ Size.X-2, linePos },
					0xFFFFFF_rgb .WithAlpha(100));
		}
	}
	if (c->GetDoOpen())
	{
		g->BlendFilledRect(RectSized(Position + Size / 2 - Vec2{ 101, 26 }, { 202, 52 }), 0x000000_rgb .WithAlpha(210));
		g->BlendRect(RectSized(Position + Size / 2 - Vec2{ 100, 25 }, Vec2{ 200, 50 }), 0xFFFFFF_rgb .WithAlpha(180));
		g->BlendText(Position + Vec2{(Size.X/2)-((Graphics::TextSize("Loading save...").X - 1)/2), (Size.Y/2)-5}, "Loading save...", style::Colour::InformationTitle.NoAlpha().WithAlpha(255));
	}
	if (!c->GetFromUrl())
	{
		g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);
	}
}

void PreviewView::OnDraw()
{
	Graphics * g = GetGraphics();

	//Window Background+Outline
	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);

	//Save preview (top-left)
	if (savePreview)
	{
		g->BlendImage(savePreview->Data(), 0xFF, RectSized(Position + Vec2(1, 1) + (RES / 2 - savePreview->Size()) / 2, savePreview->Size()));
	}
	g->BlendRect(RectSized(Position, RES / 2 + Vec2{ 1, 1 }), 0xFFFFFF_rgb .WithAlpha(100));
	g->DrawLine(Position + Vec2{ XRES/2, 1 }, Position + Vec2{ XRES/2, Size.Y-2 }, 0xC8C8C8_rgb);

	if(votesUp || votesDown)
	{
		float ryf;
		int nyu, nyd;
		int lv = (votesUp>votesDown)?votesUp:votesDown;
		lv = (lv>10)?lv:10;

		if (50>lv)
		{
			ryf = 50.0f/((float)lv);
			nyu = int(votesUp*ryf);
			nyd = int(votesDown*ryf);
		}
		else
		{
			ryf = ((float)lv)/50.0f;
			nyu = int(votesUp/ryf);
			nyd = int(votesDown/ryf);
		}
		nyu = nyu>50?50:nyu;
		nyd = nyd>50?50:nyd;

		g->DrawFilledRect(RectSized(Position + RES / 2 + Vec2{ -56, 3 }, Vec2{ 54, 7 }), 0x006B0A_rgb);
		g->DrawFilledRect(RectSized(Position + RES / 2 + Vec2{ -56, 9 }, Vec2{ 54, 7 }), 0x6B0A00_rgb);
		g->DrawRect(RectSized(Position + Vec2{ (XRES/2)-56, (YRES/2)+3 }, { 54, 7 }), 0x808080_rgb);
		g->DrawRect(RectSized(Position + Vec2{ (XRES/2)-56, (YRES/2)+9 }, { 54, 7 }), 0x808080_rgb);

		g->DrawFilledRect(RectSized(Position + RES / 2 + Vec2{ -4-nyu, 5 }, Vec2{ nyu, 3 }), 0x39BB39_rgb);
		g->DrawFilledRect(RectSized(Position + RES / 2 + Vec2{ -4-nyd, 11 }, Vec2{ nyd, 3 }), 0xBB3939_rgb);
	}
}

void PreviewView::OnTick()
{
	if(addCommentBox)
	{
		addCommentBox->Position.X = commentBoxPositionX;
		addCommentBox->Position.Y = commentBoxPositionY;

		if(addCommentBox->Size.X != commentBoxSizeX)
		{
			addCommentBox->Size.X = commentBoxSizeX;
			addCommentBox->Invalidate();
			commentBoxAutoHeight(); //make sure textbox height is correct after resizes
			addCommentBox->resetCursorPosition(); //make sure cursor is in correct position after resizes
		}
		if(addCommentBox->Size.Y != commentBoxSizeY)
		{
			addCommentBox->Size.Y = commentBoxSizeY;
			addCommentBox->Invalidate();
		}
		commentsPanel->Size.Y = addCommentBox->Position.Y-1;
	}

	c->Update();
	if (doError)
	{
		openButton->Enabled = false;
		loadErrorButton->Visible = true;
		UpdateLoadStatus();
	}

	if (reportSaveRequest && reportSaveRequest->CheckDone())
	{
		try
		{
			reportSaveRequest->Finish();
			c->Exit();
			new InformationMessage("Information", "Report submitted", false);
		}
		catch (const http::RequestError &ex)
		{
			new ErrorMessage("Error", "Unable to file report: " + ByteString(ex.what()).FromUtf8());
		}
		reportSaveRequest.reset();
	}
	if (addCommentRequest && addCommentRequest->CheckDone())
	{
		try
		{
			addCommentRequest->Finish();
			addCommentBox->SetText("");
			c->CommentAdded();
		}
		catch (const http::RequestError &ex)
		{
			new ErrorMessage("Error submitting comment", ByteString(ex.what()).FromUtf8());
		}
		isSubmittingComment = false;
		CheckCommentSubmitEnabled();
		commentBoxAutoHeight();
		addCommentRequest.reset();
		CheckComment();
	}
}

void PreviewView::OnTryExit(ExitMethod method)
{
	c->Exit();
}

void PreviewView::OnMouseWheel(int x, int y, int d)
{
	if(commentsPanel->GetScrollLimit() == 1 && d < 0)
		c->NextCommentPage();
	if(commentsPanel->GetScrollLimit() == -1 && d > 0)
	{
		if (c->PrevCommentPage())
			prevPage = true;
	}

}

void PreviewView::OnMouseUp(int x, int y, unsigned int button)
{
	//if mouse is on the scrollbar or farther right, and you are at the top of bottom of a page, change pages
	if (x > Position.X+commentsPanel->Position.X+commentsPanel->Size.X-6)
	{
		if (commentsPanel->GetScrollLimit() == 1)
			c->NextCommentPage();
		if (commentsPanel->GetScrollLimit() == -1)
		{
			if (c->PrevCommentPage())
				prevPage = true;
		}
	}
}

void PreviewView::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	if ((key == SDLK_KP_ENTER || key == SDLK_RETURN) && (!addCommentBox || !addCommentBox->IsFocused()))
		openButton->DoAction();
}

void PreviewView::ShowLoadError()
{
	new ErrorMessage("Error loading save", doErrorMessage, {});
}

void PreviewView::ShowMissingCustomElements()
{
	StringBuilder sb;
	sb << "This save uses custom elements that are not currently available. Make sure that you use the mod and/or have all the scripts the save requires to fully load.";
	auto remainingIds = missingElements.ids;
	if (missingElements.identifiers.size())
	{
		sb << "\n\nA list of identifiers of missing custom elements follows, which may help you determine how to fix this problem.\n";
		for (auto &[ identifier, id ] : missingElements.identifiers)
		{
			sb << "\n - " << identifier.FromUtf8();
			remainingIds.erase(id); // remove ids from the missing id set that are already covered by unknown identifiers
		}
	}
	if (remainingIds.size())
	{
		sb << "\n\nA list of element IDs of missing custom elements with no identifier associated follows. This can only be fixed by the author of the save.\n";
		for (auto id : remainingIds)
		{
			sb << "\n - " << id;
		}
	}
	new InformationMessage("Missing custom elements", sb.Build(), true);
}

void PreviewView::UpdateLoadStatus()
{
	auto y = YRES / 2 - 22;
	auto showButton = [&y](ui::Button *button) {
		if (button->Visible)
		{
			button->Position = { XRES / 2 - button->Size.X - 3, y };
			y -= button->Size.Y + 3;
		}
	};
	showButton(missingElementsButton);
	showButton(loadErrorButton);
}

void PreviewView::NotifySaveChanged(PreviewModel * sender)
{
	favButton->Appearance.BackgroundPulse = false;
	auto *save = sender->GetSaveInfo();
	if(save)
	{
		votesUp = save->votesUp;
		votesDown = save->votesDown;
		saveNameLabel->SetText(save->name);
		String dateType;
		if (save->updatedDate == save->createdDate)
			dateType = "Created:";
		else
			dateType = "Updated:";
		if (showAvatars)
		{
			avatarButton->SetUsername(save->userName);
			authorDateLabel->SetText("\bw" + save->userName.FromUtf8() + " \bg" + dateType + " \bw" + format::UnixtimeToDateMini(save->updatedDate).FromAscii());
		}
		else
		{
			authorDateLabel->SetText("\bgAuthor:\bw " + save->userName.FromUtf8() + " \bg" + dateType + " \bw" + format::UnixtimeToDateMini(save->updatedDate).FromAscii());
		}
		if (Client::Ref().GetAuthUser().UserID && save->userName == Client::Ref().GetAuthUser().Username)
			userIsAuthor = true;
		else
			userIsAuthor = false;
		viewsLabel->SetText(String::Build("\bgViews:\bw ", save->Views));
		saveDescriptionLabel->SetText(save->Description);
		if(save->Favourite)
		{
			favButton->Enabled = true;
			favButton->SetToggleState(true);
		}
		else if(Client::Ref().GetAuthUser().UserID)
		{
			favButton->Enabled = true;
			favButton->SetToggleState(false);
		}
		else
		{
			favButton->SetToggleState(false);
			favButton->Enabled = false;
		}

		if(save->GetGameSave())
		{
			missingElements = save->GetGameSave()->missingElements;
			RendererSettings rendererSettings;
			rendererSettings.decorationLevel = RendererSettings::decorationAntiClickbait;
			savePreview = SaveRenderer::Ref().Render(save->GetGameSave(), true, rendererSettings);
			if (savePreview)
				savePreview->ResizeToFit(RES / 2, true);
			missingElementsButton->Visible = missingElements;
			UpdateLoadStatus();
		}
		else if (!sender->GetCanOpen())
			openButton->Enabled = false;
	}
	else
	{
		votesUp = 0;
		votesDown = 0;
		saveNameLabel->SetText("");
		authorDateLabel->SetText("");
		saveDescriptionLabel->SetText("");
		favButton->SetToggleState(false);
		favButton->Enabled = false;
		if (!sender->GetCanOpen())
			openButton->Enabled = false;
	}
}

void PreviewView::submitComment()
{
	if (addCommentBox)
	{
		String comment = addCommentBox->GetText();
		if (comment.length() == 0)
		{
			c->RefreshComments();
			isRefreshingComments = true;
		}
		else if (comment.length() < 4)
		{
			new ErrorMessage("Error", "Comment is too short");
		}
		else
		{
			isSubmittingComment = true;
			FocusComponent(nullptr);

			addCommentRequest = std::make_unique<http::AddCommentRequest>(c->SaveID(), comment);
			addCommentRequest->Start();

			CheckComment();
		}

		CheckCommentSubmitEnabled();
	}
}

void PreviewView::CheckCommentSubmitEnabled()
{
	if (submitCommentButton)
		submitCommentButton->Enabled = !isRefreshingComments && !isSubmittingComment;
}

void PreviewView::NotifyCommentBoxEnabledChanged(PreviewModel * sender)
{
	if(addCommentBox)
	{
		RemoveComponent(addCommentBox);
		delete addCommentBox;
		addCommentBox = nullptr;
	}
	if(submitCommentButton)
	{
		RemoveComponent(submitCommentButton);
		delete submitCommentButton;
		submitCommentButton = nullptr;
	}
	if(sender->GetCommentBoxEnabled())
	{
		addCommentBox = new ui::Textbox(ui::Point((XRES/2)+4, Size.Y-19), ui::Point(Size.X-(XRES/2)-48, 17), "", "Add Comment");
		commentBoxPositionX.SetTarget(addCommentBox->Position.X);
		commentBoxPositionX.SetValue(addCommentBox->Position.X);
		commentBoxPositionY.SetTarget(addCommentBox->Position.Y);
		commentBoxPositionY.SetValue(addCommentBox->Position.Y);
		commentBoxSizeX.SetTarget(addCommentBox->Size.X);
		commentBoxSizeX.SetValue(addCommentBox->Size.X);
		commentBoxSizeY.SetTarget(addCommentBox->Size.Y);
		commentBoxSizeY.SetValue(addCommentBox->Size.Y);
		addCommentBox->SetActionCallback({ [this] {
			CheckComment();
			commentBoxAutoHeight();
		} });
		addCommentBox->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		addCommentBox->SetMultiline(true);
		addCommentBox->SetLimit(1000);
		AddComponent(addCommentBox);
		submitCommentButton = new ui::Button(ui::Point(Size.X-40, Size.Y-19), ui::Point(40, 19), "Submit");
		submitCommentButton->SetActionCallback({ [this] { submitComment(); } });
		AddComponent(submitCommentButton);

		commentWarningLabel = new ui::Label(ui::Point((XRES/2)+4, Size.Y-19), ui::Point(Size.X-(XRES/2)-48, 16), "If you see this it is a bug");
		commentWarningLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		commentWarningLabel->SetTextColour(ui::Colour(255, 0, 0));
		commentWarningLabel->Visible = false;
		AddComponent(commentWarningLabel);
	}
	else
	{
		submitCommentButton = new ui::Button(ui::Point(XRES/2, Size.Y-19), ui::Point(Size.X-(XRES/2), 19), "Login to comment");
		submitCommentButton->SetActionCallback({ [this] { c->ShowLogin(); } });
		AddComponent(submitCommentButton);
	}
}

void PreviewView::SaveLoadingError(String errorMessage)
{
	doError = true;
	doErrorMessage = errorMessage;
	Platform::MarkPresentable();
}

void PreviewView::NotifyCommentsPageChanged(PreviewModel * sender)
{
	pageInfo->SetText(String::Build("Page ", sender->GetCommentsPageNum(), " of ", sender->GetCommentsPageCount()));
}

void PreviewView::NotifyCommentsChanged(PreviewModel * sender)
{
	auto commentsPtr = sender->GetComments();

	for (size_t i = 0; i < commentComponents.size(); i++)
	{
		commentsPanel->RemoveChild(commentComponents[i]);
		delete commentComponents[i];
	}
	commentComponents.clear();
	commentTextComponents.clear();
	commentsPanel->InnerSize = ui::Point(0, 0);

	isRefreshingComments = false;
	CheckCommentSubmitEnabled();

	if (commentsPtr)
	{
		auto &comments = *commentsPtr;
		for (size_t i = 0; i < commentComponents.size(); i++)
		{
			commentsPanel->RemoveChild(commentComponents[i]);
			delete commentComponents[i];
		}
		commentComponents.clear();
		commentTextComponents.clear();

		int currentY = 0;//-yOffset;
		ui::Label * tempUsername;
		ui::Label * tempComment;
		ui::AvatarButton * tempAvatar;
		for (size_t i = 0; i < comments.size(); i++)
		{
			if (showAvatars)
			{
				tempAvatar = new ui::AvatarButton(ui::Point(2, currentY+7), ui::Point(26, 26), comments[i].authorName);
				tempAvatar->SetActionCallback({ [tempAvatar] {
					if (tempAvatar->GetUsername().size() > 0)
					{
						new ProfileActivity(tempAvatar->GetUsername());
					}
				} });
				commentComponents.push_back(tempAvatar);
				commentsPanel->AddChild(tempAvatar);
			}

			auto authorNameFormatted = comments[i].authorName.FromUtf8();
			if (comments[i].authorElevation != User::ElevationNone || comments[i].authorName == "jacobot")
			{
				authorNameFormatted = "\bt" + authorNameFormatted;
			}
			else if (comments[i].authorIsBanned)
			{
				authorNameFormatted = "\bg" + authorNameFormatted;
			}
			else if (Client::Ref().GetAuthUser().UserID && Client::Ref().GetAuthUser().Username == comments[i].authorName)
			{
				authorNameFormatted = "\bo" + authorNameFormatted;
			}
			else if (sender->GetSaveInfo() && sender->GetSaveInfo()->GetUserName() == comments[i].authorName)
			{
				authorNameFormatted = "\bl" + authorNameFormatted;
			}
			if (showAvatars)
				tempUsername = new ui::Label(ui::Point(31, currentY+8), ui::Point(Size.X-((XRES/2) + 13 + 26), 14), authorNameFormatted);
			else
				tempUsername = new ui::Label(ui::Point(5, currentY+8), ui::Point(Size.X-((XRES/2) + 13), 14), authorNameFormatted);
			tempUsername->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
			tempUsername->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
			currentY += 16;

			commentComponents.push_back(tempUsername);
			commentsPanel->AddChild(tempUsername);

			if (showAvatars)
				tempComment = new ui::Label(ui::Point(31, currentY+5), ui::Point(Size.X-((XRES/2) + 13 + 26), -1), comments[i].content);
			else
				tempComment = new ui::Label(ui::Point(5, currentY+5), ui::Point(Size.X-((XRES/2) + 13), -1), comments[i].content);
			tempComment->SetMultiline(true);
			tempComment->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
			tempComment->Appearance.VerticalAlign = ui::Appearance::AlignTop;
			tempComment->SetTextColour(ui::Colour(180, 180, 180));
			currentY += tempComment->Size.Y+4;

			commentComponents.push_back(tempComment);
			commentsPanel->AddChild(tempComment);
			commentTextComponents.push_back(tempComment);
		}

		commentsPanel->InnerSize = ui::Point(commentsPanel->Size.X, currentY+4);
		if (prevPage)
		{
			prevPage = false;
			commentsPanel->SetScrollPosition(currentY);
		}
	}
	//else if (sender->GetCommentsLoaded())
	//	ErrorMessage::Blocking("Error loading comments", Client::Ref().GetLastError());
}

PreviewView::~PreviewView()
{
	if(addCommentBox)
	{
		RemoveComponent(addCommentBox);
		delete addCommentBox;
	}
	if(submitCommentButton)
	{
		RemoveComponent(submitCommentButton);
		delete submitCommentButton;
	}
}


=== src\gui\preview\PreviewView.h ===

#pragma once
#include <memory>
#include <set>
#include <vector>
#include "common/String.h"
#include "gui/interface/Window.h"
#include "gui/interface/Fade.h"
#include "simulation/MissingElements.h"

namespace http
{
	class AddCommentRequest;
	class ReportSaveRequest;
}

namespace ui
{
	class Button;
	class CopyTextButton;
	class Label;
	class Textbox;
	class ScrollPanel;
	class AvatarButton;
}

class VideoBuffer;
class PreviewModel;
class PreviewController;
class PreviewView: public ui::Window
{
	PreviewController *c{};
	MissingElements missingElements;
	std::unique_ptr<VideoBuffer> savePreview;
	ui::Button *openButton{};
	ui::Button *browserOpenButton{};
	ui::Button *favButton{};
	ui::Button *reportButton{};
	ui::Button *submitCommentButton{};
	ui::Button *loadErrorButton{};
	ui::Button *missingElementsButton{};
	ui::Textbox *addCommentBox{};
	ui::Label *commentWarningLabel{};
	ui::Label *saveNameLabel{};
	ui::Label *authorDateLabel{};
	ui::AvatarButton *avatarButton{};
	ui::Label *pageInfo{};
	ui::Label *saveDescriptionLabel{};
	ui::Label *viewsLabel{};
	ui::Label *saveIDLabel{};
	ui::Label *saveIDLabel2{};
	ui::CopyTextButton *saveIDButton{};
	ui::ScrollPanel *commentsPanel{};
	std::vector<ui::Component*> commentComponents;
	std::vector<ui::Component*> commentTextComponents;
	int votesUp;
	int votesDown;
	bool userIsAuthor;
	bool doOpen;
	bool doError;
	String doErrorMessage;
	bool showAvatars;
	bool prevPage;
	bool isSubmittingComment = false;
	bool isRefreshingComments = false;

	int commentBoxHeight;
	ui::Fade commentBoxPositionX{ ui::Fade::BasicDimensionProfile };
	ui::Fade commentBoxPositionY{ ui::Fade::BasicDimensionProfile };
	ui::Fade commentBoxSizeX{ ui::Fade::BasicDimensionProfile };
	ui::Fade commentBoxSizeY{ ui::Fade::BasicDimensionProfile };
	bool commentHelpText;

	std::set<String> swearWords;

	void displayComments();
	void commentBoxAutoHeight();
	void submitComment();
	void CheckCommentSubmitEnabled();
	bool CheckSwearing(String text);
	void CheckComment();
	void ShowMissingCustomElements();
	void ShowLoadError();
	void UpdateLoadStatus();

	std::unique_ptr<http::AddCommentRequest> addCommentRequest;
	std::unique_ptr<http::ReportSaveRequest> reportSaveRequest;

public:
	void AttachController(PreviewController * controller);
	PreviewView(std::unique_ptr<VideoBuffer> newSavePreviev);
	void NotifySaveChanged(PreviewModel * sender);
	void NotifyCommentsChanged(PreviewModel * sender);
	void NotifyCommentsPageChanged(PreviewModel * sender);
	void NotifyCommentBoxEnabledChanged(PreviewModel * sender);
	void SaveLoadingError(String errorMessage);
	void OnDraw() override;
	void DoDraw() override;
	void OnTick() override;
	void OnTryExit(ExitMethod method) override;
	void OnMouseWheel(int x, int y, int d) override;
	void OnMouseUp(int x, int y, unsigned int button) override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	virtual ~PreviewView();
};


=== src\gui\profile\meson.build ===

powder_files += files(
	'ProfileActivity.cpp',
)


=== src\gui\profile\ProfileActivity.cpp ===

#include "ProfileActivity.h"
#include "client/Client.h"
#include "client/http/SaveUserInfoRequest.h"
#include "client/http/GetUserInfoRequest.h"
#include "common/platform/Platform.h"
#include "gui/Style.h"
#include "gui/interface/AvatarButton.h"
#include "gui/interface/Button.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/interface/Label.h"
#include "gui/interface/ScrollPanel.h"
#include "gui/interface/Textbox.h"
#include "Config.h"

ProfileActivity::ProfileActivity(ByteString username) :
	WindowActivity(ui::Point(-1, -1), ui::Point(236, 300)),
	loading(false),
	saving(false),
	doError(false),
	doErrorMessage("")
{
	editable = Client::Ref().GetAuthUser().UserID && Client::Ref().GetAuthUser().Username == username;

	ui::Button * closeButton = new ui::Button(ui::Point(0, Size.Y-15), ui::Point(Size.X, 15), "Close");
	closeButton->SetActionCallback({ [this] {
		Exit();
	} });
	if(editable)
	{
		closeButton->Size.X = (Size.X/2)+1;

		ui::Button * saveButton = new ui::Button(ui::Point(Size.X/2, Size.Y-15), ui::Point(Size.X/2, 15), "Save");
		saveButton->SetActionCallback({ [this, saveButton] {
			if (!loading && !saving && editable)
			{
				saveButton->Enabled = false;
				saveButton->SetText("Saving...");
				saving = true;
				info.location = location->GetText();
				info.biography = bio->GetText();
				saveUserInfoRequest = std::make_unique<http::SaveUserInfoRequest>(info);
				saveUserInfoRequest->Start();
			}
		} });
		AddComponent(saveButton);
	}

	AddComponent(closeButton);

	loading = true;

	getUserInfoRequest = std::make_unique<http::GetUserInfoRequest>(username);
	getUserInfoRequest->Start();
}

void ProfileActivity::setUserInfo(UserInfo newInfo)
{
	info = newInfo;

	if (!info.biography.length() && !editable)
		info.biography = "\bgNot Provided";
	if (!info.location.length() && !editable)
		info.location = "\bgNot Provided";
	if (!info.website.length())
		info.website = "\bgNot Provided";

	// everything is on a large scroll panel
	scrollPanel = new ui::ScrollPanel(ui::Point(1, 1), ui::Point(Size.X-2, Size.Y-16));
	AddComponent(scrollPanel);
	int currentY = 5;

	// username label
	ui::Label * title = new ui::Label(ui::Point(4, currentY), ui::Point(Size.X-8-(40+16+75), 15), info.username.FromUtf8());
	title->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	scrollPanel->AddChild(title);

	// avatar
	ui::AvatarButton * avatar = new ui::AvatarButton(ui::Point((Size.X-40)-8, 5), ui::Point(40, 40), info.username);
	scrollPanel->AddChild(avatar);

	// edit avatar button
	if (editable)
	{
		ui::Button * editAvatar = new ui::Button(ui::Point(Size.X - (40 + 16 + 75), currentY), ui::Point(75, 15), "Edit Avatar");
		editAvatar->SetActionCallback({ [] {
			Platform::OpenURI(ByteString::Build(SERVER, "/Profile/Avatar.html"));
		} });
		scrollPanel->AddChild(editAvatar);
	}
	currentY += 23;

	// age
	ui::Label * ageTitle = new ui::Label(ui::Point(4, currentY), ui::Point(23, 15), "Age:");
	ageTitle->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	ageTitle->SetTextColour(ui::Colour(180, 180, 180));
	scrollPanel->AddChild(ageTitle);

	// can't figure out how to tell a null from a 0 in the json library we use
	ui::Label *age = new ui::Label(ui::Point(5+ageTitle->Size.X, currentY), ui::Point(Size.X-ageTitle->Size.X-56, 15), info.age ? String::Build(info.age) : "\bgNot Provided");
	age->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	scrollPanel->AddChild(age);
	currentY += 2+age->Size.Y;

	// location
	ui::Label * locationTitle = new ui::Label(ui::Point(4, currentY), ui::Point(45, 15), "Location:");
	locationTitle->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	locationTitle->SetTextColour(ui::Colour(180, 180, 180));
	scrollPanel->AddChild(locationTitle);

	if (editable)
	{
		location = new ui::Textbox(ui::Point(5+locationTitle->Size.X, currentY), ui::Point(Size.X-locationTitle->Size.X-16, 17), info.location);
		((ui::Textbox*)location)->SetLimit(40);
	}
	else
	{
		location = new ui::Label(ui::Point(5+locationTitle->Size.X, currentY), ui::Point(Size.X-locationTitle->Size.X-14, 17), info.location);
	}
	location->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	scrollPanel->AddChild(location);
	currentY += 2+location->Size.Y;

	// website
	ui::Label * websiteTitle = new ui::Label(ui::Point(1, currentY), ui::Point(42, 15), "Website:");
	websiteTitle->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	websiteTitle->SetTextColour(ui::Colour(180, 180, 180));
	scrollPanel->AddChild(websiteTitle);

	ui::Label *website = new ui::Label(ui::Point(2+websiteTitle->Size.X, currentY), ui::Point(Size.X-websiteTitle->Size.X-16, 15), info.website.FromUtf8());
	website->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	scrollPanel->AddChild(website);
	currentY += 2+website->Size.Y;

	// saves
	ui::Label * savesTitle = new ui::Label(ui::Point(4, currentY), ui::Point(35, 15), "Saves:");
	savesTitle->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	savesTitle->SetTextColour(ui::Colour(180, 180, 180));
	scrollPanel->AddChild(savesTitle);
	currentY += savesTitle->Size.Y;

		// saves count
		ui::Label * saveCountTitle = new ui::Label(ui::Point(12, currentY), ui::Point(32, 15), "Count:");
		saveCountTitle->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		saveCountTitle->SetTextColour(ui::Colour(180, 180, 180));
		scrollPanel->AddChild(saveCountTitle);

		ui::Label *savesCount = new ui::Label(ui::Point(13+saveCountTitle->Size.X, currentY), ui::Point(Size.X-saveCountTitle->Size.X-24, 15), String::Build(info.saveCount));
		savesCount->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		scrollPanel->AddChild(savesCount);
		currentY += savesCount->Size.Y;

		// average score
		ui::Label * averageScoreTitle = new ui::Label(ui::Point(12, currentY), ui::Point(72, 15), "Average Score:");
		averageScoreTitle->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		averageScoreTitle->SetTextColour(ui::Colour(180, 180, 180));
		scrollPanel->AddChild(averageScoreTitle);

		ui::Label *averageScore = new ui::Label(ui::Point(13+averageScoreTitle->Size.X, currentY), ui::Point(Size.X-averageScoreTitle->Size.X-24, 15), String::Build(info.averageScore));
		averageScore->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		scrollPanel->AddChild(averageScore);
		currentY += averageScore->Size.Y;

		// highest score
		ui::Label * highestScoreTitle = new ui::Label(ui::Point(12, currentY), ui::Point(71, 15), "Highest Score:");
		highestScoreTitle->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		highestScoreTitle->SetTextColour(ui::Colour(180, 180, 180));
		scrollPanel->AddChild(highestScoreTitle);

		ui::Label *highestScore = new ui::Label(ui::Point(13+highestScoreTitle->Size.X, currentY), ui::Point(Size.X-highestScoreTitle->Size.X-24, 15), String::Build(info.highestScore));
		highestScore->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
		scrollPanel->AddChild(highestScore);
		currentY += 2+highestScore->Size.Y;

	// biograhy
	ui::Label * bioTitle = new ui::Label(ui::Point(4, currentY), ui::Point(50, 15), "Biography:");
	bioTitle->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	bioTitle->SetTextColour(ui::Colour(180, 180, 180));
	scrollPanel->AddChild(bioTitle);
	currentY += 17;

	if (editable)
	{
		bio = new ui::Textbox(ui::Point(4, currentY), ui::Point(Size.X-12, -1), info.biography);
		((ui::Textbox*)bio)->SetInputType(ui::Textbox::Multiline);
		((ui::Textbox*)bio)->SetActionCallback({ [this] { ResizeArea(); } });
		((ui::Textbox*)bio)->SetLimit(20000);
	}
	else
		bio = new ui::Label(ui::Point(4, currentY), ui::Point(Size.X-12, -1), info.biography);
	bio->SetMultiline(true);
	bio->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	bio->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	scrollPanel->AddChild(bio);
	currentY += 10+bio->Size.Y;


	scrollPanel->InnerSize = ui::Point(Size.X, currentY);
}

void ProfileActivity::OnTick()
{
	if (doError)
	{
		new ErrorMessage("Error", doErrorMessage, { [this]() {
			Exit();
		} });
	}

	if (saveUserInfoRequest && saveUserInfoRequest->CheckDone())
	{
		try
		{
			saveUserInfoRequest->Finish();
			Exit();
		}
		catch (const http::RequestError &ex)
		{
			doError = true;
			doErrorMessage = "Could not save user info: " + ByteString(ex.what()).FromUtf8();
		}
		saveUserInfoRequest.reset();
	}
	if (getUserInfoRequest && getUserInfoRequest->CheckDone())
	{
		try
		{
			auto userInfo = getUserInfoRequest->Finish();
			loading = false;
			setUserInfo(userInfo);
		}
		catch (const http::RequestError &ex)
		{
			doError = true;
			doErrorMessage = "Could not load user info: " + ByteString(ex.what()).FromUtf8();
		}
		getUserInfoRequest.reset();
	}
}

void ProfileActivity::OnDraw()
{
	Graphics * g = GetGraphics();
	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);
}

void ProfileActivity::OnTryExit(ExitMethod method)
{
	Exit();
}

void ProfileActivity::ResizeArea()
{
	int oldSize = scrollPanel->InnerSize.Y;
	scrollPanel->InnerSize = ui::Point(Size.X, bio->Position.Y + bio->Size.Y + 10);
	// auto scroll as ScrollPanel size increases
	if (oldSize+scrollPanel->ViewportPosition.Y == scrollPanel->Size.Y)
		scrollPanel->SetScrollPosition(scrollPanel->InnerSize.Y-scrollPanel->Size.Y);
}

ProfileActivity::~ProfileActivity()
{
}



=== src\gui\profile\ProfileActivity.h ===

#pragma once
#include "common/String.h"
#include "Activity.h"
#include "client/UserInfo.h"
#include <memory>

namespace http
{
	class SaveUserInfoRequest;
	class GetUserInfoRequest;
}

namespace ui
{
class Label;
class ScrollPanel;
}
class ProfileActivity: public WindowActivity {
	ui::ScrollPanel *scrollPanel;
	ui::Label *location;
	ui::Label *bio;
	UserInfo info;
	bool editable;
	bool loading;
	bool saving;
	bool doError;
	String doErrorMessage;
	void setUserInfo(UserInfo newInfo);

	std::unique_ptr<http::SaveUserInfoRequest> saveUserInfoRequest;
	std::unique_ptr<http::GetUserInfoRequest> getUserInfoRequest;

public:
	ProfileActivity(ByteString username);
	virtual ~ProfileActivity();
	void OnTick() override;
	void OnDraw() override;
	void OnTryExit(ExitMethod method) override;

	void ResizeArea();
};


=== src\gui\render\meson.build ===

powder_files += files(
	'RenderController.cpp',
	'RenderModel.cpp',
	'RenderView.cpp',
)


=== src\gui\render\RenderController.cpp ===

#include "RenderController.h"

#include "RenderView.h"
#include "RenderModel.h"

#include "Controller.h"

RenderController::RenderController(Simulation *sim, Renderer * ren, RendererSettings *rendererSettings, std::function<void ()> onDone_):
	HasExited(false)
{
	renderView = new RenderView();
	renderModel = new RenderModel();

	renderModel->SetRenderer(ren, rendererSettings);

	renderView->AttachController(this);
	renderModel->AddObserver(renderView);

	renderModel->SetSimulation(sim);

	onDone = onDone_;
}

void RenderController::SetRenderMode(uint32_t newRenderMode)
{
	renderModel->SetRenderMode(newRenderMode);
}

uint32_t RenderController::GetRenderMode()
{
	return renderModel->GetRenderMode();
}

void RenderController::SetDisplayMode(uint32_t newDisplayMode)
{
	renderModel->SetDisplayMode(newDisplayMode);
}

uint32_t RenderController::GetDisplayMode()
{
	return renderModel->GetDisplayMode();
}

void RenderController::SetColorMode(uint32_t newColorMode)
{
	renderModel->SetColorMode(newColorMode);
}

uint32_t RenderController::GetColorMode()
{
	return renderModel->GetColorMode();
}

void RenderController::LoadRenderPreset(int presetNum)
{
	renderModel->LoadRenderPreset(presetNum);
}

void RenderController::Exit()
{
	renderView->CloseActiveWindow();
	if (onDone)
		onDone();
	HasExited = true;
}

RenderController::~RenderController()
{
	delete renderModel;
	renderView->CloseActiveWindow();
	delete renderView;
}



=== src\gui\render\RenderController.h ===

#pragma once
#include <functional>
#include <cstdint>

class RenderView;
class RenderModel;
class Renderer;
struct RendererSettings;
class Simulation;
class RenderController
{
	RenderView * renderView;
	RenderModel * renderModel;
	std::function<void ()> onDone;
public:
	bool HasExited;
	RenderController(Simulation *sim, Renderer * ren, RendererSettings *rendererSettings, std::function<void ()> onDone = nullptr);
	void Exit();
	RenderView * GetView() { return renderView; }
	virtual ~RenderController();
	void SetRenderMode(uint32_t newRenderMode);
	uint32_t GetRenderMode();
	void SetDisplayMode(uint32_t newDisplayMode);
	uint32_t GetDisplayMode();
	void SetColorMode(uint32_t newColorMode);
	uint32_t GetColorMode();
	void LoadRenderPreset(int presetNum);
};


=== src\gui\render\RenderModel.cpp ===

#include "RenderModel.h"
#include "RenderView.h"
#include "gui/game/RenderPreset.h"
#include "gui/game/GameController.h"
#include "gui/game/GameView.h"
#include "graphics/Renderer.h"

void RenderModel::AddObserver(RenderView * observer)
{
	observers.push_back(observer);
	observer->NotifyRendererChanged(this);
	observer->NotifyRenderChanged(this);
	observer->NotifyDisplayChanged(this);
	observer->NotifyColourChanged(this);
}

void RenderModel::SetRenderMode(uint32_t newRenderMode)
{
	rendererSettings->renderMode = newRenderMode;
	notifyRenderChanged();
}

uint32_t RenderModel::GetRenderMode()
{
	return rendererSettings->renderMode;
}

void RenderModel::SetDisplayMode(uint32_t newDisplayMode)
{
	rendererSettings->displayMode = newDisplayMode;
	notifyDisplayChanged();
}

uint32_t RenderModel::GetDisplayMode()
{
	return rendererSettings->displayMode;
}

void RenderModel::SetColorMode(uint32_t newColorMode)
{
	rendererSettings->colorMode = newColorMode;
	notifyColourChanged();
}

uint32_t RenderModel::GetColorMode()
{
	return rendererSettings->colorMode;
}

void RenderModel::LoadRenderPreset(int presetNum)
{
	RenderPreset preset = Renderer::renderModePresets[presetNum];
	SetRenderMode(preset.renderMode);
	SetDisplayMode(preset.displayMode);
	SetColorMode(preset.colorMode);
	rendererSettings->wantHdispLimitMin = preset.wantHdispLimitMin;
	rendererSettings->wantHdispLimitMax = preset.wantHdispLimitMax;
}

void RenderModel::SetRenderer(Renderer * ren, RendererSettings *newRendererSettings)
{
	renderer = ren;
	rendererSettings = newRendererSettings;
	notifyRendererChanged();
	notifyRenderChanged();
	notifyDisplayChanged();
	notifyColourChanged();
}

void RenderModel::SetSimulation(Simulation *newSim)
{
	sim = newSim;
	notifySimulationChanged();
	notifyRenderChanged();
	notifyDisplayChanged();
	notifyColourChanged();
}

Renderer * RenderModel::GetRenderer()
{
	return renderer;
}

RendererSettings *RenderModel::GetRendererSettings()
{
	return rendererSettings;
}

Simulation *RenderModel::GetSimulation()
{
	return sim;
}

void RenderModel::notifyRendererChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyRendererChanged(this);
	}
}

void RenderModel::notifySimulationChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifySimulationChanged(this);
	}
}

void RenderModel::notifyRenderChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyRenderChanged(this);
	}
}

void RenderModel::notifyDisplayChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyDisplayChanged(this);
	}
}

void RenderModel::notifyColourChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyColourChanged(this);
	}
}

RenderModel::~RenderModel() {
}


=== src\gui\render\RenderModel.h ===

#pragma once
#include <vector>
#include <cstdint>

class RenderView;
class Renderer;
struct RendererSettings;
class Simulation;
class RenderModel
{
	std::vector<RenderView*> observers;
	Renderer * renderer = nullptr;
	RendererSettings *rendererSettings = nullptr;
	Simulation *sim = nullptr;
	void notifyRendererChanged();
	void notifySimulationChanged();
	void notifyRenderChanged();
	void notifyDisplayChanged();
	void notifyColourChanged();
public:
	Renderer * GetRenderer();
	RendererSettings *GetRendererSettings();
	Simulation *GetSimulation();
	void AddObserver(RenderView * observer);
	void SetRenderer(Renderer * ren, RendererSettings *newRendererSettings);
	void SetSimulation(Simulation *newSim);
	void SetRenderMode(uint32_t newRenderMode);
	uint32_t GetRenderMode();
	void SetDisplayMode(uint32_t newDisplayMode);
	uint32_t GetDisplayMode();
	void SetColorMode(uint32_t newColorMode);
	uint32_t GetColorMode();
	void LoadRenderPreset(int presetNum);
	virtual ~RenderModel();
};


=== src\gui\render\RenderView.cpp ===

#include "RenderView.h"
#include "simulation/ElementGraphics.h"
#include "simulation/SimulationData.h"
#include "simulation/Simulation.h"
#include "graphics/Graphics.h"
#include "graphics/Renderer.h"
#include "graphics/VideoBuffer.h"
#include "RenderController.h"
#include "RenderModel.h"
#include "gui/interface/Checkbox.h"
#include "gui/interface/Button.h"
#include "gui/game/GameController.h"
#include "gui/game/GameView.h"

class ModeCheckbox : public ui::Checkbox
{
public:
	using ui::Checkbox::Checkbox;
	uint32_t mode;
};

RenderView::RenderView():
	ui::Window(ui::Point(0, 0), ui::Point(XRES, WINDOWH)),
	ren(nullptr),
	toolTip(""),
	isToolTipFadingIn(false)
{
	auto addPresetButton = [this](int index, Icon icon, ui::Point offset, String tooltip) {
		auto *presetButton = new ui::Button(ui::Point(XRES, YRES) + offset, ui::Point(30, 13), "", tooltip);
		presetButton->SetIcon(icon);
		presetButton->SetActionCallback({ [this, index] { c->LoadRenderPreset(index); } });
		AddComponent(presetButton);
	};
	addPresetButton( 1, IconVelocity  , ui::Point( -37,  6), "Velocity display mode preset");
	addPresetButton( 2, IconPressure  , ui::Point( -37, 24), "Pressure display mode preset");
	addPresetButton( 3, IconPersistant, ui::Point( -76,  6), "Persistent display mode preset");
	addPresetButton( 4, IconFire      , ui::Point( -76, 24), "Fire display mode preset");
	addPresetButton( 5, IconBlob      , ui::Point(-115,  6), "Blob display mode preset");
	addPresetButton( 6, IconHeat      , ui::Point(-115, 24), "Heat display mode preset");
	addPresetButton( 7, IconBlur      , ui::Point(-154,  6), "Fancy display mode preset");
	addPresetButton( 8, IconBasic     , ui::Point(-154, 24), "Nothing display mode preset");
	addPresetButton( 9, IconGradient  , ui::Point(-193,  6), "Heat gradient display mode preset");
	addPresetButton( 0, IconAltAir    , ui::Point(-193, 24), "Alternative Velocity display mode preset");
	addPresetButton(10, IconLife      , ui::Point(-232,  6), "Life display mode preset");

	auto addRenderModeCheckbox = [this](unsigned int mode, Icon icon, ui::Point offset, String tooltip) {
		auto *renderModeCheckbox = new ModeCheckbox(ui::Point(0, YRES) + offset, ui::Point(30, 16), "", tooltip);
		renderModes.push_back(renderModeCheckbox);
		renderModeCheckbox->mode = mode;
		renderModeCheckbox->SetIcon(icon);
		renderModeCheckbox->SetActionCallback({ [this] {
			auto renderMode = CalculateRenderMode();
			c->SetRenderMode(renderMode);
		} });
		AddComponent(renderModeCheckbox);
	};
	addRenderModeCheckbox(RENDER_EFFE, IconEffect, ui::Point( 1,  4), "Adds Special flare effects to some elements");
	addRenderModeCheckbox(RENDER_FIRE, IconFire  , ui::Point( 1, 22), "Fire effect for gasses");
	addRenderModeCheckbox(RENDER_GLOW, IconGlow  , ui::Point(33,  4), "Glow effect on some elements");
	addRenderModeCheckbox(RENDER_BLUR, IconBlur  , ui::Point(33, 22), "Blur effect for liquids");
	addRenderModeCheckbox(RENDER_BLOB, IconBlob  , ui::Point(65,  4), "Makes everything be drawn like a blob");
	addRenderModeCheckbox(RENDER_BASC, IconBasic , ui::Point(65, 22), "Basic rendering, without this, most things will be invisible");
	addRenderModeCheckbox(RENDER_SPRK, IconEffect, ui::Point(97,  4), "Glow effect on sparks");

	auto addDisplayModeCheckbox = [this](unsigned int mode, Icon icon, ui::Point offset, String tooltip) {
		auto *displayModeCheckbox = new ModeCheckbox(ui::Point(0, YRES) + offset, ui::Point(30, 16), "", tooltip);
		displayModes.push_back(displayModeCheckbox);
		displayModeCheckbox->mode = mode;
		displayModeCheckbox->SetIcon(icon);
		displayModeCheckbox->SetActionCallback({ [this, displayModeCheckbox] {
			auto displayMode = c->GetDisplayMode();
			// Air display modes are mutually exclusive
			if (displayModeCheckbox->mode & DISPLAY_AIR)
			{
				displayMode &= ~DISPLAY_AIR;
			}
			if (displayModeCheckbox->GetChecked())
			{
				displayMode |= displayModeCheckbox->mode;
			}
			else
			{
				displayMode &= ~displayModeCheckbox->mode;
			}
			c->SetDisplayMode(displayMode);
		} });
		AddComponent(displayModeCheckbox);
	};
	line1 = 130;
	addDisplayModeCheckbox(DISPLAY_AIRC, IconAltAir    , ui::Point(135,  4), "Displays pressure as red and blue, and velocity as white");
	addDisplayModeCheckbox(DISPLAY_AIRP, IconPressure  , ui::Point(135, 22), "Displays pressure, red is positive and blue is negative");
	addDisplayModeCheckbox(DISPLAY_AIRV, IconVelocity  , ui::Point(167,  4), "Displays velocity and positive pressure: up/down adds blue, right/left adds red, still pressure adds green");
	addDisplayModeCheckbox(DISPLAY_AIRH, IconHeat      , ui::Point(167, 22), "Displays the temperature of the air like heat display does");
	line2 = 200;
	addDisplayModeCheckbox(DISPLAY_WARP, IconWarp      , ui::Point(205, 22), "Gravity lensing, Newtonian Gravity bends light with this on");
	addDisplayModeCheckbox(DISPLAY_EFFE, IconEffect    , ui::Point(205,  4), "Enables moving solids, stickmen guns, and premium(tm) graphics");
	addDisplayModeCheckbox(DISPLAY_PERS, IconPersistant, ui::Point(237,  4), "Element paths persist on the screen for a while");
	line3 = 270;

	auto addColourModeCheckbox = [this](unsigned int mode, Icon icon, ui::Point offset, String tooltip) {
		auto *colourModeCheckbox = new ModeCheckbox(ui::Point(0, YRES) + offset, ui::Point(30, 16), "", tooltip);
		colourModes.push_back(colourModeCheckbox);
		colourModeCheckbox->mode = mode;
		colourModeCheckbox->SetIcon(icon);
		colourModeCheckbox->SetActionCallback({ [this, colourModeCheckbox] {
			auto colorMode = c->GetColorMode();
			// exception: looks like an independent set of settings but behaves more like an index
			if (colourModeCheckbox->GetChecked())
			{
				colorMode = colourModeCheckbox->mode;
			}
			else
			{
				colorMode = 0;
			}
			c->SetColorMode(colorMode);
		} });
		AddComponent(colourModeCheckbox);
	};
	addColourModeCheckbox(COLOUR_HEAT, IconHeat    , ui::Point(275,  4), "Displays temperatures of the elements, dark blue is coldest, pink is hottest");
	addColourModeCheckbox(COLOUR_LIFE, IconLife    , ui::Point(275, 22), "Displays the life value of elements in greyscale gradients");
	addColourModeCheckbox(COLOUR_GRAD, IconGradient, ui::Point(307, 22), "Changes colors of elements slightly to show heat diffusing through them");
	addColourModeCheckbox(COLOUR_BASC, IconBasic   , ui::Point(307,  4), "No special effects at all for anything, overrides all other options and deco");
	line4 = 340;
}

uint32_t RenderView::CalculateRenderMode()
{
	uint32_t renderMode = 0;
	for (auto &checkbox : renderModes)
	{
		if (checkbox->GetChecked())
			renderMode |= checkbox->mode;
	}

	return renderMode;
}

void RenderView::OnMouseDown(int x, int y, unsigned button)
{
	if(x > XRES || y < YRES)
		c->Exit();
}

void RenderView::OnTryExit(ExitMethod method)
{
	c->Exit();
}

void RenderView::NotifyRendererChanged(RenderModel * sender)
{
	ren = sender->GetRenderer();
	rendererSettings = sender->GetRendererSettings();
}

void RenderView::NotifySimulationChanged(RenderModel * sender)
{
	sim = sender->GetSimulation();
}

void RenderView::NotifyRenderChanged(RenderModel * sender)
{
	for (size_t i = 0; i < renderModes.size(); i++)
	{
		//Compares bitmasks at the moment, this means that "Point" is always on when other options that depend on it are, this might confuse some users, TODO: get the full list and compare that?
		auto renderMode = renderModes[i]->mode;
		renderModes[i]->SetChecked(renderMode == (sender->GetRenderMode() & renderMode));
	}
}

void RenderView::NotifyDisplayChanged(RenderModel * sender)
{
	for (size_t i = 0; i < displayModes.size(); i++)
	{
		auto displayMode = displayModes[i]->mode;
		displayModes[i]->SetChecked(displayMode == (sender->GetDisplayMode() & displayMode));
	}
}

void RenderView::NotifyColourChanged(RenderModel * sender)
{
	for (size_t i = 0; i < colourModes.size(); i++)
	{
		auto colorMode = colourModes[i]->mode;
		colourModes[i]->SetChecked(colorMode == sender->GetColorMode());
	}
}

void RenderView::OnDraw()
{
	Graphics * g = GetGraphics();
	g->DrawFilledRect(WINDOW.OriginRect(), 0x000000_rgb);
	auto *view = GameController::Ref().GetView();
	view->PauseRendererThread();
	ren->ApplySettings(*rendererSettings);
	view->RenderSimulation(*sim, true);
	view->AfterSimDraw(*sim);
	for (auto y = 0; y < YRES; ++y)
	{
		auto &video = ren->GetVideo();
		std::copy_n(video.data() + video.Size().X * y, video.Size().X, g->Data() + g->Size().X * y);
	}
	g->DrawLine({ 0, YRES }, { XRES-1, YRES }, 0xC8C8C8_rgb);
	g->DrawLine({ line1, YRES }, { line1, WINDOWH }, 0xC8C8C8_rgb);
	g->DrawLine({ line2, YRES }, { line2, WINDOWH }, 0xC8C8C8_rgb);
	g->DrawLine({ line3, YRES }, { line3, WINDOWH }, 0xC8C8C8_rgb);
	g->DrawLine({ line4, YRES }, { line4, WINDOWH }, 0xC8C8C8_rgb);
	g->DrawLine({ XRES, 0 }, { XRES, WINDOWH }, 0xFFFFFF_rgb);
	if(toolTipPresence && toolTip.length())
	{
		g->BlendText({ 6, Size.Y-MENUSIZE-12 }, toolTip, 0xFFFFFF_rgb .WithAlpha(toolTipPresence>51?255:toolTipPresence*5));
	}
}

void RenderView::OnTick()
{
	if (isToolTipFadingIn)
	{
		isToolTipFadingIn = false;
		toolTipPresence.SetTarget(120);
	}
	else
	{
		toolTipPresence.SetTarget(0);
	}
}

void RenderView::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	if (shift && key == '1')
		c->LoadRenderPreset(10);
	else if(key >= '0' && key <= '9')
	{
		c->LoadRenderPreset(key-'0');
	}
}

void RenderView::ToolTip(ui::Point senderPosition, String toolTip)
{
	this->toolTip = toolTip;
	this->isToolTipFadingIn = true;
}

RenderView::~RenderView() {
}


=== src\gui\render\RenderView.h ===

#pragma once
#include "gui/interface/Window.h"
#include "gui/interface/Fade.h"
#include <cstdint>
#include <vector>

class ModeCheckbox;

class Renderer;
struct RendererSettings;
class Simulation;
class RenderController;
class RenderModel;
class RenderView: public ui::Window {
	RenderController * c;
	Renderer * ren;
	RendererSettings *rendererSettings = nullptr;
	Simulation *sim = nullptr;
	std::vector<ModeCheckbox *> renderModes;
	std::vector<ModeCheckbox *> displayModes;
	std::vector<ModeCheckbox *> colourModes;
	String toolTip;
	ui::Fade toolTipPresence{ ui::Fade::LinearProfile{ 120.f, 60.f }, 0, 0 };
	bool isToolTipFadingIn;
	int line1, line2, line3, line4;
	uint32_t CalculateRenderMode();
public:
	RenderView();
	void NotifyRendererChanged(RenderModel * sender);
	void NotifySimulationChanged(RenderModel * sender);
	void NotifyRenderChanged(RenderModel * sender);
	void NotifyDisplayChanged(RenderModel * sender);
	void NotifyColourChanged(RenderModel * sender);
	void AttachController(RenderController * c_) { c = c_; }
	void OnMouseDown(int x, int y, unsigned button) override;
	void OnTryExit(ExitMethod method) override;
	void OnDraw() override;
	void OnTick() override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void ToolTip(ui::Point senderPosition, String toolTip) override;
	virtual ~RenderView();
};


=== src\gui\save\LocalSaveActivity.cpp ===

#include "LocalSaveActivity.h"

#include "client/Client.h"
#include "client/GameSave.h"
#include "client/ThumbnailRendererTask.h"
#include "common/platform/Platform.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include "gui/Style.h"

#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/interface/Button.h"
#include "gui/interface/Label.h"
#include "gui/interface/Textbox.h"

#include "Config.h"

LocalSaveActivity::LocalSaveActivity(std::unique_ptr<SaveFile> newSave, OnSaved onSaved_) :
	WindowActivity(ui::Point(-1, -1), ui::Point(220, 200)),
	save(std::move(newSave)),
	thumbnailRenderer(nullptr),
	onSaved(onSaved_)
{
	ui::Label * titleLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 16), "Save to computer:");
	titleLabel->SetTextColour(style::Colour::InformationTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);

	filenameField = new ui::Textbox(ui::Point(8, 25), ui::Point(Size.X-16, 16), save->GetDisplayName(), "[filename]");
	filenameField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	filenameField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	AddComponent(filenameField);
	FocusComponent(filenameField);

	ui::Button * cancelButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point(Size.X-75, 16), "Cancel");
	cancelButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	cancelButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	cancelButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
	cancelButton->SetActionCallback({ [this] {
		Exit();
	} });
	AddComponent(cancelButton);
	SetCancelButton(cancelButton);

	ui::Button * okayButton = new ui::Button(ui::Point(Size.X-76, Size.Y-16), ui::Point(76, 16), "Save");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.TextInactive = style::Colour::InformationTitle;
	okayButton->SetActionCallback({ [this] {
		Save();
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);

	if(save->GetGameSave())
	{
		thumbnailRenderer = new ThumbnailRendererTask(*save->GetGameSave(), Size - Vec2(16, 16), RendererSettings::decorationEnabled, false);
		thumbnailRenderer->Start();
	}
}

void LocalSaveActivity::OnTick()
{
	if (thumbnailRenderer)
	{
		thumbnailRenderer->Poll();
		if (thumbnailRenderer->GetDone())
		{
			thumbnail = thumbnailRenderer->Finish();
			thumbnailRenderer = nullptr;
		}
	}
}

void LocalSaveActivity::Save()
{
	if (filenameField->GetText().Contains('/') || filenameField->GetText().BeginsWith("."))
	{
		new ErrorMessage("Error", "Invalid filename.");
	}
	else if (filenameField->GetText().length())
	{
		ByteString finalFilename = ByteString::Build(LOCAL_SAVE_DIR, PATH_SEP_CHAR, filenameField->GetText().ToUtf8(), ".cps");
		save->SetDisplayName(filenameField->GetText());
		save->SetFileName(finalFilename);
		if (Platform::FileExists(finalFilename))
		{
			new ConfirmPrompt("Overwrite file", "Are you sure you wish to overwrite\n"+finalFilename.FromUtf8(), { [this, finalFilename] {
				saveWrite(finalFilename);
			} });
		}
		else
		{
			saveWrite(finalFilename);
		}
	}
	else
	{
		new ErrorMessage("Error", "You must specify a filename.");
	}
}

void LocalSaveActivity::saveWrite(ByteString finalFilename)
{
	Platform::MakeDirectory(LOCAL_SAVE_DIR);
	Json::Value localSaveInfo;
	localSaveInfo["type"] = "localsave";
	localSaveInfo["username"] = Client::Ref().GetAuthUser().Username;
	localSaveInfo["title"] = finalFilename;
	localSaveInfo["date"] = (Json::Value::UInt64)time(nullptr);
	Client::Ref().SaveAuthorInfo(&localSaveInfo);
	{
		auto gameSave = save->TakeGameSave();
		gameSave->authors = localSaveInfo;
		save->SetGameSave(std::move(gameSave));
	}
	std::vector<char> saveData;
	std::tie(std::ignore, saveData) = save->GetGameSave()->Serialise();
	if (saveData.size() == 0)
		new ErrorMessage("Error", "Unable to serialize game data.");
	else if (!Platform::WriteFile(saveData, finalFilename))
		new ErrorMessage("Error", "Unable to write save file.");
	else
	{
		if (onSaved)
		{
			onSaved(std::move(save));
		}
		Exit();
	}
}

void LocalSaveActivity::OnDraw()
{
	Graphics * g = GetGraphics();
	g->BlendRGBAImage(saveToDiskImage->data(), RectSized(Vec2(0, 0), saveToDiskImage->Size()));
	g->DrawFilledRect(RectSized(Position, Size).Inset(-1), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);

	if (thumbnail)
	{
		auto rect = RectSized(Position + Vec2((Size.X - thumbnail->Size().X) / 2, 45), thumbnail->Size());
		g->BlendImage(thumbnail->Data(), 0xFF, rect);
		g->DrawRect(rect, 0xB4B4B4_rgb);
	}
}

LocalSaveActivity::~LocalSaveActivity()
{
	if (thumbnailRenderer)
	{
		thumbnailRenderer->Abandon();
	}
}


=== src\gui\save\LocalSaveActivity.h ===

#pragma once

#include <functional>
#include <memory>
#include <vector>
#include "Activity.h"
#include "client/SaveFile.h"
#include "common/Plane.h"
#include "Format.h"
#include "graphics/Pixel.h"

#include "save_local_png.h"

namespace ui
{
	class Textbox;
}

class VideoBuffer;

class ThumbnailRendererTask;

class LocalSaveActivity: public WindowActivity
{
	using OnSaved = std::function<void (std::unique_ptr<SaveFile>)>;
	std::unique_ptr<PlaneAdapter<std::vector<pixel_rgba>>> saveToDiskImage = format::PixelsFromPNG(save_local_png.AsCharSpan());

	std::unique_ptr<SaveFile> save;
	ThumbnailRendererTask *thumbnailRenderer;
	std::unique_ptr<VideoBuffer> thumbnail;
	ui::Textbox * filenameField;
	OnSaved onSaved;

public:
	LocalSaveActivity(std::unique_ptr<SaveFile> newSave, OnSaved onSaved = nullptr);
	void saveWrite(ByteString finalFilename);
	void Save();
	void OnDraw() override;
	void OnTick() override;
	virtual ~LocalSaveActivity();
};


=== src\gui\save\meson.build ===

powder_files += files(
	'LocalSaveActivity.cpp',
	'ServerSaveActivity.cpp',
)


=== src\gui\save\ServerSaveActivity.cpp ===

#include "ServerSaveActivity.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include "gui/interface/Label.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/Button.h"
#include "gui/interface/Checkbox.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/dialogues/SaveIDMessage.h"
#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/dialogues/InformationMessage.h"
#include "client/Client.h"
#include "client/ThumbnailRendererTask.h"
#include "client/GameSave.h"
#include "client/http/UploadSaveRequest.h"
#include "tasks/Task.h"
#include "gui/Style.h"

class SaveUploadTask: public Task
{
	SaveInfo &save;

	void before() override
	{

	}

	void after() override
	{

	}

	bool doWork() override
	{
		notifyProgress(-1);
		auto uploadSaveRequest = std::make_unique<http::UploadSaveRequest>(save);
		uploadSaveRequest->Start();
		uploadSaveRequest->Wait();
		try
		{
			save.SetID(uploadSaveRequest->Finish());
		}
		catch (const http::RequestError &ex)
		{
			notifyError(ByteString(ex.what()).FromUtf8());
			return false;
		}
		return true;
	}

public:
	SaveUploadTask(SaveInfo &newSave):
		save(newSave)
	{

	}
};

ServerSaveActivity::ServerSaveActivity(std::unique_ptr<SaveInfo> newSave, OnUploaded onUploaded_) :
	WindowActivity(ui::Point(-1, -1), ui::Point(440, 200)),
	thumbnailRenderer(nullptr),
	save(std::move(newSave)),
	onUploaded(onUploaded_),
	saveUploadTask(nullptr)
{
	titleLabel = new ui::Label(ui::Point(4, 5), ui::Point((Size.X/2)-8, 16), "");
	titleLabel->SetTextColour(style::Colour::InformationTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);
	CheckName(save->GetName()); //set titleLabel text

	ui::Label * previewLabel = new ui::Label(ui::Point((Size.X/2)+4, 5), ui::Point((Size.X/2)-8, 16), "Preview:");
	previewLabel->SetTextColour(style::Colour::InformationTitle);
	previewLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	previewLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(previewLabel);

	nameField = new ui::Textbox(ui::Point(8, 25), ui::Point((Size.X/2)-16, 16), save->GetName(), "[save name]");
	nameField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	nameField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	nameField->SetActionCallback({ [this] { CheckName(nameField->GetText()); } });
	nameField->SetLimit(50);
	AddComponent(nameField);
	FocusComponent(nameField);

	descriptionField = new ui::Textbox(ui::Point(8, 65), ui::Point((Size.X/2)-16, Size.Y-(65+16+4)), save->GetDescription(), "[save description]");
	descriptionField->SetMultiline(true);
	descriptionField->SetLimit(254);
	descriptionField->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	descriptionField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	AddComponent(descriptionField);

	publishedCheckbox = new ui::Checkbox(ui::Point(8, 45), ui::Point((Size.X/2)-80, 16), "Publish", "");
	if(Client::Ref().GetAuthUser().Username != save->GetUserName())
	{
		//Save is not owned by the user, disable by default
		publishedCheckbox->SetChecked(false);
	}
	else
	{
		//Save belongs to the current user, use published state already set
		publishedCheckbox->SetChecked(save->GetPublished());
	}
	AddComponent(publishedCheckbox);

	pausedCheckbox = new ui::Checkbox(ui::Point(160, 45), ui::Point(55, 16), "Paused", "");
	pausedCheckbox->SetChecked(save->GetGameSave()->paused);
	AddComponent(pausedCheckbox);

	ui::Button * cancelButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point((Size.X/2)-75, 16), "Cancel");
	cancelButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	cancelButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	cancelButton->Appearance.BorderInactive = ui::Colour(200, 200, 200);
	cancelButton->SetActionCallback({ [this] {
		Exit();
	} });
	AddComponent(cancelButton);
	SetCancelButton(cancelButton);

	ui::Button * okayButton = new ui::Button(ui::Point((Size.X/2)-76, Size.Y-16), ui::Point(76, 16), "Save");
	okayButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	okayButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	okayButton->Appearance.TextInactive = style::Colour::InformationTitle;
	okayButton->SetActionCallback({ [this] {
		Save();
	} });
	AddComponent(okayButton);
	SetOkayButton(okayButton);

	ui::Button * PublishingInfoButton = new ui::Button(ui::Point((Size.X*3/4)-75, Size.Y-42), ui::Point(150, 16), "Publishing Info");
	PublishingInfoButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	PublishingInfoButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	PublishingInfoButton->Appearance.TextInactive = style::Colour::InformationTitle;
	PublishingInfoButton->SetActionCallback({ [this] {
		ShowPublishingInfo();
	} });
	AddComponent(PublishingInfoButton);

	ui::Button * RulesButton = new ui::Button(ui::Point((Size.X*3/4)-75, Size.Y-22), ui::Point(150, 16), "Save Uploading Rules");
	RulesButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	RulesButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	RulesButton->Appearance.TextInactive = style::Colour::InformationTitle;
	RulesButton->SetActionCallback({ [this] {
		ShowRules();
	} });
	AddComponent(RulesButton);

	if (save->GetGameSave())
	{
		thumbnailRenderer = new ThumbnailRendererTask(*save->GetGameSave(), Size / 2 - Vec2(16, 16), RendererSettings::decorationAntiClickbait, true);
		thumbnailRenderer->Start();
	}
}

ServerSaveActivity::ServerSaveActivity(std::unique_ptr<SaveInfo> newSave, bool saveNow, OnUploaded onUploaded_) :
	WindowActivity(ui::Point(-1, -1), ui::Point(200, 50)),
	thumbnailRenderer(nullptr),
	save(std::move(newSave)),
	onUploaded(onUploaded_),
	saveUploadTask(nullptr)
{
	ui::Label * titleLabel = new ui::Label(ui::Point(0, 0), Size, "Saving to server...");
	titleLabel->SetTextColour(style::Colour::InformationTitle);
	titleLabel->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	titleLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(titleLabel);

	AddAuthorInfo();

	saveUploadTask = new SaveUploadTask(*this->save);
	saveUploadTask->AddTaskListener(this);
	saveUploadTask->Start();
}

void ServerSaveActivity::NotifyDone(Task * task)
{
	if(!task->GetSuccess())
	{
		Exit();
		new ErrorMessage("Error", task->GetError());
	}
	else
	{
		if (onUploaded)
		{
			onUploaded(std::move(save));
		}
		Exit();
	}
}

void ServerSaveActivity::Save()
{
	if (!nameField->GetText().length())
	{
		new ErrorMessage("Error", "You must specify a save name.");
		return;
	}
	if(Client::Ref().GetAuthUser().Username != save->GetUserName() && publishedCheckbox->GetChecked())
	{
		new ConfirmPrompt("Publish", "This save was created by " + save->GetUserName().FromUtf8() + ", you're about to publish this under your own name; If you haven't been given permission by the author to do so, please uncheck the publish box, otherwise continue", { [this] {
			saveUpload();
		} });
	}
	else
	{
		saveUpload();
	}
}

void ServerSaveActivity::AddAuthorInfo()
{
	Json::Value serverSaveInfo;
	serverSaveInfo["type"] = "save";
	serverSaveInfo["id"] = save->GetID();
	serverSaveInfo["username"] = Client::Ref().GetAuthUser().Username;
	serverSaveInfo["title"] = save->GetName().ToUtf8();
	serverSaveInfo["description"] = save->GetDescription().ToUtf8();
	serverSaveInfo["published"] = (int)save->GetPublished();
	serverSaveInfo["date"] = (Json::Value::UInt64)time(nullptr);
	Client::Ref().SaveAuthorInfo(&serverSaveInfo);
	{
		auto gameSave = save->TakeGameSave();
		gameSave->authors = serverSaveInfo;
		save->SetGameSave(std::move(gameSave));
	}
}

void ServerSaveActivity::saveUpload()
{
	okayButton->Enabled = false;
	save->SetName(nameField->GetText());
	save->SetDescription(descriptionField->GetText());
	save->SetPublished(publishedCheckbox->GetChecked());
	save->SetUserName(Client::Ref().GetAuthUser().Username);
	save->SetID(0);
	{
		auto gameSave = save->TakeGameSave();
		gameSave->paused = pausedCheckbox->GetChecked();
		save->SetGameSave(std::move(gameSave));
	}
	AddAuthorInfo();
	uploadSaveRequest = std::make_unique<http::UploadSaveRequest>(*save);
	uploadSaveRequest->Start();
}

void ServerSaveActivity::Exit()
{
	WindowActivity::Exit();
}

void ServerSaveActivity::ShowPublishingInfo()
{
	String info =
		"In The Powder Toy, one can save simulations to their account in two privacy levels: Published and unpublished. You can choose which one by checking or unchecking the 'publish' checkbox. Saves are unpublished by default, so if you do not check publish nobody will be able to see your saves.\n"
		"\n"
		"\btPublished saves\bw will appear on the 'By Date' feed and will be seen by many people. These saves also contribute to your Average Score, which is displayed publicly on your profile page on the website. Publish saves that you want people to see so they can comment and vote on.\n"
		"\btUnpublished saves\bw will not be shown on the 'By Date' feed. These will not contribute to your Average Score. They are not completely private though, as anyone who knows the save id will be able to view it. You can give the save id out to show specific people the save but not allow just everyone to see it.\n"
		"\n"
		"To quickly resave a save, open it and click the left side of the split resave button to \bt'Reupload the current simulation'\bw. If you want to change the description or change the published status, you can click the right side to \bt'Modify simulation properties'\bw. Note that you can't change the name of saves; this will create an entirely new save with no comments, votes, or tags; separate from the original.\n"
		"You may want to publish an unpublished save after it is finished, or to unpublish some currently published ones. You can do this by opening the save, selecting the 'Modify simulation properties' button, and changing the published status there. You can also \btunpublish or delete saves\bw by selecting them in the 'my own' section of the browser and clicking either one of the buttons that appear on bottom.\n"
		"If a save is under a week old and gains popularity fast, it will be automatically placed on the \btfront page\bw. Only published saves will be able to get here. Moderators can also choose to promote any save onto the front page, but this happens rarely. They can also demote any save from the front page that breaks a rule or they feel doesn't belong.\n"
		"Once you make a save, you can resave it as many times as you want. A short previous \btsave history\bw is saved, just right click any save in the save browser and select 'View History' to view it. This is useful for when you accidentally save something you didn't mean to and want to go back to the old version.\n"
		;

	new InformationMessage("Publishing Info", info, true);
}

void ServerSaveActivity::ShowRules()
{
	String rules =
		"\boSection S: Social and Community Rules\n"
		"\bwThere are a few rules you should follow while interacting with the community. These rules are enforced by staff members and any issues related to violations of these rules may be brought to our attention by users. This section applies to saves uploaded, comments area, forums, and other areas of the community.\n"
		"\n"
		"\bt1. Try to use proper grammar.\bw English is the official community language, but use is not required in regional or cultural groups. If you cannot write English well, we advise that you use Google Translate.\n"
		"\bt2. Do not spam.\bw There's not a one size fits all definition here, but the idea is usually obvious. In addition, the following are seen as spam and may be hidden or deleted:\n"
		   "- Posting multiple threads on the same subject. Try to combine threads on game feedback or suggestions into one thread.\n"
		   "- Bumping an old thread by replying. This is what we call 'necro' or 'necroing'. The content of the thread may be stale (fixing issues, ideas, etc). We recommend posting a new thread for an updated or more current response.\n"
		   "- Posting on a thread with '+1' or other short replies. There's no need to constantly bump a thread and make finding replies difficult. Replies are great for constructive feedback, while the '+1' button is to show your support for the content.\n"
		   "- Comments that are excessively long or gibberish. Making comments such as repeating the same letter or have little to no intended purpose, fall under this rule. Comments that are in a different language are exempt.\n"
		   "- Excessive formatting. UPPERCASE, Bold, and italics can be nice with moderate use, but please do not use them throughout the entire post.\n"
		"\bt3. Keep swearing to a minimum.\bw Comments or saves containing swearing are at risk of being deleted. This also includes swearing in other languages.\n"
		"\bt4. Refrain from uploading sexually explicit, offensive, or other inappropriate materials.\bw\n"
		   "- These include, but are not limited to: sex, drugs, racism, excessive politics, or anything that offends or insults a group of people.\n"
		   "- Reference to these topics in other languages is also prohibited. Do not attempt to bypass this rule.\n"
		   "- Posting URLs or images that violate this rule is prohibited. This includes links or text in your profile information.\n"
		"\bt5. Do not advertise third-party games, sites, or other places not related to The Powder Toy.\bw\n"
		   "- Mainly this rule is intended to prevent people going through and advertising their own games and products.\n"
		   "- Unauthorized or unofficial community gathering places, such as Discord, are prohibited.\n"
		"\bt6. Trolling is not allowed.\bw As with some rules, there's no clear definition. Users who repeatedly troll are far more likely to be banned and receive longer bans than others.\n"
		"\bt7. Do not impersonate anyone.\bw Registering accounts with names intentionally similar to other users in our community or other online communities is prohibited.\n"
		"\bt8. Do not post about moderator decisions or issues.\bw If there is a problem regarding a ban on your account or content removal, please contact a moderator through the messages system. Otherwise, discussion about moderator actions should be avoided.\n"
		"\bt9. Avoid backseat moderating.\bw Moderators are the ones who make the decisions. Users should refrain from threatening bans or possible results from breaking a rule. If there is a possible issue or you are unsure, we recommend reporting the issue through the 'Report' button or via the messaging system on the website.\n"
		"\bt10. Condoning of breaking common laws is prohibited.\bw The jurisdiction of which country's laws applies is not clear, but there are some common ones to know. These include, but not limited to:\n"
		   "- Piracy of software, music, bagels, etc.\n"
		   "- Hacking / Stealing accounts\n"
		   "- Theft / Fraud\n"
		"\bt11. Do not stalk or harass any user.\bw This has been a growing problem in recent years by different methods, but generally these include:\n"
		   "- 'Doxing' user(s) to find where they live or their real identity\n"
		   "- Constantly messaging a user when they wish to refrain from any contact\n"
		   "- Mass downvoting saves\n"
		   "- Posting rude or unnecessary comments on someone's content (saves, forum threads, etc)\n"
		   "- Coercing a group of users to 'target' a user\n"
		   "- Personal arguments or hatred. This could be arguing in the comments or making hate saves\n"
		   "- Discrimination, in general, of people. This could be religious, ethnic, etc.\n"
		"\n"
		"\boSection G: In-Game Rules\n"
		"\bwThis section of the rules is focused on in-game actions. Though, Section S also applies in-game, the following rules are more specialized to in-game community interaction.\n"
		"\bt1. Don't claim other people's work.\bw This could be simply re-uploading another user's or utilizing large sections of saves. Derivative works are allowed, with proper usage. Should you utilize someone's work, by default you must credit the author. Unless the author has explicitly noted different usage terms, this is the standard policy. Derivative works are characterized by innovative usage and originality percentage (ie. how much is original versus someone's work?). Stolen saves will be unpublished or disabled.\n"
		"\bt2. Self-voting or vote fraud is not allowed.\bw This is defined as making multiple accounts to vote on your own saves or the saves of others. We enforce this rule strictly, therefore, you must understand that there are very few successful ban appeals. Please ensure you and other accounts are not voting from the same household. All alternate accounts will be permanently banned, the main account will be temporarily banned and any affected saves will be disabaled.\n"
		"\bt3. Asking for votes of any kind is frowned upon.\bw Saves which do this will be unpublished until the issue is fixed. Examples of such that are under this rules are:\n"
		   "- Signs that may hint at voting up or down. The signature green arrow or asking for votes goes under this rule.\n"
		   "- Gimmicks that ask for votes. These might be a total number of votes in exchange for something, like '100 votes and I'll make a better version'. This is what we define as vote farming. Any type of vote farming is not allowed.\n"
		   "- Asking for votes in return for usage of a save or for any other reason is prohibited.\n"
		"\bt4. Do not spam.\bw As mentioned earlier, there are no standards for what counts as spam. Here are some examples that may qualify as spamming:\n"
		   "- Uploading or re-uploading similar saves within a short amount of time. Don't try to circumvent the system to have your saves seen/voted by people. This includes uploading 'junk' or 'blank' saves with little to no purpose. These saves will be unpublished.\n"
		   "- Uploading text-only saves. These may be announcements or looking for help of sorts. We have the forums and comments area available for many purposes these text-only saves would serve. These saves will be removed from front page.\n"
		   "- Uploading art saves is not strictly prohibited, but may result in a front-page demotion. We like to see usage of the variety of elements in a creative manner. Lack of these factors (such as in deco-only saves) will typically result in a front-page demotion\n"
		"\bt5. Refrain from uploading sexually explicit or other inappropriate materials. These saves will be deleted and will lead to a ban.\bw\n"
		   "- These include, but are not limited to: sex, drugs, racism, excessive politics, or anything that offends or insults a group of people.\n"
		   "- Don't try to circumvent this rule. Anything that intentionally refers to these concepts/ideas by direct or indirect means falls under this rule.\n"
		   "- Reference to these topics in other languages is also prohibited. Do not attempt to bypass this rule.\n"
		   "- Posting URLs or images that violate this rule is prohibited. This includes links or text in your profile information.\n"
		"\bt6. Image plotting is strictly prohibited.\bw This includes usage of scripting or any third-party tools to plot or create a save for you. Saves using CGI will be deleted and you may receive a ban.\n"
		"\bt7. Keep logos and signs to a minimum.\bw These saves may be removed from front page. Items that this rule restricts are:\n"
		   "- Excessive logos placed\n"
		   "- Signs without intended purpose\n"
		   "- Fake update or notifications signs\n"
		   "- Linking other saves that have no related purposes\n"
		"\bt8. Do not place offtopic or inappropriate tags.\bw Tags are only there to improve search results. They should generally only be one word descriptions of the save. Sentences or subjective tags may be deleted. Inappropriate or offensive tags will likely get you banned.\n"
		"\bt9. Intentional lag inducing or crashing saves are prohibited.\bw If the majority of users are writing about the save causing crashes or lag, then the save will fall under this rule. These saves will be removed from front page or disabled.\n"
		"\bt10. Do not misuse the reporting system.\bw Sending in report reasons such as 'bad save' or gibberish wastes our time. Unless the issue pertains to a possible rule violation or community issue, please refrain from sending a report. If you think the save violates or poses a community issue, send a report anyway! Bans will never happen if you are reporting a save in good faith.\n"
		"\bt11. Do not ask for saves to be demoted or removed from the front-page.\bw Unless the save violates any rules, it will stay on the front-page. There is no exception to this rule for art saves, please do not report art either.\n"
		"\n"
		"\boSection R: Other\n"
		"\bwModerators may interpret these rules as they see fit. Not all rules are equal, some are enforced less than others. Moderators make the final decision on what is and isn't against the rules, but we have made our best effort here to cover all unwanted behavior here. Notice will be posted in this thread whenever the rules are updated.\n"
		"\n"
		"Violation of these rules may result in removal of posts / comments, unpublishing or disabling saves, removing saves from front page, or in more extreme cases, a temporary or permanent ban. There are various manual and automated measures in place to enforce these rules. The severity and resulting decisions may not be consistent between moderators.\n"
		"\n"
		"If you have any questions about what is and isn't against the rules, feel free to contact a moderator.";

	new InformationMessage("Save Uploading Rules", rules, true);
}

void ServerSaveActivity::CheckName(String newname)
{
	if (newname.length() && newname == save->GetName() && save->GetUserName() == Client::Ref().GetAuthUser().Username)
		titleLabel->SetText("Modify simulation properties:");
	else
		titleLabel->SetText("Upload new simulation:");
}

void ServerSaveActivity::OnTick()
{
	if (thumbnailRenderer)
	{
		thumbnailRenderer->Poll();
		if (thumbnailRenderer->GetDone())
		{
			thumbnail = thumbnailRenderer->Finish();
			thumbnailRenderer = nullptr;
		}
	}

	if (uploadSaveRequest && uploadSaveRequest->CheckDone())
	{
		okayButton->Enabled = true;
		try
		{
			save->SetID(uploadSaveRequest->Finish());
			Exit();
			new SaveIDMessage(save->GetID());
			if (onUploaded)
			{
				onUploaded(std::move(save));
			}
		}
		catch (const http::RequestError &ex)
		{
			new ErrorMessage("Error", "Upload failed with error:\n" + ByteString(ex.what()).FromUtf8());
		}
		uploadSaveRequest.reset();
	}

	if(saveUploadTask)
		saveUploadTask->Poll();
}

void ServerSaveActivity::OnDraw()
{
	Graphics * g = GetGraphics();
	g->BlendRGBAImage(saveToServerImage->data(), RectSized(Vec2(-10, 0), saveToServerImage->Size()));
	g->DrawFilledRect(RectSized(Position, Size).Inset(-1), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);

	if (Size.X > 220)
		g->DrawLine(Position + Vec2(Size.X / 2 - 1, 0), Position + Vec2(Size.X / 2 - 1, Size.Y - 1), 0xFFFFFF_rgb);

	if (thumbnail)
	{
		auto rect = RectSized(Position + Vec2(Size.X / 2 + (Size.X / 2 - thumbnail->Size().X) / 2, 25), thumbnail->Size());
		g->BlendImage(thumbnail->Data(), 0xFF, rect);
		g->DrawRect(rect, 0xB4B4B4_rgb);
	}
}

ServerSaveActivity::~ServerSaveActivity()
{
	if (thumbnailRenderer)
	{
		thumbnailRenderer->Abandon();
	}
	delete saveUploadTask;
}


=== src\gui\save\ServerSaveActivity.h ===

#pragma once

#include <functional>
#include <memory>
#include <vector>

#include "Activity.h"
#include "client/SaveInfo.h"
#include "common/Plane.h"
#include "Format.h"
#include "graphics/Pixel.h"
#include "tasks/TaskListener.h"

#include "save_online_png.h"

namespace http
{
	class UploadSaveRequest;
}

namespace ui
{
	class Label;
	class Textbox;
	class Checkbox;
}

class ThumbnailRendererTask;
class Task;
class VideoBuffer;
class ServerSaveActivity: public WindowActivity, public TaskListener
{
	std::unique_ptr<http::UploadSaveRequest> uploadSaveRequest;

	using OnUploaded = std::function<void (std::unique_ptr<SaveInfo>)>;
	std::unique_ptr<PlaneAdapter<std::vector<pixel_rgba>>> saveToServerImage = format::PixelsFromPNG(save_online_png.AsCharSpan());

public:
	ServerSaveActivity(std::unique_ptr<SaveInfo> newSave, OnUploaded onUploaded);
	ServerSaveActivity(std::unique_ptr<SaveInfo> newSave, bool saveNow, OnUploaded onUploaded);
	void saveUpload();
	void Save();
	virtual void Exit() override;
	void ShowPublishingInfo();
	void ShowRules();
	void CheckName(String newname);
	virtual void OnDraw() override;
	virtual void OnTick() override;
	virtual ~ServerSaveActivity();
protected:
	void AddAuthorInfo();
	void NotifyDone(Task * task) override;
	ThumbnailRendererTask *thumbnailRenderer;
	std::unique_ptr<VideoBuffer> thumbnail;
	std::unique_ptr<SaveInfo> save;
private:
	OnUploaded onUploaded;
protected:
	Task * saveUploadTask;
	ui::Label * titleLabel;
	ui::Textbox * nameField;
	ui::Textbox * descriptionField;
	ui::Checkbox * publishedCheckbox;
	ui::Checkbox * pausedCheckbox;
};


=== src\gui\search\meson.build ===

powder_files += files(
	'SearchController.cpp',
	'SearchModel.cpp',
	'SearchView.cpp',
)


=== src\gui\search\SearchController.cpp ===

#include "SearchController.h"

#include "Controller.h"
#include "SearchModel.h"
#include "SearchView.h"

#include "client/Client.h"
#include "client/SaveInfo.h"
#include "client/GameSave.h"
#include "client/http/DeleteSaveRequest.h"
#include "client/http/PublishSaveRequest.h"
#include "client/http/UnpublishSaveRequest.h"
#include "client/http/FavouriteSaveRequest.h"
#include "client/http/SearchSavesRequest.h"
#include "client/http/SearchTagsRequest.h"
#include "common/platform/Platform.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include "tasks/Task.h"
#include "tasks/TaskWindow.h"

#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/preview/PreviewController.h"
#include "gui/preview/PreviewView.h"
#include "SimulationConfig.h"
#include <algorithm>

SearchController::SearchController(std::function<void ()> onDone_):
	activePreview(nullptr),
	nextQueryTime(0.0f),
	nextQueryDone(true),
	instantOpen(false),
	doRefresh(false),
	HasExited(false)
{
	searchModel = new SearchModel();
	searchView = new SearchView();
	searchModel->AddObserver(searchView);
	searchView->AttachController(this);

	searchModel->UpdateSaveList(1, "");

	onDone = onDone_;
}

const SaveInfo *SearchController::GetLoadedSave() const
{
	return searchModel->GetLoadedSave();
}

std::unique_ptr<SaveInfo> SearchController::TakeLoadedSave()
{
	return searchModel->TakeLoadedSave();
}

void SearchController::Update()
{
	if (doRefresh)
	{
		if (searchModel->UpdateSaveList(searchModel->GetPageNum(), searchModel->GetLastQuery()))
		{
			nextQueryDone = true;
			doRefresh = false;
		}
	}
	else if (!nextQueryDone && nextQueryTime < Platform::GetTime())
	{
		if (searchModel->UpdateSaveList(1, nextQuery))
			nextQueryDone = true;
	}
	searchModel->Update();
	if(activePreview && activePreview->HasExited)
	{
		delete activePreview;
		activePreview = nullptr;
		if(searchModel->GetLoadedSave())
		{
			Exit();
		}
	}
}

void SearchController::Exit()
{
	InstantOpen(false);
	searchView->CloseActiveWindow();
	if (onDone)
		onDone();
	//HasExited = true;
}

SearchController::~SearchController()
{
	delete activePreview;
	delete searchModel;
	searchView->CloseActiveWindow();
	delete searchView;
}

void SearchController::DoSearch(String query, bool now)
{
	nextQuery = query;
	if (!now)
	{
		nextQueryTime = Platform::GetTime()+600;
		nextQueryDone = false;
	}
	else
	{
		nextQueryDone = searchModel->UpdateSaveList(1, nextQuery);
	}
}

void SearchController::DoSearch2(String query)
{
	// calls SearchView function to set textbox text, then calls DoSearch
	searchView->Search(query);
}

void SearchController::Refresh()
{
	doRefresh = true;
}

void SearchController::SetPage(int page)
{
	if (page != searchModel->GetPageNum() && page > 0 && page <= searchModel->GetPageCount())
		searchModel->UpdateSaveList(page, searchModel->GetLastQuery());
}

void SearchController::SetPageRelative(int offset)
{
	int page = std::min(std::max(searchModel->GetPageNum() + offset, 1), searchModel->GetPageCount());
	if (page != searchModel->GetPageNum())
		searchModel->UpdateSaveList(page, searchModel->GetLastQuery());
}

void SearchController::ChangePeriod(int period)
{
	switch(period)
	{
		case 0:
			searchModel->SetPeriod(http::allSaves);
			break;
		case 1:
			searchModel->SetPeriod(http::todaySaves);
			break;
		case 2:
			searchModel->SetPeriod(http::weekSaves);
			break;
		case 3:
			searchModel->SetPeriod(http::monthSaves);
			break;
		case 4:
			searchModel->SetPeriod(http::yearSaves);
			break;
		default:
			searchModel->SetPeriod(http::allSaves);
	}

	searchModel->UpdateSaveList(1, searchModel->GetLastQuery());
}

void SearchController::ChangeSort()
{
	if(searchModel->GetSort() == http::sortByDate)
	{
		searchModel->SetSort(http::sortByVotes);
	}
	else
	{
		searchModel->SetSort(http::sortByDate);
	}
	searchModel->UpdateSaveList(1, searchModel->GetLastQuery());
}

void SearchController::ShowOwn(bool show)
{
	if(Client::Ref().GetAuthUser().UserID)
	{
		searchModel->SetShowFavourite(false);
		searchModel->SetShowOwn(show);
	}
	else
		searchModel->SetShowOwn(false);
	searchModel->UpdateSaveList(1, searchModel->GetLastQuery());
}

void SearchController::ShowFavourite(bool show)
{
	if(Client::Ref().GetAuthUser().UserID)
	{
		searchModel->SetShowOwn(false);
		searchModel->SetShowFavourite(show);
	}
	else
		searchModel->SetShowFavourite(false);
	searchModel->UpdateSaveList(1, searchModel->GetLastQuery());
}

void SearchController::Selected(int saveID, bool selected)
{
	if(!Client::Ref().GetAuthUser().UserID)
		return;

	if(selected)
		searchModel->SelectSave(saveID);
	else
		searchModel->DeselectSave(saveID);
}

void SearchController::SelectAllSaves() 
{
	if (!Client::Ref().GetAuthUser().UserID)
		return;
	if (searchModel->GetShowOwn() || 
		Client::Ref().GetAuthUser().UserElevation == User::ElevationMod || 
		Client::Ref().GetAuthUser().UserElevation == User::ElevationAdmin)
		searchModel->SelectAllSaves();

}

void SearchController::InstantOpen(bool instant)
{
	instantOpen = instant;
}

void SearchController::OpenSaveDone()
{
	if (activePreview->GetDoOpen() && activePreview->GetSaveInfo())
	{
		searchModel->SetLoadedSave(activePreview->TakeSaveInfo());
	}
	else
	{
		searchModel->SetLoadedSave(nullptr);
	}
}

void SearchController::OpenSave(int saveID, int saveDate, std::unique_ptr<VideoBuffer> thumbnail)
{
	delete activePreview;
	Graphics * g = searchView->GetGraphics();
	g->BlendFilledRect(RectSized(Vec2{ XRES/3, WINDOWH-20 }, Vec2{ XRES/3, 20 }), 0x000000_rgb .WithAlpha(150)); //dim the "Page X of Y" a little to make the CopyTextButton more noticeable
	activePreview = new PreviewController(saveID, saveDate, instantOpen ? savePreviewInstant : savePreviewNormal, [this] { OpenSaveDone(); }, std::move(thumbnail));
	activePreview->GetView()->MakeActiveWindow();
}

void SearchController::ClearSelection()
{
	searchModel->ClearSelected();
}

void SearchController::RemoveSelected()
{
	StringBuilder desc;
	desc << "Are you sure you want to delete " << searchModel->GetSelected().size() << " save";
	if(searchModel->GetSelected().size()>1)
		desc << "s";
	desc << "?";
	new ConfirmPrompt("Delete saves", desc.Build(), { [this] {
		removeSelectedC();
	} });
}

void SearchController::removeSelectedC()
{
	class RemoveSavesTask : public Task
	{
		SearchController *c;
		std::vector<int> saves;
	public:
		RemoveSavesTask(std::vector<int> saves_, SearchController *c_) { saves = saves_; c = c_; }
		bool doWork() override
		{
			for (size_t i = 0; i < saves.size(); i++)
			{
				notifyStatus(String::Build("Deleting save [", saves[i], "] ..."));
				auto deleteSaveRequest = std::make_unique<http::DeleteSaveRequest>(saves[i]);
				deleteSaveRequest->Start();
				deleteSaveRequest->Wait();
				try
				{
					deleteSaveRequest->Finish();
				}
				catch (const http::RequestError &ex)
				{
					notifyError(String::Build("Failed to delete [", saves[i], "]: ", ByteString(ex.what()).FromAscii()));
					c->Refresh();
					return false;
				}
				notifyProgress((i + 1) * 100 / saves.size());
			}
			c->Refresh();
			return true;
		}
	};

	std::vector<int> selected = searchModel->GetSelected();
	new TaskWindow("Removing saves", new RemoveSavesTask(selected, this));
	ClearSelection();
	searchModel->UpdateSaveList(searchModel->GetPageNum(), searchModel->GetLastQuery());
}

void SearchController::UnpublishSelected(bool publish)
{
	StringBuilder desc;
	desc << "Are you sure you want to " << (publish ? String("publish ") : String("unpublish ")) << searchModel->GetSelected().size() << " save";
	if (searchModel->GetSelected().size() > 1)
		desc << "s";
	desc << "?";
	new ConfirmPrompt(publish ? String("Publish Saves") : String("Unpublish Saves"), desc.Build(), { [this, publish] {
		unpublishSelectedC(publish);
	} });
}

void SearchController::unpublishSelectedC(bool publish)
{
	class UnpublishSavesTask : public Task
	{
		std::vector<int> saves;
		SearchController *c;
		bool publish;
	public:
		UnpublishSavesTask(std::vector<int> saves_, SearchController *c_, bool publish_) { saves = saves_; c = c_; publish = publish_; }

		void PublishSave(int saveID)
		{
			notifyStatus(String::Build("Publishing save [", saveID, "]"));
			auto publishSaveRequest = std::make_unique<http::PublishSaveRequest>(saveID);
			publishSaveRequest->Start();
			publishSaveRequest->Wait();
			publishSaveRequest->Finish();
		}

		void UnpublishSave(int saveID)
		{
			notifyStatus(String::Build("Unpublishing save [", saveID, "]"));
			auto unpublishSaveRequest = std::make_unique<http::UnpublishSaveRequest>(saveID);
			unpublishSaveRequest->Start();
			unpublishSaveRequest->Wait();
			unpublishSaveRequest->Finish();
		}

		bool doWork() override
		{
			for (size_t i = 0; i < saves.size(); i++)
			{
				try
				{
					if (publish)
					{
						PublishSave(saves[i]);
					}
					else
					{
						UnpublishSave(saves[i]);
					}
				}
				catch (const http::RequestError &ex)
				{
					if (publish) // uses html page so error message will be spam
					{
						notifyError(String::Build("Failed to publish [", saves[i], "], is this save yours?"));
					}
					else
					{
						notifyError(String::Build("Failed to unpublish [", saves[i], "]: ", ByteString(ex.what()).FromAscii()));
					}
					c->Refresh();
					return false;
				}
				notifyProgress((i + 1) * 100 / saves.size());
			}
			c->Refresh();
			return true;
		}
	};

	std::vector<int> selected = searchModel->GetSelected();
	new TaskWindow(publish ? String("Publishing Saves") : String("Unpublishing Saves"), new UnpublishSavesTask(selected, this, publish));
}

void SearchController::FavouriteSelected()
{
	class FavouriteSavesTask : public Task
	{
		std::vector<int> saves;
	public:
		FavouriteSavesTask(std::vector<int> saves_) { saves = saves_; }
		bool doWork() override
		{
			for (size_t i = 0; i < saves.size(); i++)
			{
				notifyStatus(String::Build("Favouring save [", saves[i], "]"));
				auto favouriteSaveRequest = std::make_unique<http::FavouriteSaveRequest>(saves[i], true);
				favouriteSaveRequest->Start();
				favouriteSaveRequest->Wait();
				try
				{
					favouriteSaveRequest->Finish();
				}
				catch (const http::RequestError &ex)
				{
					notifyError(String::Build("Failed to favourite [", saves[i], "]: ", ByteString(ex.what()).FromAscii()));
					return false;
				}
				notifyProgress((i + 1) * 100 / saves.size());
			}
			return true;
		}
	};

	class UnfavouriteSavesTask : public Task
	{
		std::vector<int> saves;
	public:
		UnfavouriteSavesTask(std::vector<int> saves_) { saves = saves_; }
		bool doWork() override
		{
			for (size_t i = 0; i < saves.size(); i++)
			{
				notifyStatus(String::Build("Unfavouring save [", saves[i], "]"));
				auto unfavouriteSaveRequest = std::make_unique<http::FavouriteSaveRequest>(saves[i], false);
				unfavouriteSaveRequest->Start();
				unfavouriteSaveRequest->Wait();
				try
				{
					unfavouriteSaveRequest->Finish();
				}
				catch (const http::RequestError &ex)
				{
					notifyError(String::Build("Failed to unfavourite [", saves[i], "]: ", ByteString(ex.what()).FromAscii()));
					return false;
				}
				notifyProgress((i + 1) * 100 / saves.size());
			}
			return true;
		}
	};

	std::vector<int> selected = searchModel->GetSelected();
	if (!searchModel->GetShowFavourite())
		new TaskWindow("Favouring saves", new FavouriteSavesTask(selected));
	else
		new TaskWindow("Unfavouring saves", new UnfavouriteSavesTask(selected));
	ClearSelection();
}


=== src\gui\search\SearchController.h ===

#pragma once
#include "common/String.h"
#include <functional>
#include <memory>

class SaveInfo;
class PreviewController;
class PreviewController;
class SearchView;
class SearchModel;
class VideoBuffer;
class SearchController
{
private:
	SearchModel * searchModel;
	SearchView * searchView;
	PreviewController * activePreview;
	std::function<void ()> onDone;

	double nextQueryTime;
	String nextQuery;
	bool nextQueryDone;
	bool instantOpen;
	bool doRefresh;
	void removeSelectedC();
	void unpublishSelectedC(bool publish);

	void OpenSaveDone();
public:
	bool HasExited;
	SearchController(std::function<void ()> onDone = nullptr);
	~SearchController();
	SearchView * GetView() { return searchView; }
	void Exit();
	void DoSearch(String query, bool now = false);
	void DoSearch2(String query);
	void Refresh();
	void SetPage(int page);
	void SetPageRelative(int offset);
	void ChangePeriod(int period);
	void ChangeSort();
	void ShowOwn(bool show);
	void ShowFavourite(bool show);
	void Selected(int saveID, bool selected);
	void SelectAllSaves();
	void InstantOpen(bool instant);
	void OpenSave(int saveID, int saveDate, std::unique_ptr<VideoBuffer> thumbnail);
	void Update();
	void ClearSelection();
	void RemoveSelected();
	void UnpublishSelected(bool publish);
	void FavouriteSelected();
	const SaveInfo *GetLoadedSave() const;
	std::unique_ptr<SaveInfo> TakeLoadedSave();
};


=== src\gui\search\SearchModel.cpp ===

#include "SearchModel.h"
#include "SearchView.h"
#include "Format.h"
#include "client/SaveInfo.h"
#include "client/GameSave.h"
#include "client/Client.h"
#include "client/http/SearchSavesRequest.h"
#include "client/http/SearchTagsRequest.h"
#include <algorithm>
#include <thread>
#include <cmath>

SearchModel::SearchModel():
	currentPeriod(http::allSaves),
	currentSort(http::sortByVotes),
	currentPage(1),
	resultCount(0),
	showOwn(false),
	showFavourite(false),
	showTags(true)
{
}

void SearchModel::SetShowTags(bool show)
{
	showTags = show;
}

bool SearchModel::GetShowTags()
{
	return showTags;
}

void SearchModel::BeginSearchSaves(int start, int count, String query, http::Period period, http::Sort sort, http::Category category)
{
	lastError = "";
	resultCount = 0;
	searchSaves = std::make_unique<http::SearchSavesRequest>(start, count, query.ToUtf8(), period, sort, category);
	searchSaves->Start();
}

std::vector<std::unique_ptr<SaveInfo>> SearchModel::EndSearchSaves()
{
	std::vector<std::unique_ptr<SaveInfo>> saveArray;
	try
	{
		std::tie(resultCount, saveArray) = searchSaves->Finish();
	}
	catch (const http::RequestError &ex)
	{
		lastError = ByteString(ex.what()).FromUtf8();
	}
	searchSaves.reset();
	return saveArray;
}

void SearchModel::BeginGetTags(int start, int count, String query)
{
	lastError = "";
	ByteStringBuilder urlStream;
	urlStream << SERVER << "/Browse/Tags.json?Start=" << start << "&Count=" << count;
	if(query.length())
	{
		urlStream << "&Search_Query=";
		if(query.length())
			urlStream << format::URLEncode(query.ToUtf8());
	}
	getTags = std::make_unique<http::SearchTagsRequest>(start, count, query.ToUtf8());
	getTags->Start();
}

std::vector<std::pair<ByteString, int>> SearchModel::EndGetTags()
{
	std::vector<std::pair<ByteString, int>> tagArray;
	try
	{
		tagArray = getTags->Finish();
	}
	catch (const http::RequestError &ex)
	{
		lastError = ByteString(ex.what()).FromUtf8();
	}
	getTags.reset();
	return tagArray;
}

bool SearchModel::UpdateSaveList(int pageNumber, String query)
{
	//Threading
	if (!searchSaves)
	{
		lastQuery = query;
		lastError = "";
		saveListLoaded = false;
		saveList.clear();
		//resultCount = 0;
		currentPage = pageNumber;

		if(pageNumber == 1 && !showOwn && !showFavourite && currentPeriod == http::allSaves && currentSort == http::sortByVotes && query == "")
			SetShowTags(true);
		else
			SetShowTags(false);

		notifySaveListChanged();
		notifyTagListChanged();
		notifyPageChanged();
		selected.clear();
		notifySelectedChanged();

		if (GetShowTags() && !tagList.size() && !getTags)
		{
			BeginGetTags(0, 24, "");
		}

		auto category = http::categoryNone;
		if (showFavourite)
		{
			category = http::categoryFavourites;
		}
		if (showOwn && Client::Ref().GetAuthUser().UserID)
		{
			category = http::categoryMyOwn;
		}
		BeginSearchSaves((currentPage-1)*20, 20, lastQuery, currentPeriod, currentSort, category);
		return true;
	}
	return false;
}

void SearchModel::SetLoadedSave(std::unique_ptr<SaveInfo> save)
{
	loadedSave = std::move(save);
}

const SaveInfo *SearchModel::GetLoadedSave() const
{
	return loadedSave.get();
}

std::unique_ptr<SaveInfo> SearchModel::TakeLoadedSave()
{
	return std::move(loadedSave);
}

std::vector<SaveInfo *> SearchModel::GetSaveList() // non-owning
{
	std::vector<SaveInfo *> nonOwningSaveList;
	std::transform(saveList.begin(), saveList.end(), std::back_inserter(nonOwningSaveList), [](auto &ptr) {
		return ptr.get();
	});
	return nonOwningSaveList;
}

std::vector<std::pair<ByteString, int> > SearchModel::GetTagList()
{
	return tagList;
}

void SearchModel::Update()
{
	if (searchSaves && searchSaves->CheckDone())
	{
		saveListLoaded = true;
		lastError = "";
		saveList = EndSearchSaves();
		notifyPageChanged();
		notifySaveListChanged();
	}
	if (getTags && getTags->CheckDone())
	{
		lastError = "";
		tagList = EndGetTags();
		notifyTagListChanged();
	}
}

void SearchModel::AddObserver(SearchView * observer)
{
	observers.push_back(observer);
	observer->NotifySaveListChanged(this);
	observer->NotifyPageChanged(this);
	observer->NotifyPeriodChanged(this);
	observer->NotifySortChanged(this);
	observer->NotifyShowOwnChanged(this);
	observer->NotifyTagListChanged(this);
}

void SearchModel::SelectSave(int saveID)
{
	for (size_t i = 0; i < selected.size(); i++)
	{
		if (selected[i] == saveID)
		{
			return;
		}
	}
	selected.push_back(saveID);
	notifySelectedChanged();
}

void SearchModel::SelectAllSaves()
{
	if (selected.size() == saveList.size())
	{
		for (auto &save : saveList)
		{
			DeselectSave(save->id);
		}
	}
	else
	{
		for (auto &save : saveList)
		{
			SelectSave(save->id);
		}
	}
}

void SearchModel::DeselectSave(int saveID)
{
	bool changed = false;
restart:
	for (size_t i = 0; i < selected.size(); i++)
	{
		if (selected[i] == saveID)
		{
			selected.erase(selected.begin()+i);
			changed = true;
			goto restart; //Just ensure all cases are removed.
		}
	}
	if(changed)
		notifySelectedChanged();
}

void SearchModel::notifySaveListChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		SearchView* cObserver = observers[i];
		cObserver->NotifySaveListChanged(this);
	}
}

void SearchModel::notifyTagListChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		SearchView* cObserver = observers[i];
		cObserver->NotifyTagListChanged(this);
	}
}

void SearchModel::notifyPageChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		SearchView* cObserver = observers[i];
		cObserver->NotifyPageChanged(this);
	}
}

void SearchModel::notifyPeriodChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		SearchView* cObserver = observers[i];
		cObserver->NotifyPeriodChanged(this);
	}
}

void SearchModel::notifySortChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		SearchView* cObserver = observers[i];
		cObserver->NotifySortChanged(this);
	}
}

void SearchModel::notifyShowOwnChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		SearchView* cObserver = observers[i];
		cObserver->NotifyShowOwnChanged(this);
	}
}

void SearchModel::notifyShowFavouriteChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		SearchView* cObserver = observers[i];
		cObserver->NotifyShowOwnChanged(this);
	}
}

void SearchModel::notifySelectedChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		SearchView* cObserver = observers[i];
		cObserver->NotifySelectedChanged(this);
	}
}

int SearchModel::GetPageCount()
{
	if (!showOwn && !showFavourite && currentPeriod == http::allSaves && currentSort == http::sortByVotes && lastQuery == "")
		return std::max(1, (int)(ceil(resultCount/20.0f))+1); //add one for front page (front page saves are repeated twice)
	else
		return std::max(1, (int)(ceil(resultCount/20.0f)));
}


=== src\gui\search\SearchModel.h ===

#pragma once
#include "common/String.h"
#include "client/Search.h"
#include "Config.h"
#include <vector>
#include <atomic>
#include <memory>

namespace http
{
	class SearchSavesRequest;
	class SearchTagsRequest;
}

class SaveInfo;
class SearchView;
class SearchModel
{
private:
	std::unique_ptr<http::SearchSavesRequest> searchSaves;
	void BeginSearchSaves(int start, int count, String query, http::Period period, http::Sort sort, http::Category category);
	std::vector<std::unique_ptr<SaveInfo>> EndSearchSaves();

	void BeginGetTags(int start, int count, String query);
	std::vector<std::pair<ByteString, int>> EndGetTags();
	std::unique_ptr<http::SearchTagsRequest> getTags;

	std::unique_ptr<SaveInfo> loadedSave;
	http::Period currentPeriod;
	http::Sort currentSort;
	String lastQuery;
	String lastError;
	std::vector<int> selected;
	std::vector<SearchView*> observers;
	std::vector<std::unique_ptr<SaveInfo>> saveList;
	std::vector<std::pair<ByteString, int> > tagList;
	int currentPage;
	int resultCount;
	bool showOwn;
	bool showFavourite;
	bool showTags;
	void notifySaveListChanged();
	void notifyTagListChanged();
	void notifySelectedChanged();
	void notifyPageChanged();
	void notifyPeriodChanged();
	void notifySortChanged();
	void notifyShowOwnChanged();
	void notifyShowFavouriteChanged();

	//Variables and methods for background save request
	bool saveListLoaded = false;
public:
    SearchModel();

    void SetShowTags(bool show);
    bool GetShowTags();
	void AddObserver(SearchView * observer);
	bool UpdateSaveList(int pageNumber, String query);
	std::vector<SaveInfo *> GetSaveList(); // non-owning
	std::vector<std::pair<ByteString, int> > GetTagList();
	String GetLastError() { return lastError; }
	int GetPageCount();
	int GetPageNum() { return currentPage; }
	String GetLastQuery() { return lastQuery; }
	void SetPeriod(http::Period period) { if(!searchSaves) { currentPeriod = period; } notifyPeriodChanged(); }
	http::Period GetPeriod() { return currentPeriod; }
	void SetSort(http::Sort sort) { if(!searchSaves) { currentSort = sort; } notifySortChanged(); }
	http::Sort GetSort() { return currentSort; }
	void SetShowOwn(bool show) { if(!searchSaves) { if(show!=showOwn) { showOwn = show; } } notifyShowOwnChanged();  }
	bool GetShowOwn() { return showOwn; }
	void SetShowFavourite(bool show) { if(show!=showFavourite && !searchSaves) { showFavourite = show; } notifyShowFavouriteChanged();  }
	bool GetShowFavourite() { return showFavourite; }
	void SetLoadedSave(std::unique_ptr<SaveInfo> save);
	const SaveInfo *GetLoadedSave() const;
	std::unique_ptr<SaveInfo> TakeLoadedSave();
	bool GetSavesLoaded() { return saveListLoaded; }
	std::vector<int> GetSelected() { return selected; }
	void ClearSelected() { selected.clear(); notifySelectedChanged(); }
	void SelectSave(int saveID);
	void SelectAllSaves();
	void DeselectSave(int saveID);
	void Update();
};


=== src\gui\search\SearchView.cpp ===

#include "SearchView.h"
#include "SearchController.h"
#include "SearchModel.h"
#include "client/Client.h"
#include "client/SaveInfo.h"
#include "gui/dialogues/InformationMessage.h"
#include "gui/interface/SaveButton.h"
#include "gui/interface/Button.h"
#include "gui/interface/Label.h"
#include "gui/interface/RichLabel.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/Spinner.h"
#include "gui/interface/DropDown.h"
#include "PowderToySDL.h"
#include "graphics/Graphics.h"
#include "graphics/VideoBuffer.h"
#include "SimulationConfig.h"
#include <SDL.h>

SearchView::SearchView():
	ui::Window(ui::Point(0, 0), ui::Point(WINDOWW, WINDOWH)),
	c(nullptr),
	saveButtons(std::vector<ui::SaveButton*>()),
	errorLabel(nullptr),
	changed(true),
	lastChanged(0),
	pageCount(0),
	publishButtonShown(false)
{

	Client::Ref().AddListener(this);

	nextButton = new ui::Button(ui::Point(WINDOWW-52, WINDOWH-18), ui::Point(50, 16), String("Next ") + 0xE015);
	previousButton = new ui::Button(ui::Point(2, WINDOWH-18), ui::Point(50, 16), 0xE016 + String(" Prev"));
	tagsLabel  = new ui::Label(ui::Point(270, WINDOWH-18), ui::Point(WINDOWW-540, 16), "\boPopular Tags:");
	motdLabel  = new ui::RichLabel(ui::Point(51, WINDOWH-18), ui::Point(WINDOWW-102, 16), Client::Ref().GetMessageOfTheDay());

	pageTextbox = new ui::Textbox(ui::Point(283, WINDOWH-18), ui::Point(41, 16), "");
	pageTextbox->SetActionCallback({ [this] { textChanged(); } });
	pageTextbox->SetInputType(ui::Textbox::Number);
	pageLabel = new ui::Label(ui::Point(0, WINDOWH-18), ui::Point(30, 16), "Page"); //page [TEXTBOX] of y
	pageLabel->Appearance.HorizontalAlign = ui::Appearance::AlignRight;
	pageCountLabel = new ui::Label(ui::Point(WINDOWW/2+6, WINDOWH-18), ui::Point(50, 16), "");
	pageCountLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	AddComponent(pageLabel);
	AddComponent(pageCountLabel);
	AddComponent(pageTextbox);

	searchField = new ui::Textbox(ui::Point(60, 10), ui::Point(WINDOWW-283, 17), "", "[search, F1 for help]");
	searchField->Appearance.icon = IconSearch;
	searchField->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	searchField->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	searchField->SetActionCallback({ [this] { doSearch(); } });
	searchField->SetLimit(100);
	FocusComponent(searchField);

	dateRange = new ui::DropDown(ui::Point(WINDOWW-185, 10), ui::Point(36, 17));
	dateRange->SetActionCallback({ [this] { c->ChangePeriod(dateRange->GetOption().second); } });
	dateRange->AddOption({"All", 0});
	dateRange->AddOption({"Day", 1});
	dateRange->AddOption({"Week", 2});
	dateRange->AddOption({"Month", 3});
	dateRange->AddOption({"Year", 4});
	dateRange->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	dateRange->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(dateRange);

	sortButton = new ui::Button(ui::Point(WINDOWW-140, 10), ui::Point(61, 17), "Sort");
	sortButton->SetIcon(IconVoteSort);
	sortButton->SetTogglable(true);
	sortButton->SetActionCallback({ [this] { c->ChangeSort(); } });
	sortButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	sortButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(sortButton);

	ownButton = new ui::Button(ui::Point(WINDOWW-70, 10), ui::Point(61, 17), "My Own");
	ownButton->SetIcon(IconMyOwn);
	ownButton->SetTogglable(true);
	ownButton->SetActionCallback({ [this] { c->ShowOwn(ownButton->GetToggleState()); } });
	ownButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	ownButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(ownButton);

	favButton = new ui::Button(searchField->Position+ui::Point(searchField->Size.X+15, 0), ui::Point(17, 17), "");
	favButton->SetIcon(IconFavourite);
	favButton->SetTogglable(true);
	favButton->Appearance.Margin.Left+=2;
	favButton->SetActionCallback({ [this] { c->ShowFavourite(favButton->GetToggleState()); } });
	favButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	favButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	favButton->Appearance.BorderInactive = ui::Colour(170,170,170);
	AddComponent(favButton);

	ui::Button * clearSearchButton = new ui::Button(searchField->Position+ui::Point(searchField->Size.X-1, 0), ui::Point(17, 17), "");
	clearSearchButton->SetIcon(IconClose);
	clearSearchButton->SetActionCallback({ [this] { clearSearch(); } });
	clearSearchButton->Appearance.Margin.Left+=2;
	clearSearchButton->Appearance.Margin.Top+=2;
	clearSearchButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
	clearSearchButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	clearSearchButton->Appearance.BorderInactive = ui::Colour(170,170,170);
	AddComponent(clearSearchButton);

	nextButton->SetActionCallback({ [this] { c->SetPageRelative(1); } });
	nextButton->Appearance.HorizontalAlign = ui::Appearance::AlignRight;
	nextButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	nextButton->Visible = false;
	previousButton->SetActionCallback({ [this] { c->SetPageRelative(-1); } });
	previousButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	previousButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	previousButton->Visible = false;
	AddComponent(nextButton);
	AddComponent(previousButton);
	AddComponent(searchField);

	loadingSpinner = new ui::Spinner(ui::Point((WINDOWW/2)-12, (WINDOWH/2)+12), ui::Point(24, 24));
	AddComponent(loadingSpinner);

	ui::Label * searchPrompt = new ui::Label(ui::Point(10, 10), ui::Point(50, 16), "Search:");
	searchPrompt->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	searchPrompt->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(searchPrompt);

	removeSelected = new ui::Button(ui::Point(((WINDOWW-415)/2), WINDOWH-18), ui::Point(100, 16), "Delete");
	removeSelected->Visible = false;
	removeSelected->SetActionCallback({ [this] { c->RemoveSelected(); } });
	AddComponent(removeSelected);

	unpublishSelected = new ui::Button(ui::Point(((WINDOWW-415)/2)+105, WINDOWH-18), ui::Point(100, 16), "Unpublish");
	unpublishSelected->Visible = false;
	unpublishSelected->SetActionCallback({ [this] { c->UnpublishSelected(publishButtonShown); } });
	AddComponent(unpublishSelected);

	favouriteSelected = new ui::Button(ui::Point(((WINDOWW-415)/2)+210, WINDOWH-18), ui::Point(100, 16), "Favourite");
	favouriteSelected->Visible = false;
	favouriteSelected->SetActionCallback({ [this] { c->FavouriteSelected(); } });
	AddComponent(favouriteSelected);

	clearSelection = new ui::Button(ui::Point(((WINDOWW-415)/2)+315, WINDOWH-18), ui::Point(100, 16), "Clear selection");
	clearSelection->Visible = false;
	clearSelection->SetActionCallback({ [this] { c->ClearSelection(); } });
	AddComponent(clearSelection);

	CheckAccess();
}

void SearchView::NotifyMessageOfTheDay(Client * sender)
{
	if (motdLabel)
	{
		try
		{
			motdLabel->SetText(sender->GetMessageOfTheDay());
		}
		catch (std::exception & e)
		{
			motdLabel = nullptr;
		}
	}

}

void SearchView::doSearch()
{
	if (searchField->GetText().length() > 3 || !searchField->GetText().length())
		c->DoSearch(searchField->GetText());
}

void SearchView::searchHelp()
{
	String info =
		"Type in the search bar to begin automatically searching save titles and tags. Search terms are ORed together.\n"
		"\n"
		"Sorting: click the \bt\"By Votes\"\bw / \bt\"By Date\"\bw buttons to change the order saves are displayed in\n"
		"Categories: If you're logged in, use \bt\"My Own\"\bw to view only your own saves, or click the Star icon to view your favorited saves\n"
		"Date Range: Click the dropdown to the right of the search box to select the date range for your search\n"
		"\n"
		"Special search terms:\n"
		"\btid:#######\bw - search by save id\n"
		"\bthistory:#######\bw - see previous versions for a save id\n"
		"\btuser:XXXXXX\bw - search for saves by a specific user\n"
		"\btbefore:YYYY-MM-DD\bw - all saves originally created before a certain date. Month and Day portions are both optional\n"
		"\btafter:YYYY-MM-DD\bw - all saves originally created after a certain date. Month and Day portions are both optional\n"
		"\n"
		"Advanced search:\n"
		"Start a search with \bt~\bw to do an advanced search. This search works across save titles, descriptions, usernames, and tags, rather than only save titles and tags."
		" It also concatenates search terms with AND instead of OR.\n"
		"Use \bt|\bw to OR together search terms, for example \bg~bomb | nuke | explosive\bw\n"
		"Use \bt!\bw to negate terms, for example \bg~city !destroyable !desert\bw\n"
		"Use \bt\"\bw to create multi-word search terms, for example \bg~\"power plant\" uran | plut | polo\bw\n"
		"Use \bt@title\bw to limit search to only save titles, for example \bg~@title subframe\bw\n"
		"Use \bt@description\bw to limit search to only save descriptions, for example \bg~@description \"No description provided\"\bw\n"
		"Use \bt@user\bw to limit search to only specific users, for example \bg~@user 117n00b | Catelite | Fluttershy @title laser\bw\n"
		"Use \bt@tags\bw to limit search to just save tags, for example \bg~@tags resistcup @title printer | @description spider before:2024-06\bw\n"
		"Parenthesis can be used to further complicate your searches. For example: \bg~(@user MG99 @description complete) | (@user goglesq @tags tutorial)\bw"
		;

	new InformationMessage("Search Help", info, true);
}

void SearchView::clearSearch()
{
	searchField->SetText("");
	c->DoSearch(searchField->GetText(), true);
}

void SearchView::textChanged()
{
	int num = pageTextbox->GetText().ToNumber<int>(true);
	if (num < 0) //0 is allowed so that you can backspace the 1
		pageTextbox->SetText("1");
	else if (num > pageCount)
		pageTextbox->SetText(String::Build(pageCount));
	changed = true;
	lastChanged = GetTicks()+600;
}

void SearchView::OnTryOkay(OkayMethod method)
{
	c->DoSearch(searchField->GetText(), true);
}

SearchView::~SearchView()
{
	Client::Ref().RemoveListener(this);
	RemoveComponent(nextButton);
	RemoveComponent(previousButton);
	RemoveComponent(pageTextbox);
	RemoveComponent(pageLabel);
	RemoveComponent(pageCountLabel);
	delete nextButton;
	delete previousButton;
	delete pageTextbox;
	delete pageLabel;
	delete pageCountLabel;

	for (size_t i = 0; i < saveButtons.size(); i++)
	{
		RemoveComponent(saveButtons[i]);
		delete saveButtons[i];
	}
	saveButtons.clear();
}

void SearchView::Search(String query)
{
	searchField->SetText(query);
	c->DoSearch(query, true);
}

void SearchView::NotifyPeriodChanged(SearchModel * sender)
{
	dateRange->SetOption(sender->GetPeriod());
}

void SearchView::NotifySortChanged(SearchModel * sender)
{
	if(sender->GetSort() == http::sortByVotes)
	{
		sortButton->SetToggleState(false);
		sortButton->SetText("By votes");
		sortButton->SetIcon(IconVoteSort);
	}
	else
	{
		sortButton->SetToggleState(true);
		sortButton->SetText("By date");
		sortButton->SetIcon(IconDateSort);
	}
}

void SearchView::NotifyShowOwnChanged(SearchModel * sender)
{
	ownButton->SetToggleState(sender->GetShowOwn());
	if(sender->GetShowOwn() || Client::Ref().GetAuthUser().UserElevation == User::ElevationAdmin || Client::Ref().GetAuthUser().UserElevation == User::ElevationMod)
	{
		unpublishSelected->Enabled = true;
		removeSelected->Enabled = true;
	}
	else
	{
		unpublishSelected->Enabled = false;
		removeSelected->Enabled = false;
	}
}

void SearchView::NotifyShowFavouriteChanged(SearchModel * sender)
{
	favButton->SetToggleState(sender->GetShowFavourite());
	if(sender->GetShowFavourite())
	{
		unpublishSelected->Enabled = false;
		removeSelected->Enabled = false;
	}
	else if(sender->GetShowOwn() || Client::Ref().GetAuthUser().UserElevation == User::ElevationAdmin || Client::Ref().GetAuthUser().UserElevation == User::ElevationMod)
	{
		unpublishSelected->Enabled = true;
		removeSelected->Enabled = true;
	}
	else
	{
		unpublishSelected->Enabled = false;
		removeSelected->Enabled = false;
	}
}

void SearchView::NotifyPageChanged(SearchModel * sender)
{
	pageCount = sender->GetPageCount();
	if (!sender->GetSaveList().size()) //no saves
	{
		pageLabel->Visible = pageCountLabel->Visible = pageTextbox->Visible = false;
	}
	else
	{
		String pageInfo = String::Build("of ", pageCount);
		pageCountLabel->SetText(pageInfo);
		int width = Graphics::TextSize(pageInfo).X - 1;

		pageLabel->Position.X = WINDOWW/2-width-20;
		pageTextbox->Position.X = WINDOWW/2-width+11;
		pageTextbox->Size.X = width-4;
		//pageCountLabel->Position.X = WINDOWW/2+6;
		pageLabel->Visible = pageCountLabel->Visible = pageTextbox->Visible = true;

		pageInfo = String::Build(sender->GetPageNum());
		pageTextbox->SetText(pageInfo);
	}
	if(sender->GetPageNum() == 1)
	{
		previousButton->Visible = false;
	}
	else
	{
		previousButton->Visible = true;
	}
	if(sender->GetPageNum() >= sender->GetPageCount())
	{
		nextButton->Visible = false;
	}
	else
	{
		nextButton->Visible = true;
	}
}

void SearchView::NotifyAuthUserChanged(Client * sender)
{
	CheckAccess();
}

void SearchView::CheckAccess()
{
	if (c)
	{
		c->ClearSelection();

		if(ownButton->GetToggleState())
			ownButton->DoAction();
		if(favButton->GetToggleState())
			favButton->DoAction();
	}

	if (Client::Ref().GetAuthUser().UserID)
	{
		ownButton->Enabled = true;
		favButton->Enabled = true;
		favouriteSelected->Enabled = true;

		if (Client::Ref().GetAuthUser().UserElevation == User::ElevationAdmin || Client::Ref().GetAuthUser().UserElevation == User::ElevationMod)
		{
			unpublishSelected->Enabled = true;
			removeSelected->Enabled = true;
			for (size_t i = 0; i < saveButtons.size(); i++)
			{
				saveButtons[i]->SetSelectable(true);
			}
		}

	}
	else
	{
		ownButton->Enabled = false;
		favButton->Enabled = false;


		favouriteSelected->Enabled = false;
		unpublishSelected->Enabled = false;
		removeSelected->Enabled = false;

		for (size_t i = 0; i < saveButtons.size(); i++)
		{
			saveButtons[i]->SetSelectable(false);
			saveButtons[i]->SetSelected(false);
		}
	}
}

void SearchView::NotifyTagListChanged(SearchModel * sender)
{
	int savesY = 4, buttonPadding = 1;
	int buttonAreaHeight, buttonYOffset;

	int tagWidth = 0, tagHeight = 0, tagX = 0, tagY = 0, tagsX = 6, tagsY = 4, tagPadding = 1;
	int tagAreaWidth, tagAreaHeight, tagXOffset = 0, tagYOffset = 0;

	std::vector<std::pair<ByteString, int> > tags = sender->GetTagList();

	if (motdLabel)
	{
		RemoveComponent(motdLabel);
		motdLabel->SetParentWindow(nullptr);
	}

	RemoveComponent(tagsLabel);
	tagsLabel->SetParentWindow(nullptr);

	for (size_t i = 0; i < tagButtons.size(); i++)
	{
		RemoveComponent(tagButtons[i]);
		delete tagButtons[i];
	}
	tagButtons.clear();

	buttonYOffset = 28;
	buttonAreaHeight = Size.Y - buttonYOffset - 18;

	if (sender->GetShowTags())
	{
		buttonYOffset += (buttonAreaHeight/savesY) - buttonPadding*2;
		buttonAreaHeight = Size.Y - buttonYOffset - 18;
		savesY--;

		tagXOffset = tagPadding;
		tagYOffset = 60;
		tagAreaWidth = Size.X;
		tagAreaHeight = ((buttonAreaHeight/savesY) - buttonPadding*2)-(tagYOffset-28)-5;
		tagWidth = (tagAreaWidth/tagsX) - tagPadding*2;
		tagHeight = (tagAreaHeight/tagsY) - tagPadding*2;

		AddComponent(tagsLabel);
		tagsLabel->Position.Y = tagYOffset-16;

		if (motdLabel)
		{
			AddComponent(motdLabel);
			motdLabel->Position.Y = tagYOffset-30;
		}
	}

	if (sender->GetShowTags())
	{
		for (size_t i = 0; i < tags.size(); i++)
		{
			int maxTagVotes = tags[0].second;

			std::pair<ByteString, int> tag = tags[i];

			if (tagX == tagsX)
			{
				if(tagY == tagsY-1)
					break;
				tagX = 0;
				tagY++;
			}

			int tagAlpha = 192;
			if (maxTagVotes)
				tagAlpha = 127+(128*tag.second)/maxTagVotes;

			ui::Button * tagButton;
			tagButton = new ui::Button(
				ui::Point(
						tagXOffset + tagPadding + tagX*(tagWidth+tagPadding*2),
						tagYOffset + tagPadding + tagY*(tagHeight+tagPadding*2)
					),
				ui::Point(tagWidth, tagHeight),
				tag.first.FromUtf8()
				);
			tagButton->SetActionCallback({ [this, tag] {
				Search(tag.first.FromUtf8());
			} });
			tagButton->Appearance.BorderInactive = ui::Colour(0, 0, 0);
			tagButton->Appearance.BorderHover = ui::Colour(0, 0, 0);
			tagButton->Appearance.BorderActive = ui::Colour(0, 0, 0);
			tagButton->Appearance.BackgroundHover = ui::Colour(0, 0, 0);

			tagButton->Appearance.TextInactive = ui::Colour(tagAlpha, tagAlpha, tagAlpha);
			tagButton->Appearance.TextHover = ui::Colour((tagAlpha*5)/6, (tagAlpha*5)/6, tagAlpha);
			AddComponent(tagButton);
			tagButtons.push_back(tagButton);
			tagX++;

		}
	}
}

void SearchView::NotifySaveListChanged(SearchModel * sender)
{
	int buttonWidth, buttonHeight, saveX = 0, saveY = 0, savesX = 5, savesY = 4, buttonPadding = 1;
	int buttonAreaWidth, buttonAreaHeight, buttonXOffset, buttonYOffset;

	auto saves = sender->GetSaveList();
	//string messageOfTheDay = sender->GetMessageOfTheDay();

	if(sender->GetShowFavourite())
		favouriteSelected->SetText("Unfavourite");
	else
		favouriteSelected->SetText("Favourite");

	for (size_t i = 0; i < saveButtons.size(); i++)
	{
		RemoveComponent(saveButtons[i]);
	}
	if (!sender->GetSavesLoaded())
	{
		nextButton->Enabled = false;
		previousButton->Enabled = false;
		favButton->Enabled = false;
	}
	else
	{
		nextButton->Enabled = true;
		previousButton->Enabled = true;
		if (Client::Ref().GetAuthUser().UserID)
			favButton->Enabled = true;
	}
	ownButton->Enabled = true;
	sortButton->Enabled = true;
	if (!Client::Ref().GetAuthUser().UserID || favButton->GetToggleState())
	{
		ownButton->Enabled = false;
	}
	if (!sender->GetSavesLoaded())
	{
		ownButton->Enabled = false;
		sortButton->Enabled = false;
	}
	if (!saves.size())
	{
		loadingSpinner->Visible = false;
		if (!errorLabel)
		{
			errorLabel = new ui::Label(ui::Point(0, (WINDOWH/2)-6), ui::Point(WINDOWW, 12), "Error");
			AddComponent(errorLabel);
		}
		if (!sender->GetSavesLoaded())
		{
			errorLabel->SetText("Loading...");
			loadingSpinner->Visible = true;
		}
		else
		{
			if(sender->GetLastError().length())
				errorLabel->SetText("\bo" + sender->GetLastError());
			else
				errorLabel->SetText("\boNo saves found");
		}
	}
	else
	{
		loadingSpinner->Visible = false;
		if (errorLabel)
		{
			RemoveComponent(errorLabel);
			delete errorLabel;
			errorLabel = nullptr;
		}
		for (size_t i = 0; i < saveButtons.size(); i++)
		{
			delete saveButtons[i];
		}
		saveButtons.clear();

		buttonYOffset = 28;
		buttonXOffset = buttonPadding;
		buttonAreaWidth = Size.X;
		buttonAreaHeight = Size.Y - buttonYOffset - 18;

		if (sender->GetShowTags())
		{
			buttonYOffset += (buttonAreaHeight/savesY) - buttonPadding*2;
			buttonAreaHeight = Size.Y - buttonYOffset - 18;
			savesY--;
		}

		buttonWidth = (buttonAreaWidth/savesX) - buttonPadding*2;
		buttonHeight = (buttonAreaHeight/savesY) - buttonPadding*2;

		for (size_t i = 0; i < saves.size(); i++)
		{
			if (saveX == savesX)
			{
				if (saveY == savesY-1)
					break;
				saveX = 0;
				saveY++;
			}
			ui::SaveButton * saveButton;
			saveButton = new ui::SaveButton(
						ui::Point(
							buttonXOffset + buttonPadding + saveX*(buttonWidth+buttonPadding*2),
							buttonYOffset + buttonPadding + saveY*(buttonHeight+buttonPadding*2)
							),
						ui::Point(buttonWidth, buttonHeight),
						saves[i]);
			saveButton->AddContextMenu(0);
			saveButton->SetActionCallback({
				[this, saveButton] { c->OpenSave(saveButton->GetSave()->GetID(), saveButton->GetSave()->GetVersion(), saveButton->CloneThumbnail()); },
				[this, saveButton] { Search(String::Build("history:", saveButton->GetSave()->GetID())); },
				[this, saveButton] { Search(String::Build("user:", saveButton->GetSave()->GetUserName().FromUtf8())); },
				[this, saveButton] { c->Selected(saveButton->GetSave()->GetID(), saveButton->GetSelected()); }
			});
			if(Client::Ref().GetAuthUser().UserID)
				saveButton->SetSelectable(true);
			if (saves[i]->GetUserName() == Client::Ref().GetAuthUser().Username || Client::Ref().GetAuthUser().UserElevation == User::ElevationAdmin || Client::Ref().GetAuthUser().UserElevation == User::ElevationMod)
				saveButton->SetShowVotes(true);
			saveButtons.push_back(saveButton);
			AddComponent(saveButton);
			saveX++;
		}
	}
}

void SearchView::NotifySelectedChanged(SearchModel * sender)
{
	std::vector<int> selected = sender->GetSelected();
	size_t published = 0;
	for (size_t j = 0; j < saveButtons.size(); j++)
	{
		saveButtons[j]->SetSelected(false);
		for (size_t i = 0; i < selected.size(); i++)
		{
			if (saveButtons[j]->GetSave()->GetID() == selected[i])
			{
				saveButtons[j]->SetSelected(true);
				if (saveButtons[j]->GetSave()->GetPublished())
					published++;
			}
		}
	}

	if (selected.size())
	{
		removeSelected->Visible = true;
		unpublishSelected->Visible = true;
		favouriteSelected->Visible = true;
		clearSelection->Visible = true;
		pageTextbox->Visible = false;
		pageLabel->Visible = false;
		pageCountLabel->Visible = false;
		if (published <= selected.size()/2)
		{
			unpublishSelected->SetText("Publish");
			publishButtonShown = true;
		}
		else
		{
			unpublishSelected->SetText("Unpublish");
			publishButtonShown = false;
		}
	}
	else if (removeSelected->Visible)
	{
		removeSelected->Visible = false;
		unpublishSelected->Visible = false;
		favouriteSelected->Visible = false;
		clearSelection->Visible = false;
		pageTextbox->Visible = true;
		pageLabel->Visible = true;
		pageCountLabel->Visible = true;
	}
}

void SearchView::OnTick()
{
	c->Update();
	if (changed && lastChanged < GetTicks())
	{
		changed = false;
		c->SetPage(std::max(pageTextbox->GetText().ToNumber<int>(true), 0));
	}
}

void SearchView::OnMouseWheel(int x, int y, int d)
{
	if (d)
		c->SetPageRelative(-d);
}
void SearchView::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	if (key == SDLK_ESCAPE || key == SDLK_AC_BACK)
		c->Exit();
	else if ((focusedComponent_ != pageTextbox && focusedComponent_ != searchField) && scan == SDL_SCANCODE_A && ctrl)
		c->SelectAllSaves();
	else if (key == SDLK_LCTRL || key == SDLK_RCTRL)
		c->InstantOpen(true);
	else if (key == SDLK_F1)
		searchHelp();
}

void SearchView::OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	if (key == SDLK_LCTRL || key == SDLK_RCTRL)
		c->InstantOpen(false);
}


=== src\gui\search\SearchView.h ===

#pragma once
#include "client/ClientListener.h"
#include "gui/interface/Window.h"
#include <vector>

namespace ui
{
	class RichLabel;
	class SaveButton;
	class Button;
	class Label;
	class Spinner;
	class Textbox;
	class DropDown;
}

class SearchModel;
class SearchController;

class SearchView: public ui::Window, public ClientListener
{
private:
	SearchController * c;
	std::vector<ui::SaveButton*> saveButtons;
	std::vector<ui::Button*> tagButtons;
	ui::Button * favButton;
	ui::Button * nextButton;
	ui::Button * previousButton;
	ui::Label * errorLabel;
	ui::Textbox * searchField;
	ui::Textbox * pageTextbox;
	ui::Label * pageLabel;
	ui::Label * pageCountLabel;
	ui::Label * tagsLabel;
	ui::RichLabel * motdLabel = nullptr;
	ui::DropDown * dateRange;
	ui::Button * sortButton;
	ui::Button * ownButton;
	ui::Spinner * loadingSpinner;

	ui::Button * removeSelected;
	ui::Button * unpublishSelected;
	ui::Button * favouriteSelected;
	ui::Button * clearSelection;
	void searchHelp();
	void clearSearch();
	void doSearch();
	void textChanged();
	bool changed;
	unsigned int lastChanged;
	int pageCount;
	bool publishButtonShown;
public:
	void NotifyTagListChanged(SearchModel * sender);
	void NotifySaveListChanged(SearchModel * sender);
	void NotifySelectedChanged(SearchModel * sender);
	void NotifyPageChanged(SearchModel * sender);
	void NotifyPeriodChanged(SearchModel * sender);
	void NotifySortChanged(SearchModel * sender);
	void NotifyShowOwnChanged(SearchModel * sender);
	void NotifyShowFavouriteChanged(SearchModel * sender);
	void NotifyAuthUserChanged(Client * sender) override;
	void NotifyMessageOfTheDay(Client * sender) override;
	void CheckAccess();
	void OnTryOkay(OkayMethod method) override;
    SearchView();
	virtual ~SearchView();
	void AttachController(SearchController * _c) { c = _c; }
	virtual void Search(String);
	void OnTick() override;
	void OnMouseWheel(int x, int y, int d) override;
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;

};


=== src\gui\tags\meson.build ===

powder_files += files(
	'TagsController.cpp',
	'TagsModel.cpp',
	'TagsView.cpp',
)


=== src\gui\tags\TagsController.cpp ===

#include "TagsController.h"
#include "TagsModel.h"
#include "TagsView.h"
#include "client/http/AddTagRequest.h"
#include "client/http/RemoveTagRequest.h"
#include "gui/interface/Engine.h"
#include "client/SaveInfo.h"
#include "Controller.h"

TagsController::TagsController(std::function<void ()> onDone_, SaveInfo * save):
	HasDone(false)
{
	tagsModel = new TagsModel();
	tagsView = new TagsView();
	tagsView->AttachController(this);
	tagsModel->AddObserver(tagsView);

	tagsModel->SetSave(save);

	onDone = onDone_;
}

SaveInfo * TagsController::GetSave()
{
	return tagsModel->GetSave();
}

void TagsController::RemoveTag(ByteString tag)
{
	tagsModel->RemoveTag(tag);
}


void TagsController::AddTag(ByteString tag)
{
	tagsModel->AddTag(tag);
}

void TagsController::Tick()
{
	tagsModel->Tick();
}

void TagsController::Exit()
{
	tagsView->CloseActiveWindow();
	if (onDone)
		onDone();
	HasDone = true;
}

TagsController::~TagsController()
{
	delete tagsModel;
	tagsView->CloseActiveWindow();
	delete tagsView;
}



=== src\gui\tags\TagsController.h ===

#pragma once
#include "common/String.h"
#include <functional>

class SaveInfo;
class TagsView;
class TagsModel;
class TagsController
{
	std::function<void ()> onDone;
	TagsView * tagsView;
	TagsModel * tagsModel;
public:
	bool HasDone;
	TagsController(std::function<void ()> onDone, SaveInfo * save);
	TagsView * GetView() {return tagsView;}
	SaveInfo * GetSave();
	void RemoveTag(ByteString tag);
	void AddTag(ByteString tag);
	void Exit();
	void Tick();
	virtual ~TagsController();
};


=== src\gui\tags\TagsModel.cpp ===

#include "TagsModel.h"
#include "TagsView.h"
#include "TagsModelException.h"
#include "client/Client.h"
#include "client/SaveInfo.h"
#include "client/http/AddTagRequest.h"
#include "client/http/RemoveTagRequest.h"
#include "gui/dialogues/ErrorMessage.h"

void TagsModel::SetSave(SaveInfo *newSave /* non-owning */)
{
	queuedTags.clear();
	this->save = newSave;
	notifyTagsChanged();
}

SaveInfo *TagsModel::GetSave() // non-owning
{
	return save;
}

void TagsModel::Tick()
{
	auto triggerTags = false;
	std::list<ByteString> tags;
	if (addTagRequest && addTagRequest->CheckDone())
	{
		try
		{
			tags = addTagRequest->Finish();
			triggerTags = true;
		}
		catch (const http::RequestError &ex)
		{
			new ErrorMessage("Could not add tag", ByteString(ex.what()).FromUtf8());
		}
		addTagRequest.reset();
	}
	if (removeTagRequest && removeTagRequest->CheckDone())
	{
		try
		{
			tags = removeTagRequest->Finish();
			triggerTags = true;
		}
		catch (const http::RequestError &ex)
		{
			new ErrorMessage("Could not remove tag", ByteString(ex.what()).FromUtf8());
		}
		removeTagRequest.reset();
	}
	if (triggerTags)
	{
		if (save)
		{
			save->SetTags(tags);
		}
		notifyTagsChanged();
	}
	if (!addTagRequest && !removeTagRequest && !queuedTags.empty())
	{
		auto it = queuedTags.begin();
		auto [ tag, add ] = *it;
		queuedTags.erase(it);
		if (save)
		{
			if (add)
			{
				addTagRequest = std::make_unique<http::AddTagRequest>(save->GetID(), tag);
				addTagRequest->Start();
			}
			else
			{
				removeTagRequest = std::make_unique<http::RemoveTagRequest>(save->GetID(), tag);
				removeTagRequest->Start();
			}
		}
	}
}

void TagsModel::RemoveTag(ByteString tag)
{
	queuedTags[tag] = false;
}

void TagsModel::AddTag(ByteString tag)
{
	queuedTags[tag] = true;
}

void TagsModel::AddObserver(TagsView * observer)
{
	observers.push_back(observer);
	observer->NotifyTagsChanged(this);
}

void TagsModel::notifyTagsChanged()
{
	for (size_t i = 0; i < observers.size(); i++)
	{
		observers[i]->NotifyTagsChanged(this);
	}
}


=== src\gui\tags\TagsModel.h ===

#pragma once
#include "common/String.h"
#include <vector>
#include <map>
#include <memory>

namespace http
{
	class AddTagRequest;
	class RemoveTagRequest;
}

class SaveInfo;

class TagsView;
class TagsModel {
	std::unique_ptr<http::AddTagRequest> addTagRequest;
	std::unique_ptr<http::RemoveTagRequest> removeTagRequest;
	std::map<ByteString, bool> queuedTags;
	SaveInfo *save = nullptr; // non-owning
	std::vector<TagsView*> observers;
	void notifyTagsChanged();
public:
	void AddObserver(TagsView * observer);
	void SetSave(SaveInfo *newSave /* non-owning */);
	void RemoveTag(ByteString tag);
	void AddTag(ByteString tag);
	SaveInfo *GetSave(); // non-owning
	void Tick();
};


=== src\gui\tags\TagsModelException.h ===

#pragma once
#include "common/String.h"
#include <exception>

class TagsModelException : public std::exception {
	ByteString message;
public:
	TagsModelException(String message): message(message.ToUtf8()) {};
	const char * what() const throw() override { return message.c_str(); };
	~TagsModelException() throw() {};
};


=== src\gui\tags\TagsView.cpp ===

#include "TagsView.h"

#include "TagsController.h"
#include "TagsModel.h"
#include "TagsModelException.h"

#include "client/Client.h"
#include "client/SaveInfo.h"

#include "graphics/Graphics.h"

#include "gui/dialogues/ErrorMessage.h"
#include "gui/interface/Button.h"
#include "gui/interface/Textbox.h"
#include "gui/interface/Label.h"

#include <SDL.h>

TagsView::TagsView():
	ui::Window(ui::Point(-1, -1), ui::Point(195, 250))
{
	closeButton = new ui::Button(ui::Point(0, Size.Y-16), ui::Point(195, 16), "Close");
	closeButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	closeButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	closeButton->SetActionCallback({ [this] { c->Exit(); } });
	AddComponent(closeButton);
	SetCancelButton(closeButton);

	tagInput = new ui::Textbox(ui::Point(8, Size.Y-40), ui::Point(Size.X-60, 16), "", "[new tag]");
	tagInput->Appearance.icon = IconTag;
	tagInput->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	tagInput->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	tagInput->SetLimit(16);
	AddComponent(tagInput);
	FocusComponent(tagInput);

	addButton = new ui::Button(ui::Point(tagInput->Position.X+tagInput->Size.X+4, tagInput->Position.Y), ui::Point(40, 16), "Add");
	addButton->Appearance.icon = IconAdd;
	addButton->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	addButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	addButton->SetActionCallback({ [this] { addTag(); } });
	AddComponent(addButton);

	if (!Client::Ref().GetAuthUser().UserID)
		addButton->Enabled = false;

	title = new ui::Label(ui::Point(5, 5), ui::Point(185, 28), "Manage tags:    \bgTags are only to \nbe used to improve search results");
	title->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	title->Appearance.VerticalAlign = ui::Appearance::AlignTop;
	title->SetMultiline(true);
	AddComponent(title);
}

void TagsView::OnTick()
{
	c->Tick();
}

void TagsView::OnDraw()
{
	Graphics * g = GetGraphics();
	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);
}

void TagsView::NotifyTagsChanged(TagsModel * sender)
{
	for (size_t i = 0; i < tags.size(); i++)
	{
		RemoveComponent(tags[i]);
		delete tags[i];
	}
	tags.clear();
	
	if(sender->GetSave())
	{
		std::list<ByteString> Tags = sender->GetSave()->GetTags();
		int i = 0;
		for (auto &tag : Tags)
		{
			ui::Label * tempLabel = new ui::Label(ui::Point(35, 35+(16*i)), ui::Point(120, 16), tag.FromUtf8());
			tempLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;			tempLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
			tags.push_back(tempLabel);
			AddComponent(tempLabel);

			if(sender->GetSave()->GetUserName() == Client::Ref().GetAuthUser().Username || Client::Ref().GetAuthUser().UserElevation == User::ElevationAdmin || Client::Ref().GetAuthUser().UserElevation == User::ElevationMod)
			{
				ui::Button * tempButton = new ui::Button(ui::Point(15, 37+(16*i)), ui::Point(11, 12));
				tempButton->Appearance.icon = IconDelete;
				tempButton->Appearance.Border = ui::Border(0);
				tempButton->Appearance.Margin.Top += 2;
				tempButton->Appearance.HorizontalAlign = ui::Appearance::AlignCentre;
				tempButton->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
				tempButton->SetActionCallback({ [this, tag] {
					c->RemoveTag(tag);
				} });
				tags.push_back(tempButton);
				AddComponent(tempButton);
			}
			i++;
		}
	}
}

void TagsView::OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if (repeat)
		return;
	switch(key)
	{
	case SDLK_KP_ENTER:
	case SDLK_RETURN:
		if(IsFocused(tagInput))
		{
			addTag();
		}
		break;
	}
}

void TagsView::addTag()
{
	if (tagInput->GetText().length() < 4)
	{
		new ErrorMessage("Tag not long enough", "Must be at least 4 letters");
		return;
	}
	c->AddTag(tagInput->GetText().ToUtf8());
	tagInput->SetText("");
}


=== src\gui\tags\TagsView.h ===

#pragma once
#include "gui/interface/Window.h"
#include <vector>

namespace ui
{
	class Button;
	class Textbox;
	class Label;
}

class TagsController;
class TagsModel;
class TagsView: public ui::Window {
	TagsController * c;
	ui::Button * addButton;
	ui::Button * closeButton;
	ui::Label * title;
	ui::Textbox * tagInput;
	std::vector<ui::Component*> tags;
	void addTag();
public:
	TagsView();
	void OnDraw() override;
	void OnTick() override;
	void AttachController(TagsController * c_) { c = c_; }
	void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override;
	void NotifyTagsChanged(TagsModel * sender);
};


=== src\gui\update\meson.build ===

powder_files += files(
	'UpdateActivity.cpp',
)


=== src\gui\update\UpdateActivity.cpp ===

#include "UpdateActivity.h"
#include "client/http/Request.h"
#include "prefs/GlobalPrefs.h"
#include "common/platform/Platform.h"
#include "tasks/Task.h"
#include "tasks/TaskWindow.h"
#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/interface/Engine.h"
#include "Config.h"
#include <bzlib.h>
#include <memory>

class UpdateDownloadTask : public Task
{
public:
	UpdateDownloadTask(ByteString updateName, UpdateActivity * a) : a(a), updateName(updateName) {}
private:
	UpdateActivity * a;
	ByteString updateName;
	void notifyDoneMain() override {
		a->NotifyDone(this);
	}
	void notifyErrorMain() override
	{
		a->NotifyError(this);
	}
	bool doWork() override
	{
		auto &prefs = GlobalPrefs::Ref();

		auto niceNotifyError = [this](String error) {
			notifyError("Downloaded update is corrupted\n" + error);
			return false;
		};

		auto request = std::make_unique<http::Request>(updateName);
		request->Start();
		notifyStatus("Downloading update");
		notifyProgress(-1);
		while(!request->CheckDone())
		{
			int64_t total, done;
			std::tie(total, done) = request->CheckProgress();
			if (total == -1)
			{
				notifyProgress(-1);
			}
			else
			{
				notifyProgress(total ? done * 100 / total : 0);
			}
			Platform::Millisleep(1);
		}

		int status;
		ByteString data;
		try
		{
			std::tie(status, data) = request->Finish();
		}
		catch (const http::RequestError &ex)
		{
			return niceNotifyError("Could not download update: " + String::Build("Server responded with Status ", ByteString(ex.what()).FromAscii()));
		}
		if (status!=200)
		{
			return niceNotifyError("Could not download update: " + String::Build("Server responded with Status ", status));
		}
		if (!data.size())
		{
			return niceNotifyError("Server did not return any data");
		}

		notifyStatus("Unpacking update");
		notifyProgress(-1);

		unsigned int uncompressedLength;

		if(data.size()<16)
		{
			return niceNotifyError(String::Build("Unsufficient data, got ", data.size(), " bytes"));
		}
		if (data[0]!=0x42 || data[1]!=0x75 || data[2]!=0x54 || data[3]!=0x54)
		{
			return niceNotifyError("Invalid update format");
		}

		uncompressedLength  = (unsigned char)data[4];
		uncompressedLength |= ((unsigned char)data[5])<<8;
		uncompressedLength |= ((unsigned char)data[6])<<16;
		uncompressedLength |= ((unsigned char)data[7])<<24;

		std::vector<char> res(uncompressedLength);

		int dstate;
		dstate = BZ2_bzBuffToBuffDecompress(res.data(), (unsigned *)&uncompressedLength, &data[8], data.size()-8, 0, 0);
		if (dstate)
		{
			return niceNotifyError(String::Build("Unable to decompress update: ", dstate));
		}

		notifyStatus("Applying update");
		notifyProgress(-1);

		prefs.Set("version.update", true);
		if (!Platform::UpdateStart(res))
		{
			prefs.Set("version.update", false);
			Platform::UpdateCleanup();
			notifyError("Update failed - try downloading a new version.");
			return false;
		}

		return true;
	}
};

UpdateActivity::UpdateActivity(UpdateInfo info)
{
	updateDownloadTask = new UpdateDownloadTask(info.file, this);
	updateWindow = new TaskWindow("Downloading update...", updateDownloadTask, true);
}

void UpdateActivity::NotifyDone(Task * sender)
{
	if(sender->GetSuccess())
	{
		Exit();
	}
}

void UpdateActivity::Exit()
{
	updateWindow->Exit();
	ui::Engine::Ref().Exit();
	delete this;
}

void UpdateActivity::NotifyError(Task * sender)
{
	StringBuilder sb;
	if constexpr (USE_UPDATESERVER)
	{
		sb << "Please go online to manually download a newer version.\n";
	}
	else
	{
		sb << "Please visit the website to download a newer version.\n";
	}
	sb << "Error: " << sender->GetError();
	new ConfirmPrompt("Autoupdate failed", sb.Build(), { [this] {
		if constexpr (!USE_UPDATESERVER)
		{
			Platform::OpenURI(ByteString::Build(SERVER, "/Download.html"));
		}
		Exit();
	}, [this] { Exit(); } });
}


UpdateActivity::~UpdateActivity() {
}


=== src\gui\update\UpdateActivity.h ===

#pragma once
#include "client/StartupInfo.h"

class Task;
class TaskWindow;
class UpdateActivity
{
	Task * updateDownloadTask;
	TaskWindow * updateWindow;
public:
	UpdateActivity(UpdateInfo info);
	virtual ~UpdateActivity();
	void Exit();
	virtual void NotifyDone(Task * sender);
	virtual void NotifyError(Task * sender);
};


=== src\lua\CommandInterface.cpp ===

#include "CommandInterface.h"
#include "Misc.h"
#include "gui/game/GameModel.h"
#include "simulation/Particle.h"
#include "Format.h"
#include "simulation/Simulation.h"
#include "simulation/Air.h"
#include "simulation/ElementClasses.h"
#include "gui/game/GameController.h"
#include "gui/game/GameModel.h"
#include "gui/interface/Engine.h"
#include "common/tpt-compat.h"
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <deque>

CommandInterface::CommandInterface(GameController *newGameController, GameModel *newGameModel)
{
	this->m = newGameModel;
	this->c = newGameController;
}

void CommandInterface::Log(LogType type, String message)
{
	m->Log(message, type == LogError || type == LogNotice);
}

static std::optional<int> GetPropertyOffset(ByteString key)
{
	for (auto &alias : Particle::GetPropertyAliases())
	{
		if (key == alias.from)
		{
			key = alias.to;
		}
	}
	auto &properties = Particle::GetProperties();
	for (int i = 0; i < int(properties.size()); ++i)
	{
		auto &prop = properties[i];
		if (key == prop.Name)
		{
			return i;
		}
	}
	return std::nullopt;
}

String CommandInterface::GetLastError()
{
	return lastError;
}

int CommandInterface::PlainCommand(String command)
{
	lastError = "";
	std::deque<String> words;
	std::deque<AnyType> commandWords;
	int retCode = -1;

	//Split command into words, put them on the stack
	for(String word : command.PartitionBy(' '))
		words.push_back(word);
	while(!words.empty())
	{
		try
		{
			commandWords.push_back(eval(&words));
		}
		catch (GeneralException & e)
		{
			retCode = -1;
			lastError = e.GetExceptionMessage();
			break;
		}
	}
	if(commandWords.size())
	{
		retCode = 0;
		lastError = ((StringType)commandWords.front()).Value();
	}

	//Evaluate
	return retCode;
}

struct Function
{
	const char32_t *name;
	AnyType (CommandInterface::*member)(std::deque<String> *);
};
static const std::vector<Function> functions = {
	{ U"set"   , &CommandInterface::tptS_set    },
	{ U"get"   , &CommandInterface::tptS_get    },
	{ U"create", &CommandInterface::tptS_create },
	{ U"delete", &CommandInterface::tptS_delete },
	{ U"kill"  , &CommandInterface::tptS_delete },
	{ U"load"  , &CommandInterface::tptS_load   },
	{ U"reset" , &CommandInterface::tptS_reset  },
	{ U"bubble", &CommandInterface::tptS_bubble },
	{ U"quit"  , &CommandInterface::tptS_quit   },
};

ValueType CommandInterface::testType(String word)
{
	size_t i = 0;
	String::value_type const *rawWord = word.c_str();
	//Function
	for (auto &function : functions)
	{
		if (word == function.name)
		{
			return TypeFunction;
		}
	}

	//Basic type
	for (i = 0; i < word.length(); i++)
	{
		if (!(rawWord[i] >= '0' && rawWord[i] <= '9') && !(rawWord[i] == '-' && !i))
		{
			if (rawWord[i] == '.' && rawWord[i+1])
				goto parseFloat;
			else if (rawWord[i] == ',' && rawWord[i+1] >= '0' && rawWord[i+1] <= '9')
				goto parsePoint;
			else if ((rawWord[i] == '#' || (i && rawWord[i-1] == '0' && rawWord[i] == 'x')) &&
				((rawWord[i+1] >= '0' && rawWord[i+1] <= '9')
				|| (rawWord[i+1] >= 'a' && rawWord[i+1] <= 'f')
				|| (rawWord[i+1] >= 'A' && rawWord[i+1] <= 'F')))
				goto parseNumberHex;
			else
				goto parseString;
		}
	}
	return TypeNumber;

parseFloat:
	for (i++; i < word.length(); i++)
		if (!((rawWord[i] >= '0' && rawWord[i] <= '9')))
		{
			goto parseString;
		}
	return TypeFloat;

parseNumberHex:
	for (i++; i < word.length(); i++)
		if (!((rawWord[i] >= '0' && rawWord[i] <= '9') || (rawWord[i] >= 'a' && rawWord[i] <= 'f') || (rawWord[i] >= 'A' && rawWord[i] <= 'F')))
		{
			goto parseString;
		}
	return TypeNumber;

parsePoint:
	for (i++; i < word.length(); i++)
		if (!(rawWord[i] >= '0' && rawWord[i] <= '9'))
		{
			goto parseString;
		}
	return TypePoint;

parseString:
	return TypeString;
}

int CommandInterface::parseNumber(String str)
{
	String::value_type const *stringData = str.c_str();
	char cc;
	int base = 10;
	int currentNumber = 0;
	if (stringData[0] == '#')
	{
		stringData++;
		base = 16;
	}
	else if (stringData[0] == '0' && stringData[1] == 'x')
	{
		stringData+=2;
		base = 16;
	}
	if (base == 16)
	{
		while ((cc = *(stringData++)))
		{
			currentNumber *= base;
			if (cc >= '0' && cc <= '9')
				currentNumber += cc - '0';
			else if (cc >= 'a' && cc <= 'f')
				currentNumber += (cc - 'a') + 10;
			else if (cc >= 'A' && cc <= 'F')
				currentNumber += (cc - 'A') + 10;
			else
				break;
		}
	}
	else
	{
		try
		{
			return str.ToNumber<int>();
		}
		catch (std::exception & e)
		{
			throw GeneralException(ByteString(e.what()).FromUtf8());
		}
	}
	return currentNumber;
}

AnyType CommandInterface::eval(std::deque<String> * words)
{
	if(words->size() < 1)
		return AnyType(TypeNull, ValueValue());
	String word = words->front(); words->pop_front();
	ValueType wordType = testType(word);
	switch(wordType)
	{
	case TypeFunction:
		{
			auto it = std::find_if(functions.begin(), functions.end(), [&word](auto &func) {
				return func.name == word;
			});
			return (this->*(it->member))(words);
		}
		break;
	case TypeNumber:
		return NumberType(parseNumber(word));
	case TypeFloat:
		return FloatType(atof(word.ToUtf8().c_str()));
	case TypePoint:
	{
		int x, y;
		if(String::Split comma = word.SplitNumber(x))
			if(comma.After().BeginsWith(","))
				if(comma.After().Substr(1).SplitNumber(y))
					return PointType(x, y);
		return PointType(0, 0);
	}
	case TypeString:
		return StringType(word);
	default:
		break;
	}
	return StringType(word);
}

String CommandInterface::PlainFormatCommand(String command)
{
	std::deque<String> words;
	std::deque<AnyType> commandWords;
	String outputData;

	//Split command into words, put them on the stack
	for(String word : command.PartitionBy(' ', true))
		words.push_back(word);
	while(!words.empty())
	{
		ValueType cType = testType(words.front());
		switch(cType)
		{
		case TypeFunction:
			outputData += "\bt";
			break;
		case TypeNumber:
		case TypePoint:
			outputData += "\bo";
			break;
		case TypeString:
			outputData += "\bg";
			break;
		default:
			outputData += "\bw";
			break;
		}
		outputData += words.front() + " ";
		words.pop_front();
	}
	return outputData;
}

static std::vector<int> EvaluateSelector(Simulation *sim, AnyType selector)
{
	auto &sd = SimulationData::CRef();
	std::vector<int> indices;
	if (selector.GetType() == TypePoint || selector.GetType() == TypeNumber)
	{
		int partIndex = -1;
		if(selector.GetType() == TypePoint)
		{
			ui::Point tempPoint = ((PointType)selector).Value();
			if(tempPoint.X<0 || tempPoint.Y<0 || tempPoint.Y >= YRES || tempPoint.X >= XRES)
				throw GeneralException("Invalid position");

			auto r = sim->pmap[tempPoint.Y][tempPoint.X];
			if (!r)
			{
				r = sim->photons[tempPoint.Y][tempPoint.X];
			}
			if (r)
			{
				partIndex = ID(r);
			}
		}
		else
			partIndex = ((NumberType)selector).Value();
		if(partIndex<0 || partIndex>=NPART || sim->parts[partIndex].type==0)
			throw GeneralException("Invalid particle");

		indices.push_back(partIndex);
	}
	else if (selector.GetType() == TypeString && ((StringType)selector).Value() == "all")
	{
		for(int j = 0; j < NPART; j++)
		{
			if(sim->parts[j].type)
			{
				indices.push_back(j);
			}
		}
	}
	else if(selector.GetType() == TypeString || selector.GetType() == TypeNumber)
	{
		int type = 0;
		if (selector.GetType() == TypeNumber)
			type = ((NumberType)selector).Value();
		else if (selector.GetType() == TypeString)
			type = sd.GetParticleType(((StringType)selector).Value().ToUtf8());

		if (type<0 || type>=PT_NUM)
			throw GeneralException("Invalid particle type");
		if (type==0)
			throw GeneralException("Cannot access properties of particles that do not exist");
		for (int j = 0; j < NPART; j++)
		{
			if (sim->parts[j].type == type)
			{
				indices.push_back(j);
			}
		}
	}
	else
		throw GeneralException("Invalid selector");
	return indices;
}

AnyType CommandInterface::tptS_set(std::deque<String> * words)
{
	//Arguments from stack
	StringType property = eval(words);
	AnyType selector = eval(words);
	AnyType value = eval(words);

	Simulation * sim = m->GetSimulation();
	auto prop = GetPropertyOffset(property.Value().ToUtf8());
	if (!prop)
	{
		throw GeneralException("Invalid property");
	}
	auto &propInfo = Particle::GetProperties()[*prop];

	// convert non-string temperature values to strings so format::StringToTemperature can take care of them
	if (property.Value() == "temp")
	{
		switch (value.GetType())
		{
			case TypeNumber:
				value = StringType(String::Build(((NumberType)value).Value()));
			break;
			case TypeFloat:
				value = StringType(String::Build(((FloatType)value).Value()));
			break;
			default:
				break;
		}
	}
	// assume that value can be anything
	if (value.GetType() == TypeNumber && propInfo.Type == StructProperty::Float)
	{
		value = FloatType(float(NumberType(value).Value()));
	}
	if (value.GetType() == TypeFloat && propInfo.Type != StructProperty::Float)
	{
		value = NumberType(int(FloatType(value).Value()));
	}
	// value can still be almost anything, but if it was NumberType or FloatType,
	// at least it now matches the float-ness, if not the signedness, of prop
	AccessProperty changeProperty;
	try
	{
		switch (value.GetType())
		{
		case TypeNumber:
			// get a number (an int) => take an int
			changeProperty.propertyIndex = *prop;
			changeProperty.propertyValue = NumberType(value).Value();
			if (propInfo.Type == StructProperty::UInteger)
			{
				// actually want an unsigned int => convert the int taken to one
				changeProperty.propertyValue = static_cast<unsigned int>(std::get<int>(changeProperty.propertyValue));
			}
			break;

		case TypeFloat:
			// get a float => take a float
			changeProperty.propertyIndex = *prop;
			changeProperty.propertyValue = FloatType(value).Value();
			break;

		case TypeString:
			// AccessProperty::Parse returns the appropriate variant
			changeProperty = AccessProperty::Parse(*prop, StringType(value).Value());
			break;

		default:
			// get something else => bail
			throw GeneralException("Invalid property value");
		}
	}
	catch (const AccessProperty::ParseError &ex)
	{
		// TODO: add element CAKE to invalidate this
		if (value.GetType() == TypeString && StringType(value).Value().ToUpper() == "CAKE")
		{
			throw GeneralException("Cake is a lie, not an element");
		}
		throw GeneralException(ByteString(ex.what()).FromUtf8());
	}

	int returnValue = 0;
	for (auto index : EvaluateSelector(sim, selector))
	{
		returnValue++;
		changeProperty.Set(sim, index);
	}
	return NumberType(returnValue);
}

AnyType CommandInterface::tptS_get(std::deque<String> * words)
{
	StringType property = eval(words);
	AnyType selector = eval(words);

	Simulation *sim = m->GetSimulation();
	auto prop = GetPropertyOffset(property.Value().ToUtf8());
	if (!prop)
	{
		throw GeneralException("Invalid property");
	}
	auto &propInfo = Particle::GetProperties()[*prop];
	AccessProperty accessProperty{ *prop };

	auto indices = EvaluateSelector(sim, selector);
	if (indices.size() > 1)
	{
		throw GeneralException("Multiple matching particles");
	}
	if (indices.size() < 1)
	{
		throw GeneralException("No matching particles");
	}

	auto value = accessProperty.Get(sim, indices[0]);
	switch (propInfo.Type)
	{
	case StructProperty::Float:
		return FloatType(std::get<float>(value));

	case StructProperty::UInteger:
		return NumberType(std::get<unsigned int>(value));

	default:
		break;
	}
	return NumberType(std::get<int>(value));
}

AnyType CommandInterface::tptS_create(std::deque<String> * words)
{
	auto &sd = SimulationData::CRef();
	//Arguments from stack
	AnyType createType = eval(words);
	PointType position = eval(words);

	Simulation * sim = m->GetSimulation();

	int type;
	if(createType.GetType() == TypeNumber)
		type = ((NumberType)createType).Value();
	else if(createType.GetType() == TypeString)
		type = sd.GetParticleType(((StringType)createType).Value().ToUtf8());
	else
		throw GeneralException("Invalid type");

	if(type == -1)
		throw GeneralException("Invalid particle type");

	ui::Point tempPoint = position.Value();
	if(tempPoint.X<0 || tempPoint.Y<0 || tempPoint.Y >= YRES || tempPoint.X >= XRES)
				throw GeneralException("Invalid position");

	int v = -1;
	if (ID(type))
	{
		v = ID(type);
		type = TYP(type);
	}
	int returnValue = sim->create_part(-1, tempPoint.X, tempPoint.Y, type, v);

	return NumberType(returnValue);
}

AnyType CommandInterface::tptS_delete(std::deque<String> * words)
{
	//Arguments from stack
	AnyType partRef = eval(words);

	Simulation * sim = m->GetSimulation();

	if(partRef.GetType() == TypePoint)
	{
		ui::Point deletePoint = ((PointType)partRef).Value();
		if(deletePoint.X<0 || deletePoint.Y<0 || deletePoint.Y >= YRES || deletePoint.X >= XRES)
			throw GeneralException("Invalid position");
		sim->delete_part(deletePoint.X, deletePoint.Y);
	}
	else if(partRef.GetType() == TypeNumber)
	{
		int partIndex = ((NumberType)partRef).Value();
		if(partIndex < 0 || partIndex >= NPART)
			throw GeneralException("Invalid particle index");
		sim->kill_part(partIndex);
	}
	else
		throw GeneralException("Invalid particle reference");

	return NumberType(0);
}

AnyType CommandInterface::tptS_load(std::deque<String> * words)
{
	//Arguments from stack
	NumberType saveID = eval(words);

	if (saveID.Value() > 0)
	{
		c->OpenSavePreview(saveID.Value(), 0, savePreviewNormal);
		return NumberType(0);
	}
	else
		throw GeneralException("Invalid save ID");
}

AnyType CommandInterface::tptS_bubble(std::deque<String> * words)
{
	//Arguments from stack
	PointType bubblePosA = eval(words);
	ui::Point bubblePos = bubblePosA.Value();

	if(bubblePos.X<0 || bubblePos.Y<0 || bubblePos.Y >= YRES || bubblePos.X >= XRES)
			throw GeneralException("Invalid position");

	Simulation * sim = m->GetSimulation();

	int first, rem1, rem2;

	first = sim->create_part(-1, bubblePos.X+18, bubblePos.Y, PT_SOAP);
	rem1 = first;

	for (int i = 1; i<=30; i++)
	{
		rem2 = sim->create_part(-1, int(bubblePos.X+18*cosf(i/5.0)+0.5f), int(bubblePos.Y+18*sinf(i/5.0)+0.5f), PT_SOAP);

		sim->parts[rem1].ctype = 7;
		sim->parts[rem1].tmp = rem2;
		sim->parts[rem2].tmp2 = rem1;

		rem1 = rem2;
	}

	sim->parts[rem1].ctype = 7;
	sim->parts[rem1].tmp = first;
	sim->parts[first].tmp2 = rem1;
	sim->parts[first].ctype = 7;

	return NumberType(0);
}

AnyType CommandInterface::tptS_reset(std::deque<String> * words)
{
	auto &sd = SimulationData::CRef();
	//Arguments from stack
	StringType reset = eval(words);
	String resetStr = reset.Value();

	Simulation * sim = m->GetSimulation();

	if (resetStr == "pressure")
	{
		for (int nx = 0; nx < XCELLS; nx++)
			for (int ny = 0; ny < YCELLS; ny++)
			{
				sim->pv[ny][nx] = 0;
			}
	}
	else if (resetStr == "velocity")
	{
		for (int nx = 0; nx < XCELLS; nx++)
			for (int ny = 0; ny < YCELLS; ny++)
			{
				sim->vx[ny][nx] = 0;
				sim->vy[ny][nx] = 0;
			}
	}
	else if (resetStr == "sparks")
	{
		c->ResetSpark();
	}
	else if (resetStr == "temp")
	{
		for (int i = 0; i < NPART; i++)
		{
			if (sim->parts[i].type)
			{
				sim->parts[i].temp = sd.elements[sim->parts[i].type].DefaultProperties.temp;
			}
		}
	}
	else
	{
		throw GeneralException("Unknown reset command");
	}

	return NumberType(0);
}

AnyType CommandInterface::tptS_quit(std::deque<String> * words)
{
	ui::Engine::Ref().Exit();

	return NumberType(0);
}


=== src\lua\CommandInterface.h ===

#pragma once
#include "CommandInterfacePtr.h"
#include "common/ExplicitSingleton.h"
#include "common/String.h"
#include "gui/game/GameControllerEvents.h"
#include "TPTSTypes.h"
#include <deque>
#include <optional>

class GameModel;
class GameController;
class Tool;

class CommandInterface : public ExplicitSingleton<CommandInterface>
{
protected:
	String lastError;
	GameModel * m;
	GameController * c;


	int PlainCommand(String command);
	String PlainFormatCommand(String command);

public:
	CommandInterface(GameController *newGameController, GameModel *newGameModel);

	enum LogType { LogError, LogWarning, LogNotice };
	enum FormatType { FormatInt, FormatString, FormatChar, FormatFloat, FormatElement };
	void Log(LogType type, String message);
	//void AttachGameModel(GameModel * m);

	void OnTick();
	void Init();

	bool HandleEvent(const GameControllerEvent &event);
	bool HaveSimGraphicsEventHandlers();

	int Command(String command);
	String FormatCommand(String command);
	void SetLastError(String err)
	{
		lastError = err;
	}
	String GetLastError();

	AnyType eval(std::deque<String> * words);
	int parseNumber(String str);
	AnyType tptS_set(std::deque<String> * words);
	AnyType tptS_get(std::deque<String> * words);
	AnyType tptS_create(std::deque<String> * words);
	AnyType tptS_delete(std::deque<String> * words);
	AnyType tptS_load(std::deque<String> * words);
	AnyType tptS_reset(std::deque<String> * words);
	AnyType tptS_bubble(std::deque<String> * words);
	AnyType tptS_quit(std::deque<String> * words);
	ValueType testType(String word);

	void SetToolIndex(ByteString identifier, std::optional<int> index);
	void RemoveComponents();

	static CommandInterfacePtr Create(GameController *newGameController, GameModel *newGameModel);
};


=== src\lua\CommandInterfacePtr.h ===

#pragma once
#include <memory>

class CommandInterface;
struct CommandInterfaceDeleter
{
	void operator ()(CommandInterface *ptr) const;
};
using CommandInterfacePtr = std::unique_ptr<CommandInterface, CommandInterfaceDeleter>;


=== src\lua\LuaBit.cpp ===

/*
** Lua BitOp -- a bit operations library for Lua 5.1/5.2.
** http://bitop.luajit.org/
**
** Copyright (C) 2008-2012 Mike Pall. All rights reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining
** a copy of this software and associated documentation files (the
** "Software"), to deal in the Software without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Software, and to
** permit persons to whom the Software is furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be
** included in all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**
** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]
*/
#include "LuaBit.h"

#define LUA_BITOP_VERSION	"1.0.2"

#include "LuaCompat.h"

#ifdef _MSC_VER
/* MSVC is stuck in the last century and doesn't have C99's stdint.h. */
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
#include <cstdint>
#endif

typedef int32_t SBits;
typedef uint32_t UBits;

typedef union {
  lua_Number n;
#ifdef LUA_NUMBER_DOUBLE
  uint64_t b;
#else
  UBits b;
#endif
} BitNum;

/* Convert argument to bit type. */
static UBits barg(lua_State *L, int idx)
{
  BitNum bn;
  UBits b;
#if LUA_VERSION_NUM < 502
  bn.n = lua_tonumber(L, idx);
#else
  bn.n = luaL_checknumber(L, idx);
#endif
#if defined(LUA_NUMBER_DOUBLE)
  bn.n += 6755399441055744.0;  /* 2^52+2^51 */
#ifdef SWAPPED_DOUBLE
  b = (UBits)(bn.b >> 32);
#else
  b = (UBits)bn.b;
#endif
#elif defined(LUA_NUMBER_INT) || defined(LUA_NUMBER_LONG) || \
      defined(LUA_NUMBER_LONGLONG) || defined(LUA_NUMBER_LONG_LONG) || \
      defined(LUA_NUMBER_LLONG)
  if (sizeof(UBits) == sizeof(lua_Number))
    b = bn.b;
  else
    b = (UBits)(SBits)bn.n;
#elif defined(LUA_NUMBER_FLOAT)
#error "A 'float' lua_Number type is incompatible with this library"
#else
#error "Unknown number type, check LUA_NUMBER_* in luaconf.h"
#endif
#if LUA_VERSION_NUM < 502
  if (b == 0 && !lua_isnumber(L, idx)) {
    luaL_typerror(L, idx, "number");
  }
#endif
  return b;
}

/* Return bit type. */
#define BRET(b)  lua_pushnumber(L, (lua_Number)(SBits)(b)); return 1;

static int bit_tobit(lua_State *L) { BRET(barg(L, 1)) }
static int bit_bnot(lua_State *L) { BRET(~barg(L, 1)) }

#define BIT_OP(func, opr) \
  static int func(lua_State *L) { int i; UBits b = barg(L, 1); \
    for (i = lua_gettop(L); i > 1; i--) b opr barg(L, i); \
    BRET(b) \
  }
BIT_OP(bit_band, &=)
BIT_OP(bit_bor, |=)
BIT_OP(bit_bxor, ^=)

#define bshl(b, n)  (b << n)
#define bshr(b, n)  (b >> n)
#define bsar(b, n)  ((SBits)b >> n)
#define brol(b, n)  ((b << n) | (b >> (32-n)))
#define bror(b, n)  ((b << (32-n)) | (b >> n))
#define BIT_SH(func, fn) \
  static int func(lua_State *L) { \
    UBits b = barg(L, 1); UBits n = barg(L, 2) & 31; BRET(fn(b, n)) }
BIT_SH(bit_lshift, bshl)
BIT_SH(bit_rshift, bshr)
BIT_SH(bit_arshift, bsar)
BIT_SH(bit_rol, brol)
BIT_SH(bit_ror, bror)

static int bit_bswap(lua_State *L)
{
  UBits b = barg(L, 1);
  b = (b >> 24) | ((b >> 8) & 0xff00) | ((b & 0xff00) << 8) | (b << 24);
  BRET(b)
}

static int bit_tohex(lua_State *L)
{
  UBits b = barg(L, 1);
  SBits n = lua_isnone(L, 2) ? 8 : (SBits)barg(L, 2);
  const char *hexdigits = "0123456789abcdef";
  char buf[8];
  int i;
  if (n < 0) { n = -n; hexdigits = "0123456789ABCDEF"; }
  if (n > 8) n = 8;
  for (i = (int)n; --i >= 0; ) { buf[i] = hexdigits[b & 15]; b >>= 4; }
  lua_pushlstring(L, buf, (size_t)n);
  return 1;
}

static const struct luaL_Reg bit_funcs[] = {
  { "tobit",	bit_tobit },
  { "bnot",	bit_bnot },
  { "band",	bit_band },
  { "bor",	bit_bor },
  { "bxor",	bit_bxor },
  { "lshift",	bit_lshift },
  { "rshift",	bit_rshift },
  { "arshift",	bit_arshift },
  { "rol",	bit_rol },
  { "ror",	bit_ror },
  { "bswap",	bit_bswap },
  { "tohex",	bit_tohex },
  { nullptr, nullptr }
};

/* Signed right-shifts are implementation-defined per C89/C99.
** But the de facto standard are arithmetic right-shifts on two's
** complement CPUs. This behaviour is required here, so test for it.
*/
#define BAD_SAR		(bsar(-8, 2) != (SBits)-2)

int luaopen_bit(lua_State *L)
{
  UBits b;
  lua_pushnumber(L, (lua_Number)1437217655L);
  b = barg(L, -1);
  if (b != (UBits)1437217655L || BAD_SAR) {  /* Perform a simple self-test. */
    const char *msg = "compiled with incompatible luaconf.h";
#ifdef LUA_NUMBER_DOUBLE
#ifdef _WIN32
    if (b == (UBits)1610612736L)
      msg = "use D3DCREATE_FPU_PRESERVE with DirectX";
#endif
    if (b == (UBits)1127743488L)
      msg = "not compiled with SWAPPED_DOUBLE";
#endif
    if (BAD_SAR)
      msg = "arithmetic right-shift broken";
    luaL_error(L, "bit library self-test failed (%s)", msg);
  }
//#if LUA_VERSION_NUM < 502
  luaL_register(L, "bit", bit_funcs);
//#else
//  luaL_newlib(L, bit_funcs);
//#endif
  return 1;
}


=== src\lua\LuaBit.h ===

/*
** Lua BitOp -- a bit operations library for Lua 5.1/5.2.
** http://bitop.luajit.org/
**
** Copyright (C) 2008-2012 Mike Pall. All rights reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining
** a copy of this software and associated documentation files (the
** "Software"), to deal in the Software without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Software, and to
** permit persons to whom the Software is furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be
** included in all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**
** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]
*/

#pragma once

#define LUA_BITOP_VERSION	"1.0.2"

struct lua_State;
extern "C" int luaopen_bit(lua_State *L);



=== src\lua\LuaButton.cpp ===

#include "LuaButton.h"
#include "LuaScriptInterface.h"
#include "gui/interface/Button.h"

const char LuaButton::className[] = "button";

#define method(class, name) {#name, &class::name}
Luna<LuaButton>::RegType LuaButton::methods[] = {
	method(LuaButton, action),
	method(LuaButton, text),
	method(LuaButton, position),
	method(LuaButton, size),
	method(LuaButton, visible),
	method(LuaButton, enabled),
	{nullptr, nullptr}
};

LuaButton::LuaButton(lua_State *L) :
	LuaComponent(L)
{
	int posX = luaL_optinteger(L, 1, 0);
	int posY = luaL_optinteger(L, 2, 0);
	int sizeX = luaL_optinteger(L, 3, 10);
	int sizeY = luaL_optinteger(L, 4, 10);
	String text = tpt_lua_optString(L, 5, "");
	String toolTip = tpt_lua_optString(L, 6, "");

	button = new ui::Button(ui::Point(posX, posY), ui::Point(sizeX, sizeY), text, toolTip);
	component = button;
	button->SetActionCallback({ [this] { triggerAction(); } });
}

int LuaButton::enabled(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		luaL_checktype(L, 1, LUA_TBOOLEAN);
		button->Enabled = lua_toboolean(L, 1);
		return 0;
	}
	else
	{
		lua_pushboolean(L, button->Enabled);
		return 1;
	}
}

int LuaButton::action(lua_State *L)
{
	return actionFunction.CheckAndAssignArg1(L);
}

int LuaButton::text(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		button->SetText(tpt_lua_checkString(L, 1));
		return 0;
	}
	else
	{
		tpt_lua_pushString(L, button->GetText());
		return 1;
	}
}

void LuaButton::triggerAction()
{
	if(actionFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, actionFunction);
		lua_rawgeti(L, LUA_REGISTRYINDEX, owner_ref);
		if (tpt_lua_pcall(L, 1, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

LuaButton::~LuaButton()
{
}


=== src\lua\LuaButton.h ===

#pragma once

#include "LuaLuna.h"
#include "LuaComponent.h"

namespace ui
{
	class Button;
}

class LuaScriptInterface;

class LuaButton: public LuaComponent
{
	ui::Button * button;
	LuaComponentCallback actionFunction;
	void triggerAction();
	int action(lua_State *L);
	int text(lua_State *L);
	int enabled(lua_State *L);
public:
	static const char className[];
	static Luna<LuaButton>::RegType methods[];

	LuaButton(lua_State *L);
	~LuaButton();
};


=== src\lua\LuaBz2.cpp ===

#include "LuaScriptInterface.h"
#include "bzip2/bz2wrap.h"

static int compress(lua_State *L)
{
	auto src = tpt_lua_checkByteString(L, 1);
	auto maxSize = size_t(luaL_optinteger(L, 2, 0));
	std::vector<char> dest;
	auto result = BZ2WCompress(dest, src, maxSize);
#define RETURN_ERR(str) lua_pushnil(L); lua_pushinteger(L, int(result)); lua_pushliteral(L, str); return 3
	switch (result)
	{
	case BZ2WCompressOk: break;
	case BZ2WCompressNomem: RETURN_ERR("out of memory");
	case BZ2WCompressLimit: RETURN_ERR("size limit exceeded");
	}
#undef RETURN_ERR
	tpt_lua_pushByteString(L, ByteString(dest.begin(), dest.end()));
	return 1;
}

static int decompress(lua_State *L)
{
	auto src = tpt_lua_checkByteString(L, 1);
	auto maxSize = size_t(luaL_optinteger(L, 2, 0));
	std::vector<char> dest;
	auto result = BZ2WDecompress(dest, src, maxSize);
#define RETURN_ERR(str) lua_pushnil(L); lua_pushinteger(L, int(result)); lua_pushliteral(L, str); return 3
	switch (result)
	{
	case BZ2WDecompressOk: break;
	case BZ2WDecompressNomem: RETURN_ERR("out of memory");
	case BZ2WDecompressLimit: RETURN_ERR("size limit exceeded");
	case BZ2WDecompressType:
	case BZ2WDecompressBad:
	case BZ2WDecompressEof: RETURN_ERR("corrupted stream");
	}
#undef RETURN_ERR
	tpt_lua_pushByteString(L, ByteString(dest.begin(), dest.end()));
	return 1;
}

void LuaBz2::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(compress),
		LFUNC(decompress),
#undef LFUNC
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
#define LCONSTAS(k, v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, k)
	LCONSTAS("COMPRESS_NOMEM"  , BZ2WCompressNomem  );
	LCONSTAS("COMPRESS_LIMIT"  , BZ2WCompressLimit  );
	LCONSTAS("DECOMPRESS_NOMEM", BZ2WDecompressNomem);
	LCONSTAS("DECOMPRESS_LIMIT", BZ2WDecompressLimit);
	LCONSTAS("DECOMPRESS_TYPE" , BZ2WDecompressType );
	LCONSTAS("DECOMPRESS_BAD"  , BZ2WDecompressBad  );
	LCONSTAS("DECOMPRESS_EOF"  , BZ2WDecompressEof  );
#undef LCONSTAS
	lua_setglobal(L, "bz2");
}


=== src\lua\LuaCheckbox.cpp ===

#include "LuaCheckbox.h"
#include "LuaScriptInterface.h"
#include "gui/interface/Checkbox.h"

const char LuaCheckbox::className[] = "checkbox";

#define method(class, name) {#name, &class::name}
Luna<LuaCheckbox>::RegType LuaCheckbox::methods[] = {
	method(LuaCheckbox, action),
	method(LuaCheckbox, text),
	method(LuaCheckbox, position),
	method(LuaCheckbox, size),
	method(LuaCheckbox, visible),
	method(LuaCheckbox, checked),
	{nullptr, nullptr}
};

LuaCheckbox::LuaCheckbox(lua_State *L) :
	LuaComponent(L)
{
	int posX = luaL_optinteger(L, 1, 0);
	int posY = luaL_optinteger(L, 2, 0);
	int sizeX = luaL_optinteger(L, 3, 10);
	int sizeY = luaL_optinteger(L, 4, 10);
	String text = tpt_lua_optString(L, 5, "");

	checkbox = new ui::Checkbox(ui::Point(posX, posY), ui::Point(sizeX, sizeY), text, "");
	component = checkbox;
	checkbox->SetActionCallback({ [this] { triggerAction(); } });
}

int LuaCheckbox::checked(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		checkbox->SetChecked(lua_toboolean(L, 1));
		return 0;
	}
	else
	{
		lua_pushboolean(L, checkbox->GetChecked());
		return 1;
	}
}

int LuaCheckbox::action(lua_State *L)
{
	return actionFunction.CheckAndAssignArg1(L);
}

int LuaCheckbox::text(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		checkbox->SetText(tpt_lua_checkString(L, 1));
		return 0;
	}
	else
	{
		tpt_lua_pushString(L, checkbox->GetText());
		return 1;
	}
}

void LuaCheckbox::triggerAction()
{
	if(actionFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, actionFunction);
		lua_rawgeti(L, LUA_REGISTRYINDEX, owner_ref);
		lua_pushboolean(L, checkbox->GetChecked());
		if (tpt_lua_pcall(L, 2, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

LuaCheckbox::~LuaCheckbox()
{
}


=== src\lua\LuaCheckbox.h ===

#pragma once

#include "LuaLuna.h"
#include "LuaComponent.h"

namespace ui
{
	class Checkbox;
}

class LuaScriptInterface;

class LuaCheckbox: public LuaComponent
{
	ui::Checkbox * checkbox;
	LuaComponentCallback actionFunction;
	void triggerAction();
	int action(lua_State *L);
	int checked(lua_State *L);
	int text(lua_State *L);
public:
	static const char className[];
	static Luna<LuaCheckbox>::RegType methods[];

	LuaCheckbox(lua_State *L);
	~LuaCheckbox();
};


=== src\lua\LuaCompat.cpp ===

#include "LuaCompat.h"

extern "C"
{
#if LUA_VERSION_NUM >= 502
// Implement missing luaL_typerror function
int luaL_typerror(lua_State *L, int narg, const char *tname)
{
	const char *msg = lua_pushfstring(L, "%s expected, got %s", tname, luaL_typename(L, narg));
	return luaL_argerror(L, narg, msg);
}

void luaL_register(lua_State *L, const char *libname, const luaL_Reg *l)
{
	if (libname)
	{
		lua_newtable(L);
		lua_pushvalue(L, -1);
		lua_setglobal(L, libname);
	}
	luaL_setfuncs(L, l, 0);
}
#else
# ifndef lua_pushglobaltable // * Thank you moonjit
// Implement function added in lua 5.2 that we now use
void lua_pushglobaltable(lua_State *L)
{
	lua_pushvalue(L, LUA_GLOBALSINDEX);
}
# endif
#endif
}


=== src\lua\LuaCompat.h ===

#pragma once

extern "C"
{

#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#if LUA_VERSION_NUM >= 502
void luaL_register(lua_State *L, const char *libname, const luaL_Reg *l);
#define lua_strlen(L,i) lua_rawlen(L, (i))
#define lua_objlen(L,i) lua_rawlen(L, (i))
#define lua_equal(L,idx1,idx2) lua_compare(L,(idx1),(idx2),LUA_OPEQ)
#define lua_lessthan(L,idx1,idx2) lua_compare(L,(idx1),(idx2),LUA_OPLT)

LUALIB_API int (luaL_typerror) (lua_State *L, int narg, const char *tname);
#else
# ifndef lua_pushglobaltable // * Thank you moonjit
LUALIB_API void (lua_pushglobaltable) (lua_State *L);
# endif
#endif

}


=== src\lua\LuaComponent.cpp ===

#include "LuaComponent.h"
#include "LuaScriptInterface.h"
#include "LuaWindow.h"
#include "gui/interface/Component.h"
#include "gui/interface/Window.h"

int LuaComponentCallback::CheckAndAssignArg1(lua_State *L)
{
	if (lua_type(L, 1) != LUA_TNIL)
	{
		luaL_checktype(L, 1, LUA_TFUNCTION);
	}
	LuaSmartRef::Assign(L, 1);
	return 0;
}

LuaComponent::LuaComponent(lua_State *L) : component(nullptr), owner_ref(LUA_REFNIL)
{
	this->L = L; // I don't get how this doesn't cause crashes later on
	
	ci = static_cast<LuaScriptInterface *>(&CommandInterface::Ref());
}

int LuaComponent::position(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		luaL_checktype(L, 1, LUA_TNUMBER);
		luaL_checktype(L, 2, LUA_TNUMBER);
		component->Position = ui::Point(lua_tointeger(L, 1), lua_tointeger(L, 2));
		return 0;
	}
	else
	{
		lua_pushinteger(L, component->Position.X);
		lua_pushinteger(L, component->Position.Y);
		return 2;
	}
}

int LuaComponent::size(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		luaL_checktype(L, 1, LUA_TNUMBER);
		luaL_checktype(L, 2, LUA_TNUMBER);
		component->Size = ui::Point(lua_tointeger(L, 1), lua_tointeger(L, 2));
		component->Invalidate();
		return 0;
	}
	else
	{
		lua_pushinteger(L, component->Size.X);
		lua_pushinteger(L, component->Size.Y);
		return 2;
	}
}

int LuaComponent::visible(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		luaL_checktype(L, 1, LUA_TBOOLEAN);
		component->Visible = lua_toboolean(L, 1);
		return 0;
	}
	else
	{
		lua_pushboolean(L, component->Visible);
		return 1;
	}
}

LuaComponent::~LuaComponent()
{
	if (parent)
		parent->ClearRef(this);

	if (component)
	{
		if (component->GetParentWindow())
			component->GetParentWindow()->RemoveComponent(component);
		delete component;
	}
}


=== src\lua\LuaComponent.h ===

#pragma once

#include "LuaLuna.h"
#include "LuaSmartRef.h"

namespace ui
{
	class Component;
}

class LuaScriptInterface;
class LuaWindow;

class LuaComponentCallback : public LuaSmartRef
{
public:
	using LuaSmartRef::LuaSmartRef;
	int CheckAndAssignArg1(lua_State *L);
};

class LuaComponent
{
protected:
	ui::Component * component;
	lua_State *L;
	LuaWindow * parent = nullptr;

	int position(lua_State *L);
	int size(lua_State *L);
	int visible(lua_State *L);
public:
	LuaScriptInterface * ci;
	int owner_ref;

	ui::Component * GetComponent() { return component; }
	void SetParentWindow(LuaWindow *parent) { this->parent = parent; }
	LuaComponent(lua_State *L);
	~LuaComponent();
};


=== src\lua\LuaElements.cpp ===

#include "LuaScriptInterface.h"
#include "gui/game/GameModel.h"
#include "simulation/ElementClasses.h"
#include "simulation/ElementCommon.h"
#include "simulation/SimulationData.h"
#include <mutex>

static void getDefaultProperties(lua_State *L, int id)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	lua_newtable(L);
	for (auto &prop : Particle::GetProperties())
	{
		auto propertyAddress = reinterpret_cast<intptr_t>((reinterpret_cast<const unsigned char*>(&elements[id].DefaultProperties)) + prop.Offset);
		tpt_lua_pushByteString(L, prop.Name);
		LuaGetProperty(L, prop, propertyAddress);
		lua_settable(L, -3);
	}
	for (auto &alias : Particle::GetPropertyAliases())
	{
		tpt_lua_pushByteString(L, alias.from);
		tpt_lua_pushByteString(L, alias.to);
		lua_gettable(L, -3);
		lua_settable(L, -3);
	}
}

static void setDefaultProperties(lua_State *L, int id, int stackPos)
{
	auto &sd = SimulationData::Ref();
	auto &elements = sd.elements;
	if (lua_type(L, stackPos) == LUA_TTABLE)
	{
		for (auto &prop : Particle::GetProperties())
		{
			tpt_lua_pushByteString(L, prop.Name);
			lua_gettable(L, stackPos);
			if (lua_type(L, -1) == LUA_TNIL)
			{
				for (auto &alias : Particle::GetPropertyAliases())
				{
					if (alias.to == prop.Name)
					{
						lua_pop(L, 1);
						tpt_lua_pushByteString(L, alias.from);
						lua_gettable(L, stackPos);
					}
				}
			}
			if (lua_type(L, -1) != LUA_TNIL)
			{
				auto propertyAddress = reinterpret_cast<intptr_t>((reinterpret_cast<unsigned char*>(&elements[id].DefaultProperties)) + prop.Offset);
				LuaSetProperty(L, prop, propertyAddress, -1);
			}
			lua_pop(L, 1);
		}
	}
}

static void manageElementIdentifier(lua_State *L, int id, bool add)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (elements[id].Enabled)
	{
		lua_getglobal(L, "elements");
		tpt_lua_pushByteString(L, elements[id].Identifier);
		if (add)
		{
			lua_pushinteger(L, id);
		}
		else
		{
			lua_pushnil(L);
		}
		lua_settable(L, -3);
		if (elements[id].Identifier.BeginsWith("DEFAULT_PT_"))
		{
			ByteString realIdentifier = ByteString::Build("DEFAULT_PT_", elements[id].Name.ToUtf8());
			if (id != 0 && id != PT_NBHL && id != PT_NWHL && elements[id].Identifier != realIdentifier)
			{
				tpt_lua_pushByteString(L, realIdentifier);
				if (add)
				{
					lua_pushinteger(L, id);
				}
				else
				{
					lua_pushnil(L);
				}
				lua_settable(L, -3);
			}
		}
		lua_pop(L, 1);
	}
}

static int luaUpdateWrapper(UPDATE_FUNC_ARGS)
{
	if (!sim->useLuaCallbacks)
	{
		return 0;
	}
	auto *lsi = GetLSI();
	auto &builtinElements = GetElements();
	auto *builtinUpdate = builtinElements[parts[i].type].Update;
	auto &customElements = lsi->customElements;
	if (builtinUpdate && customElements[parts[i].type].updateMode == UPDATE_AFTER)
	{
		if (builtinUpdate(UPDATE_FUNC_SUBCALL_ARGS))
			return 1;
		x = (int)(parts[i].x+0.5f);
		y = (int)(parts[i].y+0.5f);
	}
	if (customElements[parts[i].type].update)
	{
		int retval = 0, callret;
		lua_rawgeti(lsi->L, LUA_REGISTRYINDEX, customElements[parts[i].type].update);
		lua_pushinteger(lsi->L, i);
		lua_pushinteger(lsi->L, x);
		lua_pushinteger(lsi->L, y);
		lua_pushinteger(lsi->L, surround_space);
		lua_pushinteger(lsi->L, nt);
		callret = tpt_lua_pcall(lsi->L, 5, 1, 0, eventTraitSimRng);
		if (callret)
			lsi->Log(CommandInterface::LogError, LuaGetError());
		if(lua_isboolean(lsi->L, -1)){
			retval = lua_toboolean(lsi->L, -1);
		}
		lua_pop(lsi->L, 1);
		if (retval)
		{
			return 1;
		}
		x = (int)(parts[i].x+0.5f);
		y = (int)(parts[i].y+0.5f);
	}
	if (builtinUpdate && customElements[parts[i].type].updateMode == UPDATE_BEFORE)
	{
		if (builtinUpdate(UPDATE_FUNC_SUBCALL_ARGS))
			return 1;
		x = (int)(parts[i].x+0.5f);
		y = (int)(parts[i].y+0.5f);
	}
	return 0;
}

static int luaGraphicsWrapper(GRAPHICS_FUNC_ARGS)
{
	if (!gfctx.sim->useLuaCallbacks)
	{
		return Element::defaultGraphics(GRAPHICS_FUNC_SUBCALL_ARGS);
	}
	auto *lsi = GetLSI();
	auto &customElements = lsi->customElements;
	auto *sim = lsi->sim;
	if (customElements[cpart->type].graphics)
	{
		auto *pipeSubcallWcpart = gfctx.pipeSubcallCpart ? sim->parts + (gfctx.pipeSubcallCpart - gfctx.sim->parts) : nullptr;
		if (pipeSubcallWcpart)
		{
			std::swap(*pipeSubcallWcpart, *gfctx.pipeSubcallTpart);
			cpart = pipeSubcallWcpart;
		}
		int cache = 0, callret;
		int i = cpart - gfctx.sim->parts; // pointer arithmetic be like
		lua_rawgeti(lsi->L, LUA_REGISTRYINDEX, customElements[cpart->type].graphics);
		lua_pushinteger(lsi->L, i);
		lua_pushinteger(lsi->L, *colr);
		lua_pushinteger(lsi->L, *colg);
		lua_pushinteger(lsi->L, *colb);
		callret = tpt_lua_pcall(lsi->L, 4, 10, 0, eventTraitSimGraphics | eventTraitConstSim);
		if (callret)
		{
			lsi->Log(CommandInterface::LogError, LuaGetError());
			lua_pop(lsi->L, 1);
		}
		else
		{
			bool valid = true;
			for (int i = -10; i < 0; i++)
				if (!lua_isnumber(lsi->L, i) && !lua_isnil(lsi->L, i))
				{
					valid = false;
					break;
				}
			if (valid)
			{
				cache = luaL_optint(lsi->L, -10, 0);
				*pixel_mode = luaL_optint(lsi->L, -9, *pixel_mode);
				*cola = luaL_optint(lsi->L, -8, *cola);
				*colr = luaL_optint(lsi->L, -7, *colr);
				*colg = luaL_optint(lsi->L, -6, *colg);
				*colb = luaL_optint(lsi->L, -5, *colb);
				*firea = luaL_optint(lsi->L, -4, *firea);
				*firer = luaL_optint(lsi->L, -3, *firer);
				*fireg = luaL_optint(lsi->L, -2, *fireg);
				*fireb = luaL_optint(lsi->L, -1, *fireb);
			}
			lua_pop(lsi->L, 10);
		}
		if (pipeSubcallWcpart)
		{
			std::swap(*pipeSubcallWcpart, *gfctx.pipeSubcallTpart);
		}
		return cache;
	}
	return 0;
}

static void luaCreateWrapper(ELEMENT_CREATE_FUNC_ARGS)
{
	if (!sim->useLuaCallbacks)
	{
		return;
	}
	auto *lsi = GetLSI();
	auto &customElements = lsi->customElements;
	if (customElements[sim->parts[i].type].create)
	{
		lua_rawgeti(lsi->L, LUA_REGISTRYINDEX, customElements[sim->parts[i].type].create);
		lua_pushinteger(lsi->L, i);
		lua_pushinteger(lsi->L, x);
		lua_pushinteger(lsi->L, y);
		lua_pushinteger(lsi->L, t);
		lua_pushinteger(lsi->L, v);
		lsi->monopartAccessPartID = i;
		if (tpt_lua_pcall(lsi->L, 5, 0, 0, eventTraitSimRng | eventTraitMonopartAccess))
		{
			lsi->Log(CommandInterface::LogError, "In create func: " + LuaGetError());
			lua_pop(lsi->L, 1);
		}
		lsi->monopartAccessPartID = -1;
	}
}

static bool luaCreateAllowedWrapper(ELEMENT_CREATE_ALLOWED_FUNC_ARGS)
{
	if (!sim->useLuaCallbacks)
	{
		// Nothing really bad can happen, no callbacks are allowed anyway. The worst thing that can happen
		// is that a well-crafted save looks odd in previews because it has multiple Element::defaultGraphics-rendered
		// instances of something that should be limited to one instance.
		return 1;
	}
	auto *lsi = GetLSI();
	auto &customElements = lsi->customElements;
	bool ret = false;
	if (customElements[t].createAllowed)
	{
		lua_rawgeti(lsi->L, LUA_REGISTRYINDEX, customElements[t].createAllowed);
		lua_pushinteger(lsi->L, i);
		lua_pushinteger(lsi->L, x);
		lua_pushinteger(lsi->L, y);
		lua_pushinteger(lsi->L, t);
		if (tpt_lua_pcall(lsi->L, 4, 1, 0, eventTraitSimRng | eventTraitConstSim))
		{
			lsi->Log(CommandInterface::LogError, "In create allowed: " + LuaGetError());
			lua_pop(lsi->L, 1);
		}
		else
		{
			if (lua_isboolean(lsi->L, -1))
				ret = lua_toboolean(lsi->L, -1);
			lua_pop(lsi->L, 1);
		}
	}
	return ret;
}

static void luaChangeTypeWrapper(ELEMENT_CHANGETYPE_FUNC_ARGS)
{
	if (!sim->useLuaCallbacks)
	{
		return;
	}
	auto *lsi = GetLSI();
	auto &customElements = lsi->customElements;
	if (customElements[sim->parts[i].type].changeType)
	{
		lua_rawgeti(lsi->L, LUA_REGISTRYINDEX, customElements[sim->parts[i].type].changeType);
		lua_pushinteger(lsi->L, i);
		lua_pushinteger(lsi->L, x);
		lua_pushinteger(lsi->L, y);
		lua_pushinteger(lsi->L, from);
		lua_pushinteger(lsi->L, to);
		lsi->monopartAccessPartID = i;
		if (tpt_lua_pcall(lsi->L, 5, 0, 0, eventTraitSimRng | eventTraitMonopartAccess))
		{
			lsi->Log(CommandInterface::LogError, "In change type: " + LuaGetError());
			lua_pop(lsi->L, 1);
		}
		lsi->monopartAccessPartID = -1;
	}
}

static bool luaCtypeDrawWrapper(CTYPEDRAW_FUNC_ARGS)
{
	if (!sim->useLuaCallbacks)
	{
		return false;
	}
	auto *lsi = GetLSI();
	auto &customElements = lsi->customElements;
	bool ret = false;
	if (customElements[sim->parts[i].type].ctypeDraw)
	{
		lua_rawgeti(lsi->L, LUA_REGISTRYINDEX, customElements[sim->parts[i].type].ctypeDraw);
		lua_pushinteger(lsi->L, i);
		lua_pushinteger(lsi->L, t);
		lua_pushinteger(lsi->L, v);
		if (tpt_lua_pcall(lsi->L, 3, 1, 0, eventTraitSimRng))
		{
			lsi->Log(CommandInterface::LogError, LuaGetError());
			lua_pop(lsi->L, 1);
		}
		else
		{
			if (lua_isboolean(lsi->L, -1))
				ret = lua_toboolean(lsi->L, -1);
			lua_pop(lsi->L, 1);
		}
	}
	return ret;
}

static int allocate(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMutableToolsEvent();
	luaL_checktype(L, 1, LUA_TSTRING);
	luaL_checktype(L, 2, LUA_TSTRING);
	auto group = tpt_lua_toByteString(L, 1).ToUpper();
	auto id = tpt_lua_toByteString(L, 2).ToUpper();

	if (id.Contains("_"))
	{
		return luaL_error(L, "The element name may not contain '_'.");
	}
	if (group.Contains("_"))
	{
		return luaL_error(L, "The group name may not contain '_'.");
	}
	if (group == "DEFAULT")
	{
		return luaL_error(L, "You cannot create elements in the 'DEFAULT' group.");
	}

	auto identifier = group + "_PT_" + id;

	int newID = -1;
	{
		auto &sd = SimulationData::CRef();
		auto &elements = sd.elements;
		for(int i = 0; i < PT_NUM; i++)
		{
			if(elements[i].Enabled && ByteString(elements[i].Identifier) == identifier)
				return luaL_error(L, "Element identifier already in use");
		}

		// Start out at 255 so that lua element IDs are still one byte (better save compatibility)
		for (int i = PT_NUM >= 255 ? 255 : PT_NUM; i >= 0; i--)
		{
			if (!elements[i].Enabled)
			{
				newID = i;
				break;
			}
		}
		// If not enough space, then we start with the new maimum ID
		if (newID == -1)
		{
			for (int i = PT_NUM-1; i >= 255; i--)
			{
				if (!elements[i].Enabled)
				{
					newID = i;
					break;
				}
			}
		}
	}

	if (newID != -1)
	{
		{
			auto &sd = SimulationData::Ref();
			std::unique_lock lk(sd.elementGraphicsMx);
			auto &elements = sd.elements;
			elements[newID] = Element();
			elements[newID].Enabled = true;
			elements[newID].Identifier = identifier;
		}

		lua_getglobal(L, "elements");
		tpt_lua_pushByteString(L, identifier);
		lua_pushinteger(L, newID);
		lua_settable(L, -3);
		lua_pop(L, 1);

		for (auto elem = 0; elem < PT_NUM; ++elem)
		{
			lsi->customCanMove[elem][newID] = 0;
			lsi->customCanMove[newID][elem] = 0;
		}
		lsi->gameModel->AllocElementTool(newID);
		lsi->gameModel->BuildMenus();
		lsi->InitCustomCanMove();
	}

	lua_pushinteger(L, newID);
	return 1;
}

static int element(lua_State *L)
{
	auto &builtinElements = GetElements();
	auto *lsi = GetLSI();
	auto &customElements = lsi->customElements;
	int id = luaL_checkinteger(L, 1);
	if (!SimulationData::CRef().IsElementOrNone(id))
	{
		return luaL_error(L, "Invalid element");
	}

	if (lua_gettop(L) > 1)
	{
		lsi->AssertMutableToolsEvent();
		{
			auto &sd = SimulationData::Ref();
			std::unique_lock lk(sd.elementGraphicsMx);
			auto &elements = sd.elements;
			luaL_checktype(L, 2, LUA_TTABLE);
			//Write values from native data to a table
			for (auto &prop : Element::GetProperties())
			{
				tpt_lua_pushByteString(L, prop.Name);
				lua_gettable(L, -2);
				if (lua_type(L, -1) != LUA_TNIL)
				{
					intptr_t propertyAddress = (intptr_t)(((unsigned char*)&elements[id]) + prop.Offset);
					LuaSetProperty(L, prop, propertyAddress, -1);
				}
				lua_pop(L, 1);
			}

			lua_getfield(L, -1, "Update");
			if (lua_type(L, -1) == LUA_TFUNCTION)
			{
				customElements[id].update.Assign(L, -1);
				customElements[id].updateMode = UPDATE_AFTER;
				elements[id].Update = luaUpdateWrapper;
			}
			else if (lua_type(L, -1) == LUA_TBOOLEAN && !lua_toboolean(L, -1))
			{
				customElements[id].update.Clear();
				customElements[id].updateMode = UPDATE_AFTER;
				elements[id].Update = builtinElements[id].Update;
			}
			lua_pop(L, 1);

			lua_getfield(L, -1, "Graphics");
			if (lua_type(L, -1) == LUA_TFUNCTION)
			{
				customElements[id].graphics.Assign(L, -1);
				elements[id].Graphics = luaGraphicsWrapper;
			}
			else if (lua_type(L, -1) == LUA_TBOOLEAN && !lua_toboolean(L, -1))
			{
				customElements[id].graphics.Clear();
				elements[id].Graphics = builtinElements[id].Graphics;
			}
			lua_pop(L, 1);

			lua_getfield(L, -1, "Create");
			if (lua_type(L, -1) == LUA_TFUNCTION)
			{
				customElements[id].create.Assign(L, -1);
				elements[id].Create = luaCreateWrapper;
			}
			else if (lua_type(L, -1) == LUA_TBOOLEAN && !lua_toboolean(L, -1))
			{
				customElements[id].create.Clear();
				elements[id].Create = builtinElements[id].Create;
			}
			lua_pop(L, 1);

			lua_getfield(L, -1, "CreateAllowed");
			if (lua_type(L, -1) == LUA_TFUNCTION)
			{
				customElements[id].createAllowed.Assign(L, -1);
				elements[id].CreateAllowed = luaCreateAllowedWrapper;
			}
			else if (lua_type(L, -1) == LUA_TBOOLEAN && !lua_toboolean(L, -1))
			{
				customElements[id].createAllowed.Clear();
				elements[id].CreateAllowed = builtinElements[id].CreateAllowed;
			}
			lua_pop(L, 1);

			lua_getfield(L, -1, "ChangeType");
			if (lua_type(L, -1) == LUA_TFUNCTION)
			{
				customElements[id].changeType.Assign(L, -1);
				elements[id].ChangeType = luaChangeTypeWrapper;
			}
			else if (lua_type(L, -1) == LUA_TBOOLEAN && !lua_toboolean(L, -1))
			{
				customElements[id].changeType.Clear();
				elements[id].ChangeType = builtinElements[id].ChangeType;
			}
			lua_pop(L, 1);

			lua_getfield(L, -1, "CtypeDraw");
			if (lua_type(L, -1) == LUA_TFUNCTION)
			{
				customElements[id].ctypeDraw.Assign(L, -1);
				elements[id].CtypeDraw = luaCtypeDrawWrapper;
			}
			else if (lua_type(L, -1) == LUA_TBOOLEAN && !lua_toboolean(L, -1))
			{
				customElements[id].ctypeDraw.Clear();
				elements[id].CtypeDraw = builtinElements[id].CtypeDraw;
			}
			lua_pop(L, 1);

			lua_getfield(L, -1, "DefaultProperties");
			setDefaultProperties(L, id, lua_gettop(L));
			lua_pop(L, 1);

			sd.graphicscache[id].isready = 0;
		}
		lsi->gameModel->UpdateElementTool(id);
		lsi->gameModel->BuildMenus();
		lsi->InitCustomCanMove();

		return 0;
	}
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	//Write values from native data to a table
	lua_newtable(L);
	for (auto &prop : Element::GetProperties())
	{
		tpt_lua_pushByteString(L, prop.Name);
		intptr_t propertyAddress = (intptr_t)(((unsigned char*)&elements[id]) + prop.Offset);
		LuaGetProperty(L, prop, propertyAddress);
		lua_settable(L, -3);
	}

	tpt_lua_pushByteString(L, elements[id].Identifier);
	lua_setfield(L, -2, "Identifier");

	getDefaultProperties(L, id);
	lua_setfield(L, -2, "DefaultProperties");

	return 1;
}

static int property(lua_State *L)
{
	auto &builtinElements = GetElements();
	auto *lsi = GetLSI();
	auto &customElements = lsi->customElements;
	int id = luaL_checkinteger(L, 1);
	if (!SimulationData::CRef().IsElementOrNone(id))
	{
		return luaL_error(L, "Invalid element");
	}
	ByteString propertyName = tpt_lua_checkByteString(L, 2);

	auto &properties = Element::GetProperties();
	auto prop = std::find_if(properties.begin(), properties.end(), [&propertyName](StructProperty const &p) {
		return p.Name == propertyName;
	});

	if (lua_gettop(L) > 2)
	{
		lsi->AssertMutableToolsEvent();
		auto &sd = SimulationData::Ref();
		std::unique_lock lk(sd.elementGraphicsMx);
		auto &elements = sd.elements;
		if (prop != properties.end())
		{
			if (lua_type(L, 3) != LUA_TNIL)
			{
				if (prop->Type == StructProperty::TransitionType)
				{
					int type = luaL_checkinteger(L, 3);
					if (!SimulationData::CRef().IsElementOrNone(type) && type != NT && type != ST)
					{
						return luaL_error(L, "Invalid element");
					}
				}
				intptr_t propertyAddress = (intptr_t)(((unsigned char*)&elements[id]) + prop->Offset);
				manageElementIdentifier(L, id, false);
				LuaSetProperty(L, *prop, propertyAddress, 3);
				manageElementIdentifier(L, id, true);
				lsi->gameModel->UpdateElementTool(id);
				lsi->gameModel->BuildMenus();
				lsi->InitCustomCanMove();
				sd.graphicscache[id].isready = 0;
			}
		}
		else if (propertyName == "Update")
		{
			if (lua_type(L, 3) == LUA_TFUNCTION)
			{
				switch (luaL_optint(L, 4, 0))
				{
				case 2:
					customElements[id].updateMode = UPDATE_BEFORE;
					break;

				case 1:
					customElements[id].updateMode = UPDATE_REPLACE;
					break;

				default:
					customElements[id].updateMode = UPDATE_AFTER;
					break;
				}
				customElements[id].update.Assign(L, 3);
				elements[id].Update = luaUpdateWrapper;
			}
			else if (lua_type(L, 3) == LUA_TBOOLEAN && !lua_toboolean(L, 3))
			{
				customElements[id].update.Clear();
				customElements[id].updateMode = UPDATE_AFTER;
				elements[id].Update = builtinElements[id].Update;
			}
		}
		else if (propertyName == "Graphics")
		{
			if (lua_type(L, 3) == LUA_TFUNCTION)
			{
				customElements[id].graphics.Assign(L, 3);
				elements[id].Graphics = luaGraphicsWrapper;
			}
			else if (lua_type(L, 3) == LUA_TBOOLEAN && !lua_toboolean(L, 3))
			{
				customElements[id].graphics.Clear();
				elements[id].Graphics = builtinElements[id].Graphics;
			}
			sd.graphicscache[id].isready = 0;
		}
		else if (propertyName == "Create")
		{
			if (lua_type(L, 3) == LUA_TFUNCTION)
			{
				customElements[id].create.Assign(L, 3);
				elements[id].Create = luaCreateWrapper;
			}
			else if (lua_type(L, 3) == LUA_TBOOLEAN && !lua_toboolean(L, 3))
			{
				customElements[id].create.Clear();
				elements[id].Create = builtinElements[id].Create;
			}
		}
		else if (propertyName == "CreateAllowed")
		{
			if (lua_type(L, 3) == LUA_TFUNCTION)
			{
				customElements[id].createAllowed.Assign(L, 3);
				elements[id].CreateAllowed = luaCreateAllowedWrapper;
			}
			else if (lua_type(L, 3) == LUA_TBOOLEAN && !lua_toboolean(L, 3))
			{
				customElements[id].createAllowed.Clear();
				elements[id].CreateAllowed = builtinElements[id].CreateAllowed;
			}
		}
		else if (propertyName == "ChangeType")
		{
			if (lua_type(L, 3) == LUA_TFUNCTION)
			{
				customElements[id].changeType.Assign(L, 3);
				elements[id].ChangeType = luaChangeTypeWrapper;
			}
			else if (lua_type(L, 3) == LUA_TBOOLEAN && !lua_toboolean(L, 3))
			{
				customElements[id].changeType.Clear();
				elements[id].ChangeType = builtinElements[id].ChangeType;
			}
		}
		else if (propertyName == "CtypeDraw")
		{
			if (lua_type(L, 3) == LUA_TFUNCTION)
			{
				customElements[id].ctypeDraw.Assign(L, 3);
				elements[id].CtypeDraw = luaCtypeDrawWrapper;
			}
			else if (lua_type(L, 3) == LUA_TBOOLEAN && !lua_toboolean(L, 3))
			{
				customElements[id].ctypeDraw.Clear();
				elements[id].CtypeDraw = builtinElements[id].CtypeDraw;
			}
		}
		else if (propertyName == "DefaultProperties")
		{
			setDefaultProperties(L, id, 3);
		}
		else
		{
			return luaL_error(L, "Invalid element property");
		}
		return 0;
	}
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (prop != properties.end())
	{
		intptr_t propertyAddress = (intptr_t)(((const unsigned char*)&elements[id]) + prop->Offset);
		LuaGetProperty(L, *prop, propertyAddress);
		return 1;
	}
	else if (propertyName == "Identifier")
	{
		tpt_lua_pushByteString(L, elements[id].Identifier);
		return 1;
	}
	else if (propertyName == "DefaultProperties")
	{
		getDefaultProperties(L, id);
		return 1;
	}
	return luaL_error(L, "Invalid element property");
}

static int ffree(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMutableToolsEvent();

	int id = luaL_checkinteger(L, 1);
	ByteString identifier;
	{
		auto &sd = SimulationData::CRef();
		if (!sd.IsElement(id))
		{
			return luaL_error(L, "Invalid element");
		}

		identifier = sd.elements[id].Identifier;
		if (identifier.BeginsWith("DEFAULT_PT_"))
		{
			return luaL_error(L, "Cannot free default elements");
		}
	}

	{
		auto &sd = SimulationData::Ref();
		std::unique_lock lk(sd.elementGraphicsMx);
		sd.elements[id].Enabled = false;
	}
	lsi->customElements[id] = {};
	lsi->gameModel->FreeTool(lsi->gameModel->GetToolFromIdentifier(identifier));
	lsi->gameModel->BuildMenus();

	lua_getglobal(L, "elements");
	tpt_lua_pushByteString(L, identifier);
	lua_pushnil(L);
	lua_settable(L, -3);
	lua_pop(L, 1);

	return 0;
}

static int exists(lua_State *L)
{
	auto &sd = SimulationData::CRef();
	lua_pushboolean(L, sd.IsElement(luaL_checkinteger(L, 1)));
	return 1;
}

static int loadDefault(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMutableToolsEvent();
	auto &sd = SimulationData::Ref();
	std::unique_lock lk(sd.elementGraphicsMx);
	auto &elements = sd.elements;
	auto &builtinElements = GetElements();
	{
		auto loadDefaultOne = [lsi, L, &elements, &builtinElements](int id) {
			lua_getglobal(L, "elements");
			ByteString identifier = elements[id].Identifier;
			tpt_lua_pushByteString(L, identifier);
			lua_pushnil(L);
			lua_settable(L, -3);

			manageElementIdentifier(L, id, false);
			auto oldEnabled = elements[id].Enabled;
			if (id < (int)builtinElements.size() && builtinElements[id].Enabled)
			{
				elements[id] = builtinElements[id];
			}
			else
			{
				elements[id] = Element();
			}
			// TODO: somehow unify element and corresponding element tool management in a way that makes it hard to mess up
			if (oldEnabled && elements[id].Enabled)
			{
				lsi->gameModel->UpdateElementTool(id);
			}
			else if (oldEnabled && !elements[id].Enabled)
			{
				lsi->gameModel->FreeTool(lsi->gameModel->GetToolFromIdentifier(identifier));
			}
			manageElementIdentifier(L, id, true);

			tpt_lua_pushByteString(L, identifier);
			lua_pushinteger(L, id);
			lua_settable(L, -3);
			lua_pop(L, 1);
		};
		int args = lua_gettop(L);
		if (args)
		{
			luaL_checktype(L, 1, LUA_TNUMBER);
			int id = lua_tointeger(L, 1);
			if (id < 0 || id >= PT_NUM)
				return luaL_error(L, "Invalid element");
			loadDefaultOne(id);
		}
		else
		{
			for (int i = 0; i < PT_NUM; i++)
			{
				loadDefaultOne(i);
			}
		}
	}

	lsi->gameModel->BuildMenus();
	for (auto moving = 0; moving < PT_NUM; ++moving)
	{
		for (auto into = 0; into < PT_NUM; ++into)
		{
			lsi->customCanMove[moving][into] = 0;
		}
	}
	lsi->InitCustomCanMove();
	sd.graphicscache = std::array<gcache_item, PT_NUM>();
	return 0;
}

static int getByName(lua_State *L)
{
	lua_pushinteger(L, SimulationData::CRef().GetParticleType(tpt_lua_checkByteString(L, 1)));
	return 1;
}

void LuaElements::Open(lua_State *L)
{
	auto &sd = SimulationData::CRef();
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(allocate),
		LFUNC(element),
		LFUNC(property),
		LFUNC(exists),
		LFUNC(loadDefault),
		LFUNC(getByName),
#undef LFUNC
		{ "free", ffree },
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
#define LCONST(v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, #v)
#define LCONSTAS(k, v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, k)
	LCONST(TYPE_PART);
	LCONST(TYPE_LIQUID);
	LCONST(TYPE_SOLID);
	LCONST(TYPE_GAS);
	LCONST(TYPE_ENERGY);
	LCONST(PROP_CONDUCTS);
	LCONST(PROP_PHOTPASS);
	LCONST(PROP_NEUTPENETRATE);
	LCONST(PROP_NEUTABSORB);
	LCONST(PROP_NEUTPASS);
	LCONST(PROP_DEADLY);
	LCONST(PROP_HOT_GLOW);
	LCONST(PROP_LIFE);
	LCONST(PROP_RADIOACTIVE);
	LCONST(PROP_LIFE_DEC);
	LCONST(PROP_LIFE_KILL);
	LCONST(PROP_LIFE_KILL_DEC);
	LCONST(PROP_SPARKSETTLE);
	LCONST(PROP_NOAMBHEAT);
	LCONST(PROP_NOCTYPEDRAW);
	LCONST(SC_WALL);
	LCONST(SC_ELEC);
	LCONST(SC_POWERED);
	LCONST(SC_SENSOR);
	LCONST(SC_FORCE);
	LCONST(SC_EXPLOSIVE);
	LCONST(SC_GAS);
	LCONST(SC_LIQUID);
	LCONST(SC_POWDERS);
	LCONST(SC_SOLIDS);
	LCONST(SC_NUCLEAR);
	LCONST(SC_SPECIAL);
	LCONST(SC_LIFE);
	LCONST(SC_TOOL);
	LCONST(SC_DECO);
	LCONSTAS("NUM_MENUSECTIONS", int(sd.msections.size()));
	LCONST(UPDATE_AFTER);
	LCONST(UPDATE_REPLACE);
	LCONST(UPDATE_BEFORE);
	LCONST(NUM_UPDATEMODES);
#undef LCONSTAS
#undef LCONST
	lua_pushvalue(L, -1);
	lua_setglobal(L, "elements");
	lua_setglobal(L, "elem");
	for (int i = 0; i < PT_NUM; i++)
	{
		manageElementIdentifier(L, i, true);
	}
}


=== src\lua\LuaEvent.cpp ===

#include "LuaScriptInterface.h"
#include "common/VariantIndex.h"
#include "PowderToySDL.h"

static int fregister(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int eventType = luaL_checkinteger(L, 1);
	luaL_checktype(L, 2, LUA_TFUNCTION);
	if (eventType < 0 || eventType >= int(std::variant_size_v<GameControllerEvent>))
	{
		luaL_error(L, "Invalid event type: %i", lua_tointeger(L, 1));
	}
	lsi->AddEventHandler(eventType, 2);
	lua_pushvalue(L, 2);
	return 1;
}

static int unregister(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int eventType = luaL_checkinteger(L, 1);
	luaL_checktype(L, 2, LUA_TFUNCTION);
	if (eventType < 0 || eventType >= int(std::variant_size_v<GameControllerEvent>))
	{
		luaL_error(L, "Invalid event type: %i", lua_tointeger(L, 1));
	}
	lsi->RemoveEventHandler(eventType, 2);
	return 0;
}

static int getModifiers(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	lua_pushnumber(L, GetModifiers());
	return 1;
}

void LuaEvent::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(unregister),
		LFUNC(getModifiers),
#undef LFUNC
		{ "register", fregister },
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
#define LVICONST(id, v) lua_pushinteger(L, VariantIndex<GameControllerEvent, id>()); lua_setfield(L, -2, v)
	LVICONST(TextInputEvent    , "TEXTINPUT"    );
	LVICONST(TextEditingEvent  , "TEXTEDITING"  );
	LVICONST(KeyPressEvent     , "KEYPRESS"     );
	LVICONST(KeyReleaseEvent   , "KEYRELEASE"   );
	LVICONST(MouseDownEvent    , "MOUSEDOWN"    );
	LVICONST(MouseUpEvent      , "MOUSEUP"      );
	LVICONST(MouseMoveEvent    , "MOUSEMOVE"    );
	LVICONST(MouseWheelEvent   , "MOUSEWHEEL"   );
	LVICONST(TickEvent         , "TICK"         );
	LVICONST(BlurEvent         , "BLUR"         );
	LVICONST(CloseEvent        , "CLOSE"        );
	LVICONST(BeforeSimEvent    , "BEFORESIM"    );
	LVICONST(AfterSimEvent     , "AFTERSIM"     );
	LVICONST(BeforeSimDrawEvent, "BEFORESIMDRAW");
	LVICONST(AfterSimDrawEvent , "AFTERSIMDRAW" );
#undef LVICONST
	lua_pushvalue(L, -1);
	lua_setglobal(L, "event");
	lua_setglobal(L, "evt");
}


=== src\lua\LuaFileSystem.cpp ===

#include "LuaScriptInterface.h"
#include "common/platform/Platform.h"

static int list(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto directoryName = tpt_lua_checkByteString(L, 1);
	lua_newtable(L);
	int index = 0;
	for (auto &name : Platform::DirectorySearch(directoryName, "", {}))
	{
		if (name != "." && name != "..")
		{
			index += 1;
			tpt_lua_pushByteString(L, name);
			lua_rawseti(L, -2, index);
		}
	}
	return 1;
}

static int exists(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto filename = tpt_lua_checkByteString(L, 1);
	bool ret = Platform::Stat(filename);
	lua_pushboolean(L, ret);
	return 1;
}

static int isFile(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto filename = tpt_lua_checkByteString(L, 1);
	bool ret = Platform::FileExists(filename);
	lua_pushboolean(L, ret);
	return 1;
}

static int isDirectory(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto dirname = tpt_lua_checkByteString(L, 1);
	bool ret = Platform::DirectoryExists(dirname);
	lua_pushboolean(L, ret);
	return 1;
}

static int isLink(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto dirname = tpt_lua_checkByteString(L, 1);
	bool ret = Platform::IsLink(dirname);
	lua_pushboolean(L, ret);
	return 1;
}

static int makeDirectory(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto dirname = tpt_lua_checkByteString(L, 1);

	int ret = 0;
	ret = Platform::MakeDirectory(dirname);
	lua_pushboolean(L, ret);
	return 1;
}

static int removeDirectory(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto directory = tpt_lua_checkByteString(L, 1);

	bool ret = Platform::DeleteDirectory(directory);
	lua_pushboolean(L, ret);
	return 1;
}

static int removeFile(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto filename = tpt_lua_checkByteString(L, 1);
	lua_pushboolean(L, Platform::RemoveFile(filename));
	return 1;
}

static int move(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto filename = tpt_lua_checkByteString(L, 1);
	auto newFilename = tpt_lua_checkByteString(L, 2);
	bool replace = lua_toboolean(L, 3);
	lua_pushboolean(L, Platform::RenameFile(filename, newFilename, replace));
	return 1;
}

static int copy(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto filename = tpt_lua_checkByteString(L, 1);
	auto newFilename = tpt_lua_checkByteString(L, 2);
	std::vector<char> fileData;
	lua_pushboolean(L, Platform::ReadFile(fileData, filename) && Platform::WriteFile(fileData, newFilename));
	return 1;
}

void LuaFileSystem::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(list),
		LFUNC(exists),
		LFUNC(isFile),
		LFUNC(isDirectory),
		LFUNC(isLink),
		LFUNC(makeDirectory),
		LFUNC(removeDirectory),
		LFUNC(removeFile),
		LFUNC(move),
		LFUNC(copy),
#undef LFUNC
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
	lua_pushvalue(L, -1);
	lua_setglobal(L, "fileSystem");
	lua_setglobal(L, "fs");
}


=== src\lua\LuaGraphics.cpp ===

#include "LuaScriptInterface.h"
#include "graphics/Graphics.h"
#include "graphics/Renderer.h"

void NonGraphicsContext::Die()
{
	luaL_error(GetLSI()->L, "this functionality is restricted to graphics events");
}

void NonGraphicsContext::BlendPixel(Vec2<int>, RGBA)
{
	Die();
}

Vec2<int> NonGraphicsContext::BlendText(Vec2<int>, const String &, RGBA)
{
	Die();
	return { 0, 0 };
}

void NonGraphicsContext::DrawLine(Vec2<int>, Vec2<int>, RGB)
{
	Die();
}

void NonGraphicsContext::BlendLine(Vec2<int>, Vec2<int>, RGBA)
{
	Die();
}

void NonGraphicsContext::DrawRect(Rect<int>, RGB)
{
	Die();
}

void NonGraphicsContext::BlendRect(Rect<int>, RGBA)
{
	Die();
}

void NonGraphicsContext::DrawFilledRect(Rect<int>, RGB)
{
	Die();
}

void NonGraphicsContext::BlendFilledRect(Rect<int>, RGBA)
{
	Die();
}

void NonGraphicsContext::BlendEllipse(Vec2<int>, Vec2<int>, RGBA)
{
	Die();
}

void NonGraphicsContext::BlendFilledEllipse(Vec2<int>, Vec2<int>, RGBA)
{
	Die();
}

static int32_t int32Truncate(double n)
{
	if (n >= 0x1p31)
	{
		n -= 0x1p32;
	}
	return int32_t(n);
}

static int textSize(lua_State *L)
{
	auto text = tpt_lua_optString(L, 1, "");
	auto size = Graphics::TextSize(text);
	lua_pushinteger(L, size.X);
	lua_pushinteger(L, size.Y);
	return 2;
}

static int drawText(lua_State *L)
{
	int x = lua_tointeger(L, 1);
	int y = lua_tointeger(L, 2);
	auto text = tpt_lua_optString(L, 3, "");
	int r = luaL_optint(L, 4, 255);
	int g = luaL_optint(L, 5, 255);
	int b = luaL_optint(L, 6, 255);
	int a = luaL_optint(L, 7, 255);

	if (r<0) r = 0;
	else if (r>255) r = 255;
	if (g<0) g = 0;
	else if (g>255) g = 255;
	if (b<0) b = 0;
	else if (b>255) b = 255;
	if (a<0) a = 0;
	else if (a>255) a = 255;

	std::visit([x, y, r, g, b, a, &text](auto p) {
		p->BlendText({ x, y }, text, RGBA(r, g, b, a));
	}, GetLSI()->GetGraphics());
	return 0;
}

static int drawPixel(lua_State *L)
{
	auto x = luaL_optint(L, 1, 0);
	auto y = luaL_optint(L, 2, 0);
	auto r = luaL_optint(L, 3, 255);
	auto g = luaL_optint(L, 4, 255);
	auto b = luaL_optint(L, 5, 255);
	auto a = luaL_optint(L, 6, 255);
	if      (r < 0  ) r = 0  ;
	else if (r > 255) r = 255;
	if      (g < 0  ) g = 0  ;
	else if (g > 255) g = 255;
	if      (b < 0  ) b = 0  ;
	else if (b > 255) b = 255;
	if      (a < 0  ) a = 0  ;
	else if (a > 255) a = 255;
	std::visit([x, y, r, g, b, a](auto p) {
		p->BlendPixel({ x, y }, RGBA(r, g, b, a));
	}, GetLSI()->GetGraphics());
	return 0;
}

static int drawLine(lua_State *L)
{
	int x1 = lua_tointeger(L, 1);
	int y1 = lua_tointeger(L, 2);
	int x2 = lua_tointeger(L, 3);
	int y2 = lua_tointeger(L, 4);
	int r = luaL_optint(L, 5, 255);
	int g = luaL_optint(L, 6, 255);
	int b = luaL_optint(L, 7, 255);
	int a = luaL_optint(L, 8, 255);

	if (r<0) r = 0;
	else if (r>255) r = 255;
	if (g<0) g = 0;
	else if (g>255) g = 255;
	if (b<0) b = 0;
	else if (b>255) b = 255;
	if (a<0) a = 0;
	else if (a>255) a = 255;

	std::visit([x1, y1, x2, y2, r, g, b, a](auto p) {
		if (a == 255)
		{
			p->DrawLine({ x1, y1 }, { x2, y2 }, RGB(r, g, b));
		}
		else
		{
			p->BlendLine({ x1, y1 }, { x2, y2 }, RGBA(r, g, b, a));
		}
	}, GetLSI()->GetGraphics());
	return 0;
}

static int drawRect(lua_State *L)
{
	int x = lua_tointeger(L, 1);
	int y = lua_tointeger(L, 2);
	int width = lua_tointeger(L, 3);
	int height = lua_tointeger(L, 4);
	int r = luaL_optint(L, 5, 255);
	int g = luaL_optint(L, 6, 255);
	int b = luaL_optint(L, 7, 255);
	int a = luaL_optint(L, 8, 255);

	if (r<0) r = 0;
	else if (r>255) r = 255;
	if (g<0) g = 0;
	else if (g>255) g = 255;
	if (b<0) b = 0;
	else if (b>255) b = 255;
	if (a<0) a = 0;
	else if (a>255) a = 255;

	std::visit([x, y, width, height, r, g, b, a](auto p) {
		if (a == 255)
		{
			p->DrawRect(RectSized(Vec2{ x, y }, Vec2{ width, height }), RGB(r, g, b));
		}
		else
		{
			p->BlendRect(RectSized(Vec2{ x, y }, Vec2{ width, height }), RGBA(r, g, b, a));
		}
	}, GetLSI()->GetGraphics());
	return 0;
}

static int fillRect(lua_State *L)
{
	int x = lua_tointeger(L, 1);
	int y = lua_tointeger(L, 2);
	int width = lua_tointeger(L, 3);
	int height = lua_tointeger(L, 4);
	int r = luaL_optint(L, 5, 255);
	int g = luaL_optint(L, 6, 255);
	int b = luaL_optint(L, 7, 255);
	int a = luaL_optint(L, 8, 255);

	if (r<0) r = 0;
	else if (r>255) r = 255;
	if (g<0) g = 0;
	else if (g>255) g = 255;
	if (b<0) b = 0;
	else if (b>255) b = 255;
	if (a<0) a = 0;
	else if (a>255) a = 255;

	std::visit([x, y, width, height, r, g, b, a](auto p) {
		if (a == 255)
		{
			p->DrawFilledRect(RectSized(Vec2{ x, y }, Vec2{ width, height }), RGB(r, g, b));
		}
		else
		{
			p->BlendFilledRect(RectSized(Vec2{ x, y }, Vec2{ width, height }), RGBA(r, g, b, a));
		}
	}, GetLSI()->GetGraphics());
	return 0;
}

static int drawCircle(lua_State *L)
{
	int x = lua_tointeger(L, 1);
	int y = lua_tointeger(L, 2);
	int rx = lua_tointeger(L, 3);
	int ry = lua_tointeger(L, 4);
	int r = luaL_optint(L, 5, 255);
	int g = luaL_optint(L, 6, 255);
	int b = luaL_optint(L, 7, 255);
	int a = luaL_optint(L, 8, 255);

	if (r<0) r = 0;
	else if (r>255) r = 255;
	if (g<0) g = 0;
	else if (g>255) g = 255;
	if (b<0) b = 0;
	else if (b>255) b = 255;
	if (a<0) a = 0;
	else if (a>255) a = 255;

	std::visit([x, y, rx, ry, r, g, b, a](auto p) {
		p->BlendEllipse({ x, y }, { abs(rx), abs(ry) }, RGBA(r, g, b, a));
	}, GetLSI()->GetGraphics());
	return 0;
}

static int fillCircle(lua_State *L)
{
	int x = lua_tointeger(L, 1);
	int y = lua_tointeger(L, 2);
	int rx = lua_tointeger(L, 3);
	int ry = lua_tointeger(L, 4);
	int r = luaL_optint(L, 5, 255);
	int g = luaL_optint(L, 6, 255);
	int b = luaL_optint(L, 7, 255);
	int a = luaL_optint(L, 8, 255);

	if (r<0) r = 0;
	else if (r>255) r = 255;
	if (g<0) g = 0;
	else if (g>255) g = 255;
	if (b<0) b = 0;
	else if (b>255) b = 255;
	if (a<0) a = 0;
	else if (a>255) a = 255;

	std::visit([x, y, rx, ry, r, g, b, a](auto p) {
		p->BlendFilledEllipse({ x, y }, { abs(rx), abs(ry) }, RGBA(r, g, b, a));
	}, GetLSI()->GetGraphics());
	return 0;
}

static int getColors(lua_State *L)
{
	unsigned int color = int32Truncate(lua_tonumber(L, 1));

	int a = color >> 24;
	int r = (color >> 16)&0xFF;
	int g = (color >> 8)&0xFF;
	int b = color&0xFF;

	lua_pushinteger(L, r);
	lua_pushinteger(L, g);
	lua_pushinteger(L, b);
	lua_pushinteger(L, a);
	return 4;
}

static int getHexColor(lua_State *L)
{
	int r = lua_tointeger(L, 1);
	int g = lua_tointeger(L, 2);
	int b = lua_tointeger(L, 3);
	int a = 0;
	if (lua_gettop(L) >= 4)
		a = lua_tointeger(L, 4);
	unsigned int color = (a<<24) + (r<<16) + (g<<8) + b;

	lua_pushinteger(L, color);
	return 1;
}

static int setClipRect(lua_State *L)
{
	auto *lsi = GetLSI();
	if (lsi->eventTraits & eventTraitSimGraphics)
	{
		return luaL_error(L, "simulation graphics do not support clip rects");
	}
	if (!(lsi->eventTraits & eventTraitInterfaceGraphics))
	{
		NonGraphicsContext::Die();
	}
	int x = luaL_optinteger(L, 1, 0);
	int y = luaL_optinteger(L, 2, 0);
	int w = luaL_optinteger(L, 3, WINDOWW);
	int h = luaL_optinteger(L, 4, WINDOWH);
	auto rect = RectSized(Vec2(x, y), Vec2(w, h));
	lsi->g->SwapClipRect(rect);
	lua_pushinteger(L, rect.pos.X);
	lua_pushinteger(L, rect.pos.Y);
	lua_pushinteger(L, rect.size.X);
	lua_pushinteger(L, rect.size.Y);
	return 4;
}

void LuaGraphics::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(textSize),
		LFUNC(drawText),
		LFUNC(drawPixel),
		LFUNC(drawLine),
		LFUNC(drawRect),
		LFUNC(fillRect),
		LFUNC(drawCircle),
		LFUNC(fillCircle),
		LFUNC(getColors),
		LFUNC(getHexColor),
		LFUNC(setClipRect),
#undef LFUNC
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
#define LCONSTAS(k, v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, k)
	LCONSTAS("WIDTH",  WINDOWW);
	LCONSTAS("HEIGHT", WINDOWH);
#undef LCONSTAS
	lua_pushvalue(L, -1);
	lua_setglobal(L, "graphics");
	lua_setglobal(L, "gfx");
}


=== src\lua\LuaHttp.cpp ===

#include "LuaScriptInterface.h"
#include "client/http/Request.h"
#include "client/Client.h"
#include "json/json.h"
#include "LuaScriptInterface.h"
#include "Format.h"
#include "Config.h"
#include <memory>
#include <iostream>

class RequestHandle
{
public:
	enum RequestType
	{
		normal,
		getAuthToken,
	};

private:
	std::unique_ptr<http::Request> request;
	bool dead = false;
	RequestType type;

	RequestHandle() = default;

	std::pair<int, ByteString> FinishGetAuthToken(ByteString data)
	{
		std::istringstream ss(data);
		Json::Value root;
		try
		{
			ss >> root;
			auto status = root["Status"].asString();
			if (status == "OK")
			{
				return { 200, root["Token"].asString() };
			}
			return { 403, status };
		}
		catch (std::exception &e)
		{
			std::cerr << "bad auth response: " << e.what() << std::endl;
		}
		return { 600, {} };
	}

public:
	static int Make(lua_State *L, const ByteString &uri, bool isPost, const ByteString &verb, RequestType type, const http::PostData &postData, const std::vector<http::Header> &headers)
	{
		// there's no actual architectural reason to require HTTP handles to be managed from interface events
		// because the HTTP thread doesn't care what thread the requests are managed from, but requiring this
		// makes access patterns cleaner, so we do it anyway
		GetLSI()->AssertInterfaceEvent();
		auto authUser = Client::Ref().GetAuthUser();
		if (type == getAuthToken && !authUser.UserID)
		{
			lua_pushnil(L);
			lua_pushliteral(L, "not authenticated");
			return 2;
		}
		auto *rh = (RequestHandle *)lua_newuserdata(L, sizeof(RequestHandle));
		if (!rh)
		{
			return 0;
		}
		new(rh) RequestHandle();
		rh->type = type;
		rh->request = std::make_unique<http::Request>(uri);
		if (verb.size())
		{
			rh->request->Verb(verb);
		}
		for (const auto &header : headers)
		{
			rh->request->AddHeader(header);
		}
		if (isPost)
		{
			rh->request->AddPostData(postData);
		}
		if (type == getAuthToken)
		{
			rh->request->AuthHeaders(ByteString::Build(authUser.UserID), authUser.SessionID);
		}
		rh->request->Start();
		luaL_newmetatable(L, "HTTPRequest");
		lua_setmetatable(L, -2);
		return 1;
	}

	~RequestHandle()
	{
		if (!Dead())
		{
			Cancel();
		}
	}

	bool Dead() const
	{
		return dead;
	}

	bool Done() const
	{
		return request->CheckDone();
	}

	void Progress(int64_t *total, int64_t *done)
	{
		if (!dead)
		{
			std::tie(*total, *done) = request->CheckProgress();
		}
	}

	void Cancel()
	{
		if (!dead)
		{
			request.reset();
			dead = true;
		}
	}

	std::pair<int, ByteString> Finish(std::vector<http::Header> &headers)
	{
		int status = 0;
		ByteString data;
		if (!dead)
		{
			if (request->CheckDone())
			{
				if (type != getAuthToken)
				{
					headers = request->ResponseHeaders();
				}
				// Get this separately so it's always present.
				status = request->StatusCode();
				try
				{
					data = request->Finish().second;
				}
				catch (const http::RequestError &ex)
				{
					// Nothing, the only way to fail here is to fail in RequestManager, and
					// that means the problem has already been printed to std::cerr.
				}
				request.reset();
				if (type == getAuthToken)
				{
					if (status == 200)
					{
						std::tie(status, data) = FinishGetAuthToken(data);
					}
				}
				dead = true;
			}
		}
		return { status, data };
	}
};

static int HTTPRequest_gc(lua_State *L)
{
	// not subject to the check in RequestHandle::Make; that would be disastrous, and thankfully,
	// as explained there, we're not missing out on any functionality either
	auto *rh = (RequestHandle *)luaL_checkudata(L, 1, "HTTPRequest");
	rh->~RequestHandle();
	return 0;
}

static int HTTPRequest_status(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent(); // see the check in RequestHandle::Make
	auto *rh = (RequestHandle *)luaL_checkudata(L, 1, "HTTPRequest");
	if (rh->Dead())
	{
		lua_pushliteral(L, "dead");
	}
	else if (rh->Done())
	{
		lua_pushliteral(L, "done");
	}
	else
	{
		lua_pushliteral(L, "running");
	}
	return 1;
}

static int HTTPRequest_progress(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent(); // see the check in RequestHandle::Make
	auto *rh = (RequestHandle *)luaL_checkudata(L, 1, "HTTPRequest");
	if (!rh->Dead())
	{
		int64_t total, done;
		rh->Progress(&total, &done);
		lua_pushinteger(L, total);
		lua_pushinteger(L, done);
		return 2;
	}
	return 0;
}

static int HTTPRequest_cancel(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent(); // see the check in RequestHandle::Make
	auto *rh = (RequestHandle *)luaL_checkudata(L, 1, "HTTPRequest");
	if (!rh->Dead())
	{
		rh->Cancel();
	}
	return 0;
}

static int HTTPRequest_finish(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent(); // see the check in RequestHandle::Make
	auto *rh = (RequestHandle *)luaL_checkudata(L, 1, "HTTPRequest");
	if (!rh->Dead())
	{
		std::vector<http::Header> headers;
		auto [ status, data ] = rh->Finish(headers);
		tpt_lua_pushByteString(L, data);
		lua_pushinteger(L, status);
		lua_newtable(L);
		for (auto i = 0; i < int(headers.size()); ++i)
		{
			lua_newtable(L);
			lua_pushlstring(L, headers[i].name.data(), headers[i].name.size());
			lua_rawseti(L, -2, 1);
			lua_pushlstring(L, headers[i].value.data(), headers[i].value.size());
			lua_rawseti(L, -2, 2);
			lua_rawseti(L, -2, i + 1);
		}
		return 3;
	}
	return 0;
}

static int request(lua_State *L, bool isPost)
{
	ByteString uri = tpt_lua_checkByteString(L, 1);
	http::PostData postData;
	auto headersIndex = 2;
	auto verbIndex = 3;

	if (isPost)
	{
		headersIndex += 1;
		verbIndex += 1;
		if (lua_isstring(L, 2))
		{
			postData = tpt_lua_toByteString(L, 2);
		}
		else if (lua_istable(L, 2))
		{
			postData = http::FormData{};
			auto &formData = std::get<http::FormData>(postData);
			auto size = lua_objlen(L, 2);
			if (size)
			{
				for (auto i = 0U; i < size; ++i)
				{
					auto &formItem = formData.emplace_back();
					lua_rawgeti(L, 2, i + 1);
					if (!lua_istable(L, -1))
					{
						luaL_error(L, "form item %i is not a table", i + 1);
					}
					{
						lua_rawgeti(L, -1, 1);
						if (!lua_isstring(L, -1))
						{
							luaL_error(L, "name of form item %i is not a string", i + 1);
						}
						formItem.name = tpt_lua_toByteString(L, -1);
						lua_pop(L, 1);
					}
					{
						lua_rawgeti(L, -1, 2);
						if (!lua_isstring(L, -1))
						{
							luaL_error(L, "value of form item %i is not a string", i + 1);
						}
						formItem.value = tpt_lua_toByteString(L, -1);
						lua_pop(L, 1);
					}
					{
						lua_rawgeti(L, -1, 3);
						if (!lua_isnoneornil(L, -1))
						{
							if (!lua_isstring(L, -1))
							{
								luaL_error(L, "filename of form item %i is not a string", i + 1);
							}
							formItem.filename = tpt_lua_toByteString(L, -1);
						}
						lua_pop(L, 1);
					}
					{
						lua_rawgeti(L, -1, 4);
						if (!lua_isnoneornil(L, -1))
						{
							if (!lua_isstring(L, -1))
							{
								luaL_error(L, "content type of form item %i is not a string", i + 1);
							}
							formItem.contentType = tpt_lua_toByteString(L, -1);
						}
						lua_pop(L, 1);
					}
					lua_pop(L, 1);
				}
			}
			else
			{
				lua_pushnil(L);
				while (lua_next(L, 2))
				{
					lua_pushvalue(L, -2);
					auto &formItem = formData.emplace_back();
					formItem.name = tpt_lua_toByteString(L, -1);
					formItem.value = tpt_lua_toByteString(L, -2);
					lua_pop(L, 2);
				}
			}
		}
	}

	std::vector<http::Header> headers;
	if (lua_istable(L, headersIndex))
	{
		auto size = lua_objlen(L, headersIndex);
		if (size)
		{
			for (auto i = 0U; i < size; ++i)
			{
				lua_rawgeti(L, headersIndex, i + 1);
				if (!lua_istable(L, -1))
				{
					luaL_error(L, "header %i is not a table", i + 1);
				}
				lua_rawgeti(L, -1, 1);
				if (!lua_isstring(L, -1))
				{
					luaL_error(L, "name of header %i is not a string", i + 1);
				}
				auto name = tpt_lua_toByteString(L, -1);
				lua_pop(L, 1);
				lua_rawgeti(L, -1, 2);
				if (!lua_isstring(L, -1))
				{
					luaL_error(L, "value of header %i is not a string", i + 1);
				}
				auto value = tpt_lua_toByteString(L, -1);
				lua_pop(L, 1);
				headers.push_back({ name, value });
				lua_pop(L, 1);
			}
		}
		else
		{
			// old dictionary format
			lua_pushnil(L);
			while (lua_next(L, headersIndex))
			{
				lua_pushvalue(L, -2);
				headers.push_back({ tpt_lua_toByteString(L, -1), tpt_lua_toByteString(L, -2) });
				lua_pop(L, 2);
			}
		}
	}

	auto verb = tpt_lua_optByteString(L, verbIndex, "");
	return RequestHandle::Make(L, uri, isPost, verb, RequestHandle::normal, postData, headers);
}

static int getAuthToken(lua_State *L)
{
	return RequestHandle::Make(L, ByteString::Build(SERVER, "/ExternalAuth.api?Action=Get&Audience=", format::URLEncode(tpt_lua_checkByteString(L, 1))), false, {}, RequestHandle::getAuthToken, {}, {});
}

static int get(lua_State *L)
{
	return request(L, false);
}

static int post(lua_State *L)
{
	return request(L, true);
}

void LuaHttp::Open(lua_State *L)
{
	{
		static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, HTTPRequest_ ## v }
			LFUNC(status),
			LFUNC(progress),
			LFUNC(cancel),
			LFUNC(finish),
#undef LFUNC
			{ nullptr, nullptr }
		};
		luaL_newmetatable(L, "HTTPRequest");
		lua_pushcfunction(L, HTTPRequest_gc);
		lua_setfield(L, -2, "__gc");
		lua_newtable(L);
		luaL_register(L, nullptr, reg);
		lua_setfield(L, -2, "__index");
		lua_pop(L, 1);
	}
	{
		static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
			LFUNC(get),
			LFUNC(post),
			LFUNC(getAuthToken),
#undef LFUNC
			{ nullptr, nullptr }
		};
		lua_newtable(L);
		luaL_register(L, nullptr, reg);
		lua_setglobal(L, "http");
	}
}


=== src\lua\LuaInterface.cpp ===

#include "LuaScriptInterface.h"
#include "gui/dialogues/ConfirmPrompt.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/dialogues/InformationMessage.h"
#include "gui/dialogues/TextPrompt.h"
#include "gui/game/Brush.h"
#include "gui/game/GameController.h"
#include "gui/game/GameModel.h"
#include "gui/game/GameView.h"
#include "gui/game/tool/Tool.h"
#include "gui/interface/Engine.h"
#include "LuaButton.h"
#include "LuaCheckbox.h"
#include "LuaLabel.h"
#include "LuaLuna.h"
#include "LuaProgressBar.h"
#include "LuaSDLKeys.h"
#include "LuaSlider.h"
#include "LuaTextbox.h"
#include "LuaWindow.h"
#include "prefs/GlobalPrefs.h"
#include "simulation/SimulationData.h"

template<class Type>
struct PickIfTypeHelper;

template<>
struct PickIfTypeHelper<String>
{
	static constexpr auto LuaType = LUA_TSTRING;
	static String Get(lua_State *L, int index) { return tpt_lua_checkString(L, index); }
};

template<>
struct PickIfTypeHelper<bool>
{
	static constexpr auto LuaType = LUA_TBOOLEAN;
	static bool Get(lua_State *L, int index) { return lua_toboolean(L, index); }
};

template<class Type>
static Type PickIfType(lua_State *L, int index, Type defaultValue)
{
	return lua_type(L, index) == PickIfTypeHelper<Type>::LuaType ? PickIfTypeHelper<Type>::Get(L, index) : defaultValue;
}

static int beginMessageBox(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto title = PickIfType(L, 1, String("Title"));
	auto message = PickIfType(L, 2, String("Message"));
	auto large = PickIfType(L, 3, false);
	auto cb = std::make_shared<LuaSmartRef>(); // * Bind to main lua state (might be different from L).
	if (lua_gettop(L))
	{
		cb->Assign(L, lua_gettop(L));
	}
	new InformationMessage(title, message, large, { [cb]() {
		auto *lsi = GetLSI();
		auto L = lsi->L;
		cb->Push(L);
		if (lua_isfunction(L, -1))
		{
			if (tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
			{
				lsi->Log(CommandInterface::LogError, LuaGetError());
			}
		}
		else
		{
			lua_pop(L, 1);
		}
	} });
	return 0;
}

static int beginThrowError(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto errorMessage = PickIfType(L, 1, String("Error text"));
	auto cb = std::make_shared<LuaSmartRef>(); // * Bind to main lua state (might be different from L).
	if (lua_gettop(L))
	{
		cb->Assign(L, lua_gettop(L));
	}
	new ErrorMessage("Error", errorMessage, { [cb]() {
		auto *lsi = GetLSI();
		auto L = lsi->L;
		cb->Push(L);
		if (lua_isfunction(L, -1))
		{
			if (tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
			{
				lsi->Log(CommandInterface::LogError, LuaGetError());
			}
		}
		else
		{
			lua_pop(L, 1);
		}
	} });
	return 0;
}

static int beginInput(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto title = PickIfType(L, 1, String("Title"));
	auto prompt = PickIfType(L, 2, String("Enter some text:"));
	auto text = PickIfType(L, 3, String(""));
	auto shadow = PickIfType(L, 4, String(""));
	auto cb = std::make_shared<LuaSmartRef>(); // * Bind to main lua state (might be different from L).
	if (lua_gettop(L))
	{
		cb->Assign(L, lua_gettop(L));
	}
	auto handle = [cb](std::optional<String> input) {
		auto *lsi = GetLSI();
		auto L = lsi->L;
		cb->Push(L);
		if (lua_isfunction(L, -1))
		{
			if (input)
			{
				tpt_lua_pushString(L, *input);
			}
			else
			{
				lua_pushnil(L);
			}
			if (tpt_lua_pcall(L, 1, 0, 0, eventTraitInterface))
			{
				lsi->Log(CommandInterface::LogError, LuaGetError());
			}
		}
		else
		{
			lua_pop(L, 1);
		}
	};
	new TextPrompt(title, prompt, text, shadow, false, { [handle](const String &input) {
		handle(input);
	}, [handle]() {
		handle(std::nullopt);
	} });
	return 0;
}

static int beginConfirm(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto title = PickIfType(L, 1, String("Title"));
	auto message = PickIfType(L, 2, String("Message"));
	auto buttonText = PickIfType(L, 3, String("Confirm"));
	auto cb = std::make_shared<LuaSmartRef>(); // * Bind to main lua state (might be different from L).
	if (lua_gettop(L))
	{
		cb->Assign(L, lua_gettop(L));
	}
	auto handle = [cb](int result) {
		auto *lsi = GetLSI();
		auto L = lsi->L;
		cb->Push(L);
		if (lua_isfunction(L, -1))
		{
			lua_pushboolean(L, result);
			if (tpt_lua_pcall(L, 1, 0, 0, eventTraitInterface))
			{
				lsi->Log(CommandInterface::LogError, LuaGetError());
			}
		}
		else
		{
			lua_pop(L, 1);
		}
	};
	new ConfirmPrompt(title, message, { [handle]() {
		handle(1);
	}, [handle]() {
		handle(0);
	} }, buttonText);
	return 0;
}

static int console(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushboolean(L, lsi->window != ui::Engine::Ref().GetWindow());
		return 1;
	}
	if (lua_toboolean(L, 1))
		lsi->gameController->ShowConsole();
	else
		lsi->gameController->HideConsole();
	return 0;
}

static int brushID(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) < 1)
	{
		lua_pushnumber(L, lsi->gameModel->GetBrushID());
		return 1;
	}
	auto index = luaL_checkint(L, 1);
	if (index < 0 || index >= int(lsi->gameModel->BrushListSize()))
	{
		return luaL_error(L, "Invalid brush index %i", index);
	}
	lsi->gameModel->SetBrushID(index);
	return 0;
}

static int brushRadius(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) < 1)
	{
		auto radius = lsi->gameModel->GetBrush().GetRadius();
		lua_pushnumber(L, radius.X);
		lua_pushnumber(L, radius.Y);
		return 2;
	}
	lsi->gameModel->GetBrush().SetRadius({ luaL_checkint(L, 1), luaL_checkint(L, 2) });
	return 0;
}

static int mousePosition(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	auto pos = lsi->gameController->GetView()->GetMousePosition();
	lua_pushnumber(L, pos.X);
	lua_pushnumber(L, pos.Y);
	return 2;
}

static int activeTool(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	auto index = luaL_checkint(L, 1);
	if (index < 0 || index >= NUM_TOOLINDICES)
	{
		return luaL_error(L, "Invalid tool index %i", index);
	}
	if (lua_gettop(L) < 2)
	{
		tpt_lua_pushByteString(L, lsi->gameModel->GetActiveTool(index)->Identifier);
		return 1;
	}
	lsi->AssertMutableToolsEvent();
	auto identifier = tpt_lua_checkByteString(L, 2);
	auto *tool = lsi->gameModel->GetToolFromIdentifier(identifier);
	if (!tool)
	{
		return luaL_error(L, "Invalid tool identifier %s", identifier.c_str());
	}
	lsi->gameController->SetActiveTool(index, tool);
	return 0;
}

static int addComponent(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	void *opaque = nullptr;
	LuaComponent *luaComponent = nullptr;
	if ((opaque = Luna<LuaButton>::tryGet(L, 1)))
		luaComponent = Luna<LuaButton>::get(opaque);
	else if ((opaque = Luna<LuaLabel>::tryGet(L, 1)))
		luaComponent = Luna<LuaLabel>::get(opaque);
	else if ((opaque = Luna<LuaTextbox>::tryGet(L, 1)))
		luaComponent = Luna<LuaTextbox>::get(opaque);
	else if ((opaque = Luna<LuaCheckbox>::tryGet(L, 1)))
		luaComponent = Luna<LuaCheckbox>::get(opaque);
	else if ((opaque = Luna<LuaSlider>::tryGet(L, 1)))
		luaComponent = Luna<LuaSlider>::get(opaque);
	else if ((opaque = Luna<LuaProgressBar>::tryGet(L, 1)))
		luaComponent = Luna<LuaProgressBar>::get(opaque);
	else
		luaL_typerror(L, 1, "Component");
	if (lsi->window && luaComponent)
	{
		auto ok = lsi->grabbedComponents.insert(std::make_pair(luaComponent, LuaSmartRef()));
		if (ok.second)
		{
			auto it = ok.first;
			it->second.Assign(L, 1);
			it->first->owner_ref = it->second;
		}
		lsi->window->AddComponent(luaComponent->GetComponent());
	}
	return 0;
}

static int removeComponent(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	void *opaque = nullptr;
	LuaComponent *luaComponent = nullptr;
	if ((opaque = Luna<LuaButton>::tryGet(L, 1)))
		luaComponent = Luna<LuaButton>::get(opaque);
	else if ((opaque = Luna<LuaLabel>::tryGet(L, 1)))
		luaComponent = Luna<LuaLabel>::get(opaque);
	else if ((opaque = Luna<LuaTextbox>::tryGet(L, 1)))
		luaComponent = Luna<LuaTextbox>::get(opaque);
	else if ((opaque = Luna<LuaCheckbox>::tryGet(L, 1)))
		luaComponent = Luna<LuaCheckbox>::get(opaque);
	else if ((opaque = Luna<LuaSlider>::tryGet(L, 1)))
		luaComponent = Luna<LuaSlider>::get(opaque);
	else if ((opaque = Luna<LuaProgressBar>::tryGet(L, 1)))
		luaComponent = Luna<LuaProgressBar>::get(opaque);
	else
		luaL_typerror(L, 1, "Component");
	if(lsi->window && luaComponent)
	{
		ui::Component *component = luaComponent->GetComponent();
		lsi->window->RemoveComponent(component);
		auto it = lsi->grabbedComponents.find(luaComponent);
		if (it != lsi->grabbedComponents.end())
		{
			it->second.Clear();
			it->first->owner_ref = it->second;
			lsi->grabbedComponents.erase(it);
		}
	}
	return 0;
}

static int grabTextInput(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	lsi->textInputRefcount += 1;
	lsi->gameController->GetView()->DoesTextInput = lsi->textInputRefcount > 0;
	return 0;
}

static int dropTextInput(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	lsi->textInputRefcount -= 1;
	lsi->gameController->GetView()->DoesTextInput = lsi->textInputRefcount > 0;
	return 0;
}

static int textInputRect(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	int x = luaL_checkint(L, 1);
	int y = luaL_checkint(L, 2);
	int w = luaL_checkint(L, 3);
	int h = luaL_checkint(L, 4);
	ui::Engine::Ref().TextInputRect(ui::Point{ x, y }, ui::Point{ w, h });
	return 0;
}

static int showWindow(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	LuaWindow * window = Luna<LuaWindow>::check(L, 1);

	if(window && ui::Engine::Ref().GetWindow()!=window->GetWindow())
		ui::Engine::Ref().ShowWindow(window->GetWindow());
	return 0;
}

static int closeWindow(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	LuaWindow * window = Luna<LuaWindow>::check(L, 1);
	if (window)
		window->GetWindow()->CloseActiveWindow();
	return 0;
}

static int perfectCircleBrush(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (!lua_gettop(L))
	{
		lua_pushboolean(L, lsi->gameModel->GetPerfectCircle());
		return 1;
	}
	luaL_checktype(L, 1, LUA_TBOOLEAN);
	lsi->gameModel->SetPerfectCircle(lua_toboolean(L, 1));
	return 0;
}

static int activeMenu(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushinteger(L, lsi->gameModel->GetActiveMenu());
		return 1;
	}
	auto &sd = SimulationData::CRef();
	int menuid = luaL_checkint(L, 1);
	if (menuid >= 0 && menuid < int(sd.msections.size()))
		lsi->gameController->SetActiveMenu(menuid);
	else
		return luaL_error(L, "Invalid menu");
	return 0;
}

static int menuEnabled(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int menusection = luaL_checkint(L, 1);
	{
		auto &sd = SimulationData::CRef();
		if (menusection < 0 || menusection >= int(sd.msections.size()))
			return luaL_error(L, "Invalid menu");
	}
	int acount = lua_gettop(L);
	if (acount == 1)
	{
		lua_pushboolean(L, SimulationData::CRef().msections[menusection].doshow);
		return 1;
	}
	luaL_checktype(L, 2, LUA_TBOOLEAN);
	int enabled = lua_toboolean(L, 2);
	{
		auto &sd = SimulationData::Ref();
		sd.msections[menusection].doshow = enabled;
	}
	lsi->gameModel->BuildMenus();
	return 0;
}

static int numMenus(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	bool onlyEnabled = true;
	if (acount > 0)
	{
		luaL_checktype(L, 1, LUA_TBOOLEAN);
		onlyEnabled = lua_toboolean(L, 1);
	}
	lua_pushinteger(L, lsi->gameController->GetNumMenus(onlyEnabled));
	return 1;
}

static int windowSize(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto &g = ui::Engine::Ref();
	if (lua_gettop(L) < 1)
	{
		lua_pushinteger(L, g.GetScale());
		lua_pushboolean(L, g.GetFullscreen());
		return 2;
	}
	int scale = luaL_optint(L,1,1);
	auto kiosk = lua_toboolean(L,2);
	// TODO: handle this the same way as it's handled in PowderToySDL.cpp
	//   > maybe bind the maximum allowed scale to screen size somehow
	if (scale < 1 || scale > 10)
	{
		scale = 1;
	}
	{
		auto &prefs = GlobalPrefs::Ref();
		Prefs::DeferWrite dw(prefs);
		prefs.Set("Scale", scale);
		prefs.Set("Fullscreen", kiosk);
	}
	g.SetScale(scale);
	g.SetFullscreen(kiosk);
	return 0;
}

void LuaInterface::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(showWindow),
		LFUNC(closeWindow),
		LFUNC(addComponent),
		LFUNC(removeComponent),
		LFUNC(grabTextInput),
		LFUNC(dropTextInput),
		LFUNC(textInputRect),
		LFUNC(beginInput),
		LFUNC(beginMessageBox),
		LFUNC(beginConfirm),
		LFUNC(beginThrowError),
		LFUNC(activeMenu),
		LFUNC(menuEnabled),
		LFUNC(numMenus),
		LFUNC(perfectCircleBrush),
		LFUNC(console),
		LFUNC(windowSize),
		LFUNC(brushID),
		LFUNC(brushRadius),
		LFUNC(mousePosition),
		LFUNC(activeTool),
#undef LFUNC
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
#define LCONSTAS(k, v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, k)
	LCONSTAS("MOUSEUP_NORMAL" , GameController::mouseUpNormal);
	LCONSTAS("MOUSEUP_BLUR"   , GameController::mouseUpBlur);
	LCONSTAS("MOUSEUP_DRAWEND", GameController::mouseUpDrawEnd);
	LCONSTAS("NUM_TOOLINDICES", NUM_TOOLINDICES);
#undef LCONSTAS
	initLuaSDLKeys(L);
	lua_pushvalue(L, -1);
	lua_setglobal(L, "interface");
	lua_setglobal(L, "ui");
	Luna<LuaWindow     >::Register(L);
	Luna<LuaButton     >::Register(L);
	Luna<LuaLabel      >::Register(L);
	Luna<LuaTextbox    >::Register(L);
	Luna<LuaCheckbox   >::Register(L);
	Luna<LuaSlider     >::Register(L);
	Luna<LuaProgressBar>::Register(L);
}


=== src\lua\LuaLabel.cpp ===

#include "LuaScriptInterface.h"
#include "LuaLabel.h"
#include "gui/interface/Label.h"

const char LuaLabel::className[] = "label";

#define method(class, name) {#name, &class::name}
Luna<LuaLabel>::RegType LuaLabel::methods[] = {
	method(LuaLabel, text),
	method(LuaLabel, position),
	method(LuaLabel, size),
	method(LuaLabel, visible),
	{nullptr, nullptr}
};

LuaLabel::LuaLabel(lua_State *L) :
	LuaComponent(L)
{
	this->L = L;
	int posX = luaL_optinteger(L, 1, 0);
	int posY = luaL_optinteger(L, 2, 0);
	int sizeX = luaL_optinteger(L, 3, 10);
	int sizeY = luaL_optinteger(L, 4, 10);
	String text = tpt_lua_optString(L, 5, "");

	label = new ui::Label(ui::Point(posX, posY), ui::Point(sizeX, sizeY), text);
	component = label;
}

int LuaLabel::text(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		label->SetText(tpt_lua_checkString(L, 1));
		return 0;
	}
	else
	{
		tpt_lua_pushString(L, label->GetText());
		return 1;
	}
}

LuaLabel::~LuaLabel()
{
}


=== src\lua\LuaLabel.h ===

#pragma once

#include "LuaLuna.h"
#include "LuaComponent.h"

namespace ui
{
	class Label;
}

class LuaScriptInterface;

class LuaLabel: public LuaComponent
{
	ui::Label * label;
	int text(lua_State *L);
public:
	static const char className[];
	static Luna<LuaLabel>::RegType methods[];

	LuaLabel(lua_State *L);
	~LuaLabel();
};


=== src\lua\LuaLuna.h ===

#pragma once
//http://lua-users.org/wiki/SimplerCppBinding
#include "LuaCompat.h"
#include "LuaScriptInterface.h"

template <typename T> class Luna
{
	typedef struct { T *pT; } userdataType;
public:
	typedef int (T::*mfp)(lua_State *L);
	typedef struct { const char *name; mfp mfunc; } RegType;

	static void Register(lua_State *L)
	{
		lua_getglobal(L, "interface");
		int ui = lua_gettop(L);

		lua_newtable(L);
		int methods = lua_gettop(L);

		luaL_newmetatable(L, T::className);
		int metatable = lua_gettop(L);

		lua_pushliteral(L, "__metatable");
		lua_pushvalue(L, methods);
		lua_settable(L, metatable);  // hide metatable from Lua getmetatable()

		lua_pushliteral(L, "__index");
		lua_pushvalue(L, methods);
		lua_settable(L, metatable);

		lua_pushliteral(L, "__tostring");
		lua_pushcfunction(L, tostring_T);
		lua_settable(L, metatable);

		lua_pushliteral(L, "__gc");
		lua_pushcfunction(L, gc_T);
		lua_settable(L, metatable);

		// fill method table with methods from class T
		for (RegType *l = T::methods; l->name; l++)
		{
			/* edited by Snaily: shouldn't it be const RegType *l ... ? */
			lua_pushstring(L, l->name);
			lua_pushinteger(L, l - T::methods);
			lua_pushcclosure(L, thunk, 1);
			lua_settable(L, methods);
		}

		lua_pop(L, 2);  // pop metatable, and method table

		lua_pushcfunction(L, new_T);
		lua_setfield(L, ui, T::className);
		lua_pop(L, 1);
	}

	// get userdata from Lua stack and return pointer to T object
	static T * check(lua_State *L, int narg)
	{
		userdataType *ud = static_cast<userdataType*>(luaL_checkudata(L, narg, T::className));
		if(!ud)
			luaL_typerror(L, narg, T::className);
		return ud->pT;  // pointer to T object
	}

	static void * tryGet(lua_State *L, int narg)
	{
		if(checkType(L, narg, T::className))
		{
			userdataType *ud = static_cast<userdataType*>(luaL_checkudata(L, narg, T::className));
			if(!ud)
				luaL_typerror(L, narg, T::className);
			return ud;  // pointer to T object
		}
		else
		{
			return NULL;
		}
	}

	static bool checkType (lua_State *L, int idx, const char *name)
	{
		// returns true if a userdata is of a certain type
		int res;
		if (lua_type(L, idx) != LUA_TUSERDATA) return false;
		lua_getmetatable(L, idx);
		luaL_newmetatable (L, name);
		res = lua_equal(L, -2, -1);
		lua_pop(L, 2); // pop both tables (metatables) off
		return res;
	}

	static inline T * get(void * userData)
	{
		return ((userdataType*)userData)->pT;
	}

private:
	Luna();  // hide default constructor

	// member function dispatcher
	static int thunk(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent();
		// stack has userdata, followed by method args
		T *obj = check(L, 1);  // get 'self', or if you prefer, 'this'
		lua_remove(L, 1);  // remove self so member function args start at index 1
		// get member function from upvalue
		RegType *l = T::methods + lua_tointeger(L, lua_upvalueindex(1));
		return (obj->*(l->mfunc))(L);  // call member function
	}

	// create a new T object and
	// push onto the Lua stack a userdata containing a pointer to T object
	static int new_T(lua_State *L)
	{	
		GetLSI()->AssertInterfaceEvent();
		if (!lua_gettop(L))
			return 0;

		T *obj = new T(L);  // call constructor for T objects
		userdataType *ud = static_cast<userdataType*>(lua_newuserdata(L, sizeof(userdataType)));
		ud->pT = obj;  // store pointer to object in userdata

		luaL_getmetatable(L, T::className);  // lookup metatable in Lua registry
		lua_setmetatable(L, -2);
		return 1;  // userdata containing pointer to T object
	}

	// garbage collection metamethod
	static int gc_T(lua_State *L)
	{
		// not subject to the check in new_T; that would be disastrous, but
		// in theory, if the component is ready to be garbage-collected, there are no references
		// being held to it anywhere and so it can't cause trouble during its destruction...
		userdataType *ud = static_cast<userdataType*>(lua_touserdata(L, 1));
		T *obj = ud->pT;
		delete obj;  // call destructor for T objects
		return 0;
	}

	static int tostring_T (lua_State *L)
	{
		char buff[32];
		userdataType *ud = static_cast<userdataType*>(lua_touserdata(L, 1));
		T *obj = ud->pT;
		snprintf(buff, sizeof(buff), "%p", obj);
		lua_pushfstring(L, "%s (%s)", T::className, buff);
		return 1;
	}
};


=== src\lua\LuaMisc.cpp ===

#include "LuaScriptInterface.h"
#include "client/http/Request.h"
#include "common/platform/Platform.h"
#include "compat_lua.h"
#include "Config.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/dialogues/InformationMessage.h"
#include "gui/game/GameController.h"
#include "gui/game/GameModel.h"
#include "gui/game/GameView.h"
#include "gui/interface/Engine.h"

static int getUserName(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lsi->gameModel->GetUser().UserID)
	{
		tpt_lua_pushByteString(L, lsi->gameModel->GetUser().Username);
		return 1;
	}
	lua_pushliteral(L, "");
	return 1;
}

static int installScriptManager(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lsi->scriptManagerDownload)
	{
		new ErrorMessage("Script download", "A script download is already pending");
		return 0;
	}
	lsi->gameController->HideConsole();
	if (ui::Engine::Ref().GetWindow() != lsi->gameController->GetView())
	{
		new ErrorMessage("Script download", "You must run this function from the console");
		return 0;
	}
	lsi->scriptManagerDownload = std::make_unique<http::Request>(ByteString::Build("https://starcatcher.us/scripts/main.lua?get=1"));
	lsi->scriptManagerDownload->Start();
	return 0;
}

void LuaMisc::Tick(lua_State *L)
{
	auto *lsi = GetLSI();
	if (lsi->scriptManagerDownload && lsi->scriptManagerDownload->CheckDone())
	{
		auto scriptManagerDownload = std::move(lsi->scriptManagerDownload);
		struct Status
		{
			struct Ok
			{
			};
			struct GetFailed
			{
				String error;
			};
			struct RunFailed
			{
				String error;
			};
			using Value = std::variant<
				Ok,
				GetFailed,
				RunFailed
			>;
			Value value;
		};
		auto complete = [](Status status) {
			if (std::get_if<Status::Ok>(&status.value))
			{
				new InformationMessage("Install script manager", "Script manager successfully installed", false);
			}
			if (auto *requestFailed = std::get_if<Status::GetFailed>(&status.value))
			{
				new ErrorMessage("Install script manager", "Failed to get script manager: " + requestFailed->error);
			}
			if (auto *runFailed = std::get_if<Status::RunFailed>(&status.value))
			{
				new ErrorMessage("Install script manager", "Failed to run script manager: " + runFailed->error);
			}
		};
		try
		{
			auto ret = scriptManagerDownload->StatusCode();
			auto scriptData = scriptManagerDownload->Finish().second;
			if (!scriptData.size())
			{
				complete({ Status::GetFailed{ "Server did not return data" } });
				return;
			}
			if (ret != 200)
			{
				complete({ Status::GetFailed{ ByteString(http::StatusText(ret)).FromUtf8() } });
				return;
			}
			ByteString filename = "autorun.lua";
			if (!Platform::WriteFile(scriptData, filename))
			{
				complete({ Status::GetFailed{ String::Build("Unable to write to ", filename.FromUtf8()) } });
				return;
			}
			if (lsi->Autorun())
			{
				complete({ Status::RunFailed{ LuaGetError() } });
				lua_pop(lsi->L, 1);
				return;
			}
			complete({ Status::Ok{} });
		}
		catch (const http::RequestError &ex)
		{
			complete({ Status::GetFailed{ ByteString(ex.what()).FromUtf8() } });
		}
	}
}

static int flog(lua_State *L)
{
	auto *lsi = GetLSI();
	int args = lua_gettop(L);
	String text;
	bool hasText = false;
	for(int i = 1; i <= args; i++)
	{
		LuaToLoggableString(L, -1);
		if (hasText)
		{
			text = tpt_lua_optString(L, -1, "") + ", " + text;
		}
		else
		{
			text = tpt_lua_optString(L, -1, "");
			hasText = true;
		}
		lua_pop(L, 2);
	}
	lsi->Log(CommandInterface::LogNotice, text);
	return 0;
}

static int screenshot(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int captureUI = luaL_optint(L, 1, 0);
	int fileType = luaL_optint(L, 2, 0);

	ByteString filename = lsi->gameController->TakeScreenshot(captureUI, fileType);
	if (filename.size())
	{
		tpt_lua_pushByteString(L, filename);
		return 1;
	}
	return 0;
}

static int record(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (!lua_isboolean(L, -1))
		return luaL_typerror(L, 1, lua_typename(L, LUA_TBOOLEAN));
	bool record = lua_toboolean(L, -1);
	int recordingFolder = lsi->gameController->Record(record);
	lua_pushinteger(L, recordingFolder);
	return 1;
}

static int compatChunk(lua_State *L)
{
	auto data = compat_lua.AsCharSpan();
	lua_pushlstring(L, data.data(), data.size());
	return 1;
}
static int debug(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushinteger(L, lsi->gameController->GetDebugFlags());
		return 1;
	}
	int debugFlags = luaL_optint(L, 1, 0);
	lsi->gameController->SetDebugFlags(debugFlags);
	return 0;
}

static int fpsCap(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		auto fpsLimit = lsi->window->GetSimFpsLimit();
		if (std::holds_alternative<FpsLimitNone>(fpsLimit))
		{
			lua_pushnumber(L, 2);
		}
		else
		{
			lua_pushnumber(L, std::get<FpsLimitExplicit>(fpsLimit).value);
		}
		return 1;
	}
	float fpscap = luaL_checknumber(L, 1);
	if (fpscap < 2)
	{
		return luaL_error(L, "fps cap too small");
	}
	if (fpscap == 2)
	{
		lsi->window->SetSimFpsLimit(FpsLimitNone{});
		return 0;
	}
	lsi->window->SetSimFpsLimit(FpsLimitExplicit{ fpscap });
	return 0;
}

static int drawCap(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		auto drawLimit = ui::Engine::Ref().GetDrawingFrequencyLimit();
		if (std::holds_alternative<DrawLimitDisplay>(drawLimit))
		{
			lua_pushliteral(L, "display");
		}
		else if (std::holds_alternative<DrawLimitNone>(drawLimit))
		{
			lua_pushinteger(L, 0);
		}
		else
		{
			lua_pushinteger(L, std::get<DrawLimitExplicit>(drawLimit).value);
		}
		return 1;
	}
	// if (lua_isstring(L, 1) && byteStringEqualsLiteral(tpt_lua_toByteString(L, 1), "vsync")) // TODO: DrawLimitVsync
	if (lua_isstring(L, 1) && byteStringEqualsLiteral(tpt_lua_toByteString(L, 1), "display"))
	{
		ui::Engine::Ref().SetDrawingFrequencyLimit(DrawLimitDisplay{});
		return 0;
	}
	int drawcap = luaL_checkinteger(L, 1);
	if(drawcap < 0)
		return luaL_error(L, "draw cap too small");
	if (drawcap == 0)
	{
		ui::Engine::Ref().SetDrawingFrequencyLimit(DrawLimitNone{});
		return 0;
	}
	ui::Engine::Ref().SetDrawingFrequencyLimit(DrawLimitExplicit{ drawcap });
	return 0;
}

void LuaMisc::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(getUserName),
		LFUNC(installScriptManager),
		LFUNC(screenshot),
		LFUNC(record),
		LFUNC(debug),
		LFUNC(fpsCap),
		LFUNC(drawCap),
		LFUNC(compatChunk),
#undef LFUNC
		{ "log", flog },
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
#define LCONST(v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, #v)
	LCONST(DEBUG_PARTS);
	LCONST(DEBUG_ELEMENTPOP);
	LCONST(DEBUG_LINES);
	LCONST(DEBUG_PARTICLE);
	LCONST(DEBUG_SURFNORM);
	LCONST(DEBUG_SIMHUD);
	LCONST(DEBUG_RENHUD);
	LCONST(DEBUG_AIRVEL);
#undef LCONST
	{
		lua_newtable(L);
#define LCONSTAS(k, v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, k)
		LCONSTAS("major"        , DISPLAY_VERSION[0]);
		LCONSTAS("minor"        , DISPLAY_VERSION[1]);
		LCONSTAS("build"        , APP_VERSION.build);
		LCONSTAS("upstreamMajor", UPSTREAM_VERSION.displayVersion[0]);
		LCONSTAS("upstreamMinor", UPSTREAM_VERSION.displayVersion[1]);
		LCONSTAS("upstreamBuild", UPSTREAM_VERSION.build);
		LCONSTAS("modid"        , MOD_ID);
#undef LCONSTAS
		lua_pushboolean(L, SNAPSHOT);
		lua_setfield(L, -2, "snapshot");
		lua_pushboolean(L, BETA);
		lua_setfield(L, -2, "beta");
		auto vcsTag = ByteString(VCS_TAG);
		if (vcsTag.size())
		{
			tpt_lua_pushByteString(L, vcsTag);
			lua_setfield(L, -2, "vcstag");
		}
		lua_pushstring(L, PACKAGE_MODE);
		lua_setfield(L, -2, "packagemode");
		lua_setfield(L, -2, "version");
	}
	lua_setglobal(L, "tpt");
}


=== src\lua\LuaPlatform.cpp ===

#include "LuaScriptInterface.h"
#include "common/platform/Platform.h"
#include "Config.h"
#include "PowderToySDL.h"

static int platform(lua_State *L)
{
	tpt_lua_pushByteString(L, IDENT_PLATFORM);
	return 1;
}

static int ident(lua_State *L)
{
	tpt_lua_pushByteString(L, IDENT);
	return 1;
}

static int releaseType(lua_State *L)
{
	tpt_lua_pushByteString(L, ByteString(1, IDENT_RELTYPE));
	return 1;
}

static int exeName(lua_State *L)
{
	ByteString name = Platform::ExecutableName();
	if (name.length())
		tpt_lua_pushByteString(L, name);
	else
		luaL_error(L, "Error, could not get executable name");
	return 1;
}

static int restart(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	Platform::DoRestart();
	return 0;
}

static int openLink(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto uri = tpt_lua_checkByteString(L, 1);
	Platform::OpenURI(uri);
	return 0;
}

static int clipboardCopy(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	tpt_lua_pushByteString(L, ClipboardPull());
	return 1;
}

static int clipboardPaste(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	luaL_checktype(L, 1, LUA_TSTRING);
	ClipboardPush(tpt_lua_optByteString(L, 1, ""));
	return 0;
}

void LuaPlatform::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(platform),
		LFUNC(ident),
		LFUNC(releaseType),
		LFUNC(exeName),
		LFUNC(restart),
		LFUNC(openLink),
		LFUNC(clipboardCopy),
		LFUNC(clipboardPaste),
#undef LFUNC
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
	lua_pushvalue(L, -1);
	lua_setglobal(L, "platform");
	lua_setglobal(L, "plat");
}


=== src\lua\LuaProgressBar.cpp ===

#include "LuaProgressBar.h"
#include "LuaScriptInterface.h"
#include "gui/interface/ProgressBar.h"

const char LuaProgressBar::className[] = "progressBar";

#define method(class, name) {#name, &class::name}
Luna<LuaProgressBar>::RegType LuaProgressBar::methods[] = {
	method(LuaProgressBar, position),
	method(LuaProgressBar, size),
	method(LuaProgressBar, visible),
	method(LuaProgressBar, progress),
	method(LuaProgressBar, status),
	{nullptr, nullptr}
};

LuaProgressBar::LuaProgressBar(lua_State *L) :
	LuaComponent(L)
{
	int posX = luaL_optinteger(L, 1, 0);
	int posY = luaL_optinteger(L, 2, 0);
	int sizeX = luaL_optinteger(L, 3, 10);
	int sizeY = luaL_optinteger(L, 4, 10);
	int value = luaL_optinteger(L, 5, 0);
	String status = tpt_lua_optString(L, 6, "");

	progressBar = new ui::ProgressBar(ui::Point(posX, posY), ui::Point(sizeX, sizeY), value, status);
	component = progressBar;
}

int LuaProgressBar::progress(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		progressBar->SetProgress(lua_tointeger(L, 1));
		return 0;
	}
	else
	{
		lua_pushinteger(L, progressBar->GetProgress());
		return 1;
	}
}

int LuaProgressBar::status(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		progressBar->SetStatus(tpt_lua_checkString(L, 1));
		return 0;
	}
	else
	{
		tpt_lua_pushString(L, progressBar->GetStatus());
		return 1;
	}
}

LuaProgressBar::~LuaProgressBar()
{
}


=== src\lua\LuaProgressBar.h ===

#pragma once

#include "LuaLuna.h"
#include "LuaComponent.h"

namespace ui
{
	class ProgressBar;
}

class LuaScriptInterface;

class LuaProgressBar: public LuaComponent
{
	ui::ProgressBar * progressBar;
	int progress(lua_State *L);
	int status(lua_State *L);
public:
	static const char className[];
	static Luna<LuaProgressBar>::RegType methods[];

	LuaProgressBar(lua_State *L);
	~LuaProgressBar();
};


=== src\lua\LuaRenderer.cpp ===

#include "LuaScriptInterface.h"
#include "gui/game/GameController.h"
#include "gui/game/GameModel.h"
#include "graphics/Renderer.h"
#include "graphics/Graphics.h"
#include "simulation/ElementGraphics.h"

static int renderMode(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L))
	{
		lsi->gameModel->GetRendererSettings().renderMode = luaL_checkinteger(L, 1);
		return 0;
	}
	lua_pushinteger(L, lsi->gameModel->GetRendererSettings().renderMode);
	return 1;
}

static int hud(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushboolean(L, lsi->gameController->GetHudEnable());
		return 1;
	}
	auto hudstate = lua_toboolean(L, 1);
	lsi->gameController->SetHudEnable(hudstate);
	return 0;
}

static int debugHud(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushboolean(L, lsi->gameController->GetDebugHUD());
		return 1;
	}
	auto debug = lua_toboolean(L, 1);
	lsi->gameController->SetDebugHUD(debug);
	return 0;
}

static int useDisplayPreset(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int cmode = luaL_optint(L, 1, 3)+1;
	if (cmode == 11)
		cmode = 0;
	if (cmode >= 0 && cmode <= 10)
		lsi->gameController->LoadRenderPreset(cmode);
	else
		return luaL_error(L, "Invalid display mode");
	return 0;
}

static int fireSize(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) < 1)
	{
		lua_pushnumber(L, lsi->gameModel->GetRendererSettings().fireIntensity);
		return 1;
	}
	lsi->gameModel->GetRendererSettings().fireIntensity = float(luaL_checknumber(L, 1));
	return 0;
}

static int displayMode(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L))
	{
		lsi->gameModel->GetRendererSettings().displayMode = luaL_checkinteger(L, 1);
		return 0;
	}
	lua_pushinteger(L, lsi->gameModel->GetRendererSettings().displayMode);
	return 1;
}


static int colorMode(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L))
	{
		lsi->gameModel->GetRendererSettings().colorMode = luaL_checkinteger(L, 1);
		return 0;
	}
	lua_pushinteger(L, lsi->gameModel->GetRendererSettings().colorMode);
	return 1;
}

static int decorations(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushboolean(L, lsi->gameModel->GetDecoration());
		return 1;
	}
	int decostate = lua_toboolean(L, 1);
	lsi->gameModel->SetDecoration(decostate);
	lsi->gameModel->UpdateQuickOptions();
	return 0;
}

static int grid(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->gameModel->GetRendererSettings().gridSize);
		return 1;
	}
	int grid = luaL_optint(L, 1, -1);
	lsi->gameModel->GetRendererSettings().gridSize = grid;
	return 0;
}

static int showBrush(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->gameController->GetBrushEnable());
		return 1;
	}
	int brush = luaL_optint(L, 1, -1);
	lsi->gameController->SetBrushEnable(brush);
	return 0;
}

static int depth3d(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	return luaL_error(L, "This feature is no longer supported");
}

static int zoomEnabled(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) == 0)
	{
		lua_pushboolean(L, lsi->g->zoomEnabled);
		return 1;
	}
	else
	{
		luaL_checktype(L, -1, LUA_TBOOLEAN);
		lsi->g->zoomEnabled = lua_toboolean(L, -1);
		return 0;
	}
}

static int zoomWindow(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) == 0)
	{
		ui::Point location = lsi->g->zoomWindowPosition;
		lua_pushnumber(L, location.X);
		lua_pushnumber(L, location.Y);
		lua_pushnumber(L, lsi->g->ZFACTOR);
		lua_pushnumber(L, lsi->g->zoomScopeSize * lsi->g->ZFACTOR);
		return 4;
	}
	int x = luaL_optint(L, 1, 0);
	int y = luaL_optint(L, 2, 0);
	int f = luaL_optint(L, 3, 0);
	if (f <= 0)
		return luaL_error(L, "Zoom factor must be greater than 0");

	// To prevent crash when zoom window is outside screen
	if (x < 0 || y < 0 || lsi->g->zoomScopeSize * f + x > XRES || lsi->g->zoomScopeSize * f + y > YRES)
		return luaL_error(L, "Zoom window outside of bounds");

	lsi->g->zoomWindowPosition = ui::Point(x, y);
	lsi->g->ZFACTOR = f;
	return 0;
}

static int zoomScope(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) == 0)
	{
		ui::Point location = lsi->g->zoomScopePosition;
		lua_pushnumber(L, location.X);
		lua_pushnumber(L, location.Y);
		lua_pushnumber(L, lsi->g->zoomScopeSize);
		return 3;
	}
	int x = luaL_optint(L, 1, 0);
	int y = luaL_optint(L, 2, 0);
	int s = luaL_optint(L, 3, 0);
	if (s <= 0)
		return luaL_error(L, "Zoom scope size must be greater than 0");

	// To prevent crash when zoom or scope window is outside screen
	int windowEdgeRight = lsi->g->ZFACTOR * s + lsi->g->zoomWindowPosition.X;
	int windowEdgeBottom = lsi->g->ZFACTOR * s + lsi->g->zoomWindowPosition.Y;
	if (x < 0 || y < 0 || x + s > XRES || y + s > YRES)
		return luaL_error(L, "Zoom scope outside of bounds");
	if (windowEdgeRight > XRES || windowEdgeBottom > YRES)
		return luaL_error(L, "Zoom window outside of bounds");

	lsi->g->zoomScopePosition = ui::Point(x, y);
	lsi->g->zoomScopeSize = s;
	return 0;
}

static int separateThread(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L))
	{
		lsi->gameModel->SetThreadedRendering(lua_toboolean(L, 1));
		return 0;
	}
	lua_pushboolean(L, lsi->gameModel->GetThreadedRendering());
	return 1;
}

static int heatDisplayLimits(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	auto &rendererSettings = lsi->gameModel->GetRendererSettings();
	if (lua_gettop(L))
	{
		auto write = [L](auto &setting, int index) {
			if (lua_isstring(L, index) && byteStringEqualsLiteral(tpt_lua_toByteString(L, index), "auto"))
			{
				setting = HdispLimitAuto{};
			}
			else
			{
				setting = HdispLimitExplicit{ float(luaL_checknumber(L, index)) };
			}
		};
		write(rendererSettings.wantHdispLimitMin, 1);
		write(rendererSettings.wantHdispLimitMax, 2);
		return 0;
	}
	auto read = [L](auto &setting) {
		if (auto *hdispLimitExplicit = std::get_if<HdispLimitExplicit>(&setting))
		{
			lua_pushnumber(L, hdispLimitExplicit->value);
		}
		else
		{
			lua_pushliteral(L, "auto");
		}
	};
	read(rendererSettings.wantHdispLimitMin);
	read(rendererSettings.wantHdispLimitMax);
	return 2;
}

static int heatDisplayAutoArea(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	auto &rendererSettings = lsi->gameModel->GetRendererSettings();
	if (lua_gettop(L))
	{
		rendererSettings.autoHdispLimitArea.pos .X = luaL_checkinteger(L, 1);
		rendererSettings.autoHdispLimitArea.pos .Y = luaL_checkinteger(L, 2);
		rendererSettings.autoHdispLimitArea.size.X = luaL_checkinteger(L, 3);
		rendererSettings.autoHdispLimitArea.size.Y = luaL_checkinteger(L, 4);
		return 0;
	}
	lua_pushinteger(L, rendererSettings.autoHdispLimitArea.pos .X);
	lua_pushinteger(L, rendererSettings.autoHdispLimitArea.pos .Y);
	lua_pushinteger(L, rendererSettings.autoHdispLimitArea.size.X);
	lua_pushinteger(L, rendererSettings.autoHdispLimitArea.size.Y);
	return 4;
}

void LuaRenderer::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(renderMode),
		LFUNC(displayMode),
		LFUNC(colorMode),
		LFUNC(decorations),
		LFUNC(grid),
		LFUNC(debugHud),
		LFUNC(hud),
		LFUNC(showBrush),
		LFUNC(depth3d),
		LFUNC(zoomEnabled),
		LFUNC(zoomWindow),
		LFUNC(zoomScope),
		LFUNC(fireSize),
		LFUNC(useDisplayPreset),
		LFUNC(separateThread),
		LFUNC(heatDisplayLimits),
		LFUNC(heatDisplayAutoArea),
#undef LFUNC
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
#define LCONST(v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, #v)
	LCONST(PMODE);
	LCONST(PMODE_NONE);
	LCONST(PMODE_FLAT);
	LCONST(PMODE_BLOB);
	LCONST(PMODE_BLUR);
	LCONST(PMODE_GLOW);
	LCONST(PMODE_SPARK);
	LCONST(PMODE_FLARE);
	LCONST(PMODE_LFLARE);
	LCONST(PMODE_ADD);
	LCONST(PMODE_BLEND);
	LCONST(PSPEC_STICKMAN);
	LCONST(OPTIONS);
	LCONST(NO_DECO);
	LCONST(DECO_FIRE);
	LCONST(FIREMODE);
	LCONST(FIRE_ADD);
	LCONST(FIRE_BLEND);
	LCONST(FIRE_SPARK);
	LCONST(EFFECT);
	LCONST(EFFECT_GRAVIN);
	LCONST(EFFECT_GRAVOUT);
	LCONST(EFFECT_LINES);
	LCONST(EFFECT_DBGLINES);
	LCONST(RENDER_EFFE);
	LCONST(RENDER_FIRE);
	LCONST(RENDER_GLOW);
	LCONST(RENDER_BLUR);
	LCONST(RENDER_BLOB);
	LCONST(RENDER_BASC);
	LCONST(RENDER_NONE);
	LCONST(COLOUR_HEAT);
	LCONST(COLOUR_LIFE);
	LCONST(COLOUR_GRAD);
	LCONST(COLOUR_BASC);
	LCONST(COLOUR_DEFAULT);
	LCONST(DISPLAY_AIRC);
	LCONST(DISPLAY_AIRP);
	LCONST(DISPLAY_AIRV);
	LCONST(DISPLAY_AIRH);
	LCONST(DISPLAY_AIR);
	LCONST(DISPLAY_WARP);
	LCONST(DISPLAY_PERS);
	LCONST(DISPLAY_EFFE);
#undef LCONST
	lua_pushvalue(L, -1);
	lua_setglobal(L, "renderer");
	lua_setglobal(L, "ren");
}


=== src\lua\LuaScriptInterface.cpp ===

#include "LuaScriptInterface.h"
#include "client/http/Request.h"
#include "common/platform/Platform.h"
#include "common/tpt-rand.h"
#include "compat_lua.h"
#include "gui/game/GameController.h"
#include "gui/game/GameModel.h"
#include "gui/game/GameView.h"
#include "gui/interface/Engine.h"
#include "gui/interface/Window.h"
#include "LuaBit.h"
#include "LuaComponent.h"
#include "prefs/GlobalPrefs.h"
#include "simulation/Simulation.h"
#include "simulation/SimulationData.h"

static int atPanic(lua_State *L)
{
	throw std::runtime_error("Unprotected lua panic: " + tpt_lua_toByteString(L, -1));
}

static int osExit(lua_State *L)
{
	Platform::Exit(luaL_optinteger(L, 1, 0));
	return 0;
}

static int mathRandom(lua_State *L)
{
	auto *lsi = GetLSI();
	// only thing that matters is that the rng not be sim->rng when !(eventTraits & eventTraitSimRng)
	auto &rng = (lsi->eventTraits & eventTraitSimRng) ? lsi->sim->rng : interfaceRng;
	int lower, upper;
	switch (lua_gettop(L))
	{
	case 0:
		lua_pushnumber(L, rng.uniform01());
		return 1;

	case 1:
		lower = 1;
		upper = luaL_checkinteger(L, 1);
		break;

	default:
		lower = luaL_checkinteger(L, 1);
		upper = luaL_checkinteger(L, 2);
		break;
	}
	if (upper < lower)
	{
		luaL_error(L, "interval is empty");
	}
	if ((unsigned int)(upper) - (unsigned int)(lower) + 1U)
	{
		lua_pushinteger(L, rng.between(lower, upper));
	}
	else
	{
		// The interval is *so* not empty that its size overflows 32-bit integers
		// (only possible if it's exactly 0x100000000); don't use between.
		lua_pushinteger(L, int(rng()));
	}
	return 1;
}

static int mathRandomseed(lua_State *L)
{
	interfaceRng.seed(luaL_checkinteger(L, 1));
	return 0;
}

static void hook(lua_State *L, lua_Debug * ar)
{
	auto *lsi = GetLSI();
	if (ar->event == LUA_HOOKCOUNT && int(Platform::GetTime() - lsi->luaExecutionStart) > lsi->luaHookTimeout)
	{
		luaL_error(L, "Error: Script not responding");
		lsi->luaExecutionStart = Platform::GetTime();
	}
}

int LuaToLoggableString(lua_State *L, int n)
{
	luaL_checkany(L, n);
	switch (lua_type(L, n))
	{
	case LUA_TNUMBER:
		lua_tostring(L, n);
		lua_pushvalue(L, n);
		break;
	case LUA_TSTRING:
		lua_pushvalue(L, n);
		break;
	case LUA_TBOOLEAN:
		lua_pushstring(L, (lua_toboolean(L, n) ? "true" : "false"));
		break;
	case LUA_TNIL:
		lua_pushliteral(L, "nil");
		break;
	default:
		lua_pushfstring(L, "%s: %p", luaL_typename(L, n), lua_topointer(L, n));
		break;
	}
	return 1;
}

String LuaGetError()
{
	auto *lsi = GetLSI();
	LuaToLoggableString(lsi->L, -1);
	String err = tpt_lua_optString(lsi->L, -1, "failed to execute");
	lua_pop(lsi->L, 1);
	return err;
}

LuaScriptInterface::LuaScriptInterface(GameController *newGameController, GameModel *newGameModel) :
	CommandInterface(newGameController, newGameModel),
	ren(newGameModel->GetRenderer()),
	gameModel(newGameModel),
	gameController(newGameController),
	window(gameController->GetView()),
	sim(gameModel->GetSimulation()),
	g(ui::Engine::Ref().g),
	customElements(PT_NUM),
	gameControllerEventHandlers(std::variant_size_v<GameControllerEvent>)
{
	auto &prefs = GlobalPrefs::Ref();
	luaHookTimeout = prefs.Get("LuaHookTimeout", 3000);
	for (auto moving = 0; moving < PT_NUM; ++moving)
	{
		for (auto into = 0; into < PT_NUM; ++into)
		{
			customCanMove[moving][into] = 0;
		}
	}
	luaState = LuaStatePtr(luaL_newstate());
	L = luaState.get();
	lua_sethook(L, hook, LUA_MASKCOUNT, 200);
	lua_atpanic(L, atPanic);
	luaL_openlibs(L);
	{
		luaopen_bit(L);
		lua_pop(L, 1);
	}
	LuaBz2::Open(L);
	LuaElements::Open(L);
	LuaEvent::Open(L);
	LuaFileSystem::Open(L);
	LuaGraphics::Open(L);
	LuaHttp::Open(L);
	LuaInterface::Open(L);
	LuaMisc::Open(L);
	LuaPlatform::Open(L);
	LuaRenderer::Open(L);
	LuaSimulation::Open(L);
	LuaSocket::Open(L);
	LuaTools::Open(L);
	{
		lua_getglobal(L, "os");
		lua_pushcfunction(L, osExit);
		lua_setfield(L, -2, "exit");
		lua_pop(L, 1);
	}
	{
		lua_getglobal(L, "math");
		lua_pushcfunction(L, mathRandom);
		lua_setfield(L, -2, "random");
		lua_pushcfunction(L, mathRandomseed);
		lua_setfield(L, -2, "randomseed");
		lua_pop(L, 1);
	}
	auto compatSpan = compat_lua.AsCharSpan();
	if (luaL_loadbuffer(L, compatSpan.data(), compatSpan.size(), "@[built-in compat.lua]") || tpt_lua_pcall(L, 0, 0, 0, eventTraitNone))
	{
		throw std::runtime_error(ByteString("failed to load built-in compat: ") + tpt_lua_toByteString(L, -1));
	}
}

void LuaScriptInterface::InitCustomCanMove()
{
	auto &sd = SimulationData::Ref();
	sd.init_can_move();
	for (auto moving = 0; moving < PT_NUM; ++moving)
	{
		for (auto into = 0; into < PT_NUM; ++into)
		{
			if (customCanMove[moving][into] & 0x80)
			{
				sd.can_move[moving][into] = customCanMove[moving][into] & 0x7F;
			}
		}
	}
}

void CommandInterface::Init()
{
	auto *lsi = static_cast<LuaScriptInterface *>(this);
	if (lsi->Autorun())
	{
		lua_pop(lsi->L, 1);
	}
}

int LuaScriptInterface::Autorun()
{
	if (!Platform::FileExists("autorun.lua"))
	{
		lua_pushliteral(L, "autorun.lua not found");
		return 1;
	}
	if (luaL_loadfile(L, "autorun.lua") || tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
	{
		Log(CommandInterface::LogError, LuaGetError());
		return 1;
	}
	Log(CommandInterface::LogWarning, "Loaded autorun.lua");
	return 0;
}

void CommandInterface::SetToolIndex(ByteString identifier, std::optional<int> index)
{
	auto *lsi = static_cast<LuaScriptInterface *>(this);
	LuaTools::SetToolIndex(lsi->L, identifier, index);
}

void CommandInterface::RemoveComponents()
{
	auto *lsi = static_cast<LuaScriptInterface *>(this);
	for (auto &[ component, ref ] : lsi->grabbedComponents)
	{
		lsi->window->RemoveComponent(component->GetComponent());
		ref.Clear();
		component->owner_ref = ref;
		component->SetParentWindow(nullptr);
	}
}

void LuaGetProperty(lua_State *L, StructProperty property, intptr_t propertyAddress)
{
	switch (property.Type)
	{
		case StructProperty::TransitionType:
		case StructProperty::ParticleType:
		case StructProperty::Integer:
			lua_pushnumber(L, *((int*)propertyAddress));
			break;
		case StructProperty::UInteger:
			lua_pushnumber(L, *((unsigned int*)propertyAddress));
			break;
		case StructProperty::Float:
			lua_pushnumber(L, *((float*)propertyAddress));
			break;
		case StructProperty::UChar:
			lua_pushnumber(L, *((unsigned char*)propertyAddress));
			break;
		case StructProperty::BString:
		{
			tpt_lua_pushByteString(L, *((ByteString*)propertyAddress));
			break;
		}
		case StructProperty::String:
		{
			tpt_lua_pushString(L, *((String*)propertyAddress));
			break;
		}
		case StructProperty::Colour:
			lua_pushinteger(L, *((unsigned int*)propertyAddress));
			break;
		case StructProperty::Removed:
			lua_pushnil(L);
	}
}

static int32_t int32_truncate(double n)
{
	if (n >= 0x1p31)
	{
		n -= 0x1p32;
	}
	return int32_t(n);
}

void LuaSetProperty(lua_State *L, StructProperty property, intptr_t propertyAddress, int stackPos)
{
	switch (property.Type)
	{
		case StructProperty::TransitionType:
		case StructProperty::ParticleType:
		case StructProperty::Integer:
			*((int*)propertyAddress) = int32_truncate(luaL_checknumber(L, stackPos));
			break;
		case StructProperty::UInteger:
			*((unsigned int*)propertyAddress) = int32_truncate(luaL_checknumber(L, stackPos));
			break;
		case StructProperty::Float:
			*((float*)propertyAddress) = luaL_checknumber(L, stackPos);
			break;
		case StructProperty::UChar:
			*((unsigned char*)propertyAddress) = int32_truncate(luaL_checknumber(L, stackPos));
			break;
		case StructProperty::BString:
			*((ByteString*)propertyAddress) = tpt_lua_checkByteString(L, stackPos);
			break;
		case StructProperty::String:
			*((String*)propertyAddress) = tpt_lua_checkString(L, stackPos);
			break;
		case StructProperty::Colour:
			*((unsigned int*)propertyAddress) = int32_truncate(luaL_checknumber(L, stackPos));
			break;
		case StructProperty::Removed:
			break;
	}
}

void LuaSetParticleProperty(lua_State *L, int particleID, StructProperty property, intptr_t propertyAddress, int stackPos)
{
	auto *lsi = GetLSI();
	auto *sim = lsi->sim;
	if (property.Name == "type")
	{
		lsi->AssertMonopartAccessEvent(-1);
		sim->part_change_type(particleID, int(sim->parts[particleID].x+0.5f), int(sim->parts[particleID].y+0.5f), luaL_checkinteger(L, 3));
	}
	else if (property.Name == "x" || property.Name == "y")
	{
		lsi->AssertMonopartAccessEvent(-1);
		float val = luaL_checknumber(L, 3);
		float x = sim->parts[particleID].x;
		float y = sim->parts[particleID].y;
		float nx = property.Name == "x" ? val : x;
		float ny = property.Name == "y" ? val : y;
		sim->move(particleID, (int)(x + 0.5f), (int)(y + 0.5f), nx, ny);
	}
	else
	{
		lsi->AssertMonopartAccessEvent(particleID);
		LuaSetProperty(L, property, propertyAddress, 3);
	}
}

static int pushGameControllerEvent(lua_State *L, const GameControllerEvent &event)
{
	if (auto *textInputEvent = std::get_if<TextInputEvent>(&event))
	{
		tpt_lua_pushString(L, textInputEvent->text);
		return 1;
	}
	else if (auto *textEditingEvent = std::get_if<TextEditingEvent>(&event))
	{
		tpt_lua_pushString(L, textEditingEvent->text);
		return 1;
	}
	else if (auto *keyPressEvent = std::get_if<KeyPressEvent>(&event))
	{
		lua_pushinteger(L, keyPressEvent->key);
		lua_pushinteger(L, keyPressEvent->scan);
		lua_pushboolean(L, keyPressEvent->repeat);
		lua_pushboolean(L, keyPressEvent->shift);
		lua_pushboolean(L, keyPressEvent->ctrl);
		lua_pushboolean(L, keyPressEvent->alt);
		return 6;
	}
	else if (auto *keyReleaseEvent = std::get_if<KeyReleaseEvent>(&event))
	{
		lua_pushinteger(L, keyReleaseEvent->key);
		lua_pushinteger(L, keyReleaseEvent->scan);
		lua_pushboolean(L, keyReleaseEvent->repeat);
		lua_pushboolean(L, keyReleaseEvent->shift);
		lua_pushboolean(L, keyReleaseEvent->ctrl);
		lua_pushboolean(L, keyReleaseEvent->alt);
		return 6;
	}
	else if (auto *mouseDownEvent = std::get_if<MouseDownEvent>(&event))
	{
		lua_pushinteger(L, mouseDownEvent->x);
		lua_pushinteger(L, mouseDownEvent->y);
		lua_pushinteger(L, mouseDownEvent->button);
		return 3;
	}
	else if (auto *mouseUpEvent = std::get_if<MouseUpEvent>(&event))
	{
		lua_pushinteger(L, mouseUpEvent->x);
		lua_pushinteger(L, mouseUpEvent->y);
		lua_pushinteger(L, mouseUpEvent->button);
		lua_pushinteger(L, mouseUpEvent->reason);
		return 4;
	}
	else if (auto *mouseMoveEvent = std::get_if<MouseMoveEvent>(&event))
	{
		lua_pushinteger(L, mouseMoveEvent->x);
		lua_pushinteger(L, mouseMoveEvent->y);
		lua_pushinteger(L, mouseMoveEvent->dx);
		lua_pushinteger(L, mouseMoveEvent->dy);
		return 4;
	}
	else if (auto *mouseWheelEvent = std::get_if<MouseWheelEvent>(&event))
	{
		lua_pushinteger(L, mouseWheelEvent->x);
		lua_pushinteger(L, mouseWheelEvent->y);
		lua_pushinteger(L, mouseWheelEvent->d);
		return 3;
	}
	return 0;
}

bool CommandInterface::HandleEvent(const GameControllerEvent &event)
{
	auto *lsi = static_cast<LuaScriptInterface *>(this);
	auto *L = lsi->L;
	auto eventType = int(event.index());
	auto &list = lsi->gameControllerEventHandlers[eventType];
	auto it = list.begin();
	auto end = list.end();
	lsi->currentEventHandlerIts.push_back(&it);
	bool cont = true;
	while (it != end)
	{
		it->Push(L);
		++it;
		lua_pushvalue(L, -1);
		int numArgs = pushGameControllerEvent(L, event);
		int callret = tpt_lua_pcall(L, numArgs, 1, 0, std::visit([](auto &event) {
			return event.traits;
		}, event));
		if (callret)
		{
			auto err = LuaGetError();
			lua_pop(L, 1);
			Log(CommandInterface::LogError, err);
			if (err == "Error: Script not responding")
			{
				lsi->RemoveEventHandler(eventType, -1);
			}
		}
		else
		{
			if (!lua_isnoneornil(L, -1))
			{
				cont = lua_toboolean(L, -1);
			}
			lua_pop(L, 1);
		}
		lua_pop(L, 1);
	}
	assert(lsi->currentEventHandlerIts.back() == &it);
	lsi->currentEventHandlerIts.pop_back();
	return cont;
}

void LuaScriptInterface::AddEventHandler(int eventType, int stackIndex)
{
	gameControllerEventHandlers[eventType].emplace_back().Assign(L, stackIndex);
}

void LuaScriptInterface::RemoveEventHandler(int eventType, int stackIndex)
{
	auto &list = gameControllerEventHandlers[eventType];
	auto it = list.begin();
	auto end = list.end();
	lua_pushvalue(L, stackIndex);
	while (it != end)
	{
		it->Push(L);
		auto equal = lua_equal(L, -1, -2);
		lua_pop(L, 1);
		if (equal)
		{
			for (auto currentEventHandlerIt : currentEventHandlerIts)
			{
				if (*currentEventHandlerIt == it)
				{
					++*currentEventHandlerIt;
				}
			}
			list.erase(it);
			break;
		}
		++it;
	}
	lua_pop(L, 1);
}

template<size_t Index>
std::enable_if_t<Index != std::variant_size_v<GameControllerEvent>, bool> HaveSimGraphicsEventHandlersHelper(const auto &gameControllerEventHandlers)
{
	if (std::variant_alternative_t<Index, GameControllerEvent>::traits & eventTraitHindersSrt)
	{
		if (!gameControllerEventHandlers[Index].empty())
		{
			return true;
		}
	}
	return HaveSimGraphicsEventHandlersHelper<Index + 1>(gameControllerEventHandlers);
}

template<size_t Index>
std::enable_if_t<Index == std::variant_size_v<GameControllerEvent>, bool> HaveSimGraphicsEventHandlersHelper(const auto &gameControllerEventHandlers)
{
	return false;
}

bool CommandInterface::HaveSimGraphicsEventHandlers()
{
	auto &sd = SimulationData::CRef();
	auto *lsi = static_cast<LuaScriptInterface *>(this);
	for (int i = 0; i < int(lsi->customElements.size()); ++i)
	{
		if (lsi->customElements[i].graphics && !sd.graphicscache[i].isready && lsi->sim->elementCount[i])
		{
			return true;
		}
	}
	return HaveSimGraphicsEventHandlersHelper<0>(lsi->gameControllerEventHandlers);
}

void CommandInterface::OnTick()
{
	auto *lsi = static_cast<LuaScriptInterface *>(this);
	LuaMisc::Tick(lsi->L);
	HandleEvent(TickEvent{});
}

int CommandInterface::Command(String command)
{
	auto *lsi = static_cast<LuaScriptInterface *>(this);
	auto *L = lsi->L;
	lastError = "";
	lsi->luacon_hasLastError = false;
	if (command[0] == '!')
	{
		int ret = PlainCommand(command.Substr(1));
		lastError = GetLastError();
		return ret;
	}
	else
	{
		int level = lua_gettop(L), ret = -1;
		lsi->gameModel->logSink = [this](String text) {
			auto *lsi = static_cast<LuaScriptInterface *>(this);
			auto lastError = GetLastError();
			if (lsi->luacon_hasLastError)
				lastError += "; ";
			lastError += text;
			SetLastError(lastError);
			lsi->luacon_hasLastError = true;
		};
		if (lsi->lastCode.length())
			lsi->lastCode += "\n";
		lsi->lastCode += command;
		ByteString tmp = ("return " + lsi->lastCode).ToUtf8();
		luaL_loadbuffer(L, tmp.data(), tmp.size(), "@console");
		if (lua_type(L, -1) != LUA_TFUNCTION)
		{
			lua_pop(L, 1);
			ByteString lastCodeUtf8 = lsi->lastCode.ToUtf8();
			luaL_loadbuffer(L, lastCodeUtf8.data(), lastCodeUtf8.size(), "@console");
		}
		if (lua_type(L, -1) != LUA_TFUNCTION)
		{
			lastError = LuaGetError();
			String err = lastError;
			if (err.Contains("near '<eof>'")) //the idea stolen from lua-5.1.5/lua.c
				lastError = "...";
			else
				lsi->lastCode = "";
		}
		else
		{
			lsi->lastCode = "";
			ret = tpt_lua_pcall(L, 0, LUA_MULTRET, 0, eventTraitInterface);
			if (ret)
			{
				lastError = LuaGetError();
			}
			else
			{
				String text = "";
				bool hasText = false;
				for (level++; level <= lua_gettop(L); level++)
				{
					LuaToLoggableString(L, level);
					if (hasText)
					{
						text += ", " + tpt_lua_optString(L, -1, "");
					}
					else
					{
						text = tpt_lua_optString(L, -1, "");
						hasText = true;
					}
					lua_pop(L, 1);
				}
				if (text.length())
				{
					if (lastError.length())
						lastError += "; " + text;
					else
						lastError = text;
				}

			}
		}
		lsi->gameModel->logSink = nullptr;
		return ret;
	}
}

static String highlight(String command)
{
	StringBuilder result;
	int pos = 0;
	String::value_type const*raw = command.c_str();
	String::value_type c;
	while ((c = raw[pos]))
	{
		if((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_')
		{
			int len = 0;
			String::value_type w;
			String::value_type const* wstart = raw+pos;
			while((w = wstart[len]) && ((w >= 'A' && w <= 'Z') || (w >= 'a' && w <= 'z') || (w >= '0' && w <= '9') || w == '_'))
				len++;
#define CMP(X) (String(wstart, len) == X)
			if(CMP("and") || CMP("break") || CMP("do") || CMP("else") || CMP("elseif") || CMP("end") || CMP("for") || CMP("function") || CMP("if") || CMP("in") || CMP("local") || CMP("not") || CMP("or") || CMP("repeat") || CMP("return") || CMP("then") || CMP("until") || CMP("while"))
				result << "\x0F\xB5\x89\x01" << String(wstart, len) << "\bw";
			else if(CMP("false") || CMP("nil") || CMP("true"))
				result << "\x0F\xCB\x4B\x16" << String(wstart, len) << "\bw";
			else
				result << "\x0F\x2A\xA1\x98" << String(wstart, len) << "\bw";
#undef CMP
			pos += len;
		}
		else if((c >= '0' && c <= '9') || (c == '.' && raw[pos + 1] >= '0' && raw[pos + 1] <= '9'))
		{
			if(c == '0' && raw[pos + 1] == 'x')
			{
				int len = 2;
				String::value_type w;
				String::value_type const* wstart = raw+pos;
				while((w = wstart[len]) && ((w >= '0' && w <= '9') || (w >= 'A' && w <= 'F') || (w >= 'a' && w <= 'f')))
					len++;
				result << "\x0F\xD3\x36\x82" << String(wstart, len) << "\bw";
				pos += len;
			}
			else
			{
				int len = 0;
				String::value_type w;
				String::value_type const* wstart = raw+pos;
				bool seendot = false;
				while((w = wstart[len]) && ((w >= '0' && w <= '9') || w == '.'))
				{
					if(w == '.')
					{
						if(seendot)
							break;
						else
							seendot = true;
					}
					len++;
				}
				if(w == 'e')
				{
					len++;
					w = wstart[len];
					if(w == '+' || w == '-')
						len++;
					while((w = wstart[len]) && (w >= '0' && w <= '9'))
						len++;
				}
				result << "\x0F\xD3\x36\x82" << String(wstart, len) << "\bw";
				pos += len;
			}
		}
		else if(c == '\'' || c == '"' || (c == '[' && (raw[pos + 1] == '[' || raw[pos + 1] == '=')))
		{
			if(c == '[')
			{
				int len = 1, eqs=0;
				String::value_type w;
				String::value_type const* wstart = raw + pos;
				while((w = wstart[len]) && (w == '='))
				{
					eqs++;
					len++;
				}
				while((w = wstart[len]))
				{
					if(w == ']')
					{
						int nlen = 1;
						String::value_type const* cstart = wstart + len;
						while((w = cstart[nlen]) && (w == '='))
							nlen++;
						if(w == ']' && nlen == eqs+1)
						{
							len += nlen+1;
							break;
						}
					}
					len++;
				}
				result << "\x0F\xDC\x32\x2F" << String(wstart, len) << "\bw";
				pos += len;
			}
			else
			{
				int len = 1;
				String::value_type w;
				String::value_type const* wstart = raw+pos;
				while((w = wstart[len]) && (w != c))
				{
					if(w == '\\' && wstart[len + 1])
						len++;
					len++;
				}
				if(w == c)
					len++;
				result << "\x0F\xDC\x32\x2F" << String(wstart, len) << "\bw";
				pos += len;
			}
		}
		else if(c == '-' && raw[pos + 1] == '-')
		{
			if(raw[pos + 2] == '[')
			{
				int len = 3, eqs = 0;
				String::value_type w;
				String::value_type const* wstart = raw + pos;
				while((w = wstart[len]) && (w == '='))
				{
					eqs++;
					len++;
				}
				while((w = wstart[len]))
				{
					if(w == ']')
					{
						int nlen = 1;
						String::value_type const* cstart = wstart + len;
						while((w = cstart[nlen]) && (w == '='))
							nlen++;
						if(w == ']' && nlen == eqs + 1)
						{
							len += nlen+1;
							break;
						}
					}
					len++;
				}
				result << "\x0F\x85\x99\x01" << String(wstart, len) << "\bw";
				pos += len;
			}
			else
			{
				int len = 2;
				String::value_type w;
				String::value_type const* wstart = raw + pos;
				while((w = wstart[len]) && (w != '\n'))
					len++;
				result << "\x0F\x85\x99\x01" << String(wstart, len) << "\bw";
				pos += len;
			}
		}
		else if(c == '{' || c == '}')
		{
			result << "\x0F\xCB\x4B\x16" << c << "\bw";
			pos++;
		}
		else if(c == '.' && raw[pos + 1] == '.' && raw[pos + 2] == '.')
		{
			result << "\x0F\x2A\xA1\x98...\bw";
			pos += 3;
		}
		else
		{
			result << c;
			pos++;
		}
	}
	return result.Build();
}

String CommandInterface::FormatCommand(String command)
{
	if(command.size() && command[0] == '!')
	{
		return "!" + PlainFormatCommand(command.Substr(1));
	}
	else
		return highlight(command);
}

LuaScriptInterface::~LuaScriptInterface() = default;

void tpt_lua_pushByteString(lua_State *L, const ByteString &str)
{
	lua_pushlstring(L, str.data(), str.size());
}

void tpt_lua_pushString(lua_State *L, const String &str)
{
	tpt_lua_pushByteString(L, str.ToUtf8());
}

ByteString tpt_lua_toByteString(lua_State *L, int index)
{
	size_t size;
	if (auto *data = lua_tolstring(L, index, &size))
	{
		return ByteString(data, size);
	}
	return {};
}

String tpt_lua_toString(lua_State *L, int index, bool ignoreError)
{
	return tpt_lua_toByteString(L, index).FromUtf8(ignoreError);
}

ByteString tpt_lua_checkByteString(lua_State *L, int index)
{
	size_t size;
	if (auto *data = luaL_checklstring(L, index, &size))
	{
		return ByteString(data, size);
	}
	return {};
}

String tpt_lua_checkString(lua_State *L, int index, bool ignoreError)
{
	return tpt_lua_checkByteString(L, index).FromUtf8(ignoreError);
}

ByteString tpt_lua_optByteString(lua_State *L, int index, ByteString defaultValue)
{
	if (lua_isnoneornil(L, index))
	{
		return defaultValue;
	}
	return tpt_lua_checkByteString(L, index);
}

String tpt_lua_optString(lua_State *L, int index, String defaultValue, bool ignoreError)
{
	if (lua_isnoneornil(L, index))
	{
		return defaultValue;
	}
	return tpt_lua_checkString(L, index, ignoreError);
}

int tpt_lua_loadstring(lua_State *L, const ByteString &str)
{
	return luaL_loadbuffer(L, str.data(), str.size(), str.data());
}

bool tpt_lua_equalsString(lua_State *L, int index, const char *data, size_t size)
{
	return lua_isstring(L, index) && lua_objlen(L, index) == size && !memcmp(lua_tostring(L, index), data, size);
}

int tpt_lua_pcall(lua_State *L, int numArgs, int numResults, int errorFunc, EventTraits newEventTraits)
{
	auto *lsi = GetLSI();
	lsi->luaExecutionStart = Platform::GetTime();
	struct AtReturn
	{
		EventTraits oldEventTraits;

		AtReturn(EventTraits newEventTraits)
		{
			auto *lsi = GetLSI();
			oldEventTraits = lsi->eventTraits;
			lsi->eventTraits = newEventTraits;
		}

		~AtReturn()
		{
			auto *lsi = GetLSI();
			lsi->eventTraits = oldEventTraits;
		}
	} atReturn(newEventTraits);
	return lua_pcall(L, numArgs, numResults, errorFunc);
}

CommandInterfacePtr CommandInterface::Create(GameController *newGameController, GameModel *newGameModel)
{
	return CommandInterfacePtr(new LuaScriptInterface(newGameController, newGameModel));
}

void CommandInterfaceDeleter::operator ()(CommandInterface *ptr) const
{
	delete static_cast<LuaScriptInterface *>(ptr);
}


=== src\lua\LuaScriptInterface.h ===

#pragma once
#include "LuaCompat.h"
#include "LuaSmartRef.h"
#include "CommandInterface.h"
#include "gui/game/GameControllerEvents.h"
#include "graphics/Pixel.h"
#include "simulation/StructProperty.h"
#include "simulation/ElementDefs.h"
#include <cstdint>
#include <map>
#include <memory>
#include <list>
#include <deque>

namespace http
{
	class Request;
}

class GameView;
class Graphics;
class Renderer;
class Simulation;
class LuaComponent;

int LuaToLoggableString(lua_State *L, int n);
String LuaGetError();
void LuaGetProperty(lua_State *L, StructProperty property, intptr_t propertyAddress);
void LuaSetProperty(lua_State *L, StructProperty property, intptr_t propertyAddress, int stackPos);
void LuaSetParticleProperty(lua_State *L, int particleID, StructProperty property, intptr_t propertyAddress, int stackPos);

struct LuaStateDeleter
{
	void operator ()(lua_State *L) const
	{
		lua_close(L);
	}
};
using LuaStatePtr = std::unique_ptr<lua_State, LuaStateDeleter>;

enum UpdateMode
{
	UPDATE_AFTER,
	UPDATE_REPLACE,
	UPDATE_BEFORE,
	NUM_UPDATEMODES,
};

struct CustomElement
{
	UpdateMode updateMode = UPDATE_AFTER;
	LuaSmartRef update;
	LuaSmartRef graphics;
	LuaSmartRef ctypeDraw;
	LuaSmartRef create;
	LuaSmartRef createAllowed;
	LuaSmartRef changeType;
};

struct CustomTool
{
	bool valid = false;
	LuaSmartRef perform;
	LuaSmartRef click;
	LuaSmartRef drag;
	LuaSmartRef draw;
	LuaSmartRef drawLine;
	LuaSmartRef drawRect;
	LuaSmartRef drawFill;
	LuaSmartRef select;
};

struct NonGraphicsContext
{
	static void Die();

	void BlendPixel(Vec2<int>, RGBA);
	Vec2<int> BlendText(Vec2<int>, const String &, RGBA);
	void DrawLine(Vec2<int>, Vec2<int>, RGB);
	void BlendLine(Vec2<int>, Vec2<int>, RGBA);
	void DrawRect(Rect<int>, RGB);
	void BlendRect(Rect<int>, RGBA);
	void DrawFilledRect(Rect<int>, RGB);
	void BlendFilledRect(Rect<int>, RGBA);
	void BlendEllipse(Vec2<int>, Vec2<int>, RGBA);
	void BlendFilledEllipse(Vec2<int>, Vec2<int>, RGBA);
};

class LuaScriptInterface : public CommandInterface
{
	LuaStatePtr luaState;

	Renderer *ren;

public:
	lua_State *L{};

	GameModel *gameModel;
	GameController *gameController;
	GameView *window;
	Simulation *sim;
	Graphics *g;

	NonGraphicsContext ngc;

	std::variant<Graphics *, Renderer *, NonGraphicsContext *> GetGraphics()
	{
		if (eventTraits & eventTraitSimGraphics)
		{
			// This is ok without calling gameModel->view->PauseRendererThread() because
			// the renderer thread gets paused anyway if there are handlers
			// installed for eventTraitSimGraphics and *SimDraw events.
			return ren;
		}
		if (eventTraits & eventTraitInterfaceGraphics)
		{
			return g;
		}
		return &ngc;
	}

	std::vector<CustomElement> customElements; // must come after luaState
	std::vector<CustomTool> customTools;

	EventTraits eventTraits = eventTraitNone;

	bool luacon_hasLastError = false;
	String lastCode;

	int textInputRefcount = 0;
	long unsigned int luaExecutionStart = 0;
	int monopartAccessPartID = -1;

private:
	std::vector<std::list<LuaSmartRef>> gameControllerEventHandlers; // must come after luaState
	std::deque<std::list<LuaSmartRef>::iterator *> currentEventHandlerIts;

public:
	void AddEventHandler(int eventType, int stackIndex);
	void RemoveEventHandler(int eventType, int stackIndex);
	std::unique_ptr<http::Request> scriptManagerDownload;
	int luaHookTimeout;

	std::map<LuaComponent *, LuaSmartRef> grabbedComponents; // must come after luaState

	LuaScriptInterface(GameController *newGameController, GameModel *newGameModel);
	~LuaScriptInterface();

	char customCanMove[PT_NUM][PT_NUM];
	void InitCustomCanMove();

	// luaL_dostring semantics: 0: success; 1: failure, string on top of stack describes the failure
	int Autorun();

	void AssertInterfaceEvent()
	{
		if (!(eventTraits & eventTraitInterface))
		{
			luaL_error(L, "this functionality is restricted to interface events");
		}
	}

	void AssertMutableSimEvent()
	{
		if (eventTraits & eventTraitConstSim)
		{
			luaL_error(L, "this functionality is restricted to mutable simulation events");
		}
	}

	void AssertMutableToolsEvent()
	{
		AssertInterfaceEvent();
		if (eventTraits & eventTraitConstTools)
		{
			luaL_error(L, "this functionality is restricted to mutable tool events");
		}
	}

	void AssertMonopartAccessEvent(int partID)
	{
		AssertMutableSimEvent();
		if ((eventTraits & eventTraitMonopartAccess) && monopartAccessPartID != partID)
		{
			luaL_error(L, "particle management is restricted to ID %i", monopartAccessPartID);
		}
	}

	friend class CommandInterface;
};

void tpt_lua_pushByteString(lua_State *L, const ByteString &str);
void tpt_lua_pushString(lua_State *L, const String &str);

// TODO: toByteStringView once we have a ByteStringView (or std::string_view, if we get rid of ByteString)
ByteString tpt_lua_toByteString(lua_State *L, int index);
String tpt_lua_toString(lua_State *L, int index, bool ignoreError = true);

// TODO: toByteStringView once we have a ByteStringView (or std::string_view, if we get rid of ByteString)
ByteString tpt_lua_checkByteString(lua_State *L, int index);
String tpt_lua_checkString(lua_State *L, int index, bool ignoreError = true);

// TODO: toByteStringView once we have a ByteStringView (or std::string_view, if we get rid of ByteString)
ByteString tpt_lua_optByteString(lua_State *L, int index, ByteString defaultValue = {});
String tpt_lua_optString(lua_State *L, int index, String defaultValue = {}, bool ignoreError = true);

int tpt_lua_loadstring(lua_State *L, const ByteString &str);

bool tpt_lua_equalsString(lua_State *L, int index, const char *data, size_t size);

// TODO: use std::literals::string_literals::operator""s if we get rid of ByteString
template<size_t N>
bool tpt_lua_equalsLiteral(lua_State *L, int index, const char (&lit)[N])
{
	return tpt_lua_equalsString(L, index, lit, N - 1U);
}

int tpt_lua_pcall(lua_State *L, int numArgs, int numResults, int errorFunc, EventTraits eventTraits);

namespace LuaHttp
{
	void Open(lua_State *L);
}

namespace LuaBz2
{
	void Open(lua_State *L);
}

namespace LuaElements
{
	void Open(lua_State *L);
}

namespace LuaEvent
{
	void Open(lua_State *L);
}

namespace LuaFileSystem
{
	void Open(lua_State *L);
}

namespace LuaGraphics
{
	void Open(lua_State *L);
}

namespace LuaInterface
{
	void Open(lua_State *L);
}

namespace LuaMisc
{
	void Open(lua_State *L);
	void Tick(lua_State *L);
}

namespace LuaPlatform
{
	void Open(lua_State *L);
}

namespace LuaRenderer
{
	void Open(lua_State *L);
}

namespace LuaSimulation
{
	void Open(lua_State *L);
}

namespace LuaSocket
{
	int GetTime(lua_State *L);
	int Sleep(lua_State *L);
	double Now();
	void Timeout(double timeout);
	void Open(lua_State *L);
	void OpenTCP(lua_State *L);
}

namespace LuaTools
{
	void Open(lua_State *L);
	void SetToolIndex(lua_State *L, ByteString identifier, std::optional<int> index);
}

inline LuaScriptInterface *GetLSI()
{
	return static_cast<LuaScriptInterface *>(&CommandInterface::Ref());
}


=== src\lua\LuaSDLKeys.h ===

#pragma once
#include "LuaCompat.h"
#include <SDL.h>

static void initLuaSDLKeys(lua_State *L)
{
#define LCONST(v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, #v)
	LCONST(SDL_SCANCODE_UNKNOWN);
	LCONST(SDL_SCANCODE_A);
	LCONST(SDL_SCANCODE_B);
	LCONST(SDL_SCANCODE_C);
	LCONST(SDL_SCANCODE_D);
	LCONST(SDL_SCANCODE_E);
	LCONST(SDL_SCANCODE_F);
	LCONST(SDL_SCANCODE_G);
	LCONST(SDL_SCANCODE_H);
	LCONST(SDL_SCANCODE_I);
	LCONST(SDL_SCANCODE_J);
	LCONST(SDL_SCANCODE_K);
	LCONST(SDL_SCANCODE_L);
	LCONST(SDL_SCANCODE_M);
	LCONST(SDL_SCANCODE_N);
	LCONST(SDL_SCANCODE_O);
	LCONST(SDL_SCANCODE_P);
	LCONST(SDL_SCANCODE_Q);
	LCONST(SDL_SCANCODE_R);
	LCONST(SDL_SCANCODE_S);
	LCONST(SDL_SCANCODE_T);
	LCONST(SDL_SCANCODE_U);
	LCONST(SDL_SCANCODE_V);
	LCONST(SDL_SCANCODE_W);
	LCONST(SDL_SCANCODE_X);
	LCONST(SDL_SCANCODE_Y);
	LCONST(SDL_SCANCODE_Z);
	LCONST(SDL_SCANCODE_1);
	LCONST(SDL_SCANCODE_2);
	LCONST(SDL_SCANCODE_3);
	LCONST(SDL_SCANCODE_4);
	LCONST(SDL_SCANCODE_5);
	LCONST(SDL_SCANCODE_6);
	LCONST(SDL_SCANCODE_7);
	LCONST(SDL_SCANCODE_8);
	LCONST(SDL_SCANCODE_9);
	LCONST(SDL_SCANCODE_0);
	LCONST(SDL_SCANCODE_RETURN);
	LCONST(SDL_SCANCODE_ESCAPE);
	LCONST(SDL_SCANCODE_BACKSPACE);
	LCONST(SDL_SCANCODE_TAB);
	LCONST(SDL_SCANCODE_SPACE);
	LCONST(SDL_SCANCODE_MINUS);
	LCONST(SDL_SCANCODE_EQUALS);
	LCONST(SDL_SCANCODE_LEFTBRACKET);
	LCONST(SDL_SCANCODE_RIGHTBRACKET);
	LCONST(SDL_SCANCODE_BACKSLASH);
	LCONST(SDL_SCANCODE_NONUSHASH);
	LCONST(SDL_SCANCODE_SEMICOLON);
	LCONST(SDL_SCANCODE_APOSTROPHE);
	LCONST(SDL_SCANCODE_GRAVE);
	LCONST(SDL_SCANCODE_COMMA);
	LCONST(SDL_SCANCODE_PERIOD);
	LCONST(SDL_SCANCODE_SLASH);
	LCONST(SDL_SCANCODE_CAPSLOCK);
	LCONST(SDL_SCANCODE_F1);
	LCONST(SDL_SCANCODE_F2);
	LCONST(SDL_SCANCODE_F3);
	LCONST(SDL_SCANCODE_F4);
	LCONST(SDL_SCANCODE_F5);
	LCONST(SDL_SCANCODE_F6);
	LCONST(SDL_SCANCODE_F7);
	LCONST(SDL_SCANCODE_F8);
	LCONST(SDL_SCANCODE_F9);
	LCONST(SDL_SCANCODE_F10);
	LCONST(SDL_SCANCODE_F11);
	LCONST(SDL_SCANCODE_F12);
	LCONST(SDL_SCANCODE_PRINTSCREEN);
	LCONST(SDL_SCANCODE_SCROLLLOCK);
	LCONST(SDL_SCANCODE_PAUSE);
	LCONST(SDL_SCANCODE_INSERT);
	LCONST(SDL_SCANCODE_HOME);
	LCONST(SDL_SCANCODE_PAGEUP);
	LCONST(SDL_SCANCODE_DELETE);
	LCONST(SDL_SCANCODE_END);
	LCONST(SDL_SCANCODE_PAGEDOWN);
	LCONST(SDL_SCANCODE_RIGHT);
	LCONST(SDL_SCANCODE_LEFT);
	LCONST(SDL_SCANCODE_DOWN);
	LCONST(SDL_SCANCODE_UP);
	LCONST(SDL_SCANCODE_NUMLOCKCLEAR);
	LCONST(SDL_SCANCODE_KP_DIVIDE);
	LCONST(SDL_SCANCODE_KP_MULTIPLY);
	LCONST(SDL_SCANCODE_KP_MINUS);
	LCONST(SDL_SCANCODE_KP_PLUS);
	LCONST(SDL_SCANCODE_KP_ENTER);
	LCONST(SDL_SCANCODE_KP_1);
	LCONST(SDL_SCANCODE_KP_2);
	LCONST(SDL_SCANCODE_KP_3);
	LCONST(SDL_SCANCODE_KP_4);
	LCONST(SDL_SCANCODE_KP_5);
	LCONST(SDL_SCANCODE_KP_6);
	LCONST(SDL_SCANCODE_KP_7);
	LCONST(SDL_SCANCODE_KP_8);
	LCONST(SDL_SCANCODE_KP_9);
	LCONST(SDL_SCANCODE_KP_0);
	LCONST(SDL_SCANCODE_KP_PERIOD);
	LCONST(SDL_SCANCODE_NONUSBACKSLASH);
	LCONST(SDL_SCANCODE_APPLICATION);
	LCONST(SDL_SCANCODE_POWER);
	LCONST(SDL_SCANCODE_KP_EQUALS);
	LCONST(SDL_SCANCODE_F13);
	LCONST(SDL_SCANCODE_F14);
	LCONST(SDL_SCANCODE_F15);
	LCONST(SDL_SCANCODE_F16);
	LCONST(SDL_SCANCODE_F17);
	LCONST(SDL_SCANCODE_F18);
	LCONST(SDL_SCANCODE_F19);
	LCONST(SDL_SCANCODE_F20);
	LCONST(SDL_SCANCODE_F21);
	LCONST(SDL_SCANCODE_F22);
	LCONST(SDL_SCANCODE_F23);
	LCONST(SDL_SCANCODE_F24);
	LCONST(SDL_SCANCODE_EXECUTE);
	LCONST(SDL_SCANCODE_HELP);
	LCONST(SDL_SCANCODE_MENU);
	LCONST(SDL_SCANCODE_SELECT);
	LCONST(SDL_SCANCODE_STOP);
	LCONST(SDL_SCANCODE_AGAIN);
	LCONST(SDL_SCANCODE_UNDO);
	LCONST(SDL_SCANCODE_CUT);
	LCONST(SDL_SCANCODE_COPY);
	LCONST(SDL_SCANCODE_PASTE);
	LCONST(SDL_SCANCODE_FIND);
	LCONST(SDL_SCANCODE_MUTE);
	LCONST(SDL_SCANCODE_VOLUMEUP);
	LCONST(SDL_SCANCODE_VOLUMEDOWN);
	LCONST(SDL_SCANCODE_KP_COMMA);
	LCONST(SDL_SCANCODE_KP_EQUALSAS400);
	LCONST(SDL_SCANCODE_INTERNATIONAL1);
	LCONST(SDL_SCANCODE_INTERNATIONAL2);
	LCONST(SDL_SCANCODE_INTERNATIONAL3);
	LCONST(SDL_SCANCODE_INTERNATIONAL4);
	LCONST(SDL_SCANCODE_INTERNATIONAL5);
	LCONST(SDL_SCANCODE_INTERNATIONAL6);
	LCONST(SDL_SCANCODE_INTERNATIONAL7);
	LCONST(SDL_SCANCODE_INTERNATIONAL8);
	LCONST(SDL_SCANCODE_INTERNATIONAL9);
	LCONST(SDL_SCANCODE_LANG1);
	LCONST(SDL_SCANCODE_LANG2);
	LCONST(SDL_SCANCODE_LANG3);
	LCONST(SDL_SCANCODE_LANG4);
	LCONST(SDL_SCANCODE_LANG5);
	LCONST(SDL_SCANCODE_LANG6);
	LCONST(SDL_SCANCODE_LANG7);
	LCONST(SDL_SCANCODE_LANG8);
	LCONST(SDL_SCANCODE_LANG9);
	LCONST(SDL_SCANCODE_ALTERASE);
	LCONST(SDL_SCANCODE_SYSREQ);
	LCONST(SDL_SCANCODE_CANCEL);
	LCONST(SDL_SCANCODE_CLEAR);
	LCONST(SDL_SCANCODE_PRIOR);
	LCONST(SDL_SCANCODE_RETURN2);
	LCONST(SDL_SCANCODE_SEPARATOR);
	LCONST(SDL_SCANCODE_OUT);
	LCONST(SDL_SCANCODE_OPER);
	LCONST(SDL_SCANCODE_CLEARAGAIN);
	LCONST(SDL_SCANCODE_CRSEL);
	LCONST(SDL_SCANCODE_EXSEL);
	LCONST(SDL_SCANCODE_KP_00);
	LCONST(SDL_SCANCODE_KP_000);
	LCONST(SDL_SCANCODE_THOUSANDSSEPARATOR);
	LCONST(SDL_SCANCODE_DECIMALSEPARATOR);
	LCONST(SDL_SCANCODE_CURRENCYUNIT);
	LCONST(SDL_SCANCODE_CURRENCYSUBUNIT);
	LCONST(SDL_SCANCODE_KP_LEFTPAREN);
	LCONST(SDL_SCANCODE_KP_RIGHTPAREN);
	LCONST(SDL_SCANCODE_KP_LEFTBRACE);
	LCONST(SDL_SCANCODE_KP_RIGHTBRACE);
	LCONST(SDL_SCANCODE_KP_TAB);
	LCONST(SDL_SCANCODE_KP_BACKSPACE);
	LCONST(SDL_SCANCODE_KP_A);
	LCONST(SDL_SCANCODE_KP_B);
	LCONST(SDL_SCANCODE_KP_C);
	LCONST(SDL_SCANCODE_KP_D);
	LCONST(SDL_SCANCODE_KP_E);
	LCONST(SDL_SCANCODE_KP_F);
	LCONST(SDL_SCANCODE_KP_XOR);
	LCONST(SDL_SCANCODE_KP_POWER);
	LCONST(SDL_SCANCODE_KP_PERCENT);
	LCONST(SDL_SCANCODE_KP_LESS);
	LCONST(SDL_SCANCODE_KP_GREATER);
	LCONST(SDL_SCANCODE_KP_AMPERSAND);
	LCONST(SDL_SCANCODE_KP_DBLAMPERSAND);
	LCONST(SDL_SCANCODE_KP_VERTICALBAR);
	LCONST(SDL_SCANCODE_KP_DBLVERTICALBAR);
	LCONST(SDL_SCANCODE_KP_COLON);
	LCONST(SDL_SCANCODE_KP_HASH);
	LCONST(SDL_SCANCODE_KP_SPACE);
	LCONST(SDL_SCANCODE_KP_AT);
	LCONST(SDL_SCANCODE_KP_EXCLAM);
	LCONST(SDL_SCANCODE_KP_MEMSTORE);
	LCONST(SDL_SCANCODE_KP_MEMRECALL);
	LCONST(SDL_SCANCODE_KP_MEMCLEAR);
	LCONST(SDL_SCANCODE_KP_MEMADD);
	LCONST(SDL_SCANCODE_KP_MEMSUBTRACT);
	LCONST(SDL_SCANCODE_KP_MEMMULTIPLY);
	LCONST(SDL_SCANCODE_KP_MEMDIVIDE);
	LCONST(SDL_SCANCODE_KP_PLUSMINUS);
	LCONST(SDL_SCANCODE_KP_CLEAR);
	LCONST(SDL_SCANCODE_KP_CLEARENTRY);
	LCONST(SDL_SCANCODE_KP_BINARY);
	LCONST(SDL_SCANCODE_KP_OCTAL);
	LCONST(SDL_SCANCODE_KP_DECIMAL);
	LCONST(SDL_SCANCODE_KP_HEXADECIMAL);
	LCONST(SDL_SCANCODE_LCTRL);
	LCONST(SDL_SCANCODE_LSHIFT);
	LCONST(SDL_SCANCODE_LALT);
	LCONST(SDL_SCANCODE_LGUI);
	LCONST(SDL_SCANCODE_RCTRL);
	LCONST(SDL_SCANCODE_RSHIFT);
	LCONST(SDL_SCANCODE_RALT);
	LCONST(SDL_SCANCODE_RGUI);
	LCONST(SDL_SCANCODE_MODE);
	LCONST(SDL_SCANCODE_AUDIONEXT);
	LCONST(SDL_SCANCODE_AUDIOPREV);
	LCONST(SDL_SCANCODE_AUDIOSTOP);
	LCONST(SDL_SCANCODE_AUDIOPLAY);
	LCONST(SDL_SCANCODE_AUDIOMUTE);
	LCONST(SDL_SCANCODE_MEDIASELECT);
	LCONST(SDL_SCANCODE_WWW);
	LCONST(SDL_SCANCODE_MAIL);
	LCONST(SDL_SCANCODE_CALCULATOR);
	LCONST(SDL_SCANCODE_COMPUTER);
	LCONST(SDL_SCANCODE_AC_SEARCH);
	LCONST(SDL_SCANCODE_AC_HOME);
	LCONST(SDL_SCANCODE_AC_BACK);
	LCONST(SDL_SCANCODE_AC_FORWARD);
	LCONST(SDL_SCANCODE_AC_STOP);
	LCONST(SDL_SCANCODE_AC_REFRESH);
	LCONST(SDL_SCANCODE_AC_BOOKMARKS);
	LCONST(SDL_SCANCODE_BRIGHTNESSDOWN);
	LCONST(SDL_SCANCODE_BRIGHTNESSUP);
	LCONST(SDL_SCANCODE_DISPLAYSWITCH);
	LCONST(SDL_SCANCODE_KBDILLUMTOGGLE);
	LCONST(SDL_SCANCODE_KBDILLUMDOWN);
	LCONST(SDL_SCANCODE_KBDILLUMUP);
	LCONST(SDL_SCANCODE_EJECT);
	LCONST(SDL_SCANCODE_SLEEP);
	LCONST(SDL_SCANCODE_APP1);
	LCONST(SDL_SCANCODE_APP2);
	LCONST(SDL_SCANCODE_AUDIOREWIND);
	LCONST(SDL_SCANCODE_AUDIOFASTFORWARD);
	LCONST(SDL_NUM_SCANCODES);
	LCONST(SDLK_UNKNOWN);
	LCONST(SDLK_RETURN);
	LCONST(SDLK_ESCAPE);
	LCONST(SDLK_BACKSPACE);
	LCONST(SDLK_TAB);
	LCONST(SDLK_SPACE);
	LCONST(SDLK_EXCLAIM);
	LCONST(SDLK_QUOTEDBL);
	LCONST(SDLK_HASH);
	LCONST(SDLK_PERCENT);
	LCONST(SDLK_DOLLAR);
	LCONST(SDLK_AMPERSAND);
	LCONST(SDLK_QUOTE);
	LCONST(SDLK_LEFTPAREN);
	LCONST(SDLK_RIGHTPAREN);
	LCONST(SDLK_ASTERISK);
	LCONST(SDLK_PLUS);
	LCONST(SDLK_COMMA);
	LCONST(SDLK_MINUS);
	LCONST(SDLK_PERIOD);
	LCONST(SDLK_SLASH);
	LCONST(SDLK_0);
	LCONST(SDLK_1);
	LCONST(SDLK_2);
	LCONST(SDLK_3);
	LCONST(SDLK_4);
	LCONST(SDLK_5);
	LCONST(SDLK_6);
	LCONST(SDLK_7);
	LCONST(SDLK_8);
	LCONST(SDLK_9);
	LCONST(SDLK_COLON);
	LCONST(SDLK_SEMICOLON);
	LCONST(SDLK_LESS);
	LCONST(SDLK_EQUALS);
	LCONST(SDLK_GREATER);
	LCONST(SDLK_QUESTION);
	LCONST(SDLK_AT);
	LCONST(SDLK_LEFTBRACKET);
	LCONST(SDLK_BACKSLASH);
	LCONST(SDLK_RIGHTBRACKET);
	LCONST(SDLK_CARET);
	LCONST(SDLK_UNDERSCORE);
	LCONST(SDLK_BACKQUOTE);
	LCONST(SDLK_a);
	LCONST(SDLK_b);
	LCONST(SDLK_c);
	LCONST(SDLK_d);
	LCONST(SDLK_e);
	LCONST(SDLK_f);
	LCONST(SDLK_g);
	LCONST(SDLK_h);
	LCONST(SDLK_i);
	LCONST(SDLK_j);
	LCONST(SDLK_k);
	LCONST(SDLK_l);
	LCONST(SDLK_m);
	LCONST(SDLK_n);
	LCONST(SDLK_o);
	LCONST(SDLK_p);
	LCONST(SDLK_q);
	LCONST(SDLK_r);
	LCONST(SDLK_s);
	LCONST(SDLK_t);
	LCONST(SDLK_u);
	LCONST(SDLK_v);
	LCONST(SDLK_w);
	LCONST(SDLK_x);
	LCONST(SDLK_y);
	LCONST(SDLK_z);
	LCONST(SDLK_CAPSLOCK);
	LCONST(SDLK_F1);
	LCONST(SDLK_F2);
	LCONST(SDLK_F3);
	LCONST(SDLK_F4);
	LCONST(SDLK_F5);
	LCONST(SDLK_F6);
	LCONST(SDLK_F7);
	LCONST(SDLK_F8);
	LCONST(SDLK_F9);
	LCONST(SDLK_F10);
	LCONST(SDLK_F11);
	LCONST(SDLK_F12);
	LCONST(SDLK_PRINTSCREEN);
	LCONST(SDLK_SCROLLLOCK);
	LCONST(SDLK_PAUSE);
	LCONST(SDLK_INSERT);
	LCONST(SDLK_HOME);
	LCONST(SDLK_PAGEUP);
	LCONST(SDLK_DELETE);
	LCONST(SDLK_END);
	LCONST(SDLK_PAGEDOWN);
	LCONST(SDLK_RIGHT);
	LCONST(SDLK_LEFT);
	LCONST(SDLK_DOWN);
	LCONST(SDLK_UP);
	LCONST(SDLK_NUMLOCKCLEAR);
	LCONST(SDLK_KP_DIVIDE);
	LCONST(SDLK_KP_MULTIPLY);
	LCONST(SDLK_KP_MINUS);
	LCONST(SDLK_KP_PLUS);
	LCONST(SDLK_KP_ENTER);
	LCONST(SDLK_KP_1);
	LCONST(SDLK_KP_2);
	LCONST(SDLK_KP_3);
	LCONST(SDLK_KP_4);
	LCONST(SDLK_KP_5);
	LCONST(SDLK_KP_6);
	LCONST(SDLK_KP_7);
	LCONST(SDLK_KP_8);
	LCONST(SDLK_KP_9);
	LCONST(SDLK_KP_0);
	LCONST(SDLK_KP_PERIOD);
	LCONST(SDLK_APPLICATION);
	LCONST(SDLK_POWER);
	LCONST(SDLK_KP_EQUALS);
	LCONST(SDLK_F13);
	LCONST(SDLK_F14);
	LCONST(SDLK_F15);
	LCONST(SDLK_F16);
	LCONST(SDLK_F17);
	LCONST(SDLK_F18);
	LCONST(SDLK_F19);
	LCONST(SDLK_F20);
	LCONST(SDLK_F21);
	LCONST(SDLK_F22);
	LCONST(SDLK_F23);
	LCONST(SDLK_F24);
	LCONST(SDLK_EXECUTE);
	LCONST(SDLK_HELP);
	LCONST(SDLK_MENU);
	LCONST(SDLK_SELECT);
	LCONST(SDLK_STOP);
	LCONST(SDLK_AGAIN);
	LCONST(SDLK_UNDO);
	LCONST(SDLK_CUT);
	LCONST(SDLK_COPY);
	LCONST(SDLK_PASTE);
	LCONST(SDLK_FIND);
	LCONST(SDLK_MUTE);
	LCONST(SDLK_VOLUMEUP);
	LCONST(SDLK_VOLUMEDOWN);
	LCONST(SDLK_KP_COMMA);
	LCONST(SDLK_KP_EQUALSAS400);
	LCONST(SDLK_ALTERASE);
	LCONST(SDLK_SYSREQ);
	LCONST(SDLK_CANCEL);
	LCONST(SDLK_CLEAR);
	LCONST(SDLK_PRIOR);
	LCONST(SDLK_RETURN2);
	LCONST(SDLK_SEPARATOR);
	LCONST(SDLK_OUT);
	LCONST(SDLK_OPER);
	LCONST(SDLK_CLEARAGAIN);
	LCONST(SDLK_CRSEL);
	LCONST(SDLK_EXSEL);
	LCONST(SDLK_KP_00);
	LCONST(SDLK_KP_000);
	LCONST(SDLK_THOUSANDSSEPARATOR);
	LCONST(SDLK_DECIMALSEPARATOR);
	LCONST(SDLK_CURRENCYUNIT);
	LCONST(SDLK_CURRENCYSUBUNIT);
	LCONST(SDLK_KP_LEFTPAREN);
	LCONST(SDLK_KP_RIGHTPAREN);
	LCONST(SDLK_KP_LEFTBRACE);
	LCONST(SDLK_KP_RIGHTBRACE);
	LCONST(SDLK_KP_TAB);
	LCONST(SDLK_KP_BACKSPACE);
	LCONST(SDLK_KP_A);
	LCONST(SDLK_KP_B);
	LCONST(SDLK_KP_C);
	LCONST(SDLK_KP_D);
	LCONST(SDLK_KP_E);
	LCONST(SDLK_KP_F);
	LCONST(SDLK_KP_XOR);
	LCONST(SDLK_KP_POWER);
	LCONST(SDLK_KP_PERCENT);
	LCONST(SDLK_KP_LESS);
	LCONST(SDLK_KP_GREATER);
	LCONST(SDLK_KP_AMPERSAND);
	LCONST(SDLK_KP_DBLAMPERSAND);
	LCONST(SDLK_KP_VERTICALBAR);
	LCONST(SDLK_KP_DBLVERTICALBAR);
	LCONST(SDLK_KP_COLON);
	LCONST(SDLK_KP_HASH);
	LCONST(SDLK_KP_SPACE);
	LCONST(SDLK_KP_AT);
	LCONST(SDLK_KP_EXCLAM);
	LCONST(SDLK_KP_MEMSTORE);
	LCONST(SDLK_KP_MEMRECALL);
	LCONST(SDLK_KP_MEMCLEAR);
	LCONST(SDLK_KP_MEMADD);
	LCONST(SDLK_KP_MEMSUBTRACT);
	LCONST(SDLK_KP_MEMMULTIPLY);
	LCONST(SDLK_KP_MEMDIVIDE);
	LCONST(SDLK_KP_PLUSMINUS);
	LCONST(SDLK_KP_CLEAR);
	LCONST(SDLK_KP_CLEARENTRY);
	LCONST(SDLK_KP_BINARY);
	LCONST(SDLK_KP_OCTAL);
	LCONST(SDLK_KP_DECIMAL);
	LCONST(SDLK_KP_HEXADECIMAL);
	LCONST(SDLK_LCTRL);
	LCONST(SDLK_LSHIFT);
	LCONST(SDLK_LALT);
	LCONST(SDLK_LGUI);
	LCONST(SDLK_RCTRL);
	LCONST(SDLK_RSHIFT);
	LCONST(SDLK_RALT);
	LCONST(SDLK_RGUI);
	LCONST(SDLK_MODE);
	LCONST(SDLK_AUDIONEXT);
	LCONST(SDLK_AUDIOPREV);
	LCONST(SDLK_AUDIOSTOP);
	LCONST(SDLK_AUDIOPLAY);
	LCONST(SDLK_AUDIOMUTE);
	LCONST(SDLK_MEDIASELECT);
	LCONST(SDLK_WWW);
	LCONST(SDLK_MAIL);
	LCONST(SDLK_CALCULATOR);
	LCONST(SDLK_COMPUTER);
	LCONST(SDLK_AC_SEARCH);
	LCONST(SDLK_AC_HOME);
	LCONST(SDLK_AC_BACK);
	LCONST(SDLK_AC_FORWARD);
	LCONST(SDLK_AC_STOP);
	LCONST(SDLK_AC_REFRESH);
	LCONST(SDLK_AC_BOOKMARKS);
	LCONST(SDLK_BRIGHTNESSDOWN);
	LCONST(SDLK_BRIGHTNESSUP);
	LCONST(SDLK_DISPLAYSWITCH);
	LCONST(SDLK_KBDILLUMTOGGLE);
	LCONST(SDLK_KBDILLUMDOWN);
	LCONST(SDLK_KBDILLUMUP);
	LCONST(SDLK_EJECT);
	LCONST(SDLK_SLEEP);
	LCONST(SDLK_APP1);
	LCONST(SDLK_APP2);
	LCONST(SDLK_AUDIOREWIND);
	LCONST(SDLK_AUDIOFASTFORWARD);
	LCONST(KMOD_NONE);
	LCONST(KMOD_LSHIFT);
	LCONST(KMOD_RSHIFT);
	LCONST(KMOD_LCTRL);
	LCONST(KMOD_RCTRL);
	LCONST(KMOD_LALT);
	LCONST(KMOD_RALT);
	LCONST(KMOD_LGUI);
	LCONST(KMOD_RGUI);
	LCONST(KMOD_NUM);
	LCONST(KMOD_CAPS);
	LCONST(KMOD_MODE);
	LCONST(KMOD_CTRL);
	LCONST(KMOD_SHIFT);
	LCONST(KMOD_ALT);
	LCONST(KMOD_GUI);
	LCONST(SDL_BUTTON_LEFT);
	LCONST(SDL_BUTTON_MIDDLE);
	LCONST(SDL_BUTTON_RIGHT);
	LCONST(SDL_BUTTON_X1);
	LCONST(SDL_BUTTON_X2);
#undef LCONST
}


=== src\lua\LuaSimulation.cpp ===

#include "LuaScriptInterface.h"
#include "client/Client.h"
#include "client/GameSave.h"
#include "client/SaveFile.h"
#include "client/SaveInfo.h"
#include "common/RasterGeometry.h"
#include "Format.h"
#include "gui/game/GameController.h"
#include "gui/game/GameModel.h"
#include "gui/game/GameView.h"
#include "gui/game/Brush.h"
#include "gui/game/tool/Tool.h"
#include "simulation/Air.h"
#include "simulation/ElementCommon.h"
#include "simulation/GOLString.h"
#include "simulation/gravity/Gravity.h"
#include "simulation/Snapshot.h"
#include "simulation/ToolClasses.h"
#include <type_traits>

static int ambientHeatSim(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushboolean(L, lsi->sim->aheat_enable);
		return 1;
	}
	lsi->AssertInterfaceEvent();
	auto aheatstate = lua_toboolean(L, 1);
	lsi->sim->aheat_enable = aheatstate;
	lsi->gameModel->UpdateQuickOptions();

	return 0;
}

static int heatSim(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushboolean(L, !lsi->sim->legacy_enable);
		return 1;
	}
	lsi->AssertInterfaceEvent();
	auto heatstate = lua_toboolean(L, 1);
	lsi->sim->legacy_enable = !heatstate;
	return 0;
}

static int newtonianGravity(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushboolean(L, bool(lsi->sim->grav));
		return 1;
	}
	lsi->AssertInterfaceEvent();
	lsi->sim->EnableNewtonianGravity(lua_toboolean(L, 1));
	lsi->gameModel->UpdateQuickOptions();
	return 0;
}

static int paused(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushboolean(L, lsi->gameModel->GetPaused());
		return 1;
	}
	auto pausestate = lua_toboolean(L, 1);
	lsi->gameModel->SetPaused(pausestate);
	return 0;
}

static int partCount(lua_State *L)
{
	auto *lsi = GetLSI();
	lua_pushinteger(L, lsi->sim->NUM_PARTS);
	return 1;
}

static int decoSpace(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) < 1)
	{
		lua_pushnumber(L, lsi->gameModel->GetDecoSpace());
		return 1;
	}
	auto index = luaL_checkint(L, 1);
	if (index < 0 || index >= NUM_DECOSPACES)
	{
		return luaL_error(L, "Invalid deco space index %i", index);
	}
	lsi->gameModel->SetDecoSpace(index);
	return 0;
}

template<class Accessor>
struct LuaBlockMapHelper
{
	using ItemType = std::remove_reference_t<std::invoke_result_t<Accessor, Vec2<int>>>;
};

template<bool Clamp, class Accessor, class ItemType = typename LuaBlockMapHelper<Accessor>::ItemType>
static int LuaBlockMapImpl(lua_State *L, ItemType minValue, ItemType maxValue, Accessor accessor)
{
	auto pos = Vec2{ luaL_checkint(L, 1), luaL_checkint(L, 2) };
	if (!CELLS.OriginRect().Contains(pos))
	{
		return luaL_error(L, "Coordinates (%i, %i) out of range", pos.X, pos.Y);
	}
	auto argc = lua_gettop(L);
	if (argc == 2)
	{
		if constexpr (std::is_integral_v<ItemType>)
		{
			lua_pushinteger(L, lua_Integer(accessor(pos)));
		}
		else
		{
			lua_pushnumber(L, lua_Number(accessor(pos)));
		}
		return 1;
	}
	GetLSI()->AssertMutableSimEvent();
	auto size = Vec2{ 1, 1 };
	auto valuePos = 3;
	if (argc > 3)
	{
		size = Vec2{ luaL_checkint(L, 3), luaL_checkint(L, 4) };
		valuePos = 5;
	}
	ItemType value;
	if constexpr (std::is_integral_v<ItemType>)
	{
		value = ItemType(luaL_checkint(L, valuePos));
	}
	else
	{
		value = ItemType(luaL_checknumber(L, valuePos));
	}
	if constexpr (Clamp)
	{
		if (value > maxValue) value = maxValue;
		if (value < minValue) value = minValue;
	}
	for (auto p : CELLS.OriginRect() & RectSized(pos, size))
	{
		accessor(p) = value;
	}
	return 0;
}

template<class Accessor, class ItemType = typename LuaBlockMapHelper<Accessor>::ItemType>
static int LuaBlockMap(lua_State *L, ItemType minValue, ItemType maxValue, Accessor accessor)
{
	return LuaBlockMapImpl<true>(L, minValue, maxValue, accessor);
}

template<class Accessor, class ItemType = typename LuaBlockMapHelper<Accessor>::ItemType>
static int LuaBlockMap(lua_State *L, Accessor accessor)
{
	return LuaBlockMapImpl<false>(L, ItemType(0), ItemType(0), accessor);
}

static int velocityX(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, MIN_PRESSURE, MAX_PRESSURE, [lsi](Vec2<int> p) -> float & {
		return lsi->sim->vx[p.Y][p.X];
	});
}

static int velocityY(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, MIN_PRESSURE, MAX_PRESSURE, [lsi](Vec2<int> p) -> float & {
		return lsi->sim->vy[p.Y][p.X];
	});
}

static int ambientHeat(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, MIN_TEMP, MAX_TEMP, [lsi](Vec2<int> p) -> float & {
		return lsi->sim->hv[p.Y][p.X];
	});
}

static int pressure(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, MIN_PRESSURE, MAX_PRESSURE, [lsi](Vec2<int> p) -> float & {
		return lsi->sim->pv[p.Y][p.X];
	});
}

static int gravityMass(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, [lsi](Vec2<int> p) -> float & {
		return lsi->sim->gravIn.mass[p];
	});
}

static int gravityMask(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, [lsi](Vec2<int> p) -> uint32_t & {
		return lsi->sim->gravIn.mask[p];
	});
}

static int gravityField(lua_State *L)
{
	auto *lsi = GetLSI();
	auto pos = Vec2{ luaL_checkint(L, 1), luaL_checkint(L, 2) };
	if (!CELLS.OriginRect().Contains(pos))
	{
		return luaL_error(L, "Coordinates (%i, %i) out of range", pos.X, pos.Y);
	}
	lua_pushnumber(L, lsi->sim->gravOut.forceX[pos]);
	lua_pushnumber(L, lsi->sim->gravOut.forceY[pos]);
	return 2;
}

static int elecMap(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, [lsi](Vec2<int> p) -> unsigned char & {
		return lsi->sim->emap[p.Y][p.X];
	});
}

static int wallMap(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, 0, UI_WALLCOUNT - 1, [lsi](Vec2<int> p) -> unsigned char & {
		return lsi->sim->bmap[p.Y][p.X];
	});
}

static int fanVelocityX(lua_State *L)
{
	auto *lsi = GetLSI();
	return LuaBlockMap(L, [lsi](Vec2<int> p) -> float & {
		return lsi->sim->fvx[p.Y][p.X];
	});
}

static int fanVelocityY(lua_State *L)
{	auto *lsi = GetLSI();
	return LuaBlockMap(L, [lsi](Vec2<int> p) -> float & {
		return lsi->sim->fvy[p.Y][p.X];
	});
}

static int partNeighbors(lua_State *L)
{
	auto *lsi = GetLSI();
	auto *sim = lsi->sim;
	lua_newtable(L);
	int id = 1;
	int x = lua_tointeger(L, 1), y = lua_tointeger(L, 2), r = lua_tointeger(L, 3), rx, ry, n;
	if(lua_gettop(L) == 5) // this is one more than the number of arguments because a table has just been pushed onto the stack with lua_newtable(L);
	{
		int t = lua_tointeger(L, 4);
		for (rx = -r; rx <= r; rx++)
			for (ry = -r; ry <= r; ry++)
				if (x+rx >= 0 && y+ry >= 0 && x+rx < XRES && y+ry < YRES && (rx || ry))
				{
					n = sim->pmap[y+ry][x+rx];
					if (!n || TYP(n) != t)
						n = sim->photons[y+ry][x+rx];
					if (n && TYP(n) == t)
					{
						lua_pushinteger(L, ID(n));
						lua_rawseti(L, -2, id++);
					}
				}

	}
	else
	{
		for (rx = -r; rx <= r; rx++)
			for (ry = -r; ry <= r; ry++)
				if (x+rx >= 0 && y+ry >= 0 && x+rx < XRES && y+ry < YRES && (rx || ry))
				{
					n = sim->pmap[y+ry][x+rx];
					if (!n)
						n = sim->photons[y+ry][x+rx];
					if (n)
					{
						lua_pushinteger(L, ID(n));
						lua_rawseti(L, -2, id++);
					}
				}
	}
	return 1;
}

static int partChangeType(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMonopartAccessEvent(-1);
	int partIndex = lua_tointeger(L, 1);
	if(partIndex < 0 || partIndex >= NPART || !lsi->sim->parts[partIndex].type)
		return 0;
	lsi->sim->part_change_type(partIndex, int(lsi->sim->parts[partIndex].x+0.5f), int(lsi->sim->parts[partIndex].y+0.5f), lua_tointeger(L, 2));
	return 0;
}

static int partCreate(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMonopartAccessEvent(-1);
	int newID = lua_tointeger(L, 1);
	if (newID >= NPART || newID < -3)
	{
		lua_pushinteger(L, -1);
		return 1;
	}
	if (newID >= 0 && !lsi->sim->parts[newID].type)
	{
		lua_pushinteger(L, -1);
		return 1;
	}
	if (newID == -2)
	{
		lsi->AssertInterfaceEvent();
	}
	int type = lua_tointeger(L, 4);
	int v = -1;
	if (lua_gettop(L) >= 5)
	{
		v = lua_tointeger(L, 5);
	}
	else if (ID(type))
	{
		v = ID(type);
		type = TYP(type);
	}
	lua_pushinteger(L, lsi->sim->create_part(newID, lua_tointeger(L, 2), lua_tointeger(L, 3), type, v));
	return 1;
}

static int partID(lua_State *L)
{
	auto *lsi = GetLSI();
	int x = lua_tointeger(L, 1);
	int y = lua_tointeger(L, 2);

	if(x < 0 || x >= XRES || y < 0 || y >= YRES)
	{
		lua_pushnil(L);
		return 1;
	}

	int amalgam = lsi->sim->pmap[y][x];
	if(!amalgam)
		amalgam = lsi->sim->photons[y][x];
	if (!amalgam)
		lua_pushnil(L);
	else
		lua_pushinteger(L, ID(amalgam));
	return 1;
}

static int partPosition(lua_State *L)
{
	auto *lsi = GetLSI();
	auto *sim = lsi->sim;
	int particleID = lua_tointeger(L, 1);
	int argCount = lua_gettop(L);
	if (particleID < 0 || particleID >= NPART || !sim->parts[particleID].type)
	{
		if(argCount == 1)
		{
			lsi->AssertMonopartAccessEvent(-1);
			lua_pushnil(L);
			lua_pushnil(L);
			return 2;
		} else {
			return 0;
		}
	}

	if (argCount == 3)
	{
		lsi->AssertMonopartAccessEvent(-1);
		float x = sim->parts[particleID].x;
		float y = sim->parts[particleID].y;
		sim->move(particleID, (int)(x + 0.5f), (int)(y + 0.5f), lua_tonumber(L, 2), lua_tonumber(L, 3));

		return 0;
	}
	else
	{
		lua_pushnumber(L, sim->parts[particleID].x);
		lua_pushnumber(L, sim->parts[particleID].y);
		return 2;
	}
}

static int partProperty(lua_State *L)
{
	auto *lsi = GetLSI();
	int argCount = lua_gettop(L);
	int particleID = luaL_checkinteger(L, 1);
	StructProperty property;

	if (particleID < 0 || particleID >= NPART || !lsi->sim->parts[particleID].type)
	{
		if (argCount == 3)
		{
			lsi->AssertMonopartAccessEvent(-1);
			return 0;
		}
		lua_pushnil(L);
		return 1;
	}

	auto &properties = Particle::GetProperties();
	auto prop = properties.end();

	//Get field
	if (lua_type(L, 2) == LUA_TNUMBER)
	{
		int fieldID = lua_tointeger(L, 2);
		if (fieldID < 0 || fieldID >= (int)properties.size())
			return luaL_error(L, "Invalid field ID (%d)", fieldID);
		prop = properties.begin() + fieldID;
	}
	else if (lua_type(L, 2) == LUA_TSTRING)
	{
		ByteString fieldName = tpt_lua_toByteString(L, 2);
		for (auto &alias : Particle::GetPropertyAliases())
		{
			if (fieldName == alias.from)
			{
				fieldName = alias.to;
			}
		}
		prop = std::find_if(properties.begin(), properties.end(), [&fieldName](StructProperty const &p) {
			return p.Name == fieldName;
		});
		if (prop == properties.end())
			return luaL_error(L, "Unknown field (%s)", fieldName.c_str());
	}
	else
	{
		return luaL_error(L, "Field ID must be an name (string) or identifier (integer)");
	}

	//Calculate memory address of property
	intptr_t propertyAddress = (intptr_t)(((unsigned char*)&lsi->sim->parts[particleID]) + prop->Offset);

	if (argCount == 3)
	{
		LuaSetParticleProperty(L, particleID, *prop, propertyAddress, 3);
		return 0;
	}
	LuaGetProperty(L, *prop, propertyAddress);
	return 1;
}

static int partKill(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMonopartAccessEvent(-1);
	if(lua_gettop(L)==2)
		lsi->sim->delete_part(lua_tointeger(L, 1), lua_tointeger(L, 2));
	else
	{
		int i = lua_tointeger(L, 1);
		if (i>=0 && i<NPART)
			lsi->sim->kill_part(i);
	}
	return 0;
}

static int partExists(lua_State *L)
{
	auto *lsi = GetLSI();
	int i = luaL_checkinteger(L, 1);
	lua_pushboolean(L, i >= 0 && i < NPART && lsi->sim->parts[i].type);
	return 1;
}

static int createParts(lua_State *L)
{
	auto *lsi = GetLSI();
	int x = luaL_optint(L,1,-1);
	int y = luaL_optint(L,2,-1);
	int rx = luaL_optint(L,3,5);
	int ry = luaL_optint(L,4,5);
	int brushID = luaL_optint(L,6,BRUSH_CIRCLE);
	int flags = luaL_optint(L, 7, 0); // note: weird: the default is 0 in a sim context but lsi->sim->replaceModeFlags in a ui context
	                                  // note: weird: has to be 0 in a sim context
	if (!(lsi->eventTraits & eventTraitInterface) && !lua_isnoneornil(L, 5) && brushID == BRUSH_CIRCLE && flags == 0)
	{
		int c = luaL_checkint(L, 5); // note: weird: has to be specified in a sim context but not in a ui context
		auto center = Vec2(x, y);
		RasterizeEllipseRows(Vec2<float>(rx * rx, ry * ry), [lsi, c, center](int xLim, int dy) {
			for (auto pos : RectBetween(center + Vec2(-xLim, dy), center + Vec2(xLim, dy)))
			{
				lsi->sim->CreateParts(-1, pos.X, pos.Y, 0, 0, c, 0);
			}
		});
		lua_pushinteger(L, 0); // return value doesn't make sense anyway
		return 1;
	}

	lsi->AssertInterfaceEvent();
	int uiFlags = luaL_optint(L,7,lsi->sim->replaceModeFlags);
	Brush *brush = lsi->gameModel->GetBrushByID(brushID);
	if (!brush)
		return luaL_error(L, "Invalid brush id '%d'", brushID);
	auto newBrush = brush->Clone();
	newBrush->SetRadius(ui::Point(rx, ry));

	int c = luaL_optint(L,5,lsi->gameModel->GetActiveTool(0)->ToolID);
	int ret = lsi->sim->CreateParts(-2, x, y, c, *newBrush, uiFlags);
	lua_pushinteger(L, ret);
	return 1;
}

static int createLine(lua_State *L)
{
	auto *lsi = GetLSI();
	int x1 = luaL_optint(L,1,-1);
	int y1 = luaL_optint(L,2,-1);
	int x2 = luaL_optint(L,3,-1);
	int y2 = luaL_optint(L,4,-1);
	int rx = luaL_optint(L,5,5);
	int ry = luaL_optint(L,6,5);
	int brushID = luaL_optint(L,8,BRUSH_CIRCLE);
	int flags = luaL_optint(L, 9, 0); // note: weird: the default is 0 in a sim context but lsi->sim->replaceModeFlags in a ui context
	                                  // note: weird: has to be 0 in a sim context
	if (!(lsi->eventTraits & eventTraitInterface) && rx == 0 && ry == 0 && !lua_isnoneornil(L, 7) && brushID == BRUSH_CIRCLE && flags == 0)
	{
		int c = luaL_checkint(L, 7); // note: weird: has to be specified in a sim context but not in a ui context
		lsi->sim->CreateLine(x1, y1, x2, y2, c);
		return 0;
	}

	lsi->AssertInterfaceEvent();
	int c = luaL_optint(L,7,lsi->gameModel->GetActiveTool(0)->ToolID);
	int uiFlags = luaL_optint(L,9,lsi->sim->replaceModeFlags);
	Brush *brush = lsi->gameModel->GetBrushByID(brushID);
	if (!brush)
		return luaL_error(L, "Invalid brush id '%d'", brushID);
	auto newBrush = brush->Clone();
	newBrush->SetRadius(ui::Point(rx, ry));

	lsi->sim->CreateLine(x1, y1, x2, y2, c, *newBrush, uiFlags);
	return 0;
}

static int createBox(lua_State *L)
{
	auto *lsi = GetLSI();
	int x1 = luaL_optint(L,1,-1);
	int y1 = luaL_optint(L,2,-1);
	int x2 = luaL_optint(L,3,-1);
	int y2 = luaL_optint(L,4,-1);
	int flags = luaL_optint(L, 6, 0); // note: weird: the default is 0 in a sim context but lsi->sim->replaceModeFlags in a ui context
	                                  // note: weird: has to be 0 in a sim context
	if (!(lsi->eventTraits & eventTraitInterface) && !lua_isnoneornil(L, 5) && flags == 0)
	{
		int c = luaL_checkint(L, 5); // note: weird: has to be specified in a sim context but not in a ui context
		lsi->sim->CreateBox(-1, x1, y1, x2, y2, c, 0);
		return 0;
	}

	lsi->AssertInterfaceEvent();
	int c = luaL_optint(L,5,lsi->gameModel->GetActiveTool(0)->ToolID);
	int uiFlags = luaL_optint(L,6,lsi->sim->replaceModeFlags);

	lsi->sim->CreateBox(-2, x1, y1, x2, y2, c, uiFlags);
	return 0;
}

static int floodParts(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_optint(L,1,-1);
	int y = luaL_optint(L,2,-1);
	int c = luaL_optint(L,3,lsi->gameModel->GetActiveTool(0)->ToolID);
	int cm = luaL_optint(L,4,-1);
	int flags = luaL_optint(L,5,lsi->sim->replaceModeFlags);

	if (x < 0 || x >= XRES || y < 0 || y >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d)", x, y);

	int ret = lsi->sim->FloodParts(x, y, c, cm, flags);
	lua_pushinteger(L, ret);
	return 1;
}

static int createWalls(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_optint(L,1,-1);
	int y = luaL_optint(L,2,-1);
	int rx = luaL_optint(L,3,0);
	int ry = luaL_optint(L,4,0);
	int c = luaL_optint(L,5,8);

	if (x < 0 || x >= XRES || y < 0 || y >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d)", x, y);
	if (c < 0 || c >= UI_WALLCOUNT)
		return luaL_error(L, "Unrecognised wall id '%d'", c);

	int ret = lsi->sim->CreateWalls(x, y, rx, ry, c, nullptr);
	lua_pushinteger(L, ret);
	return 1;
}

static int createWallLine(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x1 = luaL_optint(L,1,-1);
	int y1 = luaL_optint(L,2,-1);
	int x2 = luaL_optint(L,3,-1);
	int y2 = luaL_optint(L,4,-1);
	int rx = luaL_optint(L,5,0);
	int ry = luaL_optint(L,6,0);
	int c = luaL_optint(L,7,8);

	if (x1 < 0 || x2 < 0 || x1 >= XRES || x2 >= XRES || y1 < 0 || y2 < 0 || y1 >= YRES || y2 >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d),(%d,%d)", x1, y1, x2, y2);
	if (c < 0 || c >= UI_WALLCOUNT)
		return luaL_error(L, "Unrecognised wall id '%d'", c);

	lsi->sim->CreateWallLine(x1, y1, x2, y2, rx, ry, c, nullptr);
	return 0;
}

static int createWallBox(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x1 = luaL_optint(L,1,-1);
	int y1 = luaL_optint(L,2,-1);
	int x2 = luaL_optint(L,3,-1);
	int y2 = luaL_optint(L,4,-1);
	int c = luaL_optint(L,5,8);

	if (x1 < 0 || x2 < 0 || x1 >= XRES || x2 >= XRES || y1 < 0 || y2 < 0 || y1 >= YRES || y2 >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d),(%d,%d)", x1, y1, x2, y2);
	if (c < 0 || c >= UI_WALLCOUNT)
		return luaL_error(L, "Unrecognised wall id '%d'", c);

	lsi->sim->CreateWallBox(x1, y1, x2, y2, c);
	return 0;
}

static int floodWalls(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_optint(L,1,-1);
	int y = luaL_optint(L,2,-1);
	int c = luaL_optint(L,3,8);
	int bm = luaL_optint(L,4,-1);
	if (x < 0 || x >= XRES || y < 0 || y >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d)", x, y);
	if (c < 0 || c >= UI_WALLCOUNT)
		return luaL_error(L, "Unrecognised wall id '%d'", c);
	if (c == WL_STREAM)
	{
		lua_pushinteger(L, 0);
		return 1;
	}
	int ret = lsi->sim->FloodWalls(x, y, c, bm);
	lua_pushinteger(L, ret);
	return 1;
}

static int toolBrush(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_optint(L,1,-1);
	int y = luaL_optint(L,2,-1);
	int rx = luaL_optint(L,3,5);
	int ry = luaL_optint(L,4,5);
	int tool = luaL_optint(L,5,0);
	int brushID = luaL_optint(L,6,BRUSH_CIRCLE);
	float strength = luaL_optnumber(L,7,1.0f);
	auto *toolPtr = lsi->gameModel->GetToolByIndex(tool);
	if (!toolPtr)
	{
		return luaL_error(L, "Invalid tool id '%d'", tool);
	}

	Brush *brush = lsi->gameModel->GetBrushByID(brushID);
	if (!brush)
		return luaL_error(L, "Invalid brush id '%d'", brushID);
	auto newBrush = brush->Clone();
	newBrush->SetRadius(ui::Point(rx, ry));

	toolPtr->Strength = strength;
	toolPtr->Draw(lsi->sim, *newBrush, { x, y });
	return 0;
}

static int toolLine(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x1 = luaL_optint(L,1,-1);
	int y1 = luaL_optint(L,2,-1);
	int x2 = luaL_optint(L,3,-1);
	int y2 = luaL_optint(L,4,-1);
	int rx = luaL_optint(L,5,5);
	int ry = luaL_optint(L,6,5);
	int tool = luaL_optint(L,7,0);
	int brushID = luaL_optint(L,8,BRUSH_CIRCLE);
	float strength = luaL_optnumber(L,9,1.0f);

	if (x1 < 0 || x2 < 0 || x1 >= XRES || x2 >= XRES || y1 < 0 || y2 < 0 || y1 >= YRES || y2 >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d),(%d,%d)", x1, y1, x2, y2);
	auto *toolPtr = lsi->gameModel->GetToolByIndex(tool);
	if (!toolPtr)
	{
		return luaL_error(L, "Invalid tool id '%d'", tool);
	}

	Brush *brush = lsi->gameModel->GetBrushByID(brushID);
	if (!brush)
		return luaL_error(L, "Invalid brush id '%d'", brushID);
	auto newBrush = brush->Clone();
	newBrush->SetRadius(ui::Point(rx, ry));
	toolPtr->Strength = strength;
	toolPtr->DrawLine(lsi->sim, *newBrush, { x1, y1 }, { x2, y2 }, false);
	return 0;
}

static int toolBox(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x1 = luaL_optint(L,1,-1);
	int y1 = luaL_optint(L,2,-1);
	int x2 = luaL_optint(L,3,-1);
	int y2 = luaL_optint(L,4,-1);
	if (x1 < 0 || x2 < 0 || x1 >= XRES || x2 >= XRES || y1 < 0 || y2 < 0 || y1 >= YRES || y2 >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d),(%d,%d)", x1, y1, x2, y2);
	int tool = luaL_optint(L,5,0);
	float strength = luaL_optnumber(L,6,1.0f);
	int brushID = luaL_optint(L,7,BRUSH_CIRCLE);
	int rx = luaL_optint(L,8,0);
	int ry = luaL_optint(L,9,0);
	Brush *brush = lsi->gameModel->GetBrushByID(brushID);
	if (!brush)
	{
		return luaL_error(L, "Invalid brush id '%d'", brushID);
	}
	auto *toolPtr = lsi->gameModel->GetToolByIndex(tool);
	if (!toolPtr)
	{
		return luaL_error(L, "Invalid tool id '%d'", tool);
	}
	auto newBrush = brush->Clone();
	newBrush->SetRadius(ui::Point(rx, ry));
	toolPtr->Strength = strength;
	toolPtr->DrawRect(lsi->sim, *newBrush, { x1, y1 }, { x2, y2 });
	return 0;
}

static int decoBrush(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_optint(L,1,-1);
	int y = luaL_optint(L,2,-1);
	int rx = luaL_optint(L,3,5);
	int ry = luaL_optint(L,4,5);
	int r = luaL_optint(L,5,255);
	int g = luaL_optint(L,6,255);
	int b = luaL_optint(L,7,255);
	int a = luaL_optint(L,8,255);
	int tool = luaL_optint(L,9,DECO_DRAW);
	int brushID = luaL_optint(L,10,BRUSH_CIRCLE);

	Brush *brush = lsi->gameModel->GetBrushByID(brushID);
	if (!brush)
		return luaL_error(L, "Invalid brush id '%d'", brushID);
	auto newBrush = brush->Clone();
	newBrush->SetRadius(ui::Point(rx, ry));

	lsi->sim->ApplyDecorationPoint(x, y, r, g, b, a, tool, *newBrush);
	return 0;
}

static int decoLine(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x1 = luaL_optint(L,1,-1);
	int y1 = luaL_optint(L,2,-1);
	int x2 = luaL_optint(L,3,-1);
	int y2 = luaL_optint(L,4,-1);
	int rx = luaL_optint(L,5,5);
	int ry = luaL_optint(L,6,5);
	int r = luaL_optint(L,7,255);
	int g = luaL_optint(L,8,255);
	int b = luaL_optint(L,9,255);
	int a = luaL_optint(L,10,255);
	int tool = luaL_optint(L,11,DECO_DRAW);
	int brushID = luaL_optint(L,12,BRUSH_CIRCLE);

	if (x1 < 0 || x2 < 0 || x1 >= XRES || x2 >= XRES || y1 < 0 || y2 < 0 || y1 >= YRES || y2 >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d),(%d,%d)", x1, y1, x2, y2);

	Brush *brush = lsi->gameModel->GetBrushByID(brushID);
	if (!brush)
		return luaL_error(L, "Invalid brush id '%d'", brushID);
	auto newBrush = brush->Clone();
	newBrush->SetRadius(ui::Point(rx, ry));

	lsi->sim->ApplyDecorationLine(x1, y1, x2, y2, r, g, b, a, tool, *newBrush);
	return 0;
}

static int decoBox(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x1 = luaL_optint(L,1,-1);
	int y1 = luaL_optint(L,2,-1);
	int x2 = luaL_optint(L,3,-1);
	int y2 = luaL_optint(L,4,-1);
	int r = luaL_optint(L,5,255);
	int g = luaL_optint(L,6,255);
	int b = luaL_optint(L,7,255);
	int a = luaL_optint(L,8,255);
	int tool = luaL_optint(L,9,0);

	if (x1 < 0 || x2 < 0 || x1 >= XRES || x2 >= XRES || y1 < 0 || y2 < 0 || y1 >= YRES || y2 >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d),(%d,%d)", x1, y1, x2, y2);

	lsi->sim->ApplyDecorationBox(x1, y1, x2, y2, r, g, b, a, tool);
	return 0;
}

static int decoColor(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	RGBA color(0, 0, 0, 0);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->gameModel->GetColourSelectorColour().Pack());
		return 1;
	}
	else if (acount == 1)
		color = RGBA::Unpack(pixel_rgba(luaL_optnumber(L, 1, 0xFFFF0000)));
	else
	{
		color.Red   = std::clamp(luaL_optint(L, 1, 255), 0, 255);
		color.Green = std::clamp(luaL_optint(L, 2, 255), 0, 255);
		color.Blue  = std::clamp(luaL_optint(L, 3, 255), 0, 255);
		color.Alpha = std::clamp(luaL_optint(L, 4, 255), 0, 255);
	}
	lsi->gameModel->SetColourSelectorColour(color);
	return 0;
}

static int floodDeco(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_checkinteger(L, 1);
	int y = luaL_checkinteger(L, 2);
	int r = luaL_checkinteger(L, 3);
	int g = luaL_checkinteger(L, 4);
	int b = luaL_checkinteger(L, 5);
	int a = luaL_checkinteger(L, 6);

	if (x < 0 || x >= XRES || y < 0 || y >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d)", x, y);

	// hilariously broken, intersects with console and all Lua graphics
	auto &rendererFrame = lsi->gameModel->GetView()->GetRendererFrame();
	auto loc = RGB::Unpack(rendererFrame[{ x, y }]);
	lsi->sim->ApplyDecorationFill(rendererFrame, x, y, r, g, b, a, loc.Red, loc.Green, loc.Blue);
	return 0;
}

static int clearSim(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	lsi->gameController->ClearSim();
	return 0;
}

static int clearRect(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_checkint(L,1);
	int y = luaL_checkint(L,2);
	int w = luaL_checkint(L,3)-1;
	int h = luaL_checkint(L,4)-1;
	lsi->sim->clear_area(x, y, w, h);
	return 0;
}

static int resetTemp(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	auto *sim = lsi->sim;
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	bool onlyConductors = luaL_optint(L, 1, 0);
	for (int i = 0; i < sim->parts.lastActiveIndex; i++)
	{
		if (sim->parts[i].type && (!onlyConductors || !sim->IsHeatInsulator(sim->parts[i])))
		{
			sim->parts[i].temp = elements[sim->parts[i].type].DefaultProperties.temp;
		}
	}
	return 0;
}

static int resetPressure(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int aCount = lua_gettop(L), width = XCELLS, height = YCELLS;
	int x1 = abs(luaL_optint(L, 1, 0));
	int y1 = abs(luaL_optint(L, 2, 0));
	if (aCount > 2)
	{
		width = abs(luaL_optint(L, 3, XCELLS));
		height = abs(luaL_optint(L, 4, YCELLS));
	}
	else if (aCount)
	{
		width = 1;
		height = 1;
	}
	if(x1 > XCELLS-1)
		x1 = XCELLS-1;
	if(y1 > YCELLS-1)
		y1 = YCELLS-1;
	if(x1+width > XCELLS-1)
		width = XCELLS-x1;
	if(y1+height > YCELLS-1)
		height = YCELLS-y1;
	for (int nx = x1; nx<x1+width; nx++)
		for (int ny = y1; ny<y1+height; ny++)
		{
			lsi->sim->pv[ny][nx] = 0;
		}
	return 0;
}

static int saveStamp(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_optint(L,1,0);
	int y = luaL_optint(L,2,0);
	int w = luaL_optint(L,3,XRES-1);
	int h = luaL_optint(L,4,YRES-1);
	bool includePressure = luaL_optint(L, 5, 1);
	ByteString name = lsi->gameController->StampRegion(ui::Point(x, y), ui::Point(x+w, y+h), includePressure);
	tpt_lua_pushByteString(L, name);
	return 1;
}

static int loadStamp(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int i = -1;
	int pushed = 1;
	std::unique_ptr<SaveFile> tempfile;
	Vec2<int> partP = {
		luaL_optint(L, 2, 0),
		luaL_optint(L, 3, 0),
	};
	auto hflip = lua_toboolean(L, 4);
	auto rotation = luaL_optint(L, 5, 0) & 3; // [0, 3] rotations
	bool includePressure = luaL_optint(L, 6, 1);
	auto &client = Client::Ref();
	if (lua_isstring(L, 1)) //Load from 10 char name, or full filename
	{
		auto filename = tpt_lua_optByteString(L, 1, "");
		tempfile = client.GetStamp(filename);
	}
	if ((!tempfile || !tempfile->GetGameSave()) && lua_isnumber(L, 1)) //Load from stamp ID
	{
		i = luaL_optint(L, 1, 0);
		auto &stampIDs = client.GetStamps();
		if (i < 0 || i >= int(stampIDs.size()))
			return luaL_error(L, "Invalid stamp ID: %d", i);
		tempfile = client.GetStamp(stampIDs[i]);
	}

	if (tempfile && tempfile->GetGameSave())
	{
		auto gameSave = tempfile->TakeGameSave();
		auto [ quoX, remX ] = floorDiv(partP.X, CELL);
		auto [ quoY, remY ] = floorDiv(partP.Y, CELL);
		if (remX || remY || hflip || rotation)
		{
			auto transform = Mat2<int>::Identity;
			if (hflip)
			{
				transform = Mat2<int>::MirrorX * transform;
			}
			for (auto i = 0; i < rotation; ++i)
			{
				transform = Mat2<int>::CCW * transform;
			}
			gameSave->Transform(transform, { remX, remY });
		}
		lsi->sim->Load(gameSave.get(), includePressure, { quoX, quoY });
		lua_pushinteger(L, 1);

		if (gameSave->authors.size())
		{
			gameSave->authors["type"] = "luastamp";
			client.MergeStampAuthorInfo(gameSave->authors);
		}
	}
	else
	{
		pushed = 2;
		lua_pushnil(L);
		tpt_lua_pushString(L, tempfile ? tempfile->GetError() : "does not exist");
	}
	return pushed;
}

static int deleteStamp(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	auto &client = Client::Ref();
	auto &stampIDs = client.GetStamps();

	if (lua_isstring(L, 1)) //note: lua_isstring returns true on numbers too
	{
		auto filename = tpt_lua_optByteString(L, 1, "");
		for (auto &stampID : stampIDs)
		{
			if (stampID == filename)
			{
				client.DeleteStamp(stampID);
				return 0;
			}
		}
	}
	if (lua_isnumber(L, 1)) //Load from stamp ID
	{
		int i = luaL_optint(L, 1, 0);
		if (i < 0 || i >= int(stampIDs.size()))
			return luaL_error(L, "Invalid stamp ID: %d", i);
		client.DeleteStamp(stampIDs[i]);
		return 0;
	}
	lua_pushnumber(L, -1);
	return 1;
}

static int listStamps(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	lua_newtable(L);
	auto &client = Client::Ref();
	auto &stampIDs = client.GetStamps();
	auto i = 0;
	for (auto &stampID : stampIDs)
	{
		tpt_lua_pushByteString(L, stampID);
		i += 1;
		lua_rawseti(L, -2, i);
	}
	return 1;
}

static int loadSave(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int saveID = luaL_optint(L,1,0);
	int instant = luaL_optint(L,2,0);
	int history = luaL_optint(L,3,0); //Exact second a previous save was saved
	lsi->gameController->OpenSavePreview(saveID, history, instant ? savePreviewInstant : savePreviewNormal);
	return 0;
}

static int reloadSave(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	lsi->gameController->ReloadSim();
	return 0;
}

static int getSaveID(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	auto *tempSave = lsi->gameModel->GetSave();
	if (tempSave)
	{
		lua_pushinteger(L, tempSave->GetID());
		lua_pushinteger(L, tempSave->Version);
		return 2;
	}
	return 0;
}

static int adjustCoords(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int x = luaL_optint(L,1,0);
	int y = luaL_optint(L,2,0);
	ui::Point Coords = lsi->gameController->PointTranslate(ui::Point(x, y));
	lua_pushinteger(L, Coords.X);
	lua_pushinteger(L, Coords.Y);
	return 2;
}

static int prettyPowders(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->sim->pretty_powder);
		return 1;
	}
	lsi->AssertInterfaceEvent();
	int prettyPowder = luaL_optint(L, 1, 0);
	lsi->sim->pretty_powder = prettyPowder;
	lsi->gameModel->UpdateQuickOptions();
	return 0;
}

static int gravityGrid(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->gameModel->GetGravityGrid());
		return 1;
	}
	int gravityGrid = luaL_optint(L, 1, 0);
	lsi->gameModel->ShowGravityGrid(gravityGrid);
	lsi->gameModel->UpdateQuickOptions();
	return 0;
}

static int edgeMode(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->gameModel->GetEdgeMode());
		return 1;
	}
	lsi->AssertInterfaceEvent();
	int edgeMode = luaL_optint(L, 1, EDGE_VOID);
	lsi->gameModel->SetEdgeMode(edgeMode);
	return 0;
}

static int gravityMode(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->sim->gravityMode);
		return 1;
	}
	lsi->AssertInterfaceEvent();
	int gravityMode = luaL_optint(L, 1, GRAV_VERTICAL);
	lsi->sim->gravityMode = gravityMode;
	return 0;
}

static int customGravity(lua_State *L)
{
	auto *lsi = GetLSI();
	auto *sim = lsi->sim;
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, sim->customGravityX);
		lua_pushnumber(L, sim->customGravityY);
		return 2;
	}
	lsi->AssertInterfaceEvent();
	if (acount == 1)
	{
		sim->customGravityX = 0.0f;
		sim->customGravityY = luaL_optnumber(L, 1, 0.0f);
		return 0;
	}
	sim->customGravityX = luaL_optnumber(L, 1, 0.0f);
	sim->customGravityY = luaL_optnumber(L, 2, 0.0f);
	return 0;
}

static int airMode(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->sim->air->airMode);
		return 1;
	}
	lsi->AssertInterfaceEvent();
	int airMode = luaL_optint(L, 1, AIR_ON);
	lsi->sim->air->airMode = airMode;
	return 0;
}

static int waterEqualization(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->sim->water_equal_test);
		return 1;
	}
	lsi->AssertInterfaceEvent();
	int waterMode = luaL_optint(L, 1, 0);
	lsi->sim->water_equal_test = waterMode;
	return 0;
}

static int ambientAirTemp(lua_State *L)
{
	auto *lsi = GetLSI();
	int acount = lua_gettop(L);
	if (acount == 0)
	{
		lua_pushnumber(L, lsi->sim->air->ambientAirTemp);
		return 1;
	}
	lsi->AssertInterfaceEvent();
	float ambientAirTemp = restrict_flt(luaL_optnumber(L, 1, R_TEMP + 273.15f), MIN_TEMP, MAX_TEMP);
	lsi->gameModel->SetAmbientAirTemperature(ambientAirTemp);
	return 0;
}

static int elementCount(lua_State *L)
{
	int element = luaL_optint(L, 1, 0);
	if (element < 0 || element >= PT_NUM)
		return luaL_error(L, "Invalid element ID (%d)", element);

	auto *lsi = GetLSI();
	lua_pushnumber(L, lsi->sim->elementCount[element]);
	return 1;
}

static int canMove(lua_State *L)
{
	auto *lsi = GetLSI();
	int movingElement = luaL_checkint(L, 1);
	int destinationElement = luaL_checkint(L, 2);
	if (movingElement < 0 || movingElement >= PT_NUM)
		return luaL_error(L, "Invalid element ID (%d)", movingElement);
	if (destinationElement < 0 || destinationElement >= PT_NUM)
		return luaL_error(L, "Invalid element ID (%d)", destinationElement);

	if (lua_gettop(L) < 3)
	{
		auto &sd = SimulationData::CRef();
		lua_pushnumber(L, sd.can_move[movingElement][destinationElement]);
		return 1;
	}
	lsi->AssertInterfaceEvent();
	int setting = luaL_checkint(L, 3) & 0x7F;
	lsi->customCanMove[movingElement][destinationElement] = setting | 0x80;
	auto &sd = SimulationData::Ref();
	sd.can_move[movingElement][destinationElement] = setting;
	return 0;
}

static int brushClosure(lua_State *L)
{
	// see Simulation::ToolBrush
	int positionX = lua_tointeger(L, lua_upvalueindex(1));
	int positionY = lua_tointeger(L, lua_upvalueindex(2));
	int i = lua_tointeger(L, lua_upvalueindex(3));
	int size = lua_tointeger(L, lua_upvalueindex(4));
	auto points = reinterpret_cast<ui::Point *>(lua_touserdata(L, lua_upvalueindex(5)));

	if (i == size)
		return 0;

	lua_pushnumber(L, i + 1);
	lua_replace(L, lua_upvalueindex(3));

	lua_pushnumber(L, points[i].X + positionX);
	lua_pushnumber(L, points[i].Y + positionY);
	return 2;
}

static int brush(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int argCount = lua_gettop(L);
	int positionX = luaL_checkint(L, 1);
	int positionY = luaL_checkint(L, 2);
	int brushradiusX, brushradiusY;
	if (argCount >= 4)
	{
		brushradiusX = luaL_checkint(L, 3);
		brushradiusY = luaL_checkint(L, 4);
	}
	else
	{
		ui::Point radius = lsi->gameModel->GetBrush().GetRadius();
		brushradiusX = radius.X;
		brushradiusY = radius.Y;
	}
	int brushID = luaL_optint(L, 5, lsi->gameModel->GetBrushID());

	Brush *brush = lsi->gameModel->GetBrushByID(brushID);
	if (!brush)
		return luaL_error(L, "Invalid brush id '%d'", brushID);
	auto newBrush = brush->Clone();
	newBrush->SetRadius(ui::Point(brushradiusX, brushradiusY));
	lua_pushnumber(L, positionX);
	lua_pushnumber(L, positionY);
	std::vector<ui::Point> points;
	std::copy(newBrush->begin(), newBrush->end(), std::back_inserter(points));
	lua_pushnumber(L, 0); // index
	lua_pushnumber(L, int(points.size()));
	auto points_ud = reinterpret_cast<ui::Point *>(lua_newuserdata(L, points.size() * sizeof(ui::Point)));
	std::copy(points.begin(), points.end(), points_ud);

	lua_pushcclosure(L, brushClosure, 5);
	return 1;
}

static int partsClosure(lua_State *L)
{
	auto *lsi = GetLSI();
	for (int i = lua_tointeger(L, lua_upvalueindex(1)); i <= lsi->sim->parts.lastActiveIndex; ++i)
	{
		if (lsi->sim->parts[i].type)
		{
			lua_pushnumber(L, i + 1);
			lua_replace(L, lua_upvalueindex(1));
			lua_pushnumber(L, i);
			return 1;
		}
	}
	return 0;
}

static int neighboursClosure(lua_State *L)
{
	auto *lsi = GetLSI();
	int cx = lua_tointeger(L, lua_upvalueindex(1));
	int cy = lua_tointeger(L, lua_upvalueindex(2));
	int rx = lua_tointeger(L, lua_upvalueindex(3));
	int ry = lua_tointeger(L, lua_upvalueindex(4));
	int t = lua_tointeger(L, lua_upvalueindex(5));
	int x = lua_tointeger(L, lua_upvalueindex(6));
	int y = lua_tointeger(L, lua_upvalueindex(7));
	while (y <= cy + ry)
	{
		int px = x;
		int py = y;
		x += 1;
		if (x > cx + rx)
		{
			x = cx - rx;
			y += 1;
		}
		int r = lsi->sim->pmap[py][px];
		if (!(r && (!t || TYP(r) == t))) // * If not [exists and is of the correct type]
		{
			r = 0;
		}
		if (!r)
		{
			r = lsi->sim->photons[py][px];
			if (!(r && (!t || TYP(r) == t))) // * If not [exists and is of the correct type]
			{
				r = 0;
			}
		}
		if (cx == px && cy == py)
		{
			r = 0;
		}
		if (r)
		{
			lua_pushnumber(L, x);
			lua_replace(L, lua_upvalueindex(6));
			lua_pushnumber(L, y);
			lua_replace(L, lua_upvalueindex(7));
			lua_pushnumber(L, ID(r));
			lua_pushnumber(L, px);
			lua_pushnumber(L, py);
			return 3;
		}
	}
	return 0;
}

static int neighbors(lua_State *L)
{
	int cx = luaL_checkint(L, 1);
	int cy = luaL_checkint(L, 2);
	int rx = luaL_optint(L, 3, 2);
	int ry = luaL_optint(L, 4, 2);
	int t = luaL_optint(L, 5, PT_NONE);
	if (rx < 0 || ry < 0)
	{
		luaL_error(L, "Invalid radius");
	}
	lua_pushnumber(L, cx);
	lua_pushnumber(L, cy);
	lua_pushnumber(L, rx);
	lua_pushnumber(L, ry);
	lua_pushnumber(L, t);
	lua_pushnumber(L, cx - rx);
	lua_pushnumber(L, cy - ry);
	lua_pushcclosure(L, neighboursClosure, 7);
	return 1;
}

static int parts(lua_State *L)
{
	lua_pushnumber(L, 0);
	lua_pushcclosure(L, partsClosure, 1);
	return 1;
}

static int pmap(lua_State *L)
{
	auto *lsi = GetLSI();
	int x = luaL_checkint(L, 1);
	int y = luaL_checkint(L, 2);
	if (x < 0 || x >= XRES || y < 0 || y >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d)", x, y);
	int r = lsi->sim->pmap[y][x];
	if (!TYP(r))
		return 0;
	lua_pushnumber(L, ID(r));
	return 1;
}

static int photons(lua_State *L)
{
	auto *lsi = GetLSI();
	int x = luaL_checkint(L, 1);
	int y = luaL_checkint(L, 2);
	if (x < 0 || x >= XRES || y < 0 || y >= YRES)
		return luaL_error(L, "coordinates out of range (%d,%d)", x, y);
	int r = lsi->sim->photons[y][x];
	if (!TYP(r))
		return 0;
	lua_pushnumber(L, ID(r));
	return 1;
}

static int frameRender(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) == 0)
	{
		lua_pushinteger(L, lsi->sim->framerender);
		return 1;
	}
	int frames = luaL_checkinteger(L, 1);
	if (frames < 0)
		return luaL_error(L, "Can't simulate a negative number of frames");
	lsi->sim->framerender = frames;
	return 0;
}

static int golSpeedRatio(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) == 0)
	{
		lua_pushinteger(L, lsi->sim->GSPEED);
		return 1;
	}
	int gspeed = luaL_checkinteger(L, 1);
	if (gspeed < 1)
		return luaL_error(L, "GSPEED must be at least 1");
	lsi->sim->GSPEED = gspeed;
	return 0;
}

static int takeSnapshot(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	lsi->gameController->HistorySnapshot();
	return 0;
}


static int historyRestore(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	bool successful = lsi->gameController->HistoryRestore();
	lua_pushboolean(L, successful);
	return 1;
}

static int historyForward(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	bool successful = lsi->gameController->HistoryForward();
	lua_pushboolean(L, successful);
	return 1;
}

static int replaceModeFlags(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) == 0)
	{
		lua_pushinteger(L, lsi->gameController->GetReplaceModeFlags());
		return 1;
	}
	unsigned int flags = luaL_checkinteger(L, 1);
	if (flags & ~(REPLACE_MODE | SPECIFIC_DELETE))
		return luaL_error(L, "Invalid flags");
	if ((flags & REPLACE_MODE) && (flags & SPECIFIC_DELETE))
		return luaL_error(L, "Cannot set replace mode and specific delete at the same time");
	lsi->gameController->SetReplaceModeFlags(flags);
	return 0;
}

static int listCustomGol(lua_State *L)
{
	auto &sd = SimulationData::CRef();
	int i = 0;
	lua_newtable(L);
	for (auto &cgol : sd.GetCustomGol())
	{
		lua_newtable(L);
		tpt_lua_pushString(L, cgol.nameString);
		lua_setfield(L, -2, "name");
		tpt_lua_pushString(L, SerialiseGOLRule(cgol.rule));
		lua_setfield(L, -2, "rulestr");
		lua_pushnumber(L, cgol.rule);
		lua_setfield(L, -2, "rule");
		lua_pushnumber(L, cgol.colour1.Pack());
		lua_setfield(L, -2, "color1");
		lua_pushnumber(L, cgol.colour2.Pack());
		lua_setfield(L, -2, "color2");
		lua_rawseti(L, -2, ++i);
	}
	return 1;
}

static int listDefaultGol(lua_State *L)
{
	int i = 0;
	lua_newtable(L);
	for (auto &gol : SimulationData::builtinGol)
	{
		lua_newtable(L);
		tpt_lua_pushString(L, gol.name);
		lua_setfield(L, -2, "name");
		tpt_lua_pushString(L, SerialiseGOLRule(gol.ruleset));
		lua_setfield(L, -2, "rulestr");
		lua_pushnumber(L, gol.ruleset);
		lua_setfield(L, -2, "rule");
		lua_pushnumber(L, gol.colour.Pack());
		lua_setfield(L, -2, "color1");
		lua_pushnumber(L, gol.colour2.Pack());
		lua_setfield(L, -2, "color2");
		lua_rawseti(L, -2, ++i);
	}
	return 1;
}

static int addCustomGol(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	auto &sd = SimulationData::CRef();
	int rule;
	String ruleString;
	if (lua_isnumber(L, 1))
	{
		rule = luaL_checkinteger(L, 1);
		ruleString = SerialiseGOLRule(rule);
		rule = ParseGOLString(ruleString);
	}
	else
	{
		ruleString = tpt_lua_checkString(L, 1);
		rule = ParseGOLString(ruleString);
	}
	String nameString = tpt_lua_checkString(L, 2);
	unsigned int color1 = luaL_checkinteger(L, 3);
	unsigned int color2 = luaL_checkinteger(L, 4);

	if (nameString.empty() || !ValidateGOLName(nameString))
		return luaL_error(L, "Invalid name provided");
	if (rule == -1)
		return luaL_error(L, "Invalid rule provided");
	if (sd.GetCustomGOLByRule(rule))
		return luaL_error(L, "This Custom GoL rule already exists");

	if (!lsi->gameModel->AddCustomGol(ruleString, nameString, RGB::Unpack(color1), RGB::Unpack(color2)))
		return luaL_error(L, "Duplicate name, cannot add");
	return 0;
}

static int removeCustomGol(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	ByteString nameString = tpt_lua_checkByteString(L, 1);
	bool removedAny = lsi->gameModel->RemoveCustomGol("DEFAULT_PT_LIFECUST_" + nameString);
	lua_pushboolean(L, removedAny);
	return 1;
}

static int lastUpdatedID(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lsi->sim->debug_mostRecentlyUpdated != -1)
	{
		lua_pushinteger(L, lsi->sim->debug_mostRecentlyUpdated);
	}
	else
	{
		lua_pushnil(L);
	}
	return 1;
}

static int updateUpTo(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	// sim.updateUpTo dispatches an update to the range [current, upTo], but GameModel::UpdateUpTo takes a range [current, upTo).
	// As a result, upTo here will be one smaller than it's logical for the duration of this function.
	int upTo = NPART - 1;
	if (lua_gettop(L) > 0)
	{
		upTo = luaL_checkinteger(L, 1);
	}
	if (upTo < -1 || upTo >= NPART) // -1 instead of 0 to allow for the empty range [0, -1] aka [0, 0)
	{
		return luaL_error(L, "ID not in valid range");
	}
	lsi->sim->framerender = 1;
	lsi->gameModel->UpdateUpTo(upTo + 1);
	return 0;
}

static int temperatureScale(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L) == 0)
	{
		lua_pushinteger(L, lsi->gameModel->GetTemperatureScale());
		return 1;
	}
	int temperatureScale = luaL_checkinteger(L, 1);
	if (temperatureScale < 0 || temperatureScale > 2)
		return luaL_error(L, "Invalid temperature scale");
	lsi->gameModel->SetTemperatureScale(temperatureScale);
	return 0;
}

static int signsIndex(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	ByteString key = tpt_lua_checkByteString(L, 2);

	//Get Raw Index value for element. Maybe there is a way to get the sign index some other way?
	lua_pushliteral(L, "id");
	lua_rawget(L, 1);
	int id = lua_tointeger(L, lua_gettop(L))-1;

	if (id < 0 || id >= MAXSIGNS)
	{
		luaL_error(L, "Invalid sign ID (stop messing with things): %i", id);
		return 0;
	}
	auto *sim = lsi->sim;
	if (id >= (int)sim->signs.size())
	{
		return lua_pushnil(L), 1;
	}

	int x, y, w, h;
	if (byteStringEqualsLiteral(key, "text"))
		return tpt_lua_pushString(L, sim->signs[id].text), 1;
	else if (byteStringEqualsLiteral(key, "displayText"))
		return tpt_lua_pushString(L, sim->signs[id].getDisplayText(sim, x, y, w, h, false)), 1;
	else if (byteStringEqualsLiteral(key, "justification"))
		return lua_pushnumber(L, (int)sim->signs[id].ju), 1;
	else if (byteStringEqualsLiteral(key, "x"))
		return lua_pushnumber(L, sim->signs[id].x), 1;
	else if (byteStringEqualsLiteral(key, "y"))
		return lua_pushnumber(L, sim->signs[id].y), 1;
	else if (byteStringEqualsLiteral(key, "screenX"))
	{
		sim->signs[id].getDisplayText(sim, x, y, w, h);
		lua_pushnumber(L, x);
		return 1;
	}
	else if (byteStringEqualsLiteral(key, "screenY"))
	{
		sim->signs[id].getDisplayText(sim, x, y, w, h);
		lua_pushnumber(L, y);
		return 1;
	}
	else if (byteStringEqualsLiteral(key, "width"))
	{
		sim->signs[id].getDisplayText(sim, x, y, w, h);
		lua_pushnumber(L, w);
		return 1;
	}
	else if (byteStringEqualsLiteral(key, "height"))
	{
		sim->signs[id].getDisplayText(sim, x, y, w, h);
		lua_pushnumber(L, h);
		return 1;
	}
	else
		return lua_pushnil(L), 1;
}

static int signsNewIndex(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	auto *sim = lsi->sim;
	ByteString key = tpt_lua_checkByteString(L, 2);

	//Get Raw Index value for element. Maybe there is a way to get the sign index some other way?
	lua_pushliteral(L, "id");
	lua_rawget(L, 1);
	int id = lua_tointeger(L, lua_gettop(L))-1;

	if (id < 0 || id >= MAXSIGNS)
	{
		luaL_error(L, "Invalid sign ID (stop messing with things)");
		return 0;
	}
	if (id >= (int)sim->signs.size())
	{
		luaL_error(L, "Sign doesn't exist");
	}

	if (byteStringEqualsLiteral(key, "text"))
	{
		auto temp = tpt_lua_checkString(L, 3);
		String cleaned = format::CleanString(temp, false, true, true).Substr(0, 45);
		if (!cleaned.empty())
			sim->signs[id].text = cleaned;
		else
			luaL_error(L, "Text is empty");
		return 0;
	}
	else if (byteStringEqualsLiteral(key, "justification"))
	{
		int ju = luaL_checkinteger(L, 3);
		if (ju >= 0 && ju <= 3)
			return sim->signs[id].ju = (sign::Justification)ju, 1;
		else
			luaL_error(L, "Invalid justification");
		return 0;
	}
	else if (byteStringEqualsLiteral(key, "x"))
	{
		int x = luaL_checkinteger(L, 3);
		if (x >= 0 && x < XRES)
			return sim->signs[id].x = x, 1;
		else
			luaL_error(L, "Invalid X coordinate");
		return 0;
	}
	else if (byteStringEqualsLiteral(key, "y"))
	{
		int y = luaL_checkinteger(L, 3);
		if (y >= 0 && y < YRES)
			return sim->signs[id].y = y, 1;
		else
			luaL_error(L, "Invalid Y coordinate");
		return 0;
	}
	else if (byteStringEqualsLiteral(key, "displayText") ||
	         byteStringEqualsLiteral(key, "screenX") ||
	         byteStringEqualsLiteral(key, "screenY") ||
	         byteStringEqualsLiteral(key, "width") ||
	         byteStringEqualsLiteral(key, "height"))
	{
		luaL_error(L, "That property can't be directly set");
	}
	return 0;
}

// Creates a new sign at the first open index
static int Sign_new(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lsi->sim->signs.size() >= MAXSIGNS)
		return lua_pushnil(L), 1;

	String text = format::CleanString(tpt_lua_checkString(L, 1), false, true, true).Substr(0, 45);
	int x = luaL_checkinteger(L, 2);
	int y = luaL_checkinteger(L, 3);
	int ju = luaL_optinteger(L, 4, 1);
	if (ju < 0 || ju > 3)
		return luaL_error(L, "Invalid justification");
	if (x < 0 || x >= XRES)
		return luaL_error(L, "Invalid X coordinate");
	if (y < 0 || y >= YRES)
		return luaL_error(L, "Invalid Y coordinate");

	lsi->sim->signs.push_back(sign(text, x, y, (sign::Justification)ju));

	lua_pushinteger(L, lsi->sim->signs.size());
	return 1;
}

// Deletes a sign
static int Sign_delete(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int signID = luaL_checkinteger(L, 1);
	if (signID <= 0 || signID > (int)lsi->sim->signs.size())
		return luaL_error(L, "Sign doesn't exist");

	lsi->sim->signs.erase(lsi->sim->signs.begin()+signID-1);
	return 1;
}

static int resetVelocity(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int nx, ny;
	int x1, y1, width, height;
	x1 = abs(luaL_optint(L, 1, 0));
	y1 = abs(luaL_optint(L, 2, 0));
	width = abs(luaL_optint(L, 3, XCELLS));
	height = abs(luaL_optint(L, 4, YCELLS));
	if(x1 > XCELLS-1)
		x1 = XCELLS-1;
	if(y1 > YCELLS-1)
		y1 = YCELLS-1;
	if(x1+width > XCELLS-1)
		width = XCELLS-x1;
	if(y1+height > YCELLS-1)
		height = YCELLS-y1;
	for (nx = x1; nx<x1+width; nx++)
		for (ny = y1; ny<y1+height; ny++)
		{
			lsi->sim->vx[ny][nx] = 0;
			lsi->sim->vy[ny][nx] = 0;
		}
	return 0;
}

static int resetSpark(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	lsi->gameController->ResetSpark();
	return 0;
}

static int randomSeed(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L))
	{
		lsi->sim->rng.state({
			uint32_t(luaL_checkinteger(L, 1)) | (uint64_t(uint32_t(luaL_checkinteger(L, 2))) << 32),
			uint32_t(luaL_checkinteger(L, 3)) | (uint64_t(uint32_t(luaL_checkinteger(L, 4))) << 32),
		});
		return 0;
	}
	auto s = lsi->sim->rng.state();
	lua_pushinteger(L,  s[0]        & UINT32_C(0xFFFFFFFF));
	lua_pushinteger(L, (s[0] >> 32) & UINT32_C(0xFFFFFFFF));
	lua_pushinteger(L,  s[1]        & UINT32_C(0xFFFFFFFF));
	lua_pushinteger(L, (s[1] >> 32) & UINT32_C(0xFFFFFFFF));
	return 4;
}

static int hash(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	lua_pushinteger(L, lsi->sim->CreateSnapshot()->Hash());
	return 1;
}

static int ensureDeterminism(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	if (lua_gettop(L))
	{
		lsi->sim->ensureDeterminism = lua_toboolean(L, 1);
		return 0;
	}
	lua_pushboolean(L, lsi->sim->ensureDeterminism);
	return 1;
}

void LuaSimulation::Open(lua_State *L)
{
	auto *lsi = GetLSI();
	auto &sd = SimulationData::CRef();
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(partNeighbors),
		LFUNC(partChangeType),
		LFUNC(partCreate),
		LFUNC(partProperty),
		LFUNC(partPosition),
		LFUNC(partID),
		LFUNC(partKill),
		LFUNC(partExists),
		LFUNC(pressure),
		LFUNC(ambientHeat),
		LFUNC(ambientHeatSim),
		LFUNC(heatSim),
		LFUNC(newtonianGravity),
		LFUNC(velocityX),
		LFUNC(velocityY),
		LFUNC(createParts),
		LFUNC(createLine),
		LFUNC(createBox),
		LFUNC(floodParts),
		LFUNC(createWalls),
		LFUNC(createWallLine),
		LFUNC(createWallBox),
		LFUNC(floodWalls),
		LFUNC(toolBrush),
		LFUNC(toolLine),
		LFUNC(toolBox),
		LFUNC(decoBrush),
		LFUNC(decoLine),
		LFUNC(decoBox),
		LFUNC(decoColor),
		LFUNC(floodDeco),
		LFUNC(clearSim),
		LFUNC(clearRect),
		LFUNC(resetTemp),
		LFUNC(resetPressure),
		LFUNC(saveStamp),
		LFUNC(loadStamp),
		LFUNC(deleteStamp),
		LFUNC(listStamps),
		LFUNC(loadSave),
		LFUNC(reloadSave),
		LFUNC(getSaveID),
		LFUNC(adjustCoords),
		LFUNC(prettyPowders),
		LFUNC(gravityGrid),
		LFUNC(edgeMode),
		LFUNC(gravityMode),
		LFUNC(customGravity),
		LFUNC(airMode),
		LFUNC(waterEqualization),
		LFUNC(ambientAirTemp),
		LFUNC(elementCount),
		LFUNC(canMove),
		LFUNC(brush),
		LFUNC(parts),
		LFUNC(pmap),
		LFUNC(photons),
		LFUNC(neighbors),
		LFUNC(frameRender),
		LFUNC(golSpeedRatio),
		LFUNC(takeSnapshot),
		LFUNC(historyRestore),
		LFUNC(historyForward),
		LFUNC(replaceModeFlags),
		LFUNC(listCustomGol),
		LFUNC(addCustomGol),
		LFUNC(removeCustomGol),
		LFUNC(lastUpdatedID),
		LFUNC(updateUpTo),
		LFUNC(temperatureScale),
		LFUNC(randomSeed),
		LFUNC(hash),
		LFUNC(ensureDeterminism),
		LFUNC(paused),
		LFUNC(gravityMass),
		LFUNC(gravityMask),
		LFUNC(gravityField),
		LFUNC(resetSpark),
		LFUNC(resetVelocity),
		LFUNC(wallMap),
		LFUNC(elecMap),
		LFUNC(partCount),
		LFUNC(decoSpace),
		LFUNC(fanVelocityX),
		LFUNC(fanVelocityY),
		LFUNC(listDefaultGol),
#undef LFUNC
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);

#define LCONST(v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, #v)
#define LCONSTF(v) lua_pushnumber(L, float(v)); lua_setfield(L, -2, #v)
#define LCONSTAS(k, v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, k)

	LCONST(CELL);
	LCONST(XCELLS);
	LCONST(YCELLS);
	LCONST(NCELL);
	LCONST(XRES);
	LCONST(YRES);
	LCONST(XCNTR);
	LCONST(YCNTR);
	LCONSTAS("MAX_PARTS", NPART);
	LCONST(NT);
	LCONST(ST);
	LCONSTF(ITH);
	LCONSTF(ITL);
	LCONSTF(IPH);
	LCONSTF(IPL);
	LCONST(PT_NUM);
	LCONSTF(R_TEMP);
	LCONSTF(MAX_TEMP);
	LCONSTF(MIN_TEMP);
	LCONSTF(MAX_PRESSURE);
	LCONSTF(MIN_PRESSURE);
	LCONST(ISTP);
	LCONSTF(CFDS);
	LCONSTF(MAX_VELOCITY);

	LCONST(DECO_DRAW);
	LCONST(DECO_CLEAR);
	LCONST(DECO_ADD);
	LCONST(DECO_SUBTRACT);
	LCONST(DECO_MULTIPLY);
	LCONST(DECO_DIVIDE);
	LCONST(DECO_SMUDGE);

	LCONST(FLAG_STAGNANT);
	LCONST(FLAG_SKIPMOVE);
	LCONST(FLAG_MOVABLE);
	LCONST(FLAG_PHOTDECO);

	LCONST(PMAPBITS);
	LCONST(PMAPMASK);

	LCONST(BRUSH_CIRCLE);
	LCONST(BRUSH_SQUARE);
	LCONST(BRUSH_TRIANGLE);
	LCONST(NUM_DEFAULTBRUSHES);
	LCONSTAS("NUM_BRUSHES", lsi->gameModel->BrushListSize());

	LCONST(EDGE_VOID);
	LCONST(EDGE_SOLID);
	LCONST(EDGE_LOOP);
	LCONST(NUM_EDGEMODES);

	LCONST(AIR_ON);
	LCONST(AIR_PRESSUREOFF);
	LCONST(AIR_VELOCITYOFF);
	LCONST(AIR_OFF);
	LCONST(AIR_NOUPDATE);
	LCONST(NUM_AIRMODES);

	LCONST(GRAV_VERTICAL);
	LCONST(GRAV_OFF);
	LCONST(GRAV_RADIAL);
	LCONST(GRAV_CUSTOM);
	LCONST(NUM_GRAVMODES);

	LCONST(DECOSPACE_SRGB);
	LCONST(DECOSPACE_LINEAR);
	LCONST(DECOSPACE_GAMMA22);
	LCONST(DECOSPACE_GAMMA18);
	LCONST(NUM_DECOSPACES);

	LCONSTAS("CANMOVE_BOUNCE", 0);
	LCONSTAS("CANMOVE_SWAP", 1);
	LCONSTAS("CANMOVE_ENTER", 2);
	LCONSTAS("CANMOVE_BUILTIN", 3);
	LCONSTAS("NUM_CANMOVEMODES", 4);

	{
		lua_newtable(L);
		for (int i = 0; i < UI_WALLCOUNT; i++)
		{
			tpt_lua_pushByteString(L, sd.wtypes[i].identifier);
			lua_pushinteger(L, i);
			lua_settable(L, -3);
			lua_pushinteger(L, i);
			tpt_lua_pushByteString(L, sd.wtypes[i].identifier);
			lua_settable(L, -3);
		}
		lua_setfield(L, -2, "walls");
		LCONSTAS("NUM_WALLS", UI_WALLCOUNT);
	}

#undef LCONSTAS
#undef LCONSTF
#undef LCONST

	{
		int particlePropertiesCount = 0;
		for (auto &prop : Particle::GetProperties())
		{
			tpt_lua_pushByteString(L, "FIELD_" + prop.Name.ToUpper());
			lua_pushinteger(L, particlePropertiesCount++);
			lua_settable(L, -3);
		}
		for (auto &alias : Particle::GetPropertyAliases())
		{
			tpt_lua_pushByteString(L, "FIELD_" + alias.from.ToUpper());
			tpt_lua_pushByteString(L, "FIELD_" + alias.to.ToUpper());
			lua_gettable(L, -3);
			lua_settable(L, -3);
		}
	}
	{
		lua_newtable(L);
		for (int i = 1; i <= MAXSIGNS; i++)
		{
			lua_newtable(L);
			lua_pushinteger(L, i); //set "id" to table index
			lua_setfield(L, -2, "id");
			lua_newtable(L);
			lua_pushcfunction(L, signsIndex);
			lua_setfield(L, -2, "__index");
			lua_pushcfunction(L, signsNewIndex);
			lua_setfield(L, -2, "__newindex");
			lua_setmetatable(L, -2);
			lua_pushinteger(L, i); //table index
			lua_insert(L, -2); //swap k and v
			lua_settable(L, -3); //set metatable to signs[i]
		}
		lua_pushcfunction(L, Sign_new);
		lua_setfield(L, -2, "new");
		lua_pushcfunction(L, Sign_delete);
		lua_setfield(L, -2, "delete");
#define LCONSTAS(k, v) lua_pushinteger(L, int(v)); lua_setfield(L, -2, k)
		LCONSTAS("JUSTMODE_LEFT"  , sign::Left),
		LCONSTAS("JUSTMODE_MIDDLE", sign::Middle),
		LCONSTAS("JUSTMODE_RIGHT" , sign::Right),
		LCONSTAS("JUSTMODE_NONE"  , sign::None),
		LCONSTAS("NUM_JUSTMODES"  , sign::Max),
		LCONSTAS("MAX_SIGNS"      , MAXSIGNS),
#undef LCONSTAS
		lua_setfield(L, -2, "signs");
	}
	lua_pushvalue(L, -1);
	lua_setglobal(L, "simulation");
	lua_setglobal(L, "sim");
}


=== src\lua\LuaSlider.cpp ===

#include "LuaSlider.h"
#include "LuaScriptInterface.h"
#include "gui/interface/Slider.h"

const char LuaSlider::className[] = "slider";

#define method(class, name) {#name, &class::name}
Luna<LuaSlider>::RegType LuaSlider::methods[] = {
	method(LuaSlider, onValueChanged),
	method(LuaSlider, position),
	method(LuaSlider, size),
	method(LuaSlider, visible),
	method(LuaSlider, value),
	method(LuaSlider, steps),
	{nullptr, nullptr}
};

LuaSlider::LuaSlider(lua_State *L) :
	LuaComponent(L)
{
	int posX = luaL_optinteger(L, 1, 0);
	int posY = luaL_optinteger(L, 2, 0);
	int sizeX = luaL_optinteger(L, 3, 10);
	int sizeY = luaL_optinteger(L, 4, 10);
	int steps = luaL_optinteger(L, 5, 10);

	slider = new ui::Slider(ui::Point(posX, posY), ui::Point(sizeX, sizeY), steps);
	component = slider;
	slider->SetActionCallback({ [this] { triggerOnValueChanged(); } });
}

int LuaSlider::steps(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		slider->SetSteps(lua_tointeger(L, 1));
		return 0;
	}
	else
	{
		lua_pushinteger(L, slider->GetSteps());
		return 1;
	}
}

int LuaSlider::onValueChanged(lua_State *L)
{
	return onValueChangedFunction.CheckAndAssignArg1(L);
}

int LuaSlider::value(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		slider->SetValue(lua_tointeger(L, 1));
		return 0;
	}
	else
	{
		lua_pushinteger(L, slider->GetValue());
		return 1;
	}
}

void LuaSlider::triggerOnValueChanged()
{
	if(onValueChangedFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onValueChangedFunction);
		lua_rawgeti(L, LUA_REGISTRYINDEX, owner_ref);
		lua_pushinteger(L, slider->GetValue());
		if (tpt_lua_pcall(L, 2, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

LuaSlider::~LuaSlider()
{
}


=== src\lua\LuaSlider.h ===

#pragma once

#include "LuaLuna.h"
#include "LuaComponent.h"

namespace ui
{
	class Slider;
}

class LuaScriptInterface;

class LuaSlider: public LuaComponent
{
	ui::Slider * slider;
	LuaComponentCallback onValueChangedFunction;
	void triggerOnValueChanged();
	int onValueChanged(lua_State *L);
	int steps(lua_State *L);
	int value(lua_State *L);
public:
	static const char className[];
	static Luna<LuaSlider>::RegType methods[];

	LuaSlider(lua_State *L);
	~LuaSlider();
};


=== src\lua\LuaSmartRef.cpp ===

#include "LuaSmartRef.h"
#include "LuaScriptInterface.h"

void LuaSmartRef::Clear()
{
	auto *lsi = GetLSI();
	if (lsi)
	{
		luaL_unref(lsi->L, LUA_REGISTRYINDEX, ref);
		ref = LUA_REFNIL;
	}
}

LuaSmartRef::~LuaSmartRef()
{
	Clear();
}

void LuaSmartRef::Assign(lua_State *L, int index)
{
	if (index < 0)
	{
		index = lua_gettop(L) + index + 1;
	}
	Clear();
	lua_pushvalue(L, index);
	ref = luaL_ref(L, LUA_REGISTRYINDEX);
}

int LuaSmartRef::Push(lua_State *L)
{
	lua_rawgeti(L, LUA_REGISTRYINDEX, ref);
	return lua_type(L, -1);
}


=== src\lua\LuaSmartRef.h ===

#pragma once
#include "LuaCompat.h"
#include <utility>

class LuaSmartRef
{
	int ref = LUA_REFNIL;

public:
	LuaSmartRef() = default;
	LuaSmartRef(const LuaSmartRef &other) = delete;
	~LuaSmartRef();

	LuaSmartRef(LuaSmartRef &&other) noexcept : LuaSmartRef()
	{
		swap(*this, other);
	}

	LuaSmartRef &operator =(LuaSmartRef other)
	{
		swap(*this, other);
		return *this;
	}

	void Assign(lua_State *L, int index); // Copies the value before getting reference, stack unchanged.
	void Clear();
	int Push(lua_State *L); // Always pushes exactly one value, possibly nil.

	inline operator int() const
	{
		return ref;
	}

	inline operator bool() const
	{
		return ref != LUA_REFNIL;
	}

	friend void swap(LuaSmartRef &one, LuaSmartRef &other)
	{
		using std::swap;
		swap(one.ref, other.ref);
	}
};


=== src\lua\LuaSocket.cpp ===

#include "LuaScriptInterface.h"
#include "Misc.h"

int LuaSocket::GetTime(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	lua_pushnumber(L, LuaSocket::Now());
	return 1;
}

int LuaSocket::Sleep(lua_State *L)
{
	GetLSI()->AssertInterfaceEvent();
	LuaSocket::Timeout(luaL_checknumber(L, 1));
	return 0;
}

void LuaSocket::Open(lua_State *L)
{
	static const luaL_Reg reg[] = {
		{ "sleep", LuaSocket::Sleep },
		{ "getTime", LuaSocket::GetTime },
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
	lua_setglobal(L, "socket");
	OpenTCP(L);
}


=== src\lua\LuaSocketDefault.cpp ===

#include "LuaScriptInterface.h"
#include "Misc.h"
#include <stdint.h>
#include <algorithm>
#include <sys/time.h>
#include <time.h>

namespace LuaSocket
{
	double Now()
	{
		struct timeval rt;
		gettimeofday(&rt, (struct timezone *)nullptr);
		return rt.tv_sec + rt.tv_usec / 1e6;
	}

	void Timeout(double timeout)
	{
		struct timespec req, rem;
		if (timeout <     0.0) timeout =     0.0;
		if (timeout > INT_MAX) timeout = INT_MAX;
		req.tv_sec = int(timeout);
		req.tv_nsec = int((timeout - req.tv_sec) * 1000000000);
		if (req.tv_nsec > 999999999) req.tv_nsec = 999999999;
		while (nanosleep(&req, &rem))
		{
			req.tv_sec = rem.tv_sec;
			req.tv_nsec = rem.tv_nsec;
		}
	}
}


=== src\lua\LuaSocketTCPHttp.cpp ===

#include "LuaScriptInterface.h"
#include "client/http/requestmanager/CurlError.h"
#include "client/http/requestmanager/RequestManager.h"
#include "Misc.h"
#include "common/String.h"
#include <curl/curl.h>
#include <vector>
#include <stdexcept>
#include <cstring>
#include <stdint.h>
#include <algorithm>

namespace LuaSocket
{
	enum Status
	{
		StatusReady,
		StatusConnecting,
		StatusConnected,
		StatusDead,
	};

	struct TCPSocket
	{
		CURL *easy;
		CURLM *multi;
		char errorBuf[CURL_ERROR_SIZE];
		Status status;
		bool timeoutIndefinite;
		bool blocking;
		double timeout;
		std::vector<char> recvBuf;
		size_t stashedLen;
		bool readClosed;
		bool writeClosed;
	};

	static void Reset(TCPSocket *tcps)
	{
		using http::HandleCURLMcode;
		if (tcps->multi)
		{
			HandleCURLMcode(curl_multi_remove_handle(tcps->multi, tcps->easy));
			curl_multi_cleanup(tcps->multi);
			tcps->multi = nullptr;
		}
		if (tcps->easy)
		{
			curl_easy_cleanup(tcps->easy);
			tcps->easy = nullptr;
		}
		tcps->status = StatusDead;
	}

	static bool ConnectPerform(TCPSocket *tcps, CURLcode *res)
	{
		using http::HandleCURLMcode;
		while (true)
		{
			int dontcare;
			auto mres = curl_multi_perform(tcps->multi, &dontcare);
			http::HandleCURLMcode(mres);
			struct CURLMsg *msg;
			while ((msg = curl_multi_info_read(tcps->multi, &dontcare)))
			{
				if (msg->msg == CURLMSG_DONE)
				{
					*res = msg->data.result;
					return true;
				}
			};
			if (mres != CURLM_CALL_MULTI_PERFORM)
			{
				break;
			}
		}
		return false;
	}

	static int New(lua_State *L)
	{
		// there's no actual architectural reason to require socket handles to be managed from interface events
		// because the HTTP thread doesn't care what thread they are managed from, but requiring this
		// makes access patterns cleaner, so we do it anyway
		GetLSI()->AssertInterfaceEvent();
		using http::HandleCURLMcode;
		if (http::RequestManager::Ref().DisableNetwork())
		{
			return luaL_error(L, "network disabled");
		}
		auto *tcps = (TCPSocket *)lua_newuserdata(L, sizeof(TCPSocket));
		new(tcps) TCPSocket;
		tcps->errorBuf[0] = 0;
		tcps->easy = curl_easy_init();
		tcps->status = StatusReady;
		tcps->timeoutIndefinite = true;
		tcps->blocking = true;
		tcps->stashedLen = 0;
		tcps->readClosed = false;
		tcps->writeClosed = false;
		if (!tcps->easy)
		{
			Reset(tcps);
			return luaL_error(L, "curl_easy_init failed");
		}
		tcps->multi = curl_multi_init();
		if (!tcps->multi)
		{
			Reset(tcps);
			return luaL_error(L, "curl_multi_init failed");
		}
		HandleCURLMcode(curl_multi_add_handle(tcps->multi, tcps->easy));
		luaL_newmetatable(L, "TCPSocket");
		lua_setmetatable(L, -2);
		return 1;
	}

	static int GC(lua_State *L)
	{
		// not subject to the check in TCPSocket::New; that would be disastrous, and thankfully,
		// as explained there, we're not missing out on any functionality either
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		Reset(tcps);
		tcps->~TCPSocket();
		return 0;
	}

	static int Close(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		Reset(tcps);
		return 0;
	}

	static int Send(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		if (tcps->status != StatusConnected)
		{
			return luaL_error(L, "attempt to send on socket while not connected");
		}
		size_t dlenu;
		auto *data = luaL_checklstring(L, 2, &dlenu);
		auto dlen = int(dlenu);
		auto first = luaL_optinteger(L, 3, 1);
		auto last = luaL_optinteger(L, 4, -1);
		if (first < 0) first += dlen + 1;
		if (last  < 0) last  += dlen + 1;
		if (first <    1) first =    1;
		if (first > dlen) first = dlen;
		if (last  <    1) last  =    1;
		if (last  > dlen) last  = dlen;
		auto begin = first - 1;
		auto end = last;
		data += begin;
		auto len = size_t((end > begin) ? (end - begin) : 0);
		auto startedAt = Now();
		size_t writtenTotal = 0;
		while (true)
		{
			size_t writtenNow = 0;
			CURLcode res = CURLE_OK;
			if (!tcps->writeClosed)
			{
				res = curl_easy_send(tcps->easy, data + writtenTotal, len - writtenTotal, &writtenNow);
			}
			writtenTotal += writtenNow;
			if (writtenTotal >= len)
			{
				break;
			}
			switch (res)
			{
			case CURLE_OK:
			case CURLE_AGAIN:
				break;

			default:
				tcps->writeClosed = true;
				break;
			}
			if (tcps->writeClosed)
			{
				Reset(tcps);
				lua_pushnil(L);
				lua_pushliteral(L, "closed");
				lua_pushinteger(L, writtenTotal + begin);
				return 3;
			}
			if (res == CURLE_AGAIN)
			{
				if (tcps->blocking && (tcps->timeoutIndefinite || startedAt + tcps->timeout > Now()))
				{
					// * Using a platform-dependent primitive to "wait" on the socket is
					//   not worth the trouble: sockets shouldn't be used with timeouts
					//   anyway because they freeze the game.
					Timeout(0.01);
					continue;
				}
				lua_pushnil(L);
				lua_pushliteral(L, "timeout");
				lua_pushinteger(L, writtenTotal + begin);
				return 3;
			}
		}
		lua_pushinteger(L, writtenTotal + begin);
		return 1;
	}

	static int ReceiveNoPrefix(lua_State *L)
	{
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		if (tcps->status != StatusConnected)
		{
			return luaL_error(L, "attempt to receive on socket while not connected");
		}
		enum
		{
			readN,
			readAll,
			readLine,
		} pattern = readN;
		size_t len = 4096;
		if (tpt_lua_equalsLiteral(L, 2, "*a"))
		{
			pattern = readAll;
		}
		else if (tpt_lua_equalsLiteral(L, 2, "*L"))
		{
			pattern = readLine;
		}
		else
		{
			len = size_t(luaL_checkinteger(L, 2));
		}
		if (pattern == readAll || pattern == readLine)
		{
			len += tcps->stashedLen;
		}
		if (tcps->recvBuf.size() < len)
		{
			tcps->recvBuf.resize(len);
		}
		auto startedAt = Now();
		size_t readTotal = 0;
		size_t returning = 0;
		int retn = 1;
		while (true)
		{
			size_t readNow = 0;
			CURLcode res = CURLE_OK;
			if (tcps->stashedLen)
			{
				readNow = tcps->stashedLen;
				tcps->stashedLen = 0;
			}
			else
			{
				res = curl_easy_recv(tcps->easy, tcps->recvBuf.data() + readTotal, len - readTotal, &readNow);
			}
			readTotal += readNow;
			returning = readTotal;
			if (pattern == readN && readTotal >= len)
			{
				returning = len;
				break;
			}
			if (pattern == readLine)
			{
				bool foundLF = false;
				for (size_t i = 0; i < readTotal; ++i)
				{
					if (tcps->recvBuf[i] == '\n')
					{
						returning = i + 1;
						foundLF = true;
						break;
					}
				}
				if (foundLF)
				{
					break;
				}
			}
			switch (res)
			{
			case CURLE_OK:
				if (!readNow)
				{
					tcps->readClosed = true;
				}
				break;

			case CURLE_AGAIN:
				break;

			default:
				tcps->readClosed = true;
				break;
			}
			if (tcps->readClosed)
			{
				Reset(tcps);
				if (pattern == readAll)
				{
					// * Closed "*a" patterns don't return an error.
					break;
				}
				lua_pushnil(L);
				lua_pushliteral(L, "closed");
				if (pattern == readLine)
				{
					// * Closed "*L" patterns don't return partial lines.
					returning = 0;
				}
				retn = 3;
				break;
			}
			if (readTotal == len && (pattern == readAll || pattern == readLine))
			{
				len += len;
				if (tcps->recvBuf.size() < len)
				{
					tcps->recvBuf.resize(len);
				}
			}
			if (res == CURLE_AGAIN)
			{
				if (tcps->blocking && (tcps->timeoutIndefinite || startedAt + tcps->timeout > Now()))
				{
					// * Using a platform-dependent primitive to "wait" on the socket is
					//   not worth the trouble: sockets shouldn't be used with timeouts
					//   anyway because they freeze the game.
					Timeout(0.01);
					continue;
				}
				lua_pushnil(L);
				lua_pushliteral(L, "timeout");
				if (pattern == readLine)
				{
					// * Timed-out "*L" patterns don't return partial lines.
					returning = 0;
				}
				retn = 3;
				break;
			}
		}
		tcps->stashedLen = readTotal - returning;
		if (pattern == readLine)
		{
			auto curOut = 0U;
			for (auto curIn = 0U; curIn < returning; ++curIn)
			{
				if (tcps->recvBuf[curIn] != '\r' && tcps->recvBuf[curIn] != '\n')
				{
					tcps->recvBuf[curOut] = tcps->recvBuf[curIn];
					curOut += 1;
				}
			}
			returning = curOut;
		}
		lua_pushlstring(L, tcps->recvBuf.data(), returning);
		// * This copy makes ReceiveNoPrefix quadratic if there's a lot of stuff in
		//   the stash (as a result of a *very* long line being returned by an "*L"
		//   pattern and then whatever was left being stashed) and it's all *very*
		//   short lines (compared to the previous *very* long one, from the point
		//   of view of an "*L" pattern). Handling this edge case in a special,
		//   sub-quadratic way isn't worth the effort.
		std::copy(
			tcps->recvBuf.data() + readTotal - tcps->stashedLen,
			tcps->recvBuf.data() + readTotal,
			tcps->recvBuf.data()
		);
		return retn;
	}

	static int Receive(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		bool prefix = false;
		if (lua_gettop(L) >= 3)
		{
			prefix = true;
			lua_tostring(L, 3);
		}
		int ret = ReceiveNoPrefix(L);
		if (prefix)
		{
			lua_pushvalue(L, 3);
			lua_insert(L, -2);
			lua_concat(L, 2);
		}
		return ret;
	}

	static int Connect(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		using http::HandleCURLcode;
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		if (tcps->status == StatusDead)
		{
			return luaL_error(L, "attempt to connect dead socket");
		}
		if (tcps->status == StatusConnected)
		{
			return luaL_error(L, "attempt to connect connected socket");
		}
		auto startedAt = Now();
		while (true)
		{
			if (tcps->status != StatusConnecting)
			{
				try
				{
					tcps->status = StatusConnecting;
					// * Using CURLPROTO_HTTPS and CURLPROTO_HTTP with CURL_HTTP_VERSION_1_0
					//   because these really don't send anything while connecting if
					//   CURLOPT_CONNECT_ONLY is 1 and there are no proxies involved. The
					//   only ugly bit is that we have to prepend http:// or https:// to
					//   the hostnames.
					HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_ERRORBUFFER, tcps->errorBuf));
					HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_CONNECT_ONLY, 1L));
					ByteString address = tpt_lua_checkByteString(L, 2);
					HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_PORT, long(luaL_checkinteger(L, 3))));
					HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_NOSIGNAL, 1L));
					HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0));
					if (lua_toboolean(L, 4))
					{
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 85, 0)
						HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_PROTOCOLS_STR, "https"));
						HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_REDIR_PROTOCOLS_STR, "https"));
#else
						HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_PROTOCOLS, CURLPROTO_HTTPS));
						HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTPS));
#endif
						http::SetupCurlEasyCiphers(tcps->easy);
						address = "https://" + address;
					}
					else
					{
#if defined(CURL_AT_LEAST_VERSION) && CURL_AT_LEAST_VERSION(7, 85, 0)
						HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_PROTOCOLS_STR, "http"));
						HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_REDIR_PROTOCOLS_STR, "http"));
#else
						HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_PROTOCOLS, CURLPROTO_HTTP));
						HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTP));
#endif
						address = "http://" + address;
					}
					HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_URL, address.c_str()));
				}
				catch (const http::CurlError &ex)
				{
					return luaL_error(L, ex.what());
				}
			}

			CURLcode res;
			if (!ConnectPerform(tcps, &res))
			{
				if (tcps->blocking && (tcps->timeoutIndefinite || startedAt + tcps->timeout > Now()))
				{
					// * Using a platform-dependent primitive to "wait" on the socket is
					//   not worth the trouble: sockets shouldn't be used with timeouts
					//   anyway because they freeze the game.
					Timeout(0.01);
					continue;
				}
				lua_pushnil(L);
				lua_pushliteral(L, "timeout");
				return 2;
			}
			if (res != CURLE_OK)
			{
				Reset(tcps);
				lua_pushnil(L);
				lua_pushstring(L, tcps->errorBuf);
				return 2;
			}
			break;
		}
		tcps->status = StatusConnected;
		lua_pushinteger(L, 1);
		return 1;
	}

	static int LastError(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		lua_pushstring(L, tcps->errorBuf);
		return 1;
	}

	static int GetStatus(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		switch (tcps->status)
		{
		case StatusReady:      lua_pushliteral(L,      "ready"); break;
		case StatusConnecting: lua_pushliteral(L, "connecting"); break;
		case StatusConnected:  lua_pushliteral(L,  "connected"); break;
		case StatusDead:       lua_pushliteral(L,       "dead"); break;
		}
		return 1;
	}

	static int GetPeerName(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		using http::HandleCURLcode;
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		if (tcps->status != StatusConnected)
		{
			return luaL_error(L, "attempt to get remote socket info while not connected");
		}
		char *address;
		HandleCURLcode(curl_easy_getinfo(tcps->easy, CURLINFO_PRIMARY_IP, &address));
		lua_pushstring(L, address);
		long port;
		HandleCURLcode(curl_easy_getinfo(tcps->easy, CURLINFO_PRIMARY_PORT, &port));
		lua_pushinteger(L, port);
		return 2;
	}

	static int SetTimeout(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		tcps->blocking = true;
		if (lua_isnoneornil(L, 2))
		{
			tcps->timeoutIndefinite = true;
		}
		else
		{
			tcps->timeoutIndefinite = false;
			tcps->timeout = luaL_checknumber(L, 2);
			if (int(tcps->timeout) == 0)
			{
				tcps->blocking = false;
			}
		}
		return 0;
	}

	static int GetSockName(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		using http::HandleCURLcode;
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		if (tcps->status != StatusConnected)
		{
			return luaL_error(L, "attempt to get local socket info while not connected");
		}
		char *address;
		HandleCURLcode(curl_easy_getinfo(tcps->easy, CURLINFO_LOCAL_IP, &address));
		lua_pushstring(L, address);
		long port;
		HandleCURLcode(curl_easy_getinfo(tcps->easy, CURLINFO_LOCAL_PORT, &port));
		lua_pushinteger(L, port);
		return 2;
	}

	static int SetOption(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		using http::HandleCURLcode;
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		auto option = tpt_lua_checkByteString(L, 2);
		try
		{
			if (byteStringEqualsLiteral(option, "keepalive"))
			{
				HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_TCP_KEEPALIVE, long(lua_toboolean(L, 3))));
				return 0;
			}
			else if (byteStringEqualsLiteral(option, "tcp-nodelay"))
			{
				HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_TCP_NODELAY, long(lua_toboolean(L, 3))));
				return 0;
			}
			else if (byteStringEqualsLiteral(option, "verify-peer"))
			{
				HandleCURLcode(curl_easy_setopt(tcps->easy, CURLOPT_SSL_VERIFYPEER, long(lua_toboolean(L, 3))));
				return 0;
			}
		}
		catch (const http::CurlError &ex)
		{
			return luaL_error(L, ex.what());
		}
		return luaL_error(L, "unknown option");
	}

	static int Shutdown(lua_State *L)
	{
		GetLSI()->AssertInterfaceEvent(); // see the check in TCPSocket::New
		auto *tcps = (TCPSocket *)luaL_checkudata(L, 1, "TCPSocket");
		auto direction = tpt_lua_optByteString(L, 2, "both");
		if (byteStringEqualsLiteral(direction, "receive"))
		{
			tcps->readClosed = true;
			return 0;
		}
		else if (byteStringEqualsLiteral(direction, "send"))
		{
			tcps->writeClosed = true;
			return 0;
		}
		else if (byteStringEqualsLiteral(direction, "both"))
		{
			tcps->readClosed = true;
			tcps->writeClosed = true;
			return 0;
		}
		return luaL_error(L, "unknown direction");
	}

	void OpenTCP(lua_State *L)
	{
		luaL_newmetatable(L, "TCPSocket");
		lua_pushcfunction(L, LuaSocket::GC);
		lua_setfield(L, -2, "__gc");
		lua_newtable(L);
		struct luaL_Reg tcpSocketIndexMethods[] = {
			{     "connect", LuaSocket::Connect     },
			{       "close", LuaSocket::Close       },
			{        "send", LuaSocket::Send        },
			{     "receive", LuaSocket::Receive     },
			{   "lasterror", LuaSocket::LastError   },
			{      "status", LuaSocket::GetStatus   },
			{ "getpeername", LuaSocket::GetPeerName },
			{ "getsockname", LuaSocket::GetSockName },
			{  "settimeout", LuaSocket::SetTimeout  },
			{   "setoption", LuaSocket::SetOption   },
			{    "shutdown", LuaSocket::Shutdown    },
			{       nullptr, nullptr                },
		};
		luaL_register(L, nullptr, tcpSocketIndexMethods);
		lua_setfield(L, -2, "__index");
		lua_pop(L, 1);
		lua_getglobal(L, "socket");
		lua_pushcfunction(L, LuaSocket::New);
		lua_setfield(L, -2, "tcp");
		lua_pop(L, 1);
	}
}


=== src\lua\LuaSocketTCPNoHttp.cpp ===

#include "LuaScriptInterface.h"

namespace LuaSocket
{
	void OpenTCP(lua_State *L)
	{
	}
}


=== src\lua\LuaSocketWindows.cpp ===

#include "LuaScriptInterface.h"
#include "Misc.h"
#include <stdint.h>
#include <algorithm>
#include <windows.h>
#include <float.h>

namespace LuaSocket
{
	double Now()
	{
		FILETIME rt;
		GetSystemTimeAsFileTime(&rt);
		return (rt.dwLowDateTime + (uint64_t(rt.dwHighDateTime) << 32) - uint64_t(116444736000000000ULL)) / 1e7;
	}

	void Timeout(double timeout)
	{
		if (timeout <              0.0) timeout  =     0.0;
		if (timeout < DBL_MAX / 1000.0) timeout *=  1000.0;
		if (timeout >          INT_MAX) timeout  = INT_MAX;
		::Sleep(int(timeout));
	}
}


=== src\lua\LuaTextbox.cpp ===

#include "LuaTextbox.h"
#include "LuaScriptInterface.h"
#include "gui/interface/Textbox.h"

const char LuaTextbox::className[] = "textbox";

#define method(class, name) {#name, &class::name}
Luna<LuaTextbox>::RegType LuaTextbox::methods[] = {
	method(LuaTextbox, text),
	method(LuaTextbox, readonly),
	method(LuaTextbox, onTextChanged),
	method(LuaTextbox, position),
	method(LuaTextbox, size),
	method(LuaTextbox, visible),
	{nullptr, nullptr}
};

LuaTextbox::LuaTextbox(lua_State *L) :
	LuaComponent(L)
{
	this->L = L;
	int posX = luaL_optinteger(L, 1, 0);
	int posY = luaL_optinteger(L, 2, 0);
	int sizeX = luaL_optinteger(L, 3, 10);
	int sizeY = luaL_optinteger(L, 4, 10);
	String text = tpt_lua_optString(L, 5, "");
	String placeholder = tpt_lua_optString(L, 6, "");

	textbox = new ui::Textbox(ui::Point(posX, posY), ui::Point(sizeX, sizeY), text, placeholder);
	textbox->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	textbox->SetActionCallback({ [this] { triggerOnTextChanged(); } });
	component = textbox;
}

int LuaTextbox::readonly(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		luaL_checktype(L, 1, LUA_TBOOLEAN);
		textbox->ReadOnly = lua_toboolean(L, 1);
		return 0;
	}
	else
	{
		lua_pushboolean(L, textbox->ReadOnly);
		return 1;
	}
}

int LuaTextbox::onTextChanged(lua_State *L)
{
	return onTextChangedFunction.CheckAndAssignArg1(L);
}

void LuaTextbox::triggerOnTextChanged()
{
	if(onTextChangedFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onTextChangedFunction);
		lua_rawgeti(L, LUA_REGISTRYINDEX, owner_ref);
		if (tpt_lua_pcall(L, 1, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_optString(L, -1));
		}
	}
}

int LuaTextbox::text(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		textbox->SetText(tpt_lua_checkString(L, 1));
		return 0;
	}
	else
	{
		tpt_lua_pushString(L, textbox->GetText());
		return 1;
	}
}

LuaTextbox::~LuaTextbox()
{
}


=== src\lua\LuaTextbox.h ===

#pragma once

#include "LuaLuna.h"
#include "LuaComponent.h"

namespace ui
{
	class Textbox;
}

class LuaScriptInterface;

class LuaTextbox: public LuaComponent
{
	LuaComponentCallback onTextChangedFunction;
	ui::Textbox * textbox;
	int text(lua_State *L);
	int readonly(lua_State *L);
	int onTextChanged(lua_State *L);
	void triggerOnTextChanged();
public:
	static const char className[];
	static Luna<LuaTextbox>::RegType methods[];

	LuaTextbox(lua_State *L);
	~LuaTextbox();
};


=== src\lua\LuaTools.cpp ===

#include "LuaScriptInterface.h"
#include "gui/game/GameModel.h"
#include "simulation/SimTool.h"
#include "simulation/Simulation.h"
#include <type_traits>

static int allocate(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMutableToolsEvent();
	luaL_checktype(L, 1, LUA_TSTRING);
	luaL_checktype(L, 2, LUA_TSTRING);
	auto group = tpt_lua_toByteString(L, 1).ToUpper();
	auto name = tpt_lua_toByteString(L, 2).ToUpper();
	if (name.Contains("_"))
	{
		return luaL_error(L, "The tool name may not contain '_'.");
	}
	if (group.Contains("_"))
	{
		return luaL_error(L, "The group name may not contain '_'.");
	}
	if (group == "DEFAULT")
	{
		return luaL_error(L, "You cannot create tools in the 'DEFAULT' group.");
	}
	auto identifier = group + "_TOOL_" + name;
	if (lsi->gameModel->GetToolFromIdentifier(identifier))
	{
		return luaL_error(L, "Tool identifier already in use.");
	}
	{
		SimTool tool;
		tool.Identifier = identifier;
		lsi->gameModel->AllocTool(std::make_unique<SimTool>(tool));
	}
	lsi->gameModel->BuildMenus();
	auto index = *lsi->gameModel->GetToolIndex(lsi->gameModel->GetToolFromIdentifier(identifier));
	lsi->customTools.resize(std::max(int(lsi->customTools.size()), index + 1));
	lsi->customTools[index].valid = true;
	lua_pushinteger(L, index);
	return 1;
}

static bool IsCustom(int index)
{
	auto *lsi = GetLSI();
	return index >= 0 && index < int(lsi->customTools.size()) && lsi->customTools[index].valid;
}

static int ffree(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMutableToolsEvent();
	int index = luaL_checkinteger(L, 1);
	auto *tool = lsi->gameModel->GetToolByIndex(index);
	if (!tool)
	{
		return luaL_error(L, "Invalid tool");
	}
	if (!IsCustom(index))
	{
		return luaL_error(L, "Can only free custom tools");
	}
	lsi->customTools[index] = {};
	lsi->gameModel->FreeTool(tool);
	lsi->gameModel->BuildMenus();
	return 0;
}

static int luaPerformWrapper(SimTool *tool, Simulation *sim, Particle *cpart, int x, int y, int brushX, int brushY, float strength)
{
	int ok = 0;
	auto *lsi = GetLSI();
	auto L = lsi->L;
	auto index = *lsi->gameModel->GetToolIndex(tool);
	auto &customTools = lsi->customTools;
	if (customTools[index].perform)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, customTools[index].perform);
		if (cpart)
		{
			lua_pushinteger(L, cpart - &lsi->sim->parts[0]);
		}
		else
		{
			lua_pushnil(L);
		}
		lua_pushinteger(L, x);
		lua_pushinteger(L, y);
		lua_pushnumber(L, tool->Strength);
		lua_pushboolean(L, tool->shiftBehaviour);
		lua_pushboolean(L, tool->ctrlBehaviour);
		lua_pushboolean(L, tool->altBehaviour);
		lua_pushinteger(L, brushX);
		lua_pushinteger(L, brushY);
		if (tpt_lua_pcall(L, 9, 1, 0, eventTraitNone))
		{
			lsi->Log(CommandInterface::LogError, "In perform func: " + LuaGetError());
			lua_pop(L, 1);
		}
		else
		{
			if (lua_isboolean(L, -1))
			{
				ok = lua_toboolean(L, -1);
			}
			lua_pop(L, 1);
		}
	}
	return ok;
}

static void luaClickWrapper(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position)
{
	auto *lsi = GetLSI();
	auto L = lsi->L;
	auto index = *lsi->gameModel->GetToolIndex(tool);
	auto &customTools = lsi->customTools;
	if (customTools[index].click)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, customTools[index].click);
		lua_pushinteger(L, lsi->gameModel->GetBrushIndex(brush));
		lua_pushinteger(L, position.X);
		lua_pushinteger(L, position.Y);
		lua_pushnumber(L, tool->Strength);
		lua_pushboolean(L, tool->shiftBehaviour);
		lua_pushboolean(L, tool->ctrlBehaviour);
		lua_pushboolean(L, tool->altBehaviour);
		if (tpt_lua_pcall(L, 7, 0, 0, eventTraitInterface | eventTraitConstTools))
		{
			lsi->Log(CommandInterface::LogError, "In click func: " + LuaGetError());
			lua_pop(L, 1);
		}
	}
}

static void luaDragWrapper(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2)
{
	auto *lsi = GetLSI();
	auto L = lsi->L;
	auto index = *lsi->gameModel->GetToolIndex(tool);
	auto &customTools = lsi->customTools;
	if (customTools[index].drag)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, customTools[index].drag);
		lua_pushinteger(L, lsi->gameModel->GetBrushIndex(brush));
		lua_pushinteger(L, position1.X);
		lua_pushinteger(L, position1.Y);
		lua_pushinteger(L, position2.X);
		lua_pushinteger(L, position2.Y);
		lua_pushnumber(L, tool->Strength);
		lua_pushboolean(L, tool->shiftBehaviour);
		lua_pushboolean(L, tool->ctrlBehaviour);
		lua_pushboolean(L, tool->altBehaviour);
		if (tpt_lua_pcall(L, 9, 0, 0, eventTraitNone))
		{
			lsi->Log(CommandInterface::LogError, "In drag func: " + LuaGetError());
			lua_pop(L, 1);
		}
	}
}

static void luaDrawWrapper(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position)
{
	auto *lsi = GetLSI();
	auto L = lsi->L;
	auto index = *lsi->gameModel->GetToolIndex(tool);
	auto &customTools = lsi->customTools;
	if (customTools[index].draw)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, customTools[index].draw);
		lua_pushinteger(L, lsi->gameModel->GetBrushIndex(brush));
		lua_pushinteger(L, position.X);
		lua_pushinteger(L, position.Y);
		lua_pushnumber(L, tool->Strength);
		lua_pushboolean(L, tool->shiftBehaviour);
		lua_pushboolean(L, tool->ctrlBehaviour);
		lua_pushboolean(L, tool->altBehaviour);
		if (tpt_lua_pcall(L, 7, 0, 0, eventTraitNone))
		{
			lsi->Log(CommandInterface::LogError, "In draw func: " + LuaGetError());
			lua_pop(L, 1);
		}
	}
}

static void luaDrawLineWrapper(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2, bool dragging)
{
	auto *lsi = GetLSI();
	auto L = lsi->L;
	auto index = *lsi->gameModel->GetToolIndex(tool);
	auto &customTools = lsi->customTools;
	if (customTools[index].drawLine)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, customTools[index].drawLine);
		lua_pushinteger(L, lsi->gameModel->GetBrushIndex(brush));
		lua_pushinteger(L, position1.X);
		lua_pushinteger(L, position1.Y);
		lua_pushinteger(L, position2.X);
		lua_pushinteger(L, position2.Y);
		lua_pushnumber(L, tool->Strength);
		lua_pushboolean(L, tool->shiftBehaviour);
		lua_pushboolean(L, tool->ctrlBehaviour);
		lua_pushboolean(L, tool->altBehaviour);
		if (tpt_lua_pcall(L, 9, 0, 0, eventTraitNone))
		{
			lsi->Log(CommandInterface::LogError, "In drawLine func: " + LuaGetError());
			lua_pop(L, 1);
		}
	}
}

static void luaDrawRectWrapper(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2)
{
	auto *lsi = GetLSI();
	auto L = lsi->L;
	auto index = *lsi->gameModel->GetToolIndex(tool);
	auto &customTools = lsi->customTools;
	if (customTools[index].drawRect)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, customTools[index].drawRect);
		lua_pushinteger(L, lsi->gameModel->GetBrushIndex(brush));
		lua_pushinteger(L, position1.X);
		lua_pushinteger(L, position1.Y);
		lua_pushinteger(L, position2.X);
		lua_pushinteger(L, position2.Y);
		lua_pushnumber(L, tool->Strength);
		lua_pushboolean(L, tool->shiftBehaviour);
		lua_pushboolean(L, tool->ctrlBehaviour);
		lua_pushboolean(L, tool->altBehaviour);
		if (tpt_lua_pcall(L, 9, 0, 0, eventTraitNone))
		{
			lsi->Log(CommandInterface::LogError, "In drawRect func: " + LuaGetError());
			lua_pop(L, 1);
		}
	}
}

static void luaDrawFillWrapper(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position)
{
	auto *lsi = GetLSI();
	auto L = lsi->L;
	auto index = *lsi->gameModel->GetToolIndex(tool);
	auto &customTools = lsi->customTools;
	if (customTools[index].drawFill)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, customTools[index].drawFill);
		lua_pushinteger(L, lsi->gameModel->GetBrushIndex(brush));
		lua_pushinteger(L, position.X);
		lua_pushinteger(L, position.Y);
		lua_pushnumber(L, tool->Strength);
		lua_pushboolean(L, tool->shiftBehaviour);
		lua_pushboolean(L, tool->ctrlBehaviour);
		lua_pushboolean(L, tool->altBehaviour);
		if (tpt_lua_pcall(L, 7, 0, 0, eventTraitNone))
		{
			lsi->Log(CommandInterface::LogError, "In drawFill func: " + LuaGetError());
			lua_pop(L, 1);
		}
	}
}

static void luaSelectWrapper(SimTool *tool, int toolSelection)
{
	auto *lsi = GetLSI();
	auto L = lsi->L;
	auto index = *lsi->gameModel->GetToolIndex(tool);
	auto &customTools = lsi->customTools;
	if (customTools[index].select)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, customTools[index].select);
		lua_pushinteger(L, toolSelection);
		if (tpt_lua_pcall(L, 1, 0, 0, eventTraitInterface | eventTraitConstTools))
		{
			lsi->Log(CommandInterface::LogError, "In select func: " + LuaGetError());
			lua_pop(L, 1);
		}
	}
}

template <typename T>
struct DependentFalse : std::false_type
{
};

static int property(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertMutableToolsEvent();
	int index = luaL_checkinteger(L, 1);
	auto *tool = lsi->gameModel->GetToolByIndex(index);
	if (!tool)
	{
		return luaL_error(L, "Invalid tool");
	}
	if (lua_gettop(L) > 2 && !IsCustom(index))
	{
		return luaL_error(L, "Can only change properties of custom tools");
	}
	ByteString propertyName = tpt_lua_checkByteString(L, 2);
	auto handleCallback = [lsi, L, index, tool, &propertyName](
		auto customToolMember,
		auto simToolMember,
		auto wrapper,
		const char *luaPropertyName
	) {
		if (propertyName == luaPropertyName)
		{
			if (lua_gettop(L) > 2)
			{
				if (lua_type(L, 3) == LUA_TFUNCTION)
				{
					(lsi->customTools[index].*customToolMember).Assign(L, 3);
					(static_cast<SimTool *>(tool)->*simToolMember) = wrapper;
				}
				else if (lua_type(L, 3) == LUA_TBOOLEAN && !lua_toboolean(L, 3))
				{
					(lsi->customTools[index].*customToolMember).Clear();
					(static_cast<SimTool *>(tool)->*simToolMember) = SimTool().*simToolMember;
				}
				return true;
			}
			luaL_error(L, "Invalid tool property");
		}
		return false;
	};
	if (handleCallback(&CustomTool::perform , &SimTool::Perform        , luaPerformWrapper , "Perform" ) ||
	    handleCallback(&CustomTool::click   , &SimTool::PerformClick   , luaClickWrapper   , "Click"   ) ||
	    handleCallback(&CustomTool::drag    , &SimTool::PerformDrag    , luaDragWrapper    , "Drag"    ) ||
	    handleCallback(&CustomTool::draw    , &SimTool::PerformDraw    , luaDrawWrapper    , "Draw"    ) ||
	    handleCallback(&CustomTool::drawLine, &SimTool::PerformDrawLine, luaDrawLineWrapper, "DrawLine") ||
	    handleCallback(&CustomTool::drawRect, &SimTool::PerformDrawRect, luaDrawRectWrapper, "DrawRect") ||
	    handleCallback(&CustomTool::drawFill, &SimTool::PerformDrawFill, luaDrawFillWrapper, "DrawFill") ||
	    handleCallback(&CustomTool::select  , &SimTool::PerformSelect  , luaSelectWrapper  , "Select"  ))
	{
		return 0;
	}
	int returnValueCount = 0;
	auto handleProperty = [L, lsi, tool, &propertyName, &returnValueCount](auto simToolMember, const char *luaPropertyName, bool buildMenusIfChanged) {
		if (propertyName == luaPropertyName)
		{
			auto &thing = tool->*simToolMember;
			using PropertyType = std::remove_reference_t<decltype(thing)>;
			if (lua_gettop(L) > 2)
			{
				if      constexpr (std::is_same_v<PropertyType, String      >) thing = tpt_lua_checkString(L, 3);
				else if constexpr (std::is_same_v<PropertyType, bool        >) thing = lua_toboolean(L, 3);
				else if constexpr (std::is_same_v<PropertyType, int         >) thing = luaL_checkinteger(L, 3);
				else if constexpr (std::is_same_v<PropertyType, RGB         >) thing = RGB::Unpack(luaL_checkinteger(L, 3));
				else static_assert(DependentFalse<PropertyType>::value);
				if (buildMenusIfChanged)
				{
					lsi->gameModel->BuildMenus();
				}
			}
			else
			{
				if      constexpr (std::is_same_v<PropertyType, String      >) tpt_lua_pushString(L, thing);
				else if constexpr (std::is_same_v<PropertyType, bool        >) lua_pushboolean(L, thing);
				else if constexpr (std::is_same_v<PropertyType, int         >) lua_pushinteger(L, thing);
				else if constexpr (std::is_same_v<PropertyType, RGB         >) lua_pushinteger(L, thing.Pack());
				else static_assert(DependentFalse<PropertyType>::value);
				returnValueCount = 1;
			}
			return true;
		}
		return false;
	};
	if (handleProperty(&SimTool::Name       , "Name"       ,  true) ||
	    handleProperty(&SimTool::Description, "Description",  true) ||
	    handleProperty(&SimTool::Colour     , "Colour"     ,  true) ||
	    handleProperty(&SimTool::Colour     , "Color"      ,  true) ||
	    handleProperty(&SimTool::MenuSection, "MenuSection",  true) ||
	    handleProperty(&SimTool::MenuVisible, "MenuVisible",  true))
	{
		return returnValueCount;
	}
	if (propertyName == "Identifier")
	{
		tpt_lua_pushByteString(L, tool->Identifier);
		return 1;
	}
	return luaL_error(L, "Invalid tool property");
}

static int exists(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int index = luaL_checkinteger(L, 1);
	lua_pushboolean(L, bool(lsi->gameModel->GetToolByIndex(index)));
	return 1;
}

static int isCustom(lua_State *L)
{
	auto *lsi = GetLSI();
	lsi->AssertInterfaceEvent();
	int index = luaL_checkinteger(L, 1);
	auto *tool = lsi->gameModel->GetToolByIndex(index);
	if (!tool)
	{
		return luaL_error(L, "Invalid tool");
	}
	lua_pushboolean(L, IsCustom(index));
	return 1;
}

void LuaTools::Open(lua_State *L)
{
	auto *lsi = GetLSI();
	static const luaL_Reg reg[] = {
#define LFUNC(v) { #v, v }
		LFUNC(allocate),
		LFUNC(property),
		LFUNC(exists),
		LFUNC(isCustom),
#undef LFUNC
		{ "free", ffree },
		{ nullptr, nullptr }
	};
	lua_newtable(L);
	luaL_register(L, nullptr, reg);
	lua_newtable(L);
	lua_setfield(L, -2, "index");
	lua_setglobal(L, "tools");
	auto &toolList = lsi->gameModel->GetTools();
	for (int i = 0; i < int(toolList.size()); ++i)
	{
		if (!toolList[i])
		{
			continue;
		}
		SetToolIndex(L, toolList[i]->Identifier, i);
	}
}

void LuaTools::SetToolIndex(lua_State *L, ByteString identifier, std::optional<int> index)
{
	lua_getglobal(L, "tools");
	lua_getfield(L, -1, "index");
	tpt_lua_pushByteString(L, identifier);
	if (index)
	{
		lua_pushinteger(L, *index);
	}
	else
	{
		lua_pushnil(L);
	}
	lua_settable(L, -3);
	lua_pop(L, 2);
}


=== src\lua\LuaWindow.cpp ===

#include "LuaWindow.h"
#include "LuaScriptInterface.h"
#include "LuaButton.h"
#include "LuaLabel.h"
#include "LuaTextbox.h"
#include "LuaCheckbox.h"
#include "LuaSlider.h"
#include "LuaProgressBar.h"
#include "gui/interface/Window.h"
#include "gui/interface/Engine.h"
#include "graphics/Graphics.h"

const char LuaWindow::className[] = "window";

#define method(class, name) {#name, &class::name}
Luna<LuaWindow>::RegType LuaWindow::methods[] = {
	method(LuaWindow, position),
	method(LuaWindow, size),
	method(LuaWindow, addComponent),
	method(LuaWindow, removeComponent),
	method(LuaWindow, onInitialized),
	method(LuaWindow, onExit),
	method(LuaWindow, onTick),
	method(LuaWindow, onDraw),
	method(LuaWindow, onFocus),
	method(LuaWindow, onBlur),
	method(LuaWindow, onTryExit),
	method(LuaWindow, onTryOkay),
	method(LuaWindow, onMouseMove),
	method(LuaWindow, onMouseDown),
	method(LuaWindow, onMouseUp),
	method(LuaWindow, onMouseWheel),
	method(LuaWindow, onKeyPress),
	method(LuaWindow, onKeyRelease),
	{nullptr, nullptr}
};

LuaWindow::LuaWindow(lua_State *L)
{
	this->L = L;
	int posX = luaL_optinteger(L, 1, 1);
	int posY = luaL_optinteger(L, 2, 1);
	int sizeX = luaL_optinteger(L, 3, 10);
	int sizeY = luaL_optinteger(L, 4, 10);

	// We should replace this with errors
	if (posX < 1 && posX != -1)
		posX = 1;
	if (posY < 1 && posY != -1)
		posY = 1;
	if (sizeX < 10)
		sizeX = 10;
	if (sizeY < 10)
		sizeY = 10;

	ci = static_cast<LuaScriptInterface *>(&CommandInterface::Ref());

	class DrawnWindow : public ui::Window
	{
		LuaWindow * luaWindow;
	public:
		DrawnWindow(ui::Point position, ui::Point size, LuaWindow * luaWindow) : ui::Window(position, size), luaWindow(luaWindow) {}
		void OnDraw() override
		{
			Graphics * g = ui::Engine::Ref().g;
			g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
			g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);
			luaWindow->triggerOnDraw();
		}
		void OnInitialized() override { luaWindow->triggerOnInitialized(); }
		void OnExit() override { luaWindow->triggerOnExit(); }
		void OnTick() override { luaWindow->triggerOnTick(); }
		void OnFocus() override { luaWindow->triggerOnFocus(); }
		void OnBlur() override { luaWindow->triggerOnBlur(); }
		void OnTryExit(ExitMethod) override { luaWindow->triggerOnTryExit(); }
		void OnTryOkay(OkayMethod) override { luaWindow->triggerOnTryOkay(); }
		void OnMouseMove(int x, int y, int dx, int dy) override { luaWindow->triggerOnMouseMove(x, y, dx, dy); }
		void OnMouseDown(int x, int y, unsigned button) override { luaWindow->triggerOnMouseDown(x, y, button); }
		void OnMouseUp(int x, int y, unsigned button) override { luaWindow->triggerOnMouseUp(x, y, button); }
		void OnMouseWheel(int x, int y, int d) override { luaWindow->triggerOnMouseWheel(x, y, d); }
		void OnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override { luaWindow->triggerOnKeyPress(key, scan, repeat, shift, ctrl, alt); }
		void OnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt) override { luaWindow->triggerOnKeyRelease(key, scan, repeat, shift, ctrl, alt); }
	};

	window = new DrawnWindow(ui::Point(posX, posY), ui::Point(sizeX, sizeY), this);
}

int LuaWindow::addComponent(lua_State *L)
{
	void *opaque = nullptr;
	LuaComponent *luaComponent = nullptr;
	if ((opaque = Luna<LuaButton>::tryGet(L, 1)))
		luaComponent = Luna<LuaButton>::get(opaque);
	else if ((opaque = Luna<LuaLabel>::tryGet(L, 1)))
		luaComponent = Luna<LuaLabel>::get(opaque);
	else if ((opaque = Luna<LuaTextbox>::tryGet(L, 1)))
		luaComponent = Luna<LuaTextbox>::get(opaque);
	else if ((opaque = Luna<LuaCheckbox>::tryGet(L, 1)))
		luaComponent = Luna<LuaCheckbox>::get(opaque);
	else if ((opaque = Luna<LuaSlider>::tryGet(L, 1)))
		luaComponent = Luna<LuaSlider>::get(opaque);
	else if ((opaque = Luna<LuaProgressBar>::tryGet(L, 1)))
		luaComponent = Luna<LuaProgressBar>::get(opaque);
	else
		luaL_typerror(L, 1, "Component");
	if (luaComponent)
	{
		auto ok = grabbedComponents.insert(std::make_pair(luaComponent, LuaSmartRef()));
		if (ok.second)
		{
			auto it = ok.first;
			it->second.Assign(L, 1);
			it->first->owner_ref = it->second;
		}
		window->AddComponent(luaComponent->GetComponent());
		luaComponent->SetParentWindow(this);
	}
	return 0;
}

int LuaWindow::removeComponent(lua_State *L)
{
	void *opaque = nullptr;
	LuaComponent *luaComponent = nullptr;
	if ((opaque = Luna<LuaButton>::tryGet(L, 1)))
		luaComponent = Luna<LuaButton>::get(opaque);
	else if ((opaque = Luna<LuaLabel>::tryGet(L, 1)))
		luaComponent = Luna<LuaLabel>::get(opaque);
	else if ((opaque = Luna<LuaTextbox>::tryGet(L, 1)))
		luaComponent = Luna<LuaTextbox>::get(opaque);
	else if ((opaque = Luna<LuaCheckbox>::tryGet(L, 1)))
		luaComponent = Luna<LuaCheckbox>::get(opaque);
	else if ((opaque = Luna<LuaSlider>::tryGet(L, 1)))
		luaComponent = Luna<LuaSlider>::get(opaque);
	else if ((opaque = Luna<LuaProgressBar>::tryGet(L, 1)))
		luaComponent = Luna<LuaProgressBar>::get(opaque);
	else
		luaL_typerror(L, 1, "Component");
	if (luaComponent)
	{
		ui::Component *component = luaComponent->GetComponent();
		window->RemoveComponent(component);
		auto it = grabbedComponents.find(luaComponent);
		if (it != grabbedComponents.end())
		{
			it->second.Clear();
			it->first->owner_ref = it->second;
			grabbedComponents.erase(it);
			luaComponent->SetParentWindow(nullptr);
		}
	}
	return 0;
}

int LuaWindow::position(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		luaL_checktype(L, 1, LUA_TNUMBER);
		luaL_checktype(L, 2, LUA_TNUMBER);
		int posX = lua_tointeger(L, 1);
		int posY = lua_tointeger(L, 2);

		if (posX < 1 || posY < 1)
		{
			return luaL_error(L, "Invalid position: '%d,%d'", posX, posY);
		}
		window->Position = ui::Point(posX, posY);
		return 0;
	}
	else
	{
		lua_pushinteger(L, window->Position.X);
		lua_pushinteger(L, window->Position.Y);
		return 2;
	}
}

int LuaWindow::size(lua_State *L)
{
	int args = lua_gettop(L);
	if(args)
	{
		luaL_checktype(L, 1, LUA_TNUMBER);
		luaL_checktype(L, 2, LUA_TNUMBER);
		int sizeX = lua_tointeger(L, 1);
		int sizeY = lua_tointeger(L, 2);

		if (sizeX < 10 || sizeY < 10)
		{
			return luaL_error(L, "Invalid size: '%d,%d'", sizeX, sizeY);
		}
		window->Size = ui::Point(sizeX, sizeY);
		return 0;
	}
	else
	{
		lua_pushinteger(L, window->Size.X);
		lua_pushinteger(L, window->Size.Y);
		return 2;
	}
}

void LuaWindow::triggerOnInitialized()
{
	if(onInitializedFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onInitializedFunction);
		if(tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnExit()
{
	if(onExitFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onExitFunction);
		if(tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnTick()
{
	if(onTickFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onTickFunction);
		lua_pushnumber(L, 1); // this used to be dt, which was measured in 60ths of a second; this hardcodes 60fps
		if(tpt_lua_pcall(L, 1, 0, 0, eventTraitInterface | eventTraitInterfaceGraphics))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnDraw()
{
	if(onDrawFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onDrawFunction);
		if(tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface | eventTraitInterfaceGraphics))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnFocus()
{
	if(onFocusFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onFocusFunction);
		if(tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnBlur()
{
	if(onBlurFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onBlurFunction);
		if(tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnTryExit()
{
	if(onTryExitFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onTryExitFunction);
		if(tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnTryOkay()
{
	if(onTryOkayFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onTryOkayFunction);
		if(tpt_lua_pcall(L, 0, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnMouseMove(int x, int y, int dx, int dy)
{
	if(onMouseMoveFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onMouseMoveFunction);
		lua_pushinteger(L, x);
		lua_pushinteger(L, y);
		lua_pushinteger(L, dx);
		lua_pushinteger(L, dy);
		if(tpt_lua_pcall(L, 4, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnMouseDown(int x, int y, unsigned button)
{
	if(onMouseDownFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onMouseDownFunction);
		lua_pushinteger(L, x);
		lua_pushinteger(L, y);
		lua_pushinteger(L, button);
		if(tpt_lua_pcall(L, 3, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnMouseUp(int x, int y, unsigned button)
{
	if(onMouseUpFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onMouseUpFunction);
		lua_pushinteger(L, x);
		lua_pushinteger(L, y);
		lua_pushinteger(L, button);
		if(tpt_lua_pcall(L, 3, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnMouseWheel(int x, int y, int d)
{
	if(onMouseWheelFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onMouseWheelFunction);
		lua_pushinteger(L, x);
		lua_pushinteger(L, y);
		lua_pushinteger(L, d);
		if(tpt_lua_pcall(L, 3, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if(onKeyPressFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onKeyPressFunction);
		lua_pushinteger(L, key);
		lua_pushinteger(L, scan);
		lua_pushboolean(L, shift);
		lua_pushboolean(L, ctrl);
		lua_pushboolean(L, alt);
		if(tpt_lua_pcall(L, 5, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

void LuaWindow::triggerOnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt)
{
	if(onKeyReleaseFunction)
	{
		lua_rawgeti(L, LUA_REGISTRYINDEX, onKeyReleaseFunction);
		lua_pushinteger(L, key);
		lua_pushinteger(L, scan);
		lua_pushboolean(L, shift);
		lua_pushboolean(L, ctrl);
		lua_pushboolean(L, alt);
		if(tpt_lua_pcall(L, 5, 0, 0, eventTraitInterface))
		{
			ci->Log(CommandInterface::LogError, tpt_lua_toString(L, -1));
		}
	}
}

int LuaWindow::onInitialized(lua_State *L)
{
	return onInitializedFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onExit(lua_State *L)
{
	return onExitFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onTick(lua_State *L)
{
	return onTickFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onDraw(lua_State *L)
{
	return onDrawFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onFocus(lua_State *L)
{
	return onFocusFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onBlur(lua_State *L)
{
	return onBlurFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onTryExit(lua_State *L)
{
	return onTryExitFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onTryOkay(lua_State *L)
{
	return onTryOkayFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onMouseMove(lua_State *L)
{
	return onMouseMoveFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onMouseDown(lua_State *L)
{
	return onMouseDownFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onMouseUp(lua_State *L)
{
	return onMouseUpFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onMouseWheel(lua_State *L)
{
	return onMouseWheelFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onKeyPress(lua_State *L)
{
	return onKeyPressFunction.CheckAndAssignArg1(L);
}

int LuaWindow::onKeyRelease(lua_State *L)
{
	return onKeyReleaseFunction.CheckAndAssignArg1(L);
}

void LuaWindow::ClearRef(LuaComponent *luaComponent)
{
	auto it = grabbedComponents.find(luaComponent);
	if (it != grabbedComponents.end())
	{
		it->second.Clear();
		it->first->owner_ref = it->second;
		it->first->SetParentWindow(nullptr);
		grabbedComponents.erase(it);
	}
}

LuaWindow::~LuaWindow()
{
	for (auto &component_and_ref : grabbedComponents)
	{
		window->RemoveComponent(component_and_ref.first->GetComponent());
		component_and_ref.second.Clear();
		component_and_ref.first->owner_ref = component_and_ref.second;
		component_and_ref.first->SetParentWindow(nullptr);
	}
	window->CloseActiveWindow();
	delete window;
}


=== src\lua\LuaWindow.h ===

#pragma once
#include "LuaLuna.h"
#include "LuaComponent.h"
#include "LuaSmartRef.h"
#include <map>

namespace ui
{
	class Window;
}

class LuaScriptInterface;
class LuaWindow
{
	LuaComponentCallback onInitializedFunction;
	LuaComponentCallback onExitFunction;
	LuaComponentCallback onTickFunction;
	LuaComponentCallback onDrawFunction;
	LuaComponentCallback onFocusFunction;
	LuaComponentCallback onBlurFunction;
	LuaComponentCallback onTryExitFunction;
	LuaComponentCallback onTryOkayFunction;
	LuaComponentCallback onMouseMoveFunction;
	LuaComponentCallback onMouseDownFunction;
	LuaComponentCallback onMouseUpFunction;
	LuaComponentCallback onMouseWheelFunction;
	LuaComponentCallback onKeyPressFunction;
	LuaComponentCallback onKeyReleaseFunction;

	std::map<LuaComponent *, LuaSmartRef> grabbedComponents;

	ui::Window * window;
	lua_State *L;
	int position(lua_State *L);
	int size(lua_State *L);
	int addComponent(lua_State *L);
	int removeComponent(lua_State *L);

	//Set event handlers
	int onInitialized(lua_State *L);
	int onExit(lua_State *L);
	int onTick(lua_State *L);
	int onDraw(lua_State *L);
	int onFocus(lua_State *L);
	int onBlur(lua_State *L);
	int onTryExit(lua_State *L);
	int onTryOkay(lua_State *L);
	int onMouseMove(lua_State *L);
	int onMouseDown(lua_State *L);
	int onMouseUp(lua_State *L);
	int onMouseWheel(lua_State *L);
	int onKeyPress(lua_State *L);
	int onKeyRelease(lua_State *L);

	void triggerOnInitialized();
	void triggerOnExit();
	void triggerOnTick();
	void triggerOnDraw();
	void triggerOnFocus();
	void triggerOnBlur();
	void triggerOnTryExit();
	void triggerOnTryOkay();
	void triggerOnMouseMove(int x, int y, int dx, int dy);
	void triggerOnMouseDown(int x, int y, unsigned button);
	void triggerOnMouseUp(int x, int y, unsigned button);
	void triggerOnMouseWheel(int x, int y, int d);
	void triggerOnKeyPress(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);
	void triggerOnKeyRelease(int key, int scan, bool repeat, bool shift, bool ctrl, bool alt);

public:
	LuaScriptInterface * ci;
	static const char className[];
	static Luna<LuaWindow>::RegType methods[];

	ui::Window * GetWindow() { return window; }
	void ClearRef(LuaComponent *luaComponent);

	LuaWindow(lua_State *L);
	~LuaWindow();
};


=== src\lua\meson.build ===

luaconsole_files = files(
	'LuaButton.cpp',
	'LuaBz2.cpp',
	'LuaCheckbox.cpp',
	'LuaCompat.cpp',
	'LuaComponent.cpp',
	'LuaElements.cpp',
	'LuaEvent.cpp',
	'LuaFileSystem.cpp',
	'LuaGraphics.cpp',
	'LuaHttp.cpp',
	'LuaInterface.cpp',
	'LuaLabel.cpp',
	'LuaMisc.cpp',
	'LuaPlatform.cpp',
	'LuaProgressBar.cpp',
	'LuaRenderer.cpp',
	'LuaScriptInterface.cpp',
	'LuaSimulation.cpp',
	'LuaSlider.cpp',
	'LuaSocket.cpp',
	'LuaSmartRef.cpp',
	'LuaTextbox.cpp',
	'LuaTools.cpp',
	'LuaWindow.cpp',
)
if lua_variant != 'luajit'
	luaconsole_files += files(
		'LuaBit.cpp',
	)
endif
if host_platform == 'windows'
	luaconsole_files += files('LuaSocketWindows.cpp')
else
	luaconsole_files += files('LuaSocketDefault.cpp')
endif
if not enable_http or host_platform == 'emscripten'
	luaconsole_files += files('LuaSocketTCPNoHttp.cpp')
else
	luaconsole_files += files('LuaSocketTCPHttp.cpp')
endif
conf_data.set('LUACONSOLE', (lua_variant != 'none').to_string())

subdir('luascripts')

powder_files += luaconsole_files


=== src\lua\PlainCommandInterface.cpp ===

#include "CommandInterface.h"

CommandInterfacePtr CommandInterface::Create(GameController *newGameController, GameModel *newGameModel)
{
	return CommandInterfacePtr(new CommandInterface(newGameController, newGameModel));
}

void CommandInterfaceDeleter::operator ()(CommandInterface *ptr) const
{
	delete ptr;
}

void CommandInterface::OnTick()
{
}

void CommandInterface::Init()
{
}

bool CommandInterface::HandleEvent(const GameControllerEvent &event)
{
	return true;
}

bool CommandInterface::HaveSimGraphicsEventHandlers()
{
	return false;
}

int CommandInterface::Command(String command)
{
	return PlainCommand(command);
}

String CommandInterface::FormatCommand(String command)
{
	return PlainFormatCommand(command);
}

void CommandInterface::SetToolIndex(ByteString identifier, std::optional<int> index)
{
}

void CommandInterface::RemoveComponents()
{
}


=== src\lua\TPTSTypes.cpp ===

#include "TPTSTypes.h"

AnyType::AnyType(ValueType type_, ValueValue value_):
	type(type_),
	value(value_)
{
}

ValueType AnyType::GetType()
{
	return type;
}

AnyType::operator NumberType()
{
	if (type == TypeNumber)
		return NumberType(std::get<int>(value));
	else if (type == TypeFloat)
		return NumberType(int(std::get<float>(value)));
	else
		throw InvalidConversionException(type, TypeNumber);
}

AnyType::operator FloatType()
{
	if (type == TypeNumber)
		return FloatType(float(std::get<int>(value)));
	else if (type == TypeFloat)
		return FloatType(std::get<float>(value));
	else
		throw InvalidConversionException(type, TypeFloat);
}

AnyType::operator StringType()
{
	if(type == TypeNumber)
	{
		return StringType(String::Build(((NumberType *)this)->Value()));
	}
	else if(type == TypeString && std::holds_alternative<String>(value))
	{
		return StringType(std::get<String>(value));
	}
	else if (type == TypePoint && std::holds_alternative<ui::Point>(value))
	{
		ui::Point thisPoint = std::get<ui::Point>(value);
		return StringType(String::Build(thisPoint.X, ",", thisPoint.Y));
	}
	else
		throw InvalidConversionException(type, TypeString);

}

AnyType::operator PointType()
{
	if (type == TypePoint)
	{
		return PointType(std::get<ui::Point>(value));
	}
	else if (type == TypeString)
	{
		int x, y;
		if (String::Split comma = std::get<String>(value).SplitNumber(x))
			if (comma.After().BeginsWith(","))
			{
				String after = comma.After().Substr(1);
				if (String::Split end = after.SplitNumber(y))
					if (!end.After().size())
						return PointType(x, y);
			}
		throw InvalidConversionException(type, TypePoint);
	}
	else
		throw InvalidConversionException(type, TypePoint);
}

//Number Type

NumberType::NumberType(int number): AnyType(TypeNumber, ValueValue())
{
	value = number;
}

int NumberType::Value()
{
	return std::get<int>(value);
}

//Float Type

FloatType::FloatType(float number): AnyType(TypeFloat, ValueValue())
{
	value = number;
}

float FloatType::Value()
{
	return std::get<float>(value);
}

//String type

StringType::StringType(String string):	AnyType(TypeString, ValueValue())
{
	value = string;
}

String StringType::Value()
{
	return std::get<String>(value);
}

//Point type

PointType::PointType(ui::Point point): AnyType(TypePoint, ValueValue())
{
	value = point;
}

PointType::PointType(int pointX, int pointY): AnyType(TypePoint, ValueValue())
{
	value = ui::Point(pointX, pointY);
}

ui::Point PointType::Value()
{
	return std::get<ui::Point>(value);
}


=== src\lua\TPTSTypes.h ===

#pragma once
#include "common/String.h"
#include "gui/interface/Point.h"
#include <variant>

enum ValueType { TypeNumber, TypeFloat, TypePoint, TypeString, TypeNull, TypeFunction };
typedef std::variant<int, float, String, ui::Point> ValueValue;

class GeneralException
{
protected:
	String exception;
public:
	GeneralException(String message){
		exception = message;
	}
	String GetExceptionMessage() {
		return exception;
	}
};


class NumberType;
class FloatType;
class StringType;
class PointType;

class AnyType
{
protected:
	ValueType type;
	ValueValue value;
public:
	AnyType(ValueType type_, ValueValue value_);
	operator NumberType();
	operator FloatType();
	operator StringType();
	operator PointType();
	ValueType GetType();
	ByteString TypeName()
	{
		switch(type)
		{
		case TypeNumber:
			return "Number";
		case TypeFloat:
			return "Float";
		case TypePoint:
			return "Point";
		case TypeString:
			return "String";
		case TypeNull:
			return "Null";
		case TypeFunction:
			return "Function";
		default:
			return "Unknown";
		}
	}
	static ByteString TypeName(ValueType type)
	{
		switch(type)
		{
		case TypeNumber:
			return "Number";
		case TypeFloat:
			return "Float";
		case TypePoint:
			return "Point";
		case TypeString:
			return "String";
		case TypeNull:
			return "Null";
		case TypeFunction:
			return "Function";
		default:
			return "Unknown";
		}
	}
};

class InvalidConversionException: public GeneralException
{
public:
	InvalidConversionException(ValueType from_, ValueType to_):
	GeneralException("Invalid conversion from " + AnyType::TypeName(from_).FromAscii() + " to " + AnyType::TypeName(to_).FromAscii()) {
	}
};

class NumberType: public AnyType
{
public:
	NumberType(int number);
	int Value();
};

class FloatType: public AnyType
{
public:
	FloatType(float number);
	float Value();
};

class StringType: public AnyType
{
public:
	StringType(String string);
	String Value();
};

class PointType: public AnyType
{
public:
	PointType(ui::Point point);
	PointType(int pointX, int pointY);
	ui::Point Value();
};


=== src\lua\luascripts\compat.lua ===

bz2.compressLimit       = bz2.COMPRESS_LIMIT
bz2.compressNomem       = bz2.COMPRESS_NOMEM
bz2.decompressBad       = bz2.DECOMPRESS_BAD
bz2.decompressEof       = bz2.DECOMPRESS_EOF
bz2.decompressLimit     = bz2.DECOMPRESS_LIMIT
bz2.decompressNomem     = bz2.DECOMPRESS_NOMEM
bz2.decompressType      = bz2.DECOMPRESS_TYPE
elem.FLAG_MOVABLE       = sim.FLAG_MOVABLE
elem.FLAG_PHOTDECO      = sim.FLAG_PHOTDECO
elem.FLAG_SKIPMOVE      = sim.FLAG_SKIPMOVE
elem.FLAG_STAGNANT      = sim.FLAG_STAGNANT
elem.PROP_BLACK         = 0
elem.PROP_DRAWONCTYPE   = 0
elem.ST_GAS             = 0
elem.ST_LIQUID          = 0
elem.ST_NONE            = 0
elem.ST_SOLID           = 0
event.aftersimdraw      = event.AFTERSIMDRAW
event.aftersim          = event.AFTERSIM
event.beforesimdraw     = event.BEFORESIMDRAW
event.beforesim         = event.BEFORESIM
event.blur              = event.BLUR
event.close             = event.CLOSE
event.getmodifiers      = event.getModifiers
event.keypress          = event.KEYPRESS
event.keyrelease        = event.KEYRELEASE
event.mousedown         = event.MOUSEDOWN
event.mousemove         = event.MOUSEMOVE
event.mouseup           = event.MOUSEUP
event.mousewheel        = event.MOUSEWHEEL
event.textediting       = event.TEXTEDITING
event.textinput         = event.TEXTINPUT
event.tick              = event.TICK
ren.colourMode          = ren.colorMode
sim.can_move            = sim.canMove
sim.decoColour          = sim.decoColor
sim.framerender         = sim.frameRender
sim.gspeed              = sim.golSpeedRatio
sim.neighbours          = sim.neighbors
sim.partNeighbours      = sim.partNeighbors
sim.randomseed          = sim.randomSeed
sim.waterEqualisation   = sim.waterEqualization
tpt.active_menu         = ui.activeMenu
tpt.display_mode        = ren.useDisplayPreset
tpt.get_clipboard       = plat.clipboardCopy
tpt.get_name            = tpt.getUserName
tpt.menu_enabled        = ui.menuEnabled
tpt.num_menus           = ui.numMenus
tpt.perfectCircleBrush  = ui.perfectCircleBrush
tpt.reset_spark         = sim.resetSpark
tpt.reset_velocity      = sim.resetVelocity
tpt.set_clipboard       = plat.clipboardPaste
tpt.setdrawcap          = tpt.drawCap
tpt.setfpscap           = tpt.fpsCap
tpt.get_numOfParts      = sim.partCount
ui.MOUSE_UP_BLUR        = ui.MOUSEUP_BLUR
ui.MOUSE_UP_DRAW_END    = ui.MOUSEUP_DRAWEND
ui.MOUSE_UP_NORMAL      = ui.MOUSEUP_NORMAL
sim.TOOL_HEAT           = tools.index.DEFAULT_TOOL_HEAT
sim.TOOL_COOL           = tools.index.DEFAULT_TOOL_COOL
sim.TOOL_VAC            = tools.index.DEFAULT_TOOL_VAC
sim.TOOL_PGRV           = tools.index.DEFAULT_TOOL_PGRV
sim.TOOL_AIR            = tools.index.DEFAULT_TOOL_AIR
sim.TOOL_NGRV           = tools.index.DEFAULT_TOOL_NGRV
sim.TOOL_MIX            = tools.index.DEFAULT_TOOL_MIX
sim.TOOL_CYCL           = tools.index.DEFAULT_TOOL_CYCL
sim.TOOL_WIND           = tools.index.DEFAULT_TOOL_WIND
if socket then
	socket.gettime = socket.getTime
end
print = tpt.log

local function fake_boolean_wrapper(func, true_is_1)
	return function(param)
		if not param then
			return func() and 1 or 0
		end
		local enable
		if true_is_1 then
			enable = param == 1
		else
			enable = param ~= 0
		end
		func(enable)
	end
end
tpt.set_console        = fake_boolean_wrapper(ui.console          , true )
tpt.ambient_heat       = fake_boolean_wrapper(sim.ambientHeatSim  , true )
tpt.heat               = fake_boolean_wrapper(sim.heatSim         , false)
tpt.set_pause          = fake_boolean_wrapper(sim.paused          , false)
tpt.decorations_enable = fake_boolean_wrapper(ren.decorations     , false)
tpt.hud                = fake_boolean_wrapper(ren.hud             , false)
tpt.newtonian_gravity  = fake_boolean_wrapper(sim.newtonianGravity, false)
ren.debugHUD           = fake_boolean_wrapper(ren.debugHud        , false)

function tpt.setdebug(flags)
	-- correct usage passed 0 to 1 arguments
	tpt.debug(flags or 0)
end

function sim.gravMap(x, y, ...)
	-- correct usage passed 2, 3, or 5 arguments
	if select("#", ...) == 0 then
		-- 2-argument calls are handled here
		local gx, gy = sim.gravityField(x, y)
		return math.sqrt(gx * gx + gy * gy)
	end
	-- sim.gravityMass is compatible with 3- and 5-argument calls
	sim.gravityMass(x, y, ...)
end

function tpt.set_wallmap(x, y, ...)
	-- correct usage passed 3, 5, or 7 arguments
	if select("#", ...) == 5 then
		-- 7-argument calls are handled here
		local w, h, fvx, fvy, v = ...
		sim.wallMap(x, y, w, h, v)
		sim.fanVelocityX(x, y, w, h, fvx)
		sim.fanVelocityY(x, y, w, h, fvy)
		return
	end
	-- sim.wallMap is compatible with 3- and 5-argument calls
	sim.wallMap(x, y, ...)
end

function tpt.get_wallmap(x, y)
	-- correct usage passed 0 to 2 arguments
	return sim.wallMap(x or 0, y or 0)
end

function tpt.set_elecmap(...)
	-- correct usage passed 0 to 5 arguments
	local x1, y1, width, height
	local argc = select("#", ...)
	if argc == 5 then
		-- only the 5-argument calls enabled area mode
		x1, y1, width, height = ...
	else
		x1, y1 = ...
		x1 = x1 or 0
		y1 = y1 or 0
		width, height = 1, 1
	end
	-- value was always the last argument
	local value = argc > 0 and select(argc, ...) or 0
	-- sim.elecMap is used with a 5-argument call
	sim.elecMap(x1, y1, width, height, value)
end

function tpt.get_elecmap(x, y)
	-- correct usage passed 0 to 2 arguments
	return sim.elecMap(x or 0, y or 0)
end

function tpt.set_pressure(x1, y1, width, height, value)
	-- correct usage passed 0 to 5 arguments
	return sim.pressure(x1 or 0, y1 or 0, width or sim.XCELLS, height or sim.YCELLS, value or 0)
end

function tpt.set_gravity(x1, y1, width, height, value)
	-- correct usage passed 0 to 5 arguments
	sim.gravityMass(x1 or 0, y1 or 0, width or sim.XCELLS, height or sim.YCELLS, value or 0)
end

function tpt.setwindowsize(scale, fullscreen)
	-- correct usage passed 0 to 2 arguments
	ui.windowSize(scale or 1, (fullscreen or 0) == 1)
end

function tpt.setfire(intensity)
	-- correct usage passed 0 to 1 arguments
	ren.fireSize(intensity or 1)
end

local old_ui_ctor
do
	local ctor_mt = {}
	function ctor_mt:__call(...)
		return self.new(...)
	end
	function ctor_mt:__newindex()
		error("table is read-only", 2)
	end
	function old_ui_ctor(func)
		return setmetatable({ new = function(_, ...)
			return func(...)
		end }, ctor_mt)
	end
end
Slider      = old_ui_ctor(ui.slider     )
Textbox     = old_ui_ctor(ui.textbox    )
ProgressBar = old_ui_ctor(ui.progressBar)
Window      = old_ui_ctor(ui.window     )
Button      = old_ui_ctor(ui.button     )
Label       = old_ui_ctor(ui.label      )
Checkbox    = old_ui_ctor(ui.checkbox   )

function tpt.register_step(f)
	event.register(event.tick, f)
end

function tpt.unregister_step(f)
	event.unregister(event.tick, f)
end

do
	local registered_mouseclicks = {}

	function tpt.register_mouseclick(f)
		if registered_mouseclicks[f] then return end
		local mousex = -1
		local mousey = -1
		local mousedown = -1
		local function mousedownfunc(x, y, button)
			--replicate hack in original function
			if button == 3 then
				button = 4
			end
			mousex = x
			mousey = y
			mousedown = button
			return f(x, y, button, 1, 0)
		end
		local function mouseupfunc(x, y, button, evt)
			--ignore automatic mouseup event sent when switching windows
			if mousedown == -1 and evt == 1 then
				return
			end
			--replicate hack in original function
			if button == 3 then
				button = 4
			end
			local evtType = 2
			if evt == 1 then
				evtType = 4
			elseif evt == 2 then
				evtType = 5
			end
			--zoom window cancel
			--Original function would have started returning 0 for mousetick events
			--(until the actual mousedown), but we don't replicate that here
			if evt ~= 2 then
				mousedown = -1
			end
			return f(x, y, button, evtType, 0)
		end
		local function mousemovefunc(x, y, dx, dy)
			mousex = x
			mousey = y
		end
		local function mousewheelfunc(x, y, d)
			return f(x, y, 0, 0, d)
		end
		local function tickfunc()
			if mousedown ~= -1 then
				return f(mousex, mousey, mousedown, 3, 0)
			end
		end
		event.register(event.mousedown, mousedownfunc)
		event.register(event.mouseup, mouseupfunc)
		event.register(event.mousemove, mousemovefunc)
		event.register(event.mousewheel, mousewheelfunc)
		event.register(event.tick, tickfunc)
		local funcs = {mousedownfunc, mouseupfunc, mousemovefunc, mousewheelfunc, tickfunc}
		registered_mouseclicks[f] = funcs
	end
	tpt.register_mouseevent = tpt.register_mouseclick

	function tpt.unregister_mouseclick(f)
		if not registered_mouseclicks[f] then return end

		local funcs = registered_mouseclicks[f]
		event.unregister(event.mousedown, funcs[1])
		event.unregister(event.mouseup, funcs[2])
		event.unregister(event.mousemove, funcs[3])
		event.unregister(event.mousewheel, funcs[4])
		event.unregister(event.tick, funcs[5])
		
		registered_mouseclicks[f] = nil
	end
	tpt.unregister_mouseevent = tpt.unregister_mouseclick
end

do
	local registered_keypresses = {}
	local keyMapping = {}
	-- lctrl, rctlr, lshift, rshift, lalt, ralt
	keyMapping[225] = 304
	keyMapping[229] = 303
	keyMapping[224] = 306
	keyMapping[228] = 305
	keyMapping[226] = 308
	keyMapping[230] = 307
	--up, down, right, left
	keyMapping[82] = 273
	keyMapping[81] = 274
	keyMapping[79] = 275
	keyMapping[80] = 276
	-- shift mapping for US keyboard layout
	local shiftMapping = {
		["`"] = "~",
		["1"] = "!",
		["2"] = "@",
		["3"] = "#",
		["4"] = "$",
		["5"] = "%",
		["6"] = "^",
		["7"] = "&",
		["8"] = "*",
		["9"] = "(",
		["0"] = ")",
		["-"] = "_",
		["="] = "+",

		["["] = "{",
		["]"] = "}",
		["\\"] = "|",
		[";"] = ":",
		["'"] = "\"",
		[","] = "<",
		["."] = ">",
		["/"] = "?"
	}

	function tpt.register_keypress(f)
		if registered_keypresses[f] then return end
		local function keypress(key, scan, rep, shift, ctrl, alt)
			if rep then return end
			local mod = event.getmodifiers()
			-- attempt to convert to string representation
			local err, keyStr = pcall(string.char, key)
			if not err then keyStr = "" end
			if keyStr ~= "" and shift then
				keyStr = shiftMapping[keyStr] and shiftMapping[keyStr] or string.upper(keyStr)
			end
			-- key mapping for common keys, extremely incomplete
			if keyMapping[scan] then key = keyMapping[scan] end
			return f(keyStr, key, mod, 1)
		end
		local function keyrelease(key, scan, rep, shift, ctrl, alt)
			local mod = event.getmodifiers()
			-- attempt to convert to string representation
			local err, keyStr = pcall(string.char, key)
			if not err then keyStr = "" end
			-- key mapping for common keys, extremely incomplete
			if keyMapping[scan] then key = keyMapping[scan] end
			return f(keyStr, key, mod, 2)
		end
		event.register(event.keypress, keypress)
		event.register(event.keyrelease, keyrelease)
		local funcs = { keypress, keyrelease }
		registered_keypresses[f] = funcs
	end
	tpt.register_keyevent = tpt.register_keypress

	function tpt.unregister_keypress(f)
		if not registered_keypresses[f] then return end
		local funcs = registered_keypresses[f]
		event.unregister(event.keypress, funcs[1])
		event.unregister(event.keyrelease, funcs[2])
		registered_keypresses[f] = nil
	end
	tpt.unregister_keyevent = tpt.unregister_keypress
end

function tpt.element_func(f, element, replace)
	if f == nil then f = false end
	elem.property(element, "Update", f, replace)
end

function tpt.graphics_func(f, element)
	if f == nil then f = false end
	elem.property(element, "Graphics", f)
end

function tpt.getscript(id, name, run)
	if not (id == 1 and name == "autorun.lua" and run == 1) then
		error("only use tpt.getscript to install the script manager")
	end
	tpt.installScriptManager()
end

tpt.drawpixel = gfx.drawPixel
function tpt.drawrect(x, y, w, h, r, g, b, a)
	gfx.drawRect(x, y, w + 1, h + 1, r, g, b, a)
end
function tpt.fillrect(x, y, w, h, r, g, b, a)
	gfx.fillRect(x + 1, y + 1, w - 1, h - 1, r, g, b, a)
end
tpt.drawline = gfx.drawLine
tpt.drawtext = gfx.drawText

function tpt.textwidth(str)
	local width = gfx.textSize(str)
	return width - 1
end

function tpt.toggle_pause()
	sim.paused(not sim.paused())
	return tpt.set_pause()
end

function tpt.watertest()
	sim.waterEqualization(sim.waterEqualization() == 1 and 0 or 1)
	return sim.waterEqualization()
end

do
	local index = -1
	function tpt.start_getPartIndex()
		index = -1
	end
	function tpt.next_getPartIndex()
		while true do
			index = index + 1
			if index >= sim.MAX_PARTS then
				index = -1
				return false
			end
			if sim.partExists(index) then
				break
			end
		end
		return true
	end
	function tpt.getPartIndex()
		return index
	end
end

function tpt.element(thing)
	if type(thing) == "string" then
		local id = elem.getByName(thing)
		if id == -1 then
			error("Unrecognised element " .. thing, 2)
		end
		return id
	end
	return elem.property(thing, "Name")
end

function tpt.create(x, y, thing)
	if type(thing) ~= "number" then
		thing = tpt.element(thing or "dust")
	end
	return sim.partCreate(-1, x, y, thing)
end

function tpt.delete(x, y)
	if y then
		local id = sim.partID(x, y)
		if id then
			sim.partKill(id)
		end
		return
	end
	sim.partKill(x)
end

do
	local el_names = {
		[ "name"             ] = "Name"            ,
		[ "colour"           ] = "Colour"          ,
		[ "color"            ] = "Color"           ,
		[ "menu"             ] = "MenuVisible"     ,
		[ "menusection"      ] = "MenuSection"     ,
		[ "enabled"          ] = "Enabled"         ,
		[ "advection"        ] = "Advection"       ,
		[ "airdrag"          ] = "AirDrag"         ,
		[ "airloss"          ] = "AirLoss"         ,
		[ "loss"             ] = "Loss"            ,
		[ "collision"        ] = "Collision"       ,
		[ "gravity"          ] = "Gravity"         ,
		[ "newtoniangravity" ] = "NewtonianGravity",
		[ "diffusion"        ] = "Diffusion"       ,
		[ "hotair"           ] = "HotAir"          ,
		[ "falldown"         ] = "Falldown"        ,
		[ "flammable"        ] = "Flammable"       ,
		[ "explosive"        ] = "Explosive"       ,
		[ "meltable"         ] = "Meltable"        ,
		[ "hardness"         ] = "Hardness"        ,
		[ "weight"           ] = "Weight"          ,
		[ "heat"             ] = "Temperature"     ,
		[ "hconduct"         ] = "HeatConduct"     ,
		[ "description"      ] = "Description"     ,
		[ "state"            ] = "State"           ,
		[ "properties"       ] = "Properties"      ,
	}
	local el_mt = {}
	function el_mt:__index(key)
		return elem.property(self.id, el_names[key])
	end
	function el_mt:__newindex(key, value)
		elem.property(self.id, el_names[key], value)
	end

	local eltransition_names = {
		[ "presLowValue"  ] = "LowPressure"              ,
		[ "presLowType"   ] = "LowPressureTransition"    ,
		[ "presHighValue" ] = "HighPressure"             ,
		[ "presHighType"  ] = "HighPressureTransition"   ,
		[ "tempLowValue"  ] = "LowTemperature"           ,
		[ "tempLowType"   ] = "LowTemperatureTransition" ,
		[ "tempHighValue" ] = "HighTemperature"          ,
		[ "tempHighType"  ] = "HighTemperatureTransition",
	}
	local eltransition_mt = {}
	function eltransition_mt:__index(key)
		return elem.property(self.id, eltransition_names[key])
	end
	function eltransition_mt:__newindex(key, value)
		elem.property(self.id, eltransition_names[key], value)
	end

	tpt.el = {}
	tpt.eltransition = {}
	for i = 1, sim.PT_NUM do
		if elem.exists(i) then
			local name = elem.property(i, "Name"):lower()
			tpt.el          [name] = setmetatable({ id = i }, el_mt          )
			tpt.eltransition[name] = setmetatable({ id = i }, eltransition_mt)
		end
	end

	local part_mt = {}
	local last_id
	function part_mt:__index(key)
		if not sim.partExists(last_id) then
			error("dead particle", 2)
		end
		if key == "id" then
			return last_id
		end
		return sim.partProperty(last_id, key)
	end
	function part_mt:__newindex(key, value)
		if not sim.partExists(last_id) then
			error("dead particle", 2)
		end
		sim.partProperty(last_id, key, value)
	end
	local part_proxy = setmetatable({}, part_mt)

	local parts_mt = {}
	function parts_mt:__index(key)
		last_id = key
		return part_proxy
	end
	function parts_mt:__newindex()
		error("table is read-only", 2)
	end
	tpt.parts = setmetatable({}, parts_mt)
end

function tpt.set_property(prop, value, ...)
	if type(value) == "string" then
		value = tpt.element(value)
	end
	local argc = select("#", ...)
	local filter = argc > 0 and select(argc, ...)
	local have_filter = type(filter) == "string"
	if not have_filter then
		-- fast path for the common cases; the slow path covers these too though
		if argc == 1 then
			sim.partProperty(..., prop, value)
			return
		end
		if argc == 2 then
			local i = sim.partID(...)
			if i then
				sim.partProperty(i, prop, value)
			end
			return
		end
	end
	filter = have_filter and tpt.element(filter)
	do
		-- is this a region?
		local x, y, w, h = ...
		if type(x) ~= "number" or argc >= 4 then
			if argc < 4 then -- we're here because type(x) ~= "number", use default x, y, w, h
				x, y, w, h = 0, 0, sim.XRES, sim.YRES
			end
			for i in sim.parts() do
				local ix, iy = sim.partPosition(i)
				ix = math.floor(ix + 0.5)
				iy = math.floor(iy + 0.5)
				if ix >= x and iy >= y and ix < x + w and iy < y + h and (not filter or sim.partProperty(i, "type") == filter) then
					sim.partProperty(i, prop, value)
				end
			end
			return
		end
	end
	local x, y = ...
	local i
	if type(y) == "number" then
		i = sim.pmap(x, y)
		if i and filter and sim.partProperty(i, "type") ~= filter then
			i = nil
		end
		if not i then
			i = sim.photons(x, y)
			if i and filter and sim.partProperty(i, "type") ~= filter then
				i = nil
			end
		end
	else
		i = x
	end
	if i and filter and sim.partProperty(i, "type") ~= filter then
		i = nil
	end
	if i then
		sim.partProperty(i, prop, value)
	end
end

function tpt.get_property(prop, x, y)
	local i
	if type(y) == "number" then
		i = sim.partID(x, y)
	else
		i = sim.partExists(x) and x
	end
	if i then
		if prop == "id" then
			return i
		end
	else
		if prop == "type" then
			return 0
		end
	end
	return sim.partProperty(i, prop)
end

local sim_mt = {}
function sim_mt:__index(key)
	if key == "NUM_PARTS" then
		return sim.partCount()
	end
end
function sim_mt:__newindex(key)
	if key == "NUM_PARTS" then
		error("property is read-only", 2)
	end
	rawset(self, key, value)
end
setmetatable(sim, sim_mt)

local tpt_mt = {}
function tpt_mt:__index(key)
	if key == "selectedl" then
		return ui.activeTool(0)
	elseif key == "mousex" then
		local x, y = ui.mousePosition()
		return x
	elseif key == "mousey" then
		local x, y = ui.mousePosition()
		return y
	elseif key == "selectedr" then
		return ui.activeTool(1)
	elseif key == "selecteda" then
		return ui.activeTool(2)
	elseif key == "selectedreplace" then
		return ui.activeTool(3)
	elseif key == "brushID" then
		return ui.brushID()
	elseif key == "brushx" then
		local w, h = ui.brushRadius()
		return w
	elseif key == "brushy" then
		local w, h = ui.brushRadius()
		return h
	elseif key == "decoSpace" then
		return sim.decoSpace()
	end
end
function tpt_mt:__newindex(key, value)
	if key == "selectedl" then
		return ui.activeTool(0, value)
	elseif key == "mousex" then
		error("property is read-only", 2)
	elseif key == "mousey" then
		error("property is read-only", 2)
	elseif key == "selectedr" then
		return ui.activeTool(1, value)
	elseif key == "selecteda" then
		return ui.activeTool(2, value)
	elseif key == "selectedreplace" then
		return ui.activeTool(3, value)
	elseif key == "brushID" then
		return ui.brushID(value)
	elseif key == "brushx" then
		local w, h = ui.brushRadius()
		ui.brushRadius(value, h)
		return
	elseif key == "brushy" then
		local w, h = ui.brushRadius()
		ui.brushRadius(w, value)
		return
	elseif key == "decoSpace" then
		return sim.decoSpace(value)
	end
	rawset(self, key, value)
end
setmetatable(tpt, tpt_mt)

function ren.renderModes(tbl)
	if tbl then
		local combined = 0
		for i = 1, #tbl do
			combined = bit.bor(combined, tbl[i])
		end
		ren.renderMode(combined)
		return
	end
	return { ren.renderMode() }
end

function ren.displayModes(tbl)
	if tbl then
		local combined = 0
		for i = 1, #tbl do
			combined = bit.bor(combined, tbl[i])
		end
		ren.displayMode(combined)
		return
	end
	return { ren.displayMode() }
end


=== src\lua\luascripts\meson.build ===

embedded_files += [
	[ 'compat_lua', files('compat.lua') ],
]


=== src\prefs\GlobalPrefs.h ===

#pragma once
#include "Prefs.h"
#include "common/ExplicitSingleton.h"

class GlobalPrefs : public Prefs, public ExplicitSingleton<GlobalPrefs>
{
public:
	GlobalPrefs() : Prefs("powder.pref")
	{
	}
};


=== src\prefs\meson.build ===

powder_files += files(
	'Prefs.cpp',
)


=== src\prefs\Prefs.cpp ===

#include "Prefs.h"
#include "common/platform/Platform.h"
#include "common/tpt-rand.h"
#include "client/User.h"
#include <fstream>
#include <iostream>

Prefs::Prefs(ByteString newPath) : path(newPath)
{
	Read();
}

void Prefs::Read()
{
	std::vector<char> data;
	if (!Platform::ReadFile(data, path))
	{
		return;
	}
	Json::CharReaderBuilder rbuilder;
	std::unique_ptr<Json::CharReader> const reader(rbuilder.newCharReader());
	ByteString errs;
	if (!data.size())
	{
		std::cerr << "no json data" << std::endl;
		return;
	}
	if (!reader->parse(data.data(), data.data() + data.size(), &root, &errs))
	{
		std::cerr << errs << std::endl;
		return;
	}
	backedByFile = true;
}

void Prefs::ShouldWrite()
{
	shouldWrite = true;
	Write();
}

void Prefs::Write()
{
	if (deferWriteLevel)
	{
		return;
	}
	if (!shouldWrite)
	{
		return;
	}
	shouldWrite = false;
	Json::StreamWriterBuilder wbuilder;
	wbuilder["indentation"] = "\t";
	ByteString data = Json::writeString(wbuilder, root);
	if (!Platform::WriteFile(data, path))
	{
		return;
	}
	backedByFile = true;
}

void Prefs::GrabDeferWriteLevel(DeferWriteTag)
{
	deferWriteLevel += 1;
}

void Prefs::DropDeferWriteLevel(DeferWriteTag)
{
	deferWriteLevel -= 1;
	Write();
}

Json::Value Prefs::GetJson(const Json::Value &node, ByteString path)
{
	if (node.type() != Json::objectValue)
	{
		return Json::nullValue;
	}
	auto split = path.SplitBy('.');
	if (!split)
	{
		return node[path];
	}
	return GetJson(node[split.Before()], split.After());
}

void Prefs::SetJson(Json::Value &node, ByteString path, Json::Value value)
{
	if (node.type() != Json::objectValue)
	{
		node = Json::objectValue;
	}
	auto split = path.SplitBy('.');
	if (!split)
	{
		node[path] = value;
		return;
	}
	SetJson(node[split.Before()], split.After(), value);
}

template<> Json::Value Prefs::Bipacker<int>::Pack  (const int         &value) { return Json::Value(value); }
template<> int         Prefs::Bipacker<int>::Unpack(const Json::Value &value) { return value.asInt(); }

template<> Json::Value  Prefs::Bipacker<unsigned int>::Pack  (const unsigned int &value) { return Json::Value(value); }
template<> unsigned int Prefs::Bipacker<unsigned int>::Unpack(const Json::Value  &value) { return value.asUInt(); }

template<> Json::Value Prefs::Bipacker<uint64_t>::Pack  (const uint64_t    &value) { return Json::Value(Json::UInt64(value)); }
template<> uint64_t    Prefs::Bipacker<uint64_t>::Unpack(const Json::Value &value) { return value.asUInt64(); }

template<> Json::Value Prefs::Bipacker<float>::Pack  (const float       &value) { return Json::Value(value); }
template<> float       Prefs::Bipacker<float>::Unpack(const Json::Value &value) { return value.asFloat(); }

template<> Json::Value Prefs::Bipacker<bool>::Pack  (const bool        &value) { return Json::Value(value); }
template<> bool        Prefs::Bipacker<bool>::Unpack(const Json::Value &value) { return value.asBool(); }

template<> Json::Value Prefs::Bipacker<ByteString>::Pack  (const ByteString  &value) { return Json::Value(value); }
template<> ByteString  Prefs::Bipacker<ByteString>::Unpack(const Json::Value &value) { return value.asString(); }

template<> Json::Value Prefs::Bipacker<String>::Pack  (const String      &value) { return Json::Value(value.ToUtf8()); }
template<> String      Prefs::Bipacker<String>::Unpack(const Json::Value &value) { return ByteString(value.asString()).FromUtf8(); }

template<> Json::Value     Prefs::Bipacker<User::Elevation>::Pack  (const User::Elevation &value) { return Json::Value(User::ElevationToString(value)); }
template<> User::Elevation Prefs::Bipacker<User::Elevation>::Unpack(const Json::Value     &value) { return User::ElevationFromString(value.asString()); }

template<class Item>
struct Prefs::Bipacker<std::vector<Item>>
{
	static Json::Value Pack(const std::vector<Item> &value);
	static std::vector<Item> Unpack(const Json::Value &value);
};

template<class Item>
Json::Value Prefs::Bipacker<std::vector<Item>>::Pack(const std::vector<Item> &value)
{
	Json::Value array = Json::arrayValue;
	for (auto item : value)
	{
		array.append(Bipacker<Item>::Pack(item));
	}
	return array;
}

template<class Item>
std::vector<Item> Prefs::Bipacker<std::vector<Item>>::Unpack(const Json::Value &value)
{
	std::vector<Item> array;
	if (value.type() != Json::arrayValue)
	{
		throw std::exception();
	}
	for (auto &item : value)
	{
		array.push_back(Bipacker<Item>::Unpack(item));
	}
	return array;
}

template struct Prefs::Bipacker<std::vector<String>>;
template struct Prefs::Bipacker<std::vector<ByteString>>;
template struct Prefs::Bipacker<std::vector<unsigned int>>;


=== src\prefs\Prefs.h ===

#pragma once
#include "common/String.h"
#include <json/json.h>
#include <optional>

class Prefs
{
	struct DeferWriteTag
	{
	};

	Json::Value root;
	static Json::Value GetJson(const Json::Value &node, ByteString path);
	static void SetJson(Json::Value &node, ByteString path, Json::Value value);

	template<class Type>
	struct Bipacker
	{
		static Json::Value Pack(const Type &value);
		static Type Unpack(const Json::Value &value);
	};

	void Read();
	void Write();
	void ShouldWrite();
	unsigned int deferWriteLevel = 0;
	bool backedByFile = false;
	bool shouldWrite = false;

	ByteString path;

	Prefs(const Prefs &) = delete;
	Prefs &operator =(const Prefs &) = delete;

public:
	Prefs(ByteString path);

	template<class Type>
	std::optional<Type> Get(ByteString path) const
	{
		auto value = GetJson(root, path);
		if (value != Json::nullValue)
		{
			try
			{
				return Bipacker<Type>::Unpack(value);
			}
			catch (const std::exception &e)
			{
			}
		}
		return std::nullopt;
	}

	template<class Type>
	Type Get(ByteString path, Type defaultValue) const
	{
		auto value = Get<Type>(path);
		if (value)
		{
			return *value;
		}
		return defaultValue;
	}

	template<class Enum, class EnumBase = int>
	Enum Get(ByteString path, Enum numValues, Enum defaultValue) const
	{
		EnumBase value = Get(path, EnumBase(defaultValue));
		if (value < 0 || value >= EnumBase(numValues))
		{
			value = EnumBase(defaultValue);
		}
		return Enum(value);
	}

	template<class Type>
	void Set(ByteString path, Type value)
	{
		SetJson(root, path, Bipacker<Type>::Pack(value));
		ShouldWrite();
	}

	void Clear(ByteString path)
	{
		SetJson(root, path, Json::nullValue);
		ShouldWrite();
	}

	void GrabDeferWriteLevel(DeferWriteTag);
	void DropDeferWriteLevel(DeferWriteTag);

	struct DeferWrite
	{
		Prefs &prefs;

		DeferWrite(const DeferWrite &) = delete;
		DeferWrite &operator =(const DeferWrite &) = delete;

		DeferWrite(Prefs &newPrefs) : prefs(newPrefs)
		{
			prefs.GrabDeferWriteLevel({});
		}

		~DeferWrite()
		{
			prefs.DropDeferWriteLevel({});
		}
	};

	bool BackedByFile() const
	{
		return backedByFile;
	}
};


=== src\resampler\meson.build ===

resampler_files = files(
	'resampler.cpp',
)

common_files += resampler_files


=== src\resampler\resampler.cpp ===

#include "resampler.h"

#ifdef HIGH_QUALITY_RESAMPLE
// http://code.google.com/p/imageresampler/
// resampler.cpp, Separable filtering image rescaler v2.21, Rich Geldreich - richgel99@gmail.com
// See unlicense at the bottom of resampler.h, or at http://unlicense.org/
//
// Feb. 1996: Creation, losely based on a heavily bugfixed version of Schumacher's resampler in Graphics Gems 3.
// Oct. 2000: Ported to C++, tweaks.
// May 2001: Continuous to discrete mapping, box filter tweaks.
// March 9, 2002: Kaiser filter grabbed from Jonathan Blow's GD magazine mipmap sample code.
// Sept. 8, 2002: Comments cleaned up a bit.
// Dec. 31, 2008: v2.2: Bit more cleanup, released as public domain.
// June 4, 2012: v2.21: Switched to unlicense.org, integrated GCC fixes supplied by Peter Nagy <petern@crytek.com>, Anteru at anteru.net, and clay@coge.net,
// added Codeblocks project (for testing with MinGW and GCC), VS2008 static code analysis pass.

#include <cmath>
#include <cfloat>
#include <cassert>
#include <cstring>

#define resampler_assert assert

static inline int resampler_range_check(int v, int h) { (void)h; resampler_assert((v >= 0) && (v < h)); return v; }

#include <algorithm>

#ifndef TRUE
   #define TRUE (1)
#endif

#ifndef FALSE
   #define FALSE (0)
#endif

#define RESAMPLER_DEBUG 0

#include "common/tpt-compat.h"

// Float to int cast with truncation.
static inline int cast_to_int(Resample_Real i)
{
   return (int)i;
}

// (x mod y) with special handling for negative x values.
static inline int posmod(int x, int y)
{
   if (x >= 0)
      return (x % y);
   else
   {
      int m = (-x) % y;

      if (m != 0)
         m = y - m;

      return (m);
   }
}

// To add your own filter, insert the new function below and update the filter table.
// There is no need to make the filter function particularly fast, because it's
// only called during initializing to create the X and Y axis contributor tables.

#define BOX_FILTER_SUPPORT (0.5f)
static Resample_Real box_filter(Resample_Real t)    /* pulse/Fourier window */
{
   // make_clist() calls the filter function with t inverted (pos = left, neg = right)
   if ((t >= -0.5f) && (t < 0.5f))
      return 1.0f;
   else
      return 0.0f;
}

#define TENT_FILTER_SUPPORT (1.0f)
static Resample_Real tent_filter(Resample_Real t)   /* box (*) box, bilinear/triangle */
{
   if (t < 0.0f)
      t = -t;

   if (t < 1.0f)
      return 1.0f - t;
   else
      return 0.0f;
}

#define BELL_SUPPORT (1.5f)
static Resample_Real bell_filter(Resample_Real t)    /* box (*) box (*) box */
{
   if (t < 0.0f)
      t = -t;

   if (t < .5f)
      return (.75f - (t * t));

   if (t < 1.5f)
   {
      t = (t - 1.5f);
      return (.5f * (t * t));
   }

   return (0.0f);
}

#define B_SPLINE_SUPPORT (2.0f)
static Resample_Real B_spline_filter(Resample_Real t)  /* box (*) box (*) box (*) box */
{
   Resample_Real tt;

   if (t < 0.0f)
      t = -t;

   if (t < 1.0f)
   {
      tt = t * t;
      return ((.5f * tt * t) - tt + (2.0f / 3.0f));
   }
   else if (t < 2.0f)
   {
      t = 2.0f - t;
      return ((1.0f / 6.0f) * (t * t * t));
   }

   return (0.0f);
}

// Dodgson, N., "Quadratic Interpolation for Image Resampling"
#define QUADRATIC_SUPPORT 1.5f
static Resample_Real quadratic(Resample_Real t, const Resample_Real R)
{
   if (t < 0.0f)
      t = -t;
   if (t < QUADRATIC_SUPPORT)
   {
      Resample_Real tt = t * t;
      if (t <= .5f)
         return (-2.0f * R) * tt + .5f * (R + 1.0f);
      else
         return (R * tt) + (-2.0f * R - .5f) * t + (3.0f / 4.0f) * (R + 1.0f);
   }
   else
      return 0.0f;
}

static Resample_Real quadratic_interp_filter(Resample_Real t)
{
   return quadratic(t, 1.0f);
}

static Resample_Real quadratic_approx_filter(Resample_Real t)
{
   return quadratic(t, .5f);
}

static Resample_Real quadratic_mix_filter(Resample_Real t)
{
   return quadratic(t, .8f);
}

// Mitchell, D. and A. Netravali, "Reconstruction Filters in Computer Graphics."
// Computer Graphics, Vol. 22, No. 4, pp. 221-228.
// (B, C)
// (1/3, 1/3)  - Defaults recommended by Mitchell and Netravali
// (1, 0)	   - Equivalent to the Cubic B-Spline
// (0, 0.5)		- Equivalent to the Catmull-Rom Spline
// (0, C)		- The family of Cardinal Cubic Splines
// (B, 0)		- Duff's tensioned B-Splines.
static Resample_Real mitchell(Resample_Real t, const Resample_Real B, const Resample_Real C)
{
   Resample_Real tt;

   tt = t * t;

   if(t < 0.0f)
      t = -t;

   if(t < 1.0f)
   {
      t = (((12.0f - 9.0f * B - 6.0f * C) * (t * tt))
         + ((-18.0f + 12.0f * B + 6.0f * C) * tt)
         + (6.0f - 2.0f * B));

      return (t / 6.0f);
   }
   else if (t < 2.0f)
   {
      t = (((-1.0f * B - 6.0f * C) * (t * tt))
         + ((6.0f * B + 30.0f * C) * tt)
         + ((-12.0f * B - 48.0f * C) * t)
         + (8.0f * B + 24.0f * C));

      return (t / 6.0f);
   }

   return (0.0f);
}

#define MITCHELL_SUPPORT (2.0f)
static Resample_Real mitchell_filter(Resample_Real t)
{
   return mitchell(t, 1.0f / 3.0f, 1.0f / 3.0f);
}

#define CATMULL_ROM_SUPPORT (2.0f)
static Resample_Real catmull_rom_filter(Resample_Real t)
{
   return mitchell(t, 0.0f, .5f);
}

static double sinc(double x)
{
   x = (x * TPT_PI_DBL);

   if ((x < 0.01f) && (x > -0.01f))
      return 1.0f + x*x*(-1.0f/6.0f + x*x*1.0f/120.0f);

   return sin(x) / x;
}

static Resample_Real clean(double t)
{
   const Resample_Real EPSILON = .0000125f;
   if (fabs(t) < EPSILON)
      return 0.0f;
   return (Resample_Real)t;
}

//static double blackman_window(double x)
//{
//	return .42f + .50f * cos(TPT_PI_DBL*x) + .08f * cos(2.0f*TPT_PI_DBL*x);
//}

static double blackman_exact_window(double x)
{
   return 0.42659071f + 0.49656062f * cos(TPT_PI_DBL*x) + 0.07684867f * cos(2.0f*TPT_PI_DBL*x);
}

#define BLACKMAN_SUPPORT (3.0f)
static Resample_Real blackman_filter(Resample_Real t)
{
   if (t < 0.0f)
      t = -t;

   if (t < 3.0f)
      //return clean(sinc(t) * blackman_window(t / 3.0f));
      return clean(sinc(t) * blackman_exact_window(t / 3.0f));
   else
      return (0.0f);
}

#define GAUSSIAN_SUPPORT (1.25f)
static Resample_Real gaussian_filter(Resample_Real t) // with blackman window
{
   if (t < 0)
      t = -t;
   if (t < GAUSSIAN_SUPPORT)
      return clean(exp(-2.0f * t * t) * sqrt(2.0f / TPT_PI_DBL) * blackman_exact_window(t / GAUSSIAN_SUPPORT));
   else
      return 0.0f;
}

// Windowed sinc -- see "Jimm Blinn's Corner: Dirty Pixels" pg. 26.
#define LANCZOS3_SUPPORT (3.0f)
static Resample_Real lanczos3_filter(Resample_Real t)
{
   if (t < 0.0f)
      t = -t;

   if (t < 3.0f)
      return clean(sinc(t) * sinc(t / 3.0f));
   else
      return (0.0f);
}

#define LANCZOS4_SUPPORT (4.0f)
static Resample_Real lanczos4_filter(Resample_Real t)
{
   if (t < 0.0f)
      t = -t;

   if (t < 4.0f)
      return clean(sinc(t) * sinc(t / 4.0f));
   else
      return (0.0f);
}

#define LANCZOS6_SUPPORT (6.0f)
static Resample_Real lanczos6_filter(Resample_Real t)
{
   if (t < 0.0f)
      t = -t;

   if (t < 6.0f)
      return clean(sinc(t) * sinc(t / 6.0f));
   else
      return (0.0f);
}

#define LANCZOS12_SUPPORT (12.0f)
static Resample_Real lanczos12_filter(Resample_Real t)
{
   if (t < 0.0f)
      t = -t;

   if (t < 12.0f)
      return clean(sinc(t) * sinc(t / 12.0f));
   else
      return (0.0f);
}

static double bessel0(double x)
{
   const double EPSILON_RATIO = 1E-16;
   double xh, sum, pow, ds;
   int k;

   xh = 0.5 * x;
   sum = 1.0;
   pow = 1.0;
   k = 0;
   ds = 1.0;
   while (ds > sum * EPSILON_RATIO) // FIXME: Shouldn't this stop after X iterations for max. safety?
   {
      ++k;
      pow = pow * (xh / k);
      ds = pow * pow;
      sum = sum + ds;
   }

   return sum;
}

//static const Resample_Real KAISER_ALPHA = 4.0;
static double kaiser(double alpha, double half_width, double x)
{
   const double ratio = (x / half_width);
   return bessel0(alpha * sqrt(1 - ratio * ratio)) / bessel0(alpha);
}

#define KAISER_SUPPORT 3
static Resample_Real kaiser_filter(Resample_Real t)
{
   if (t < 0.0f)
      t = -t;

   if (t < KAISER_SUPPORT)
   {
      // db atten
      const Resample_Real att = 40.0f;
      const Resample_Real alpha = (Resample_Real)(exp(log((double)0.58417 * (att - 20.96)) * 0.4) + 0.07886 * (att - 20.96));
      //const Resample_Real alpha = KAISER_ALPHA;
      return (Resample_Real)clean(sinc(t) * kaiser(alpha, KAISER_SUPPORT, t));
   }

   return 0.0f;
}

// filters[] is a list of all the available filter functions.
static struct
{
   char name[32];
   Resample_Real (*func)(Resample_Real t);
   Resample_Real support;
} g_filters[] =
{
   { "box",		            box_filter,			         BOX_FILTER_SUPPORT },
   { "tent",			      tent_filter,		         TENT_FILTER_SUPPORT },
   { "bell",			      bell_filter,	            BELL_SUPPORT },
   { "b-spline",	         B_spline_filter,	         B_SPLINE_SUPPORT },
   { "mitchell",	         mitchell_filter,	         MITCHELL_SUPPORT },
   { "lanczos3",	         lanczos3_filter,	         LANCZOS3_SUPPORT },
   { "blackman",	         blackman_filter,	         BLACKMAN_SUPPORT },
   { "lanczos4",	         lanczos4_filter,	         LANCZOS4_SUPPORT },
   { "lanczos6",	         lanczos6_filter,	         LANCZOS6_SUPPORT },
   { "lanczos12",          lanczos12_filter,          LANCZOS12_SUPPORT },
   { "kaiser",		         kaiser_filter,		         KAISER_SUPPORT },
   { "gaussian",	         gaussian_filter,	         GAUSSIAN_SUPPORT },
   { "catmullrom",         catmull_rom_filter,        CATMULL_ROM_SUPPORT },
   { "quadratic_interp",   quadratic_interp_filter,   QUADRATIC_SUPPORT },
   { "quadratic_approx",   quadratic_approx_filter,   QUADRATIC_SUPPORT },
   { "quadratic_mix",      quadratic_mix_filter,      QUADRATIC_SUPPORT },
};

static const int NUM_FILTERS = sizeof(g_filters) / sizeof(g_filters[0]);

/* Ensure that the contributing source sample is
* within bounds. If not, reflect, clamp, or wrap.
*/
int Resampler::reflect(const int j, const int src_x, const Boundary_Op boundary_op)
{
   int n;

   if (j < 0)
   {
      if (boundary_op == BOUNDARY_REFLECT)
      {
         n = -j;

         if (n >= src_x)
            n = src_x - 1;
      }
      else if (boundary_op == BOUNDARY_WRAP)
         n = posmod(j, src_x);
      else
         n = 0;
   }
   else if (j >= src_x)
   {
      if (boundary_op == BOUNDARY_REFLECT)
      {
         n = (src_x - j) + (src_x - 1);

         if (n < 0)
            n = 0;
      }
      else if (boundary_op == BOUNDARY_WRAP)
         n = posmod(j, src_x);
      else
         n = src_x - 1;
   }
   else
      n = j;

   return n;
}

// The make_clist() method generates, for all destination samples,
// the list of all source samples with non-zero weighted contributions.
Resampler::Contrib_List* Resampler::make_clist(
   int src_x, int dst_x, Boundary_Op boundary_op,
   Resample_Real (*Pfilter)(Resample_Real),
   Resample_Real filter_support,
   Resample_Real filter_scale,
   Resample_Real src_ofs)
{
   typedef struct
   {
      // The center of the range in DISCRETE coordinates (pixel center = 0.0f).
      Resample_Real center;
      int left, right;
   } Contrib_Bounds;

   int i, j, k, n, left, right;
   Resample_Real total_weight;
   Resample_Real xscale, center, half_width, weight;
   Contrib_List* Pcontrib;
   Contrib* Pcpool;
   Contrib* Pcpool_next;
   Contrib_Bounds* Pcontrib_bounds;

   if ((Pcontrib = (Contrib_List*)calloc(dst_x, sizeof(Contrib_List))) == nullptr)
      return nullptr;

   Pcontrib_bounds = (Contrib_Bounds*)calloc(dst_x, sizeof(Contrib_Bounds));
   if (!Pcontrib_bounds)
   {
      free(Pcontrib);
      return (nullptr);
   }

   const Resample_Real oo_filter_scale = 1.0f / filter_scale;

   const Resample_Real NUDGE = 0.5f;
   xscale = dst_x / (Resample_Real)src_x;

   if (xscale < 1.0f)
   {
      int total; (void)total;

      /* Handle case when there are fewer destination
      * samples than source samples (downsampling/minification).
      */

      // stretched half width of filter
      half_width = (filter_support / xscale) * filter_scale;

      // Find the range of source sample(s) that will contribute to each destination sample.

      for (i = 0, n = 0; i < dst_x; i++)
      {
         // Convert from discrete to continuous coordinates, scale, then convert back to discrete.
         center = ((Resample_Real)i + NUDGE) / xscale;
         center -= NUDGE;
         center += src_ofs;

         left   = cast_to_int((Resample_Real)floor(center - half_width));
         right  = cast_to_int((Resample_Real)ceil(center + half_width));

         Pcontrib_bounds[i].center = center;
         Pcontrib_bounds[i].left		= left;
         Pcontrib_bounds[i].right	= right;

         n += (right - left + 1);
      }

      /* Allocate memory for contributors. */

      if ((n == 0) || ((Pcpool = (Contrib*)calloc(n, sizeof(Contrib))) == nullptr))
      {
         free(Pcontrib);
         free(Pcontrib_bounds);
         return nullptr;
      }
      total = n;

      Pcpool_next = Pcpool;

      /* Create the list of source samples which
      * contribute to each destination sample.
      */

      for (i = 0; i < dst_x; i++)
      {
         int max_k = -1;
         Resample_Real max_w = -1e+20f;

         center = Pcontrib_bounds[i].center;
         left   = Pcontrib_bounds[i].left;
         right  = Pcontrib_bounds[i].right;

         Pcontrib[i].n = 0;
         Pcontrib[i].p = Pcpool_next;
         Pcpool_next += (right - left + 1);
         resampler_assert ((Pcpool_next - Pcpool) <= total);

         total_weight = 0;

         for (j = left; j <= right; j++)
            total_weight += (*Pfilter)((center - (Resample_Real)j) * xscale * oo_filter_scale);
         const Resample_Real norm = static_cast<Resample_Real>(1.0f / total_weight);

         total_weight = 0;

#if RESAMPLER_DEBUG
         printf("%i: ", i);
#endif

         for (j = left; j <= right; j++)
         {
            weight = (*Pfilter)((center - (Resample_Real)j) * xscale * oo_filter_scale) * norm;
            if (weight == 0.0f)
               continue;

            n = reflect(j, src_x, boundary_op);

#if RESAMPLER_DEBUG
            printf("%i(%f), ", n, weight);
#endif

            /* Increment the number of source
            * samples which contribute to the
            * current destination sample.
            */

            k = Pcontrib[i].n++;

            Pcontrib[i].p[k].pixel  = (unsigned short)(n);       /* store src sample number */
            Pcontrib[i].p[k].weight = weight; /* store src sample weight */

            total_weight += weight;          /* total weight of all contributors */

            if (weight > max_w)
            {
               max_w = weight;
               max_k = k;
            }
         }

#if RESAMPLER_DEBUG
         printf("\n\n");
#endif

         //resampler_assert(Pcontrib[i].n);
         //resampler_assert(max_k != -1);
         if ((max_k == -1) || (Pcontrib[i].n == 0))
         {
            free(Pcpool);
            free(Pcontrib);
            free(Pcontrib_bounds);
            return nullptr;
         }

         if (total_weight != 1.0f)
            Pcontrib[i].p[max_k].weight += 1.0f - total_weight;
      }
   }
   else
   {
      /* Handle case when there are more
      * destination samples than source
      * samples (upsampling).
      */

      half_width = filter_support * filter_scale;

      // Find the source sample(s) that contribute to each destination sample.

      for (i = 0, n = 0; i < dst_x; i++)
      {
         // Convert from discrete to continuous coordinates, scale, then convert back to discrete.
         center = ((Resample_Real)i + NUDGE) / xscale;
         center -= NUDGE;
         center += src_ofs;

         left   = cast_to_int((Resample_Real)floor(center - half_width));
         right  = cast_to_int((Resample_Real)ceil(center + half_width));

         Pcontrib_bounds[i].center = center;
         Pcontrib_bounds[i].left		= left;
         Pcontrib_bounds[i].right	= right;

         n += (right - left + 1);
      }

      /* Allocate memory for contributors. */

      int total = n;
      if ((total == 0) || ((Pcpool = (Contrib*)calloc(total, sizeof(Contrib))) == nullptr))
      {
         free(Pcontrib);
         free(Pcontrib_bounds);
         return nullptr;
      }

      Pcpool_next = Pcpool;

      /* Create the list of source samples which
      * contribute to each destination sample.
      */

      for (i = 0; i < dst_x; i++)
      {
         int max_k = -1;
         Resample_Real max_w = -1e+20f;

         center = Pcontrib_bounds[i].center;
         left   = Pcontrib_bounds[i].left;
         right  = Pcontrib_bounds[i].right;

         Pcontrib[i].n = 0;
         Pcontrib[i].p = Pcpool_next;
         Pcpool_next += (right - left + 1);
         resampler_assert((Pcpool_next - Pcpool) <= total);

         total_weight = 0;
         for (j = left; j <= right; j++)
            total_weight += (*Pfilter)((center - (Resample_Real)j) * oo_filter_scale);

         const Resample_Real norm = static_cast<Resample_Real>(1.0f / total_weight);

         total_weight = 0;

#if RESAMPLER_DEBUG
         printf("%i: ", i);
#endif

         for (j = left; j <= right; j++)
         {
            weight = (*Pfilter)((center - (Resample_Real)j) * oo_filter_scale) * norm;
            if (weight == 0.0f)
               continue;

            n = reflect(j, src_x, boundary_op);

#if RESAMPLER_DEBUG
            printf("%i(%f), ", n, weight);
#endif

            /* Increment the number of source
            * samples which contribute to the
            * current destination sample.
            */

            k = Pcontrib[i].n++;

            Pcontrib[i].p[k].pixel  = (unsigned short)(n);       /* store src sample number */
            Pcontrib[i].p[k].weight = weight; /* store src sample weight */

            total_weight += weight;          /* total weight of all contributors */

            if (weight > max_w)
            {
               max_w = weight;
               max_k = k;
            }
         }

#if RESAMPLER_DEBUG
         printf("\n\n");
#endif

         //resampler_assert(Pcontrib[i].n);
         //resampler_assert(max_k != -1);

         if ((max_k == -1) || (Pcontrib[i].n == 0))
         {
            free(Pcpool);
            free(Pcontrib);
            free(Pcontrib_bounds);
            return nullptr;
         }

         if (total_weight != 1.0f)
            Pcontrib[i].p[max_k].weight += 1.0f - total_weight;
      }
   }

#if RESAMPLER_DEBUG
   printf("*******\n");
#endif

   free(Pcontrib_bounds);

   return Pcontrib;
}

void Resampler::resample_x(Sample* Pdst, const Sample* Psrc)
{
   resampler_assert(Pdst);
   resampler_assert(Psrc);

   int i, j;
   Sample total;
   Contrib_List *Pclist = m_Pclist_x;
   Contrib *p;

   for (i = m_resample_dst_x; i > 0; i--, Pclist++)
   {
#if RESAMPLER_DEBUG_OPS
      total_ops += Pclist->n;
#endif

      for (j = Pclist->n, p = Pclist->p, total = 0; j > 0; j--, p++)
         total += Psrc[p->pixel] * p->weight;

      *Pdst++ = total;
   }
}

void Resampler::scale_y_mov(Sample* Ptmp, const Sample* Psrc, Resample_Real weight, int dst_x)
{
   int i;

#if RESAMPLER_DEBUG_OPS
   total_ops += dst_x;
#endif

   // Not += because temp buf wasn't cleared.
   for (i = dst_x; i > 0; i--)
      *Ptmp++ = *Psrc++ * weight;
}

void Resampler::scale_y_add(Sample* Ptmp, const Sample* Psrc, Resample_Real weight, int dst_x)
{
#if RESAMPLER_DEBUG_OPS
   total_ops += dst_x;
#endif

   for (int i = dst_x; i > 0; i--)
      (*Ptmp++) += *Psrc++ * weight;
}

void Resampler::clamp(Sample* Pdst, int n)
{
   while (n > 0)
   {
      *Pdst = clamp_sample(*Pdst);
      ++Pdst;
      n--;
   }
}

void Resampler::resample_y(Sample* Pdst)
{
   int i, j;
   Sample* Psrc;
   Contrib_List* Pclist = &m_Pclist_y[m_cur_dst_y];

   Sample* Ptmp = m_delay_x_resample ? m_Ptmp_buf : Pdst;
   resampler_assert(Ptmp);

   /* Process each contributor. */

   for (i = 0; i < Pclist->n; i++)
   {
      /* locate the contributor's location in the scan
      * buffer -- the contributor must always be found!
      */

      for (j = 0; j < MAX_SCAN_BUF_SIZE; j++)
         if (m_Pscan_buf->scan_buf_y[j] == Pclist->p[i].pixel)
            break;

      resampler_assert(j < MAX_SCAN_BUF_SIZE);

      Psrc = m_Pscan_buf->scan_buf_l[j];

      if (!i)
         scale_y_mov(Ptmp, Psrc, Pclist->p[i].weight, m_intermediate_x);
      else
         scale_y_add(Ptmp, Psrc, Pclist->p[i].weight, m_intermediate_x);

      /* If this source line doesn't contribute to any
      * more destination lines then mark the scanline buffer slot
      * which holds this source line as free.
      * (The max. number of slots used depends on the Y
      * axis sampling factor and the scaled filter width.)
      */

      if (--m_Psrc_y_count[resampler_range_check(Pclist->p[i].pixel, m_resample_src_y)] == 0)
      {
         m_Psrc_y_flag[resampler_range_check(Pclist->p[i].pixel, m_resample_src_y)] = FALSE;
         m_Pscan_buf->scan_buf_y[j] = -1;
      }
   }

   /* Now generate the destination line */

   if (m_delay_x_resample) // Was X resampling delayed until after Y resampling?
   {
      resampler_assert(Pdst != Ptmp);
      resample_x(Pdst, Ptmp);
   }
   else
   {
      resampler_assert(Pdst == Ptmp);
   }

   if (m_lo < m_hi)
      clamp(Pdst, m_resample_dst_x);
}

bool Resampler::put_line(const Sample* Psrc)
{
   int i;

   if (m_cur_src_y >= m_resample_src_y)
      return false;

   /* Does this source line contribute
   * to any destination line? if not,
   * exit now.
   */

   if (!m_Psrc_y_count[resampler_range_check(m_cur_src_y, m_resample_src_y)])
   {
      m_cur_src_y++;
      return true;
   }

   /* Find an empty slot in the scanline buffer. (FIXME: Perf. is terrible here with extreme scaling ratios.) */

   for (i = 0; i < MAX_SCAN_BUF_SIZE; i++)
      if (m_Pscan_buf->scan_buf_y[i] == -1)
         break;

   /* If the buffer is full, exit with an error. */

   if (i == MAX_SCAN_BUF_SIZE)
   {
      m_status = STATUS_SCAN_BUFFER_FULL;
      return false;
   }

   m_Psrc_y_flag[resampler_range_check(m_cur_src_y, m_resample_src_y)] = TRUE;
   m_Pscan_buf->scan_buf_y[i]  = m_cur_src_y;

   /* Does this slot have any memory allocated to it? */

   if (!m_Pscan_buf->scan_buf_l[i])
   {
      if ((m_Pscan_buf->scan_buf_l[i] = (Sample*)malloc(m_intermediate_x * sizeof(Sample))) == nullptr)
      {
         m_status = STATUS_OUT_OF_MEMORY;
         return false;
      }
   }

   // Resampling on the X axis first?
   if (m_delay_x_resample)
   {
      resampler_assert(m_intermediate_x == m_resample_src_x);

      // Y-X resampling order
      memcpy(m_Pscan_buf->scan_buf_l[i], Psrc, m_intermediate_x * sizeof(Sample));
   }
   else
   {
      resampler_assert(m_intermediate_x == m_resample_dst_x);

      // X-Y resampling order
      resample_x(m_Pscan_buf->scan_buf_l[i], Psrc);
   }

   m_cur_src_y++;

   return true;
}

const Resampler::Sample* Resampler::get_line()
{
   int i;

   /* If all the destination lines have been
   * generated, then always return NULL.
   */

   if (m_cur_dst_y == m_resample_dst_y)
      return nullptr;

   /* Check to see if all the required
   * contributors are present, if not,
   * return NULL.
   */

   for (i = 0; i < m_Pclist_y[m_cur_dst_y].n; i++)
      if (!m_Psrc_y_flag[resampler_range_check(m_Pclist_y[m_cur_dst_y].p[i].pixel, m_resample_src_y)])
         return nullptr;

   resample_y(m_Pdst_buf);

   m_cur_dst_y++;

   return m_Pdst_buf;
}

Resampler::~Resampler()
{
   int i;

#if RESAMPLER_DEBUG_OPS
   printf("actual ops: %i\n", total_ops);
#endif

   free(m_Pdst_buf);
   m_Pdst_buf = nullptr;

   if (m_Ptmp_buf)
   {
      free(m_Ptmp_buf);
      m_Ptmp_buf = nullptr;
   }

   /* Don't deallocate a contibutor list
   * if the user passed us one of their own.
   */

   if ((m_Pclist_x) && (!m_clist_x_forced))
   {
      free(m_Pclist_x->p);
      free(m_Pclist_x);
      m_Pclist_x = nullptr;
   }

   if ((m_Pclist_y) && (!m_clist_y_forced))
   {
      free(m_Pclist_y->p);
      free(m_Pclist_y);
      m_Pclist_y = nullptr;
   }

   free(m_Psrc_y_count);
   m_Psrc_y_count = nullptr;

   free(m_Psrc_y_flag);
   m_Psrc_y_flag = nullptr;

   if (m_Pscan_buf)
   {
      for (i = 0; i < MAX_SCAN_BUF_SIZE; i++)
         free(m_Pscan_buf->scan_buf_l[i]);

      free(m_Pscan_buf);
      m_Pscan_buf = nullptr;
   }
}

void Resampler::restart()
{
   if (STATUS_OKAY != m_status)
      return;

   m_cur_src_y = m_cur_dst_y = 0;

   int i, j;
   for (i = 0; i < m_resample_src_y; i++)
   {
      m_Psrc_y_count[i] = 0;
      m_Psrc_y_flag[i] = FALSE;
   }

   for (i = 0; i < m_resample_dst_y; i++)
   {
      for (j = 0; j < m_Pclist_y[i].n; j++)
         m_Psrc_y_count[resampler_range_check(m_Pclist_y[i].p[j].pixel, m_resample_src_y)]++;
   }

   for (i = 0; i < MAX_SCAN_BUF_SIZE; i++)
   {
      m_Pscan_buf->scan_buf_y[i] = -1;

      free(m_Pscan_buf->scan_buf_l[i]);
      m_Pscan_buf->scan_buf_l[i] = nullptr;
   }
}

Resampler::Resampler(int src_x, int src_y,
                     int dst_x, int dst_y,
                     Boundary_Op boundary_op,
                     Resample_Real sample_low, Resample_Real sample_high,
                     const char* Pfilter_name,
                     Contrib_List* Pclist_x,
                     Contrib_List* Pclist_y,
                     Resample_Real filter_x_scale,
                     Resample_Real filter_y_scale,
                     Resample_Real src_x_ofs,
                     Resample_Real src_y_ofs)
{
   int i, j;
   Resample_Real support, (*func)(Resample_Real);

   resampler_assert(src_x > 0);
   resampler_assert(src_y > 0);
   resampler_assert(dst_x > 0);
   resampler_assert(dst_y > 0);

#if RESAMPLER_DEBUG_OPS
   total_ops = 0;
#endif

   m_lo = sample_low;
   m_hi = sample_high;

   m_delay_x_resample = false;
   m_intermediate_x = 0;
   m_Pdst_buf = nullptr;
   m_Ptmp_buf = nullptr;
   m_clist_x_forced = false;
   m_Pclist_x = nullptr;
   m_clist_y_forced = false;
   m_Pclist_y = nullptr;
   m_Psrc_y_count = nullptr;
   m_Psrc_y_flag = nullptr;
   m_Pscan_buf = nullptr;
   m_status = STATUS_OKAY;

   m_resample_src_x = src_x;
   m_resample_src_y = src_y;
   m_resample_dst_x = dst_x;
   m_resample_dst_y = dst_y;

   m_boundary_op = boundary_op;

   if ((m_Pdst_buf = (Sample*)malloc(m_resample_dst_x * sizeof(Sample))) == nullptr)
   {
      m_status = STATUS_OUT_OF_MEMORY;
      return;
   }

   // Find the specified filter.

   if (Pfilter_name == nullptr)
      Pfilter_name = RESAMPLER_DEFAULT_FILTER;

   for (i = 0; i < NUM_FILTERS; i++)
      if (strcmp(Pfilter_name, g_filters[i].name) == 0)
         break;

   if (i == NUM_FILTERS)
   {
      m_status = STATUS_BAD_FILTER_NAME;
      return;
   }

   func = g_filters[i].func;
   support = g_filters[i].support;

   /* Create contributor lists, unless the user supplied custom lists. */

   if (!Pclist_x)
   {
      m_Pclist_x = make_clist(m_resample_src_x, m_resample_dst_x, m_boundary_op, func, support, filter_x_scale, src_x_ofs);
      if (!m_Pclist_x)
      {
         m_status = STATUS_OUT_OF_MEMORY;
         return;
      }
   }
   else
   {
      m_Pclist_x = Pclist_x;
      m_clist_x_forced = true;
   }

   if (!Pclist_y)
   {
      m_Pclist_y = make_clist(m_resample_src_y, m_resample_dst_y, m_boundary_op, func, support, filter_y_scale, src_y_ofs);
      if (!m_Pclist_y)
      {
         m_status = STATUS_OUT_OF_MEMORY;
         return;
      }
   }
   else
   {
      m_Pclist_y = Pclist_y;
      m_clist_y_forced = true;
   }

   if ((m_Psrc_y_count = (int*)calloc(m_resample_src_y, sizeof(int))) == nullptr)
   {
      m_status = STATUS_OUT_OF_MEMORY;
      return;
   }

   if ((m_Psrc_y_flag = (unsigned char*)calloc(m_resample_src_y, sizeof(unsigned char))) == nullptr)
   {
      m_status = STATUS_OUT_OF_MEMORY;
      return;
   }

   /* Count how many times each source line
   * contributes to a destination line.
   */

   for (i = 0; i < m_resample_dst_y; i++)
      for (j = 0; j < m_Pclist_y[i].n; j++)
         m_Psrc_y_count[resampler_range_check(m_Pclist_y[i].p[j].pixel, m_resample_src_y)]++;

   if ((m_Pscan_buf = (Scan_Buf*)malloc(sizeof(Scan_Buf))) == nullptr)
   {
      m_status = STATUS_OUT_OF_MEMORY;
      return;
   }

   for (i = 0; i < MAX_SCAN_BUF_SIZE; i++)
   {
      m_Pscan_buf->scan_buf_y[i] = -1;
      m_Pscan_buf->scan_buf_l[i] = nullptr;
   }

   m_cur_src_y = m_cur_dst_y = 0;
   {
      // Determine which axis to resample first by comparing the number of multiplies required
      // for each possibility.
      int x_ops = count_ops(m_Pclist_x, m_resample_dst_x);
      int y_ops = count_ops(m_Pclist_y, m_resample_dst_y);

      // Hack 10/2000: Weight Y axis ops a little more than X axis ops.
      // (Y axis ops use more cache resources.)
      int xy_ops = x_ops * m_resample_src_y +
         (4 * y_ops * m_resample_dst_x)/3;

      int yx_ops = (4 * y_ops * m_resample_src_x)/3 +
         x_ops * m_resample_dst_y;

#if RESAMPLER_DEBUG_OPS
      printf("src: %i %i\n", m_resample_src_x, m_resample_src_y);
      printf("dst: %i %i\n", m_resample_dst_x, m_resample_dst_y);
      printf("x_ops: %i\n", x_ops);
      printf("y_ops: %i\n", y_ops);
      printf("xy_ops: %i\n", xy_ops);
      printf("yx_ops: %i\n", yx_ops);
#endif

      // Now check which resample order is better. In case of a tie, choose the order
      // which buffers the least amount of data.
      if ((xy_ops > yx_ops) ||
         ((xy_ops == yx_ops) && (m_resample_src_x < m_resample_dst_x))
         )
      {
         m_delay_x_resample = true;
         m_intermediate_x = m_resample_src_x;
      }
      else
      {
         m_delay_x_resample = false;
         m_intermediate_x = m_resample_dst_x;
      }
#if RESAMPLER_DEBUG_OPS
      printf("delaying: %i\n", m_delay_x_resample);
#endif
   }

   if (m_delay_x_resample)
   {
      if ((m_Ptmp_buf = (Sample*)malloc(m_intermediate_x * sizeof(Sample))) == nullptr)
      {
         m_status = STATUS_OUT_OF_MEMORY;
         return;
      }
   }
}

void Resampler::get_clists(Contrib_List** ptr_clist_x, Contrib_List** ptr_clist_y)
{
   if (ptr_clist_x)
      *ptr_clist_x = m_Pclist_x;

   if (ptr_clist_y)
      *ptr_clist_y = m_Pclist_y;
}

int Resampler::get_filter_num()
{
   return NUM_FILTERS;
}

char* Resampler::get_filter_name(int filter_num)
{
   if ((filter_num < 0) || (filter_num >= NUM_FILTERS))
      return nullptr;
   else
      return g_filters[filter_num].name;
}

#endif


=== src\resampler\resampler.h ===

// http://code.google.com/p/imageresampler/
// resampler.h, Separable filtering image rescaler v2.21, Rich Geldreich - richgel99@gmail.com
// See unlicense.org text at the bottom of this file.
#pragma once
#include <cstdlib>

#define HIGH_QUALITY_RESAMPLE

#define RESAMPLER_DEBUG_OPS 0
#define RESAMPLER_DEFAULT_FILTER "lanczos4"

#define RESAMPLER_MAX_DIMENSION 16384

// float or double
typedef float Resample_Real;

class Resampler
{
public:
   typedef Resample_Real Sample;

   struct Contrib
   {
      Resample_Real weight;
      unsigned short pixel;
   };

   struct Contrib_List
   {
      unsigned short n;
      Contrib* p;
   };

   enum Boundary_Op
   {
      BOUNDARY_WRAP = 0,
      BOUNDARY_REFLECT = 1,
      BOUNDARY_CLAMP = 2
   };

   enum Status
   {
      STATUS_OKAY = 0,
      STATUS_OUT_OF_MEMORY = 1,
      STATUS_BAD_FILTER_NAME = 2,
      STATUS_SCAN_BUFFER_FULL = 3
   };

   // src_x/src_y - Input dimensions
   // dst_x/dst_y - Output dimensions
   // boundary_op - How to sample pixels near the image boundaries
   // sample_low/sample_high - Clamp output samples to specified range, or disable clamping if sample_low >= sample_high
   // Pclist_x/Pclist_y - Optional pointers to contributor lists from another instance of a Resampler
   // src_x_ofs/src_y_ofs - Offset input image by specified amount (fractional values okay)
   Resampler(
      int src_x, int src_y,
      int dst_x, int dst_y,
      Boundary_Op boundary_op = BOUNDARY_CLAMP,
      Resample_Real sample_low = 0.0f, Resample_Real sample_high = 0.0f,
      const char* Pfilter_name = RESAMPLER_DEFAULT_FILTER,
      Contrib_List* Pclist_x = NULL,
      Contrib_List* Pclist_y = NULL,
      Resample_Real filter_x_scale = 1.0f,
      Resample_Real filter_y_scale = 1.0f,
      Resample_Real src_x_ofs = 0.0f,
      Resample_Real src_y_ofs = 0.0f);

   ~Resampler();

   // Reinits resampler so it can handle another frame.
   void restart();

   // false on out of memory.
   bool put_line(const Sample* Psrc);

   // NULL if no scanlines are currently available (give the resampler more scanlines!)
   const Sample* get_line();

   Status status() const { return m_status; }

   // Returned contributor lists can be shared with another Resampler.
   void get_clists(Contrib_List** ptr_clist_x, Contrib_List** ptr_clist_y);
   Contrib_List* get_clist_x() const {	return m_Pclist_x; }
   Contrib_List* get_clist_y() const {	return m_Pclist_y; }

   // Filter accessors.
   static int get_filter_num();
   static char* get_filter_name(int filter_num);

private:
   Resampler();
   Resampler(const Resampler& o);
   Resampler& operator= (const Resampler& o);

#ifdef RESAMPLER_DEBUG_OPS
   int total_ops;
#endif

   int m_intermediate_x;

   int m_resample_src_x;
   int m_resample_src_y;
   int m_resample_dst_x;
   int m_resample_dst_y;

   Boundary_Op m_boundary_op;

   Sample* m_Pdst_buf;
   Sample* m_Ptmp_buf;

   Contrib_List* m_Pclist_x;
   Contrib_List* m_Pclist_y;

   bool m_clist_x_forced;
   bool m_clist_y_forced;

   bool m_delay_x_resample;

   int* m_Psrc_y_count;
   unsigned char* m_Psrc_y_flag;

   // The maximum number of scanlines that can be buffered at one time.
   enum { MAX_SCAN_BUF_SIZE = RESAMPLER_MAX_DIMENSION };

   struct Scan_Buf
   {
      int scan_buf_y[MAX_SCAN_BUF_SIZE];
      Sample* scan_buf_l[MAX_SCAN_BUF_SIZE];
   };

   Scan_Buf* m_Pscan_buf;

   int m_cur_src_y;
   int m_cur_dst_y;

   Status m_status;

   void resample_x(Sample* Pdst, const Sample* Psrc);
   void scale_y_mov(Sample* Ptmp, const Sample* Psrc, Resample_Real weight, int dst_x);
   void scale_y_add(Sample* Ptmp, const Sample* Psrc, Resample_Real weight, int dst_x);
   void clamp(Sample* Pdst, int n);
   void resample_y(Sample* Pdst);

   int reflect(const int j, const int src_x, const Boundary_Op boundary_op);

   Contrib_List* make_clist(
      int src_x, int dst_x, Boundary_Op boundary_op,
      Resample_Real (*Pfilter)(Resample_Real),
      Resample_Real filter_support,
      Resample_Real filter_scale,
      Resample_Real src_ofs);

   inline int count_ops(Contrib_List* Pclist, int k)
   {
      int i, t = 0;
      for (i = 0; i < k; i++)
         t += Pclist[i].n;
      return (t);
   }

   Resample_Real m_lo;
   Resample_Real m_hi;

   inline Resample_Real clamp_sample(Resample_Real f) const
   {
      if (f < m_lo)
         f = m_lo;
      else if (f > m_hi)
         f = m_hi;
      return f;
   }
};
// This is free and unencumbered software released into the public domain.
//
// Anyone is free to copy, modify, publish, use, compile, sell, or
// distribute this software, either in source code form or as a compiled
// binary, for any purpose, commercial or non-commercial, and by any
// means.
//
// In jurisdictions that recognize copyright laws, the author or authors
// of this software dedicate any and all copyright interest in the
// software to the public domain. We make this dedication for the benefit
// of the public at large and to the detriment of our heirs and
// successors. We intend this dedication to be an overt act of
// relinquishment in perpetuity of all present and future rights to this
// software under copyright law.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
// For more information, please refer to <http://unlicense.org/>


=== src\simulation\AccessProperty.cpp ===

#include "AccessProperty.h"
#include "simulation/Simulation.h"

void AccessProperty::Set(Simulation *sim, int i) const
{
	auto &part = sim->parts[i];
	auto &prop = Particle::GetProperties()[propertyIndex];
	auto *ptr = (reinterpret_cast<char *>(&part) + prop.Offset);
	if (propertyIndex == FIELD_TYPE)
	{
		sim->part_change_type(i, int(part.x + 0.5f), int(part.y + 0.5f), std::get<int>(propertyValue));
		return;
	}
	switch (prop.Type)
	{
	case StructProperty::Float:
		*reinterpret_cast<float *>(ptr) = std::get<float>(propertyValue);
		break;

	case StructProperty::ParticleType:
	case StructProperty::Integer:
		*reinterpret_cast<int *>(ptr) = std::get<int>(propertyValue);
		break;

	case StructProperty::UInteger:
		*reinterpret_cast<unsigned int *>(ptr) = std::get<unsigned int>(propertyValue);
		break;

	default:
		break;
	}
}

PropertyValue AccessProperty::Get(const Simulation *sim, int i) const
{
	PropertyValue propValue;
	auto &part = sim->parts[i];
	auto &prop = Particle::GetProperties()[propertyIndex];
	auto *ptr = (reinterpret_cast<const char *>(&part) + prop.Offset);
	switch (prop.Type)
	{
	case StructProperty::Float:
		propValue = *reinterpret_cast<const float *>(ptr);
		break;

	case StructProperty::ParticleType:
	case StructProperty::Integer:
		propValue = *reinterpret_cast<const int *>(ptr);
		break;

	case StructProperty::UInteger:
		propValue = *reinterpret_cast<const unsigned int *>(ptr);
		break;

	default:
		break;
	}
	return propValue;
}


=== src\simulation\AccessProperty.h ===

#pragma once
#include "StructProperty.h"
#include "common/String.h"
#include <stdexcept>

class Simulation;

struct AccessProperty
{
	int propertyIndex;
	PropertyValue propertyValue;

	void Set(Simulation *sim, int i) const;
	PropertyValue Get(const Simulation *sim, int i) const;

	struct ParseError : public std::runtime_error
	{
		using runtime_error::runtime_error;
	};
	static AccessProperty Parse(int prop, String value);
};



=== src\simulation\AccessPropertyParse.cpp ===

#include "AccessProperty.h"
#include "simulation/ElementClasses.h"
#include "simulation/GOLString.h"
#include "simulation/SimulationData.h"
#include "Config.h"
#include "Format.h"
#include "gui/game/GameController.h"
#include <iostream>

AccessProperty AccessProperty::Parse(int prop, String value)
{
	AccessProperty changeProperty;
	auto &sd = SimulationData::CRef();
	auto &properties = Particle::GetProperties();
	auto &elements = sd.elements;
	if (prop < 0 || prop >= int(properties.size()) || !value.size())
	{
		throw ParseError("invalid property index");
	}
	value = value.ToUpper();
	try
	{
		switch(properties[prop].Type)
		{
		case StructProperty::Integer:
		case StructProperty::ParticleType:
		{
			int v;
			if(value.length() > 2 && value.BeginsWith("0X"))
			{
				//0xC0FFEE
				v = value.Substr(2).ToNumber<unsigned int>(Format::Hex());
			}
			else if(value.length() > 1 && value.BeginsWith("#"))
			{
				//#C0FFEE
				v = value.Substr(1).ToNumber<unsigned int>(Format::Hex());
			}
			else
			{
				// Try to parse as particle name
				v = sd.GetParticleType(value.ToUtf8());

				// Try to parse special GoL rules
				if (v == -1 && properties[prop].Name == "ctype")
				{
					if (value.length() > 1 && value.BeginsWith("B") && value.Contains("/"))
					{
						v = ParseGOLString(value);
						if (v == -1)
						{
							class InvalidGOLString : public std::exception
							{
							};
							throw InvalidGOLString();
						}
					}
					else
					{
						v = sd.GetParticleType(value.ToUtf8());
						auto &builtinGol = SimulationData::builtinGol;
						auto &customGol = sd.GetCustomGol();
						if (v == -1)
						{
							for (int i = 0; i < int(builtinGol.size()); ++i)
							{
								if (builtinGol[i].name == value)
								{
									v = PMAP(i, PT_LIFE);
									break;
								}
							}
						}
						if (v == -1)
						{
							for (int i = 0; i < int(customGol.size()); ++i)
							{
								if (customGol[i].nameString == value)
								{
									v = PMAP(customGol[i].rule, PT_LIFE);
									break;
								}
							}
						}
					}
				}

				// Parse as plain number
				if (v == -1)
				{
					v = value.ToNumber<int>();
				}
			}

			if (properties[prop].Name == "type" && (v < 0 || v >= PT_NUM || !elements[v].Enabled))
			{
				throw ParseError("invalid element");
			}
			if constexpr (DEBUG)
			{
				std::cout << "Got int value " << v << std::endl;
			}
			changeProperty.propertyValue = v;
			break;
		}
		case StructProperty::UInteger:
		{
			unsigned int v;
			if(value.length() > 2 && value.BeginsWith("0X"))
			{
				//0xC0FFEE
				v = value.Substr(2).ToNumber<unsigned int>(Format::Hex());
			}
			else if(value.length() > 1 && value.BeginsWith("#"))
			{
				//#C0FFEE
				v = value.Substr(1).ToNumber<unsigned int>(Format::Hex());
			}
			else
			{
				v = value.ToNumber<unsigned int>();
			}
			if constexpr (DEBUG)
			{
				std::cout << "Got uint value " << v << std::endl;
			}
			changeProperty.propertyValue = v;
			break;
		}
		case StructProperty::Float:
		{
			if (properties[prop].Name == "temp")
				changeProperty.propertyValue = format::StringToTemperature(value, GameController::Ref().GetTemperatureScale());
			else
				changeProperty.propertyValue = value.ToNumber<float>();
		}
			break;
		default:
			throw ParseError("invalid property value");
		}
		changeProperty.propertyIndex = prop;
	}
	catch (const std::exception& ex)
	{
		throw ParseError("invalid property value");
	}
	return changeProperty;
}


=== src\simulation\Air.cpp ===

#include "Air.h"
#include "Simulation.h"
#include "ElementClasses.h"
#include "common/tpt-rand.h"
#include <cmath>
#include <algorithm>

void Air::make_kernel(void) //used for velocity
{
	float s = 0.0f;
	for (auto j=-1; j<2; j++)
	{
		for (auto i=-1; i<2; i++)
		{
			kernel[(i+1)+3*(j+1)] = expf(-2.0f*(i*i+j*j));
			s += kernel[(i+1)+3*(j+1)];
		}
	}
	s = 1.0f / s;
	for (auto j=-1; j<2; j++)
	{
		for (auto i=-1; i<2; i++)
		{
			kernel[(i+1)+3*(j+1)] *= s;
		}
	}
}

void Air::Clear()
{
	std::fill(&sim.pv[0][0], &sim.pv[0][0]+NCELL, 0.0f);
	std::fill(&sim.vy[0][0], &sim.vy[0][0]+NCELL, 0.0f);
	std::fill(&sim.vx[0][0], &sim.vx[0][0]+NCELL, 0.0f);
}

void Air::ClearAirH()
{
	std::fill(&sim.hv[0][0], &sim.hv[0][0]+NCELL, ambientAirTemp);
}

// Used when updating temp or velocity from far away
const float advDistanceMult = 0.7f;

void Air::update_airh(void)
{
	auto &vx = sim.vx;
	auto &vy = sim.vy;
	auto &hv = sim.hv;
	for (auto i=0; i<YCELLS; i++) //sets air temp on the edges every frame
	{
		hv[i][0] = ambientAirTemp;
		hv[i][1] = ambientAirTemp;
		hv[i][XCELLS-2] = ambientAirTemp;
		hv[i][XCELLS-1] = ambientAirTemp;
	}
	for (auto i=0; i<XCELLS; i++) //sets air temp on the edges every frame
	{
		hv[0][i] = ambientAirTemp;
		hv[1][i] = ambientAirTemp;
		hv[YCELLS-2][i] = ambientAirTemp;
		hv[YCELLS-1][i] = ambientAirTemp;
	}
	for (auto y=0; y<YCELLS; y++) //update air temp and velocity
	{
		for (auto x=0; x<XCELLS; x++)
		{
			auto dh = 0.0f;
			auto dx = 0.0f;
			auto dy = 0.0f;
			for (auto j=-1; j<2; j++)
			{
				for (auto i=-1; i<2; i++)
				{
					if (y+j>0 && y+j<YCELLS-2 && x+i>0 && x+i<XCELLS-2 && !(bmap_blockairh[y+j][x+i]&0x8))
					{
						auto f = kernel[i+1+(j+1)*3];
						dh += hv[y+j][x+i]*f;
						dx += vx[y+j][x+i]*f;
						dy += vy[y+j][x+i]*f;
					}
					else
					{
						auto f = kernel[i+1+(j+1)*3];
						dh += hv[y][x]*f;
						dx += vx[y][x]*f;
						dy += vy[y][x]*f;
					}
				}
			}

			// Trying to take air temp from far away.
			// The code is almost identical to the "far away" velocity code from update_air
			auto tx = x - dx*advDistanceMult;
			auto ty = y - dy*advDistanceMult;
			if ((std::abs(dx*advDistanceMult)>1.0f || std::abs(dy*advDistanceMult)>1.0f) && (tx>=2 && tx<XCELLS-2 && ty>=2 && ty<YCELLS-2))
			{
				float stepX, stepY;
				int stepLimit;
				if (std::abs(dx)>std::abs(dy))
				{
					stepX = (dx<0.0f) ? 1.f : -1.f;
					stepY = -dy/fabsf(dx);
					stepLimit = (int)(fabsf(dx*advDistanceMult));
				}
				else
				{
					stepY = (dy<0.0f) ? 1.f : -1.f;
					stepX = -dx/fabsf(dy);
					stepLimit = (int)(fabsf(dy*advDistanceMult));
				}
				tx = float(x);
				ty = float(y);
				auto step = 0;
				for (; step<stepLimit; ++step)
				{
					tx += stepX;
					ty += stepY;
					if (bmap_blockairh[(int)(ty+0.5f)][(int)(tx+0.5f)]&0x8)
					{
						tx -= stepX;
						ty -= stepY;
						break;
					}
				}
				if (step==stepLimit)
				{
					// No wall found
					tx = x - dx*advDistanceMult;
					ty = y - dy*advDistanceMult;
				}
			}
			auto i = (int)tx;
			auto j = (int)ty;
			tx -= i;
			ty -= j;
			if (!(bmap_blockairh[y][x]&0x8) && i>=2 && i<XCELLS-3 && j>=2 && j<YCELLS-3)
			{
				auto odh = dh;
				dh *= 1.0f - AIR_VADV;
				dh += AIR_VADV*(1.0f-tx)*(1.0f-ty)*((bmap_blockairh[j][i]&0x8) ? odh : hv[j][i]);
				dh += AIR_VADV*tx*(1.0f-ty)*((bmap_blockairh[j][i+1]&0x8) ? odh : hv[j][i+1]);
				dh += AIR_VADV*(1.0f-tx)*ty*((bmap_blockairh[j+1][i]&0x8) ? odh : hv[j+1][i]);
				dh += AIR_VADV*tx*ty*((bmap_blockairh[j+1][i+1]&0x8) ? odh : hv[j+1][i+1]);
			}

			// Temp caps
			if (dh > MAX_TEMP) dh = MAX_TEMP;
			if (dh < MIN_TEMP) dh = MIN_TEMP;

			ohv[y][x] = dh;

			// Air convection.
			// We use the Boussinesq approximation, i.e. we assume density to be nonconstant only
			// near the gravity term of the fluid equation, and we suppose that it depends linearly on the
			// difference between the current temperature (hv[y][x]) and some "stationary" temperature (ambientAirTemp).
			float dvx, dvy;
			dvx = vx[y][x];
		       	dvy = vy[y][x];

			if (x>=2 && x<XCELLS-2 && y>=2 && y<YCELLS-2)
			{
				float convGravX, convGravY;
				sim.GetGravityField(x*CELL, y*CELL, -1.0f, -1.0f, convGravX, convGravY);

				// Cap the gravity field
				float gravMagn = std::sqrt(convGravX*convGravX + convGravY*convGravY);
				if (gravMagn > 10.0f)
				{
					convGravX /= 0.1f*gravMagn;
					convGravY /= 0.1f*gravMagn;
				}

				auto weight = (hv[y][x] - ambientAirTemp) / 10000.0f;

				// Our approximation works best when the temperature difference is small, so we cap it from above.
				if (weight > 0.01f) weight = 0.01f;

				dvx += weight * convGravX;
				dvy += weight * convGravY;
			}

			// Velocity cap
			if (dvx > MAX_PRESSURE) dvx = MAX_PRESSURE;
			if (dvx < MIN_PRESSURE) dvx = MIN_PRESSURE;
			if (dvy > MAX_PRESSURE) dvy = MAX_PRESSURE;
			if (dvy < MIN_PRESSURE) dvy = MIN_PRESSURE;

			vx[y][x] = dvx;
			vy[y][x] = dvy;
		}
	}
	memcpy(hv, ohv, sizeof(hv));
}

void Air::update_air(void)
{
	auto &vx = sim.vx;
	auto &vy = sim.vy;
	auto &pv = sim.pv;
	auto &fvx = sim.fvx;
	auto &fvy = sim.fvy;
	auto &bmap = sim.bmap;
	if (airMode != AIR_NOUPDATE) //airMode 4 is no air/pressure update
	{
		for (auto i=0; i<YCELLS; i++) //reduces pressure/velocity on the edges every frame
		{
			pv[i][0] = pv[i][0]*0.8f;
			pv[i][1] = pv[i][1]*0.8f;
			pv[i][XCELLS-2] = pv[i][XCELLS-2]*0.8f;
			pv[i][XCELLS-1] = pv[i][XCELLS-1]*0.8f;
			vx[i][0] = vx[i][0]*0.9f;
			vx[i][1] = vx[i][1]*0.9f;
			vx[i][XCELLS-2] = vx[i][XCELLS-2]*0.9f;
			vx[i][XCELLS-1] = vx[i][XCELLS-1]*0.9f;
			vy[i][0] = vy[i][0]*0.9f;
			vy[i][1] = vy[i][1]*0.9f;
			vy[i][XCELLS-2] = vy[i][XCELLS-2]*0.9f;
			vy[i][XCELLS-1] = vy[i][XCELLS-1]*0.9f;
		}
		for (auto i=0; i<XCELLS; i++) //reduces pressure/velocity on the edges every frame
		{
			pv[0][i] = pv[0][i]*0.8f;
			pv[1][i] = pv[1][i]*0.8f;
			pv[YCELLS-2][i] = pv[YCELLS-2][i]*0.8f;
			pv[YCELLS-1][i] = pv[YCELLS-1][i]*0.8f;
			vx[0][i] = vx[0][i]*0.9f;
			vx[1][i] = vx[1][i]*0.9f;
			vx[YCELLS-2][i] = vx[YCELLS-2][i]*0.9f;
			vx[YCELLS-1][i] = vx[YCELLS-1][i]*0.9f;
			vy[0][i] = vy[0][i]*0.9f;
			vy[1][i] = vy[1][i]*0.9f;
			vy[YCELLS-2][i] = vy[YCELLS-2][i]*0.9f;
			vy[YCELLS-1][i] = vy[YCELLS-1][i]*0.9f;
		}

		for (auto j=1; j<YCELLS-1; j++) //clear some velocities near walls
		{
			for (auto i=1; i<XCELLS-1; i++)
			{
				if (bmap_blockair[j][i])
				{
					vx[j][i] = 0.0f;
					vx[j][i-1] = 0.0f;
					vx[j][i+1] = 0.0f;
					vy[j][i] = 0.0f;
					vy[j-1][i] = 0.0f;
					vy[j+1][i] = 0.0f;
				}
			}
		}

		for (auto y=1; y<YCELLS-1; y++) //pressure adjustments from velocity
		{
			for (auto x=1; x<XCELLS-1; x++)
			{
				auto dp = 0.0f;
				dp += vx[y][x-1] - vx[y][x+1];
				dp += vy[y-1][x] - vy[y+1][x];
				pv[y][x] *= AIR_PLOSS;
				pv[y][x] += dp*AIR_TSTEPP * 0.5f;;
			}
		}

		for (auto y=1; y<YCELLS-1; y++) //velocity adjustments from pressure
		{
			for (auto x=1; x<XCELLS-1; x++)
			{
				auto dx = 0.0f;
				auto dy = 0.0f;
				dx += pv[y][x-1] - pv[y][x+1];
				dy += pv[y-1][x] - pv[y+1][x];
				vx[y][x] *= AIR_VLOSS;
				vy[y][x] *= AIR_VLOSS;
				vx[y][x] += dx*AIR_TSTEPV * 0.5f;
				vy[y][x] += dy*AIR_TSTEPV * 0.5f;
				if (bmap_blockair[y][x-1] || bmap_blockair[y][x] || bmap_blockair[y][x+1])
					vx[y][x] = 0;
				if (bmap_blockair[y-1][x] || bmap_blockair[y][x] || bmap_blockair[y+1][x])
					vy[y][x] = 0;
			}
		}

		for (auto y=0; y<YCELLS; y++) //update velocity and pressure
		{
			for (auto x=0; x<XCELLS; x++)
			{
				auto dx = 0.0f;
				auto dy = 0.0f;
				auto dp = 0.0f;
				for (auto j=-1; j<2; j++)
				{
					for (auto i=-1; i<2; i++)
					{
						if (y+j>0 && y+j<YCELLS-1 &&
						        x+i>0 && x+i<XCELLS-1 &&
						        !bmap_blockair[y+j][x+i])
						{
							auto f = kernel[i+1+(j+1)*3];
							dx += vx[y+j][x+i]*f;
							dy += vy[y+j][x+i]*f;
							dp += pv[y+j][x+i]*f;
						}
						else
						{
							auto f = kernel[i+1+(j+1)*3];
							dx += vx[y][x]*f;
							dy += vy[y][x]*f;
							dp += pv[y][x]*f;
						}
					}
				}

				auto tx = x - dx*advDistanceMult;
				auto ty = y - dy*advDistanceMult;
				if ((std::abs(dx*advDistanceMult)>1.0f || std::abs(dy*advDistanceMult)>1.0f) && (tx>=2 && tx<XCELLS-2 && ty>=2 && ty<YCELLS-2))
				{
					// Trying to take velocity from far away, check whether there is an intervening wall.
					// Step from current position to desired source location, looking for walls, with either the x or y step size being 1 cell
					float stepX, stepY;
					int stepLimit;
					if (std::abs(dx)>std::abs(dy))
					{
						stepX = (dx<0.0f) ? 1.f : -1.f;
						stepY = -dy/fabsf(dx);
						stepLimit = (int)(fabsf(dx*advDistanceMult));
					}
					else
					{
						stepY = (dy<0.0f) ? 1.f : -1.f;
						stepX = -dx/fabsf(dy);
						stepLimit = (int)(fabsf(dy*advDistanceMult));
					}
					tx = float(x);
					ty = float(y);
					auto step = 0;
					for (; step<stepLimit; ++step)
					{
						tx += stepX;
						ty += stepY;
						if (bmap_blockair[(int)(ty+0.5f)][(int)(tx+0.5f)])
						{
							tx -= stepX;
							ty -= stepY;
							break;
						}
					}
					if (step==stepLimit)
					{
						// No wall found
						tx = x - dx*advDistanceMult;
						ty = y - dy*advDistanceMult;
					}
				}
				auto i = (int)tx;
				auto j = (int)ty;
				tx -= i;
				ty -= j;
				if (!bmap_blockair[y][x] && i>=2 && i<XCELLS-3 && j>=2 && j<YCELLS-3)
				{
					dx *= 1.0f - AIR_VADV;
					dy *= 1.0f - AIR_VADV;

					dx += AIR_VADV*(1.0f-tx)*(1.0f-ty)*vx[j][i];
					dy += AIR_VADV*(1.0f-tx)*(1.0f-ty)*vy[j][i];

					dx += AIR_VADV*tx*(1.0f-ty)*vx[j][i+1];
					dy += AIR_VADV*tx*(1.0f-ty)*vy[j][i+1];

					dx += AIR_VADV*(1.0f-tx)*ty*vx[j+1][i];
					dy += AIR_VADV*(1.0f-tx)*ty*vy[j+1][i];

					dx += AIR_VADV*tx*ty*vx[j+1][i+1];
					dy += AIR_VADV*tx*ty*vy[j+1][i+1];
				}

				if (bmap[y][x] == WL_FAN)
				{
					dx += fvx[y][x];
					dy += fvy[y][x];
				}
				// pressure/velocity caps
				if (dp > MAX_PRESSURE) dp = MAX_PRESSURE;
				if (dp < MIN_PRESSURE) dp = MIN_PRESSURE;
				if (dx > MAX_PRESSURE) dx = MAX_PRESSURE;
				if (dx < MIN_PRESSURE) dx = MIN_PRESSURE;
				if (dy > MAX_PRESSURE) dy = MAX_PRESSURE;
				if (dy < MIN_PRESSURE) dy = MIN_PRESSURE;


				switch (airMode)
				{
				default:
				case AIR_ON:  //Default
					break;
				case AIR_PRESSUREOFF:  //0 Pressure
					dp = 0.0f;
					break;
				case AIR_VELOCITYOFF:  //0 Velocity
					dx = 0.0f;
					dy = 0.0f;
					break;
				case AIR_OFF: //0 Air
					dx = 0.0f;
					dy = 0.0f;
					dp = 0.0f;
					break;
				case AIR_NOUPDATE: //No Update
					break;
				}

				ovx[y][x] = dx;
				ovy[y][x] = dy;
				opv[y][x] = dp;
			}
		}
		memcpy(vx, ovx, sizeof(vx));
		memcpy(vy, ovy, sizeof(vy));
		memcpy(pv, opv, sizeof(pv));
	}
}

void Air::Invert()
{
	auto &vx = sim.vx;
	auto &vy = sim.vy;
	auto &pv = sim.pv;
	for (auto nx = 0; nx<XCELLS; nx++)
	{
		for (auto ny = 0; ny<YCELLS; ny++)
		{
			pv[ny][nx] = -pv[ny][nx];
			vx[ny][nx] = -vx[ny][nx];
			vy[ny][nx] = -vy[ny][nx];
		}
	}
}

// called when loading saves / stamps to ensure nothing "leaks" the first frame
void Air::ApproximateBlockAirMaps()
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (int i = 0; i <= sim.parts.lastActiveIndex; i++)
	{
		int type = sim.parts[i].type;
		if (!type)
			continue;
		// Real TTAN would only block if there was enough TTAN
		// but it would be more expensive and complicated to actually check that
		// so just block for a frame, if it wasn't supposed to block it will continue allowing air next frame
		if (type == PT_TTAN)
		{
			int x = ((int)(sim.parts[i].x+0.5f))/CELL, y = ((int)(sim.parts[i].y+0.5f))/CELL;
			if (InBounds(x, y))
			{
				bmap_blockair[y][x] = 1;
				bmap_blockairh[y][x] = 0x8;
			}
		}
		// mostly accurate insulator blocking, besides checking GEL
		else if (sim.IsHeatInsulator(sim.parts[i]) || elements[type].HeatConduct <= (sim.rng()%250))
		{
			int x = ((int)(sim.parts[i].x+0.5f))/CELL, y = ((int)(sim.parts[i].y+0.5f))/CELL;
			if (InBounds(x, y) && !(bmap_blockairh[y][x]&0x8))
				bmap_blockairh[y][x]++;
		}
	}
}

Air::Air(Simulation & simulation):
	sim(simulation),
	airMode(AIR_ON),
	ambientAirTemp(R_TEMP + 273.15f)
{
	//Simulation should do this.
	make_kernel();
	std::fill(&bmap_blockair [0][0], &bmap_blockair [0][0] + NCELL, 0);
	std::fill(&bmap_blockairh[0][0], &bmap_blockairh[0][0] + NCELL, 0);
	std::fill(&sim.vx[0][0], &sim.vx[0][0] + NCELL, 0.0f);
	std::fill(&ovx   [0][0], &ovx   [0][0] + NCELL, 0.0f);
	std::fill(&sim.vy[0][0], &sim.vy[0][0] + NCELL, 0.0f);
	std::fill(&ovy   [0][0], &ovy   [0][0] + NCELL, 0.0f);
	std::fill(&sim.hv[0][0], &sim.hv[0][0] + NCELL, 0.0f);
	std::fill(&ohv   [0][0], &ohv   [0][0] + NCELL, 0.0f);
	std::fill(&sim.pv[0][0], &sim.pv[0][0] + NCELL, 0.0f);
	std::fill(&opv   [0][0], &opv   [0][0] + NCELL, 0.0f);
}


=== src\simulation\Air.h ===

#pragma once
#include "SimulationConfig.h"

class Simulation;

class Air
{
public:
	Simulation & sim;
	int airMode;
	float ambientAirTemp;
	float ovx[YCELLS][XCELLS];
	float ovy[YCELLS][XCELLS];
	float opv[YCELLS][XCELLS];
	float ohv[YCELLS][XCELLS]; // Ambient Heat
	unsigned char bmap_blockair[YCELLS][XCELLS];
	unsigned char bmap_blockairh[YCELLS][XCELLS];
	float kernel[9];
	void make_kernel(void);
	void update_airh(void);
	void update_air(void);
	void Clear();
	void ClearAirH();
	void Invert();
	void ApproximateBlockAirMaps();
	Air(Simulation & sim);
};


=== src\simulation\BuiltinGOL.h ===

#pragma once

#include "graphics/Pixel.h"
#include "common/String.h"

struct BuiltinGOL
{
	String name;
	int oldtype;
	int ruleset;
	RGB colour = RGB(0, 0, 0);
	RGB colour2 = RGB(0, 0, 0);
	int goltype;
	String description;
};


=== src\simulation\CoordStack.h ===

/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
#include <cstdlib>
#include <exception>

class CoordStackOverflowException: public std::exception
{
public:
	CoordStackOverflowException() { }
	const char* what() const throw() override
	{
		return "Maximum number of entries in the coordinate stack was exceeded";
	}
	~CoordStackOverflowException() throw() {}
};

class CoordStack
{
private:
	unsigned short (*stack)[2];
	int stack_size;
	const static int stack_limit = XRES*YRES;
public:
	CoordStack() :
		stack(NULL),
		stack_size(0)
	{
		stack = new unsigned short[stack_limit][2];
	}
	~CoordStack()
	{
		delete[] stack;
	}
	void push(int x, int y)
	{
		if (stack_size>=stack_limit)
			throw CoordStackOverflowException();
		stack[stack_size][0] = x;
		stack[stack_size][1] = y;
		stack_size++;
	}
	void pop(int& x, int& y)
	{
		stack_size--;
		x = stack[stack_size][0];
		y = stack[stack_size][1];
	}
	int getSize() const
	{
		return stack_size;
	}
	void clear()
	{
		stack_size = 0;
	}
};


=== src\simulation\CustomGOLData.h ===

#pragma once
#include "graphics/Pixel.h"
#include "common/String.h"

struct CustomGOLData
{
	int rule;
	RGB colour1, colour2;
	String nameString;

	inline bool operator <(const CustomGOLData &other) const
	{
		return rule < other.rule;
	}
};


=== src\simulation\Editing.cpp ===

#include "Simulation.h"
#include "Sample.h"
#include "Snapshot.h"
#include "Air.h"
#include "gravity/Gravity.h"
#include "common/tpt-rand.h"
#include "common/tpt-compat.h"
#include "client/GameSave.h"
#include "ElementClasses.h"
#include "graphics/Renderer.h"
#include "gui/game/Brush.h"
#include <iostream>
#include <cmath>

std::unique_ptr<Snapshot> Simulation::CreateSnapshot() const
{
	auto snap = std::make_unique<Snapshot>();
	snap->AirPressure    .insert   (snap->AirPressure    .begin(), &pv  [0][0]      , &pv  [0][0] + NCELL);
	snap->AirVelocityX   .insert   (snap->AirVelocityX   .begin(), &vx  [0][0]      , &vx  [0][0] + NCELL);
	snap->AirVelocityY   .insert   (snap->AirVelocityY   .begin(), &vy  [0][0]      , &vy  [0][0] + NCELL);
	snap->AmbientHeat    .insert   (snap->AmbientHeat    .begin(), &hv  [0][0]      , &hv  [0][0] + NCELL);
	snap->BlockMap       .insert   (snap->BlockMap       .begin(), &bmap[0][0]      , &bmap[0][0] + NCELL);
	snap->ElecMap        .insert   (snap->ElecMap        .begin(), &emap[0][0]      , &emap[0][0] + NCELL);
	snap->BlockAir       .insert   (snap->BlockAir       .begin(), &air->bmap_blockair[0][0] , &air->bmap_blockair[0][0]  + NCELL);
	snap->BlockAirH      .insert   (snap->BlockAirH      .begin(), &air->bmap_blockairh[0][0], &air->bmap_blockairh[0][0] + NCELL);
	snap->FanVelocityX   .insert   (snap->FanVelocityX   .begin(), &fvx [0][0]      , &fvx [0][0] + NCELL);
	snap->FanVelocityY   .insert   (snap->FanVelocityY   .begin(), &fvy [0][0]      , &fvy [0][0] + NCELL);
	snap->Particles      .insert   (snap->Particles      .begin(), &parts  [0]      , &parts  [0] + parts.lastActiveIndex + 1);
	snap->PortalParticles.insert   (snap->PortalParticles.begin(), &portalp[0][0][0], &portalp[0][0][0] + CHANNELS * 8 * 80);
	snap->WirelessData   .insert   (snap->WirelessData   .begin(), &wireless[0][0]  , &wireless[0][0] + CHANNELS * 2);
	snap->stickmen       .insert   (snap->stickmen       .begin(), &fighters[0]     , &fighters[0] + MAX_FIGHTERS);
	snap->stickmen       .push_back(player2);
	snap->stickmen       .push_back(player);
	snap->GravMass  .insert(snap->GravMass  .begin(), &gravIn.mass[{ 0, 0 }]   , &gravIn.mass[{ 0, 0 }]    + NCELL);
	snap->GravMask  .insert(snap->GravMask  .begin(), &gravIn.mask[{ 0, 0 }]   , &gravIn.mask[{ 0, 0 }]    + NCELL);
	snap->GravForceX.insert(snap->GravForceX.begin(), &gravOut.forceX[{ 0, 0 }], &gravOut.forceX[{ 0, 0 }] + NCELL);
	snap->GravForceY.insert(snap->GravForceY.begin(), &gravOut.forceY[{ 0, 0 }], &gravOut.forceY[{ 0, 0 }] + NCELL);
	snap->signs = signs;
	snap->FrameCount = frameCount;
	snap->RngState = rng.state();
	return snap;
}

void Simulation::Restore(const Snapshot &snap)
{
	std::fill(elementCount, elementCount + PT_NUM, 0);
	elementRecount = true;
	force_stacking_check = true;
	for (auto &part : parts.data)
	{
		part.type = 0;
	}
	std::copy(snap.AirPressure    .begin(), snap.AirPressure    .end(), &pv[0][0]        );
	std::copy(snap.AirVelocityX   .begin(), snap.AirVelocityX   .end(), &vx[0][0]        );
	std::copy(snap.AirVelocityY   .begin(), snap.AirVelocityY   .end(), &vy[0][0]        );
	std::copy(snap.AmbientHeat    .begin(), snap.AmbientHeat    .end(), &hv[0][0]        );
	std::copy(snap.BlockMap       .begin(), snap.BlockMap       .end(), &bmap[0][0]      );
	std::copy(snap.ElecMap        .begin(), snap.ElecMap        .end(), &emap[0][0]      );
	std::copy(snap.BlockAir       .begin(), snap.BlockAir       .end(), &air->bmap_blockair[0][0] );
	std::copy(snap.BlockAirH      .begin(), snap.BlockAirH      .end(), &air->bmap_blockairh[0][0]);
	std::copy(snap.FanVelocityX   .begin(), snap.FanVelocityX   .end(), &fvx[0][0]       );
	std::copy(snap.FanVelocityY   .begin(), snap.FanVelocityY   .end(), &fvy[0][0]       );
	std::copy(snap.Particles      .begin(), snap.Particles      .end(), &parts[0]        );
	std::copy(snap.PortalParticles.begin(), snap.PortalParticles.end(), &portalp[0][0][0]);
	std::copy(snap.WirelessData   .begin(), snap.WirelessData   .end(), &wireless[0][0]  );
	std::copy(snap.stickmen       .begin(), snap.stickmen.end() - 2   , &fighters[0]     );
	player  = snap.stickmen[snap.stickmen.size() - 1];
	player2 = snap.stickmen[snap.stickmen.size() - 2];
	{
		GravityInput newGravIn;
		GravityOutput newGravOut;
		std::copy(snap.GravMass  .begin(), snap.GravMass  .end(), &newGravIn.mass[{ 0, 0 }]   );
		std::copy(snap.GravMask  .begin(), snap.GravMask  .end(), &newGravIn.mask[{ 0, 0 }]   );
		std::copy(snap.GravForceX.begin(), snap.GravForceX.end(), &newGravOut.forceX[{ 0, 0 }]);
		std::copy(snap.GravForceY.begin(), snap.GravForceY.end(), &newGravOut.forceY[{ 0, 0 }]);
		// we apply the old grav values but Newtonian gravity enable state is not part of the snapshot so this may be pointless
		// TODO: maybe track settings like Newtonian gravity enable state in the history
		ResetNewtonianGravity(newGravIn, newGravOut);
	}
	signs = snap.signs;
	frameCount = snap.FrameCount;
	rng.state(snap.RngState);
	parts.lastActiveIndex = NPART - 1;
	RecalcFreeParticles(false);
}

void Simulation::clear_area(int area_x, int area_y, int area_w, int area_h)
{
	auto intersection = RES.OriginRect() & RectSized(Vec2{ area_x, area_y }, Vec2{ area_w, area_h });
	area_x = intersection.pos.X;
	area_y = intersection.pos.Y;
	area_w = intersection.size.X;
	area_h = intersection.size.Y;
	float fx = area_x-.5f, fy = area_y-.5f;
	for (int i = 0; i <= parts.lastActiveIndex; i++)
	{
		if (parts[i].type)
			if (parts[i].x >= fx && parts[i].x <= fx+area_w+1 && parts[i].y >= fy && parts[i].y <= fy+area_h+1)
				kill_part(i);
	}
	int cx1 = area_x/CELL, cy1 = area_y/CELL, cx2 = (area_x+area_w)/CELL, cy2 = (area_y+area_h)/CELL;
	for (int y = cy1; y <= cy2; y++)
	{
		for (int x = cx1; x <= cx2; x++)
		{
			if (bmap[y][x] == WL_GRAV)
				gravWallChanged = true;
			bmap[y][x] = 0;
			emap[y][x] = 0;
		}
	}
	for( int i = signs.size()-1; i >= 0; i--)
	{
		if (signs[i].text.length() && signs[i].x >= area_x && signs[i].y >= area_y && signs[i].x <= area_x+area_w && signs[i].y <= area_y+area_h)
		{
			signs.erase(signs.begin()+i);
		}
	}
}

SimulationSample Simulation::GetSample(int x, int y)
{
	SimulationSample sample;
	sample.particle.type = 0;
	sample.PositionX = x;
	sample.PositionY = y;
	if (x >= 0 && x < XRES && y >= 0 && y < YRES)
	{
		if (photons[y][x])
		{
			sample.particle = parts[ID(photons[y][x])];
			sample.ParticleID = ID(photons[y][x]);
		}
		else if (pmap[y][x])
		{
			sample.particle = parts[ID(pmap[y][x])];
			sample.ParticleID = ID(pmap[y][x]);
		}
		if (bmap[y/CELL][x/CELL])
		{
			sample.WallType = bmap[y/CELL][x/CELL];
		}
		sample.AirPressure = pv[y/CELL][x/CELL];
		sample.AirTemperature = hv[y/CELL][x/CELL];
		sample.AirVelocityX = vx[y/CELL][x/CELL];
		sample.AirVelocityY = vy[y/CELL][x/CELL];

		if (grav)
		{
			sample.GravityVelocityX = gravOut.forceX[Vec2{ x, y } / CELL];
			sample.GravityVelocityY = gravOut.forceY[Vec2{ x, y } / CELL];
		}
	}
	else
		sample.isMouseInSim = false;

	sample.NumParts = NUM_PARTS;
	return sample;
}

void Simulation::SetDecoSpace(int newDecoSpace)
{
	if (newDecoSpace < 0 || newDecoSpace >= NUM_DECOSPACES)
	{
		newDecoSpace = DECOSPACE_SRGB;
	}
	deco_space = newDecoSpace;
}

int Simulation::CreateWalls(int x, int y, int rx, int ry, int wall, Brush const *cBrush)
{
	if(cBrush)
	{
		rx = cBrush->GetRadius().X;
		ry = cBrush->GetRadius().Y;
	}

	ry = ry/CELL;
	rx = rx/CELL;
	x = x/CELL;
	y = y/CELL;
	x -= rx;
	y -= ry;
	for (int wallX = x; wallX <= x+rx+rx; wallX++)
	{
		for (int wallY = y; wallY <= y+ry+ry; wallY++)
		{
			if (wallX >= 0 && wallX < XCELLS && wallY >= 0 && wallY < YCELLS)
			{
				if (wall == WL_FAN)
				{
					fvx[wallY][wallX] = 0.0f;
					fvy[wallY][wallX] = 0.0f;
				}
				else if (wall == WL_STREAM)
				{
					wallX = x + rx;
					wallY = y + ry;
					//streamlines can't be drawn next to each other
					for (int tempY = wallY-1; tempY < wallY+2; tempY++)
						for (int tempX = wallX-1; tempX < wallX+2; tempX++)
						{
							if (tempX >= 0 && tempX < XCELLS && tempY >= 0 && tempY < YCELLS && bmap[tempY][tempX] == WL_STREAM)
								return 1;
						}
				}
				if (wall == WL_GRAV || bmap[wallY][wallX] == WL_GRAV)
					gravWallChanged = true;

				if (wall == WL_ERASEALL)
				{
					for (int i = 0; i < CELL; i++)
						for (int j = 0; j < CELL; j++)
						{
							delete_part(wallX*CELL+i, wallY*CELL+j);
						}
					for (int i = signs.size()-1; i >= 0; i--)
						if (signs[i].x >= wallX*CELL && signs[i].y >= wallY*CELL && signs[i].x <= (wallX+1)*CELL && signs[i].y <= (wallY+1)*CELL)
							signs.erase(signs.begin()+i);
					bmap[wallY][wallX] = 0;
				}
				else
					bmap[wallY][wallX] = wall;
			}
		}
	}
	return 1;
}

void Simulation::CreateWallLine(int x1, int y1, int x2, int y2, int rx, int ry, int wall, Brush const *cBrush)
{
	int x, y, dx, dy, sy;
	bool reverseXY = abs(y2-y1) > abs(x2-x1);
	float e = 0.0f, de;
	if (reverseXY)
	{
		y = x1;
		x1 = y1;
		y1 = y;
		y = x2;
		x2 = y2;
		y2 = y;
	}
	if (x1 > x2)
	{
		y = x1;
		x1 = x2;
		x2 = y;
		y = y1;
		y1 = y2;
		y2 = y;
	}
	dx = x2 - x1;
	dy = abs(y2 - y1);
	de = dx ? dy/(float)dx : 0.0f;
	y = y1;
	sy = (y1<y2) ? 1 : -1;
	for (x=x1; x<=x2; x++)
	{
		if (reverseXY)
			CreateWalls(y, x, rx, ry, wall, cBrush);
		else
			CreateWalls(x, y, rx, ry, wall, cBrush);
		e += de;
		if (e >= 0.5f)
		{
			y += sy;
			if ((y1<y2) ? (y<=y2) : (y>=y2))
			{
				if (reverseXY)
					CreateWalls(y, x, rx, ry, wall, cBrush);
				else
					CreateWalls(x, y, rx, ry, wall, cBrush);
			}
			e -= 1.0f;
		}
	}
}

void Simulation::CreateWallBox(int x1, int y1, int x2, int y2, int wall)
{
	int i, j;
	if (x1>x2)
	{
		i = x2;
		x2 = x1;
		x1 = i;
	}
	if (y1>y2)
	{
		j = y2;
		y2 = y1;
		y1 = j;
	}
	for (j=y1; j<=y2; j++)
		for (i=x1; i<=x2; i++)
			CreateWalls(i, j, 0, 0, wall, nullptr);
}

int Simulation::FloodWalls(int x, int y, int wall, int bm)
{
	int x1, x2, dy = CELL;
	if (bm==-1)
	{
		if (wall==WL_ERASE || wall==WL_ERASEALL)
		{
			bm = bmap[y/CELL][x/CELL];
			if (!bm)
				return 0;
		}
		else
			bm = 0;
	}

	if (bmap[y/CELL][x/CELL]!=bm)
		return 1;

	// go left as far as possible
	x1 = x2 = x;
	while (x1>=CELL)
	{
		if (bmap[y/CELL][(x1-1)/CELL]!=bm)
		{
			break;
		}
		x1--;
	}
	while (x2<XRES-CELL)
	{
		if (bmap[y/CELL][(x2+1)/CELL]!=bm)
		{
			break;
		}
		x2++;
	}

	// fill span
	for (x=x1; x<=x2; x++)
	{
		if (!CreateWalls(x, y, 0, 0, wall, nullptr))
			return 0;
	}
	// fill children
	if (y>=CELL)
		for (x=x1; x<=x2; x++)
			if (bmap[(y-dy)/CELL][x/CELL]==bm)
				if (!FloodWalls(x, y-dy, wall, bm))
					return 0;
	if (y<YRES-CELL)
		for (x=x1; x<=x2; x++)
			if (bmap[(y+dy)/CELL][x/CELL]==bm)
				if (!FloodWalls(x, y+dy, wall, bm))
					return 0;
	return 1;
}

int Simulation::CreatePartFlags(int p, int x, int y, int c, int flags)
{
	if (x < 0 || y < 0 || x >= XRES || y >= YRES)
	{
		return 0;
	}

	if (flags & REPLACE_MODE)
	{
		// if replace whatever and there's something to replace
		// or replace X and there's a non-energy particle on top with type X
		// or replace X and there's an energy particle on top with type X
		if ((!replaceModeSelected && (photons[y][x] || pmap[y][x])) ||
			(!photons[y][x] && pmap[y][x] && TYP(pmap[y][x]) == replaceModeSelected) ||
			(photons[y][x] && TYP(photons[y][x]) == replaceModeSelected))
		{
			if (c)
				create_part(photons[y][x] ? ID(photons[y][x]) : ID(pmap[y][x]), x, y, TYP(c), ID(c));
			else
				delete_part(x, y);
		}
		return 0;
	}
	else if (!c)
	{
		delete_part(x, y);
		return 0;
	}
	else if (flags & SPECIFIC_DELETE)
	{
		// if delete whatever and there's something to delete
		// or delete X and there's a non-energy particle on top with type X
		// or delete X and there's an energy particle on top with type X
		if ((!replaceModeSelected && (photons[y][x] || pmap[y][x])) ||
			(!photons[y][x] && pmap[y][x] && TYP(pmap[y][x]) == replaceModeSelected) ||
			(photons[y][x] && TYP(photons[y][x]) == replaceModeSelected))
		{
			delete_part(x, y);
		}
		return 0;
	}
	else
	{
		return (create_part(p, x, y, TYP(c), ID(c)) == -1);
	}

	// I'm sure at least one compiler exists that would complain if this wasn't here
	return 0;
}

void Simulation::ApplyDecoration(int x, int y, int colR_, int colG_, int colB_, int colA_, int mode)
{
	int rp;
	float tr, tg, tb, ta, colR = float(colR_), colG = float(colG_), colB = float(colB_), colA = float(colA_);
	float strength = 0.01f;
	rp = pmap[y][x];
	if (!rp)
		rp = photons[y][x];
	if (!rp)
		return;

	ta = float((parts[ID(rp)].dcolour>>24)&0xFF);
	tr = float((parts[ID(rp)].dcolour>>16)&0xFF);
	tg = float((parts[ID(rp)].dcolour>>8)&0xFF);
	tb = float((parts[ID(rp)].dcolour)&0xFF);

	ta /= 255.0f; tr /= 255.0f; tg /= 255.0f; tb /= 255.0f;
	colR /= 255.0f; colG /= 255.0f; colB /= 255.0f; colA /= 255.0f;

	if (mode == DECO_DRAW)
	{
		ta = colA;
		tr = colR;
		tg = colG;
		tb = colB;
	}
	else if (mode == DECO_CLEAR)
	{
		ta = tr = tg = tb = 0.0f;
	}
	else if (mode == DECO_ADD)
	{
		//ta += (colA*strength)*colA;
		tr += (colR*strength)*colA;
		tg += (colG*strength)*colA;
		tb += (colB*strength)*colA;
	}
	else if (mode == DECO_SUBTRACT)
	{
		//ta -= (colA*strength)*colA;
		tr -= (colR*strength)*colA;
		tg -= (colG*strength)*colA;
		tb -= (colB*strength)*colA;
	}
	else if (mode == DECO_MULTIPLY)
	{
		tr *= 1.0f+(colR*strength)*colA;
		tg *= 1.0f+(colG*strength)*colA;
		tb *= 1.0f+(colB*strength)*colA;
	}
	else if (mode == DECO_DIVIDE)
	{
		tr /= 1.0f+(colR*strength)*colA;
		tg /= 1.0f+(colG*strength)*colA;
		tb /= 1.0f+(colB*strength)*colA;
	}
	else if (mode == DECO_SMUDGE)
	{
		if (x >= CELL && x < XRES-CELL && y >= CELL && y < YRES-CELL)
		{
			float tas = 0.0f, trs = 0.0f, tgs = 0.0f, tbs = 0.0f;

			int rx, ry;
			float num = 0;
			for (rx=-2; rx<3; rx++)
				for (ry=-2; ry<3; ry++)
				{
					if (abs(rx)+abs(ry) > 2 && TYP(pmap[y+ry][x+rx]) && parts[ID(pmap[y+ry][x+rx])].dcolour)
					{
						Particle part = parts[ID(pmap[y+ry][x+rx])];
						num += 1.0f;
						float pa = ((float)((part.dcolour>>24)&0xFF)) / 255.f;
						float pr = ((float)((part.dcolour>>16)&0xFF)) / 255.f;
						float pg = ((float)((part.dcolour>> 8)&0xFF)) / 255.f;
						float pb = ((float)((part.dcolour    )&0xFF)) / 255.f;
						switch (deco_space)
						{
						case DECOSPACE_SRGB:
							pa = (pa <= 0.04045f) ? (pa / 12.92f) : pow((pa + 0.055f) / 1.055f, 2.4f);
							pr = (pr <= 0.04045f) ? (pr / 12.92f) : pow((pr + 0.055f) / 1.055f, 2.4f);
							pg = (pg <= 0.04045f) ? (pg / 12.92f) : pow((pg + 0.055f) / 1.055f, 2.4f);
							pb = (pb <= 0.04045f) ? (pb / 12.92f) : pow((pb + 0.055f) / 1.055f, 2.4f);
							break;

						case DECOSPACE_LINEAR:
							break;

						case DECOSPACE_GAMMA22:
							pa = pow(pa, 2.2f);
							pr = pow(pr, 2.2f);
							pg = pow(pg, 2.2f);
							pb = pow(pb, 2.2f);
							break;

						case DECOSPACE_GAMMA18:
							pa = pow(pa, 1.8f);
							pr = pow(pr, 1.8f);
							pg = pow(pg, 1.8f);
							pb = pow(pb, 1.8f);
							break;
						}
						tas += pa;
						trs += pr;
						tgs += pg;
						tbs += pb;
					}
				}
			if (num == 0)
				return;
			ta = tas / num;
			tr = trs / num;
			tg = tgs / num;
			tb = tbs / num;
			switch (deco_space)
			{
			case DECOSPACE_SRGB:
				ta = (ta <= 0.0031308f) ? (ta * 12.92f) : (1.055f * pow(ta, 1.f / 2.4f) - 0.055f);
				tr = (tr <= 0.0031308f) ? (tr * 12.92f) : (1.055f * pow(tr, 1.f / 2.4f) - 0.055f);
				tg = (tg <= 0.0031308f) ? (tg * 12.92f) : (1.055f * pow(tg, 1.f / 2.4f) - 0.055f);
				tb = (tb <= 0.0031308f) ? (tb * 12.92f) : (1.055f * pow(tb, 1.f / 2.4f) - 0.055f);
				break;

			case DECOSPACE_LINEAR:
				break;

			case DECOSPACE_GAMMA22:
				ta = pow(ta, 1.f / 2.2f);
				tr = pow(tr, 1.f / 2.2f);
				tg = pow(tg, 1.f / 2.2f);
				tb = pow(tb, 1.f / 2.2f);
				break;

			case DECOSPACE_GAMMA18:
				ta = pow(ta, 1.f / 1.8f);
				tr = pow(tr, 1.f / 1.8f);
				tg = pow(tg, 1.f / 1.8f);
				tb = pow(tb, 1.f / 1.8f);
				break;
			}
			if (!parts[ID(rp)].dcolour)
				ta -= 3/255.0f;
		}
	}

	ta *= 255.0f; tr *= 255.0f; tg *= 255.0f; tb *= 255.0f;
	ta += .5f; tr += .5f; tg += .5f; tb += .5f;

	colA_ = int(ta);
	colR_ = int(tr);
	colG_ = int(tg);
	colB_ = int(tb);

	if(colA_ > 255)
		colA_ = 255;
	else if(colA_ < 0)
		colA_ = 0;
	if(colR_ > 255)
		colR_ = 255;
	else if(colR_ < 0)
		colR_ = 0;
	if(colG_ > 255)
		colG_ = 255;
	else if(colG_ < 0)
		colG_ = 0;
	if(colB_ > 255)
		colB_ = 255;
	else if(colB_ < 0)
		colB_ = 0;
	parts[ID(rp)].dcolour = ((colA_<<24)|(colR_<<16)|(colG_<<8)|colB_);
}

void Simulation::ApplyDecorationPoint(int positionX, int positionY, int colR, int colG, int colB, int colA, int mode, Brush const &cBrush)
{
	for (ui::Point off : cBrush)
	{
		ui::Point coords = ui::Point(positionX, positionY) + off;
		if (coords.X >= 0 && coords.Y >= 0 && coords.X < XRES && coords.Y < YRES)
			ApplyDecoration(coords.X, coords.Y, colR, colG, colB, colA, mode);
	}
}

void Simulation::ApplyDecorationLine(int x1, int y1, int x2, int y2, int colR, int colG, int colB, int colA, int mode, Brush const &cBrush)
{
	bool reverseXY = abs(y2-y1) > abs(x2-x1);
	int x, y, dx, dy, sy, rx = 0, ry = 0;
	float e = 0.0f, de;

	rx = cBrush.GetRadius().X;
	ry = cBrush.GetRadius().Y;

	if (reverseXY)
	{
		y = x1;
		x1 = y1;
		y1 = y;
		y = x2;
		x2 = y2;
		y2 = y;
	}
	if (x1 > x2)
	{
		y = x1;
		x1 = x2;
		x2 = y;
		y = y1;
		y1 = y2;
		y2 = y;
	}
	dx = x2 - x1;
	dy = abs(y2 - y1);
	de = dx ? dy/(float)dx : 0.0f;
	y = y1;
	sy = (y1<y2) ? 1 : -1;
	for (x=x1; x<=x2; x++)
	{
		if (reverseXY)
			ApplyDecorationPoint(y, x, colR, colG, colB, colA, mode, cBrush);
		else
			ApplyDecorationPoint(x, y, colR, colG, colB, colA, mode, cBrush);
		e += de;
		if (e >= 0.5f)
		{
			y += sy;
			if (!(rx+ry))
			{
				if (reverseXY)
					ApplyDecorationPoint(y, x, colR, colG, colB, colA, mode, cBrush);
				else
					ApplyDecorationPoint(x, y, colR, colG, colB, colA, mode, cBrush);
			}
			e -= 1.0f;
		}
	}
}

void Simulation::ApplyDecorationBox(int x1, int y1, int x2, int y2, int colR, int colG, int colB, int colA, int mode)
{
	int i, j;

	if (x1>x2)
	{
		i = x2;
		x2 = x1;
		x1 = i;
	}
	if (y1>y2)
	{
		j = y2;
		y2 = y1;
		y1 = j;
	}
	for (j=y1; j<=y2; j++)
		for (i=x1; i<=x2; i++)
			ApplyDecoration(i, j, colR, colG, colB, colA, mode);
}

bool Simulation::ColorCompare(const RendererFrame &frame, int x, int y, int replaceR, int replaceG, int replaceB)
{
	auto pix = RGB::Unpack(frame[{ x, y }]);
	int r = pix.Red;
	int g = pix.Green;
	int b = pix.Blue;
	int diff = std::abs(replaceR-r) + std::abs(replaceG-g) + std::abs(replaceB-b);
	return diff < 15;
}

void Simulation::ApplyDecorationFill(const RendererFrame &frame, int x, int y, int colR, int colG, int colB, int colA, int replaceR, int replaceG, int replaceB)
{
	int x1, x2;
	char *bitmap = (char*)malloc(XRES*YRES); //Bitmap for checking
	if (!bitmap)
		return;
	memset(bitmap, 0, XRES*YRES);

	if (!ColorCompare(frame, x, y, replaceR, replaceG, replaceB)) {
		free(bitmap);
		return;
	}

	try
	{
		CoordStack& cs = getCoordStackSingleton();
		cs.clear();
		
		cs.push(x, y);
		do
		{
			cs.pop(x, y);
			x1 = x2 = x;
			// go left as far as possible
			while (x1>0)
			{
				if (bitmap[(x1-1)+y*XRES] || !ColorCompare(frame, x1-1, y, replaceR, replaceG, replaceB))
				{
					break;
				}
				x1--;
			}
			// go right as far as possible
			while (x2<XRES-1)
			{
				if (bitmap[(x1+1)+y*XRES] || !ColorCompare(frame, x2+1, y, replaceR, replaceG, replaceB))
				{
					break;
				}
				x2++;
			}
			// fill span
			for (x=x1; x<=x2; x++)
			{
				ApplyDecoration(x, y, colR, colG, colB, colA, DECO_DRAW);
				bitmap[x+y*XRES] = 1;
			}

			if (y >= 1)
				for (x=x1; x<=x2; x++)
					if (!bitmap[x+(y-1)*XRES] && ColorCompare(frame, x, y-1, replaceR, replaceG, replaceB))
						cs.push(x, y-1);

			if (y < YRES-1)
				for (x=x1; x<=x2; x++)
					if (!bitmap[x+(y+1)*XRES] && ColorCompare(frame, x, y+1, replaceR, replaceG, replaceB))
						cs.push(x, y+1);
		} while (cs.getSize() > 0);
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		free(bitmap);
		return;
	}
	free(bitmap);
}

int Simulation::CreateParts(int p, int positionX, int positionY, int c, Brush const &cBrush, int flags)
{
	if (flags == -1)
		flags = replaceModeFlags;
	int radiusX = cBrush.GetRadius().X, radiusY = cBrush.GetRadius().Y;

	// special case for LIGH
	if (c == PT_LIGH)
	{
		if (currentTick < lightningRecreate)
			return 1;
		int newlife = radiusX + radiusY;
		if (newlife > 55)
			newlife = 55;
		c = PMAP(newlife, c);
		lightningRecreate = currentTick + std::max(newlife / 4, 1);
		return CreatePartFlags(p, positionX, positionY, c, flags);
	}
	else if (c == PT_TESC)
	{
		int newtmp = (radiusX*4+radiusY*4+7);
		if (newtmp > 300)
			newtmp = 300;
		c = PMAP(newtmp, c);
	}

	for (ui::Point off : cBrush)
	{
		ui::Point coords = ui::Point(positionX, positionY) + off;
		if (coords.X >= 0 && coords.Y >= 0 && coords.X < XRES && coords.Y < YRES)
			CreatePartFlags(p, coords.X, coords.Y, c, flags);
	}
	return 0;
}

int Simulation::CreateParts(int p, int x, int y, int rx, int ry, int c, int flags)
{
	bool created = false;

	if (flags == -1)
		flags = replaceModeFlags;

	// special case for LIGH
	if (c == PT_LIGH)
	{
		if (currentTick < lightningRecreate)
			return 1;
		int newlife = rx + ry;
		if (newlife > 55)
			newlife = 55;
		c = PMAP(newlife, c);
		lightningRecreate = currentTick + std::max(newlife / 4, 1);
		rx = ry = 0;
	}
	else if (c == PT_TESC)
	{
		int newtmp = (rx*4+ry*4+7);
		if (newtmp > 300)
			newtmp = 300;
		c = PMAP(newtmp, c);
	}

	for (int j = -ry; j <= ry; j++)
		for (int i = -rx; i <= rx; i++)
			if (CreatePartFlags(p, x+i, y+j, c, flags))
				created = true;
	return !created;
}

void Simulation::CreateLine(int x1, int y1, int x2, int y2, int c, Brush const &cBrush, int flags)
{
	int x, y, dx, dy, sy, rx = cBrush.GetRadius().X, ry = cBrush.GetRadius().Y;
	bool reverseXY = abs(y2-y1) > abs(x2-x1);
	float e = 0.0f, de;
	if (reverseXY)
	{
		y = x1;
		x1 = y1;
		y1 = y;
		y = x2;
		x2 = y2;
		y2 = y;
	}
	if (x1 > x2)
	{
		y = x1;
		x1 = x2;
		x2 = y;
		y = y1;
		y1 = y2;
		y2 = y;
	}
	dx = x2 - x1;
	dy = abs(y2 - y1);
	de = dx ? dy/(float)dx : 0.0f;
	y = y1;
	sy = (y1<y2) ? 1 : -1;
	for (x=x1; x<=x2; x++)
	{
		if (reverseXY)
			CreateParts(-2, y, x, c, cBrush, flags);
		else
			CreateParts(-2, x, y, c, cBrush, flags);
		e += de;
		if (e >= 0.5f)
		{
			y += sy;
			if (!(rx+ry) && ((y1<y2) ? (y<=y2) : (y>=y2)))
			{
				if (reverseXY)
					CreateParts(-2, y, x, c, cBrush, flags);
				else
					CreateParts(-2, x, y, c, cBrush, flags);
			}
			e -= 1.0f;
		}
	}
}

void Simulation::CreateBox(int p, int x1, int y1, int x2, int y2, int c, int flags)
{
	int i, j;
	if (x1>x2)
	{
		i = x2;
		x2 = x1;
		x1 = i;
	}
	if (y1>y2)
	{
		j = y2;
		y2 = y1;
		y1 = j;
	}
	for (j=y2; j>=y1; j--)
		for (i=x1; i<=x2; i++)
			CreateParts(p, i, j, 0, 0, c, flags);
}

int Simulation::FloodParts(int x, int y, int fullc, int cm, int flags)
{
	int c = TYP(fullc);
	int x1, x2, dy = (c<PT_NUM)?1:CELL;
	int coord_stack_limit = XRES*YRES;
	unsigned short (*coord_stack)[2];
	int coord_stack_size = 0;
	int created_something = 0;

	// Bitmap for checking where we've already looked
	auto bitmapPtr = std::unique_ptr<char[]>(new char[XRES * YRES]);
	char *bitmap = bitmapPtr.get();
	std::fill(&bitmap[0], &bitmap[0] + XRES * YRES, 0);

	if (cm==-1)
	{
		//if initial flood point is out of bounds, do nothing
		if (c != 0 && (x < CELL || x >= XRES-CELL || y < CELL || y >= YRES-CELL || c == PT_SPRK))
			return 1;
		else if (x < 0 || x >= XRES || y < 0 || y >= YRES)
			return 1;
		
		if (c == 0)
		{
			cm = TYP(pmap[y][x]);
			if (!cm)
			{
				cm = TYP(photons[y][x]);
				if (!cm)
				{
					if (bmap[y/CELL][x/CELL])
						return FloodWalls(x, y, WL_ERASE, -1);
					else
						return -1;
				}
			}
		}
		else
			cm = 0;
	}
	
	if (c != 0 && IsWallBlocking(x, y, c))
		return 1;

	if (!FloodFillPmapCheck(x, y, cm))
		return 1;

	coord_stack = (short unsigned int (*)[2])malloc(sizeof(unsigned short)*2*coord_stack_limit);
	coord_stack[coord_stack_size][0] = x;
	coord_stack[coord_stack_size][1] = y;
	coord_stack_size++;

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	do
	{
		coord_stack_size--;
		x = coord_stack[coord_stack_size][0];
		y = coord_stack[coord_stack_size][1];
		x1 = x2 = x;
		// go left as far as possible
		while (c?x1>CELL:x1>0)
		{
			if (bitmap[(y * XRES) + x1 - 1] || !FloodFillPmapCheck(x1-1, y, cm) || (c != 0 && IsWallBlocking(x1-1, y, c)))
			{
				break;
			}
			x1--;
		}
		// go right as far as possible
		while (c?x2<XRES-CELL-1:x2<XRES-1)
		{
			if (bitmap[(y * XRES) + x2 + 1] || !FloodFillPmapCheck(x2+1, y, cm) || (c != 0 && IsWallBlocking(x2+1, y, c)))
			{
				break;
			}
			x2++;
		}
		// fill span
		for (x=x1; x<=x2; x++)
		{
			if (!fullc)
			{
				if (elements[cm].Properties&TYPE_ENERGY)
				{
					if (photons[y][x])
					{
						kill_part(ID(photons[y][x]));
						created_something = 1;
					}
				}
				else if (pmap[y][x])
				{
					kill_part(ID(pmap[y][x]));
					created_something = 1;
				}
			}
			else if (CreateParts(-2, x, y, 0, 0, fullc, flags))
				created_something = 1;
			bitmap[(y * XRES) + x] = 1;
		}

		if (c?y>=CELL+dy:y>=dy)
			for (x=x1; x<=x2; x++)
				if (!bitmap[((y - dy) * XRES) + x] && FloodFillPmapCheck(x, y-dy, cm) && (c == 0 || !IsWallBlocking(x, y-dy, c)))
				{
					coord_stack[coord_stack_size][0] = x;
					coord_stack[coord_stack_size][1] = y-dy;
					coord_stack_size++;
					if (coord_stack_size>=coord_stack_limit)
					{
						free(coord_stack);
						return -1;
					}
				}

		if (c?y<YRES-CELL-dy:y<YRES-dy)
			for (x=x1; x<=x2; x++)
				if (!bitmap[((y + dy) * XRES) + x] && FloodFillPmapCheck(x, y+dy, cm) && (c == 0 || !IsWallBlocking(x, y+dy, c)))
				{
					coord_stack[coord_stack_size][0] = x;
					coord_stack[coord_stack_size][1] = y+dy;
					coord_stack_size++;
					if (coord_stack_size>=coord_stack_limit)
					{
						free(coord_stack);
						return -1;
					}
				}
	} while (coord_stack_size>0);
	free(coord_stack);
	return created_something;
}


=== src\simulation\Element.cpp ===

#include "ElementCommon.h"
#include "StructProperty.h"

Element::Element():
	Identifier("DEFAULT_INVALID"),
	Name(""),
	Colour(0xFF00FF_rgb),
	MenuVisible(0),
	MenuSection(0),
	Enabled(0),

	Advection(0.0f),
	AirDrag(-0.0f * CFDS),
	AirLoss(1.0f),
	Loss(1.0f),
	Collision(0.0f),
	Gravity(0.0f),
	NewtonianGravity(1.0f),
	Diffusion(0.0f),
	HotAir(0.0f * CFDS),
	Falldown(0),

	Flammable(0),
	Explosive(0),
	Meltable(0),
	Hardness(30),
	PhotonReflectWavelengths(0x3FFFFFFF),

	Weight(50),

	HeatConduct(128),
	LatentHeat(0),
	Description("No description"),

	Properties(TYPE_SOLID),
	CarriesTypeIn(0),

	LowPressure(IPL),
	LowPressureTransition(NT),
	HighPressure(IPH),
	HighPressureTransition(NT),
	LowTemperature(ITL),
	LowTemperatureTransition(NT),
	HighTemperature(ITH),
	HighTemperatureTransition(NT),

	Update(nullptr),
	Graphics(&Element::defaultGraphics),
	CtypeDraw(nullptr),
	IconGenerator(nullptr)
{
	memset(&DefaultProperties, 0, sizeof(Particle));
	DefaultProperties.temp = R_TEMP + 273.15f;
}

std::vector<StructProperty> const &Element::GetProperties()
{
	struct DoOnce
	{
		std::vector<StructProperty> properties;

		DoOnce()
		{
			properties = {
				{ "Name",                      StructProperty::String,   offsetof(Element, Name                     ) },
				{ "Colour",                    StructProperty::Colour,   offsetof(Element, Colour                   ) },
				{ "Color",                     StructProperty::Colour,   offsetof(Element, Colour                   ) },
				{ "MenuVisible",               StructProperty::Integer,  offsetof(Element, MenuVisible              ) },
				{ "MenuSection",               StructProperty::Integer,  offsetof(Element, MenuSection              ) },
				{ "Enabled",                   StructProperty::Integer,  offsetof(Element, Enabled                  ) },
				{ "Advection",                 StructProperty::Float,    offsetof(Element, Advection                ) },
				{ "AirDrag",                   StructProperty::Float,    offsetof(Element, AirDrag                  ) },
				{ "AirLoss",                   StructProperty::Float,    offsetof(Element, AirLoss                  ) },
				{ "Loss",                      StructProperty::Float,    offsetof(Element, Loss                     ) },
				{ "Collision",                 StructProperty::Float,    offsetof(Element, Collision                ) },
				{ "Gravity",                   StructProperty::Float,    offsetof(Element, Gravity                  ) },
				{ "NewtonianGravity",          StructProperty::Float,    offsetof(Element, NewtonianGravity         ) },
				{ "Diffusion",                 StructProperty::Float,    offsetof(Element, Diffusion                ) },
				{ "HotAir",                    StructProperty::Float,    offsetof(Element, HotAir                   ) },
				{ "Falldown",                  StructProperty::Integer,  offsetof(Element, Falldown                 ) },
				{ "Flammable",                 StructProperty::Integer,  offsetof(Element, Flammable                ) },
				{ "Explosive",                 StructProperty::Integer,  offsetof(Element, Explosive                ) },
				{ "Meltable",                  StructProperty::Integer,  offsetof(Element, Meltable                 ) },
				{ "Hardness",                  StructProperty::Integer,  offsetof(Element, Hardness                 ) },
				{ "PhotonReflectWavelengths",  StructProperty::UInteger, offsetof(Element, PhotonReflectWavelengths ) },
				{ "CarriesTypeIn",             StructProperty::UInteger, offsetof(Element, CarriesTypeIn            ) },
				{ "Weight",                    StructProperty::Integer,  offsetof(Element, Weight                   ) },
				{ "Temperature",               StructProperty::Float,    offsetof(Element, DefaultProperties.temp   ) },
				{ "HeatConduct",               StructProperty::UChar,    offsetof(Element, HeatConduct              ) },
				{ "Description",               StructProperty::String,   offsetof(Element, Description              ) },
				{ "State",                     StructProperty::Removed,  0                                            },
				{ "Properties",                StructProperty::Integer,  offsetof(Element, Properties               ) },
				{ "LowPressure",               StructProperty::Float,    offsetof(Element, LowPressure              ) },
				{ "LowPressureTransition",     StructProperty::TransitionType,  offsetof(Element, LowPressureTransition    ) },
				{ "HighPressure",              StructProperty::Float,    offsetof(Element, HighPressure             ) },
				{ "HighPressureTransition",    StructProperty::TransitionType,  offsetof(Element, HighPressureTransition   ) },
				{ "LowTemperature",            StructProperty::Float,    offsetof(Element, LowTemperature           ) },
				{ "LowTemperatureTransition",  StructProperty::TransitionType,  offsetof(Element, LowTemperatureTransition ) },
				{ "HighTemperature",           StructProperty::Float,    offsetof(Element, HighTemperature          ) },
				{ "HighTemperatureTransition", StructProperty::TransitionType,  offsetof(Element, HighTemperatureTransition) }
			};
			if constexpr (LATENTHEAT)
			{
				properties.push_back({ "LatentHeat", StructProperty::UInteger, offsetof(Element, LatentHeat) });
			}
		}
	};
	static DoOnce doOnce;
	return doOnce.properties;
}

int Element::legacyUpdate(UPDATE_FUNC_ARGS) {
	int r, rx, ry;
	int t = parts[i].type;
	if (t==PT_WTRV) {
		for (rx=-2; rx<3; rx++)
			for (ry=-2; ry<3; ry++)
				if (x+rx>=0 && y+ry>0 &&
				        x+rx<XRES && y+ry<YRES && (rx || ry))
				{
					r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if ((TYP(r)==PT_WATR||TYP(r)==PT_DSTW||TYP(r)==PT_SLTW) && sim->rng.chance(1, 1000))
					{
						sim->part_change_type(i,x,y,PT_WATR);
						sim->part_change_type(ID(r),x+rx,y+ry,PT_WATR);
					}
					if ((TYP(r)==PT_ICEI || TYP(r)==PT_SNOW) && sim->rng.chance(1, 1000))
					{
						sim->part_change_type(i,x,y,PT_WATR);
						if (sim->rng.chance(1, 1000))
							sim->part_change_type(ID(r),x+rx,y+ry,PT_WATR);
					}
				}
	}
	else if (t==PT_WATR) {
		for (rx=-2; rx<3; rx++)
			for (ry=-2; ry<3; ry++)
				if (x+rx>=0 && y+ry>0 &&
				        x+rx<XRES && y+ry<YRES && (rx || ry))
				{
					r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if ((TYP(r)==PT_FIRE || TYP(r)==PT_LAVA) && sim->rng.chance(1, 10))
					{
						sim->part_change_type(i,x,y,PT_WTRV);
					}
				}
	}
	else if (t==PT_SLTW) {
		for (rx=-2; rx<3; rx++)
			for (ry=-2; ry<3; ry++)
				if (x+rx>=0 && y+ry>0 &&
				        x+rx<XRES && y+ry<YRES && (rx || ry))
				{
					r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if ((TYP(r)==PT_FIRE || TYP(r)==PT_LAVA) && sim->rng.chance(1, 10))
					{
						if (sim->rng.chance(1, 4))
							sim->part_change_type(i,x,y,PT_SALT);
						else
							sim->part_change_type(i,x,y,PT_WTRV);
					}
				}
	}
	else if (t==PT_DSTW) {
		for (rx=-2; rx<3; rx++)
			for (ry=-2; ry<3; ry++)
				if (x+rx>=0 && y+ry>0 &&
				        x+rx<XRES && y+ry<YRES && (rx || ry))
				{
					r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if ((TYP(r)==PT_FIRE || TYP(r)==PT_LAVA) && sim->rng.chance(1, 10))
					{
						sim->part_change_type(i,x,y,PT_WTRV);
					}
				}
	}
	else if (t==PT_ICEI) {
		for (rx=-2; rx<3; rx++)
			for (ry=-2; ry<3; ry++)
				if (x+rx>=0 && y+ry>0 && x+rx<XRES && y+ry<YRES && (rx || ry))
				{
					r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if ((TYP(r)==PT_WATR || TYP(r)==PT_DSTW) && sim->rng.chance(1, 1000))
					{
						sim->part_change_type(i,x,y,PT_ICEI);
						sim->part_change_type(ID(r),x+rx,y+ry,PT_ICEI);
					}
				}
	}
	else if (t==PT_SNOW) {
		for (rx=-2; rx<3; rx++)
			for (ry=-2; ry<3; ry++)
				if (x+rx>=0 && y+ry>0 && x+rx<XRES && y+ry<YRES && (rx || ry))
				{
					r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if ((TYP(r)==PT_WATR || TYP(r)==PT_DSTW) && sim->rng.chance(1, 1000))
					{
						sim->part_change_type(i,x,y,PT_ICEI);
						sim->part_change_type(ID(r),x+rx,y+ry,PT_ICEI);
					}
					if ((TYP(r)==PT_WATR || TYP(r)==PT_DSTW) && sim->rng.chance(3, 200))
						sim->part_change_type(i,x,y,PT_WATR);
				}
	}
	if (t==PT_WTRV && sim->pv[y/CELL][x/CELL]>4.0f)
		sim->part_change_type(i,x,y,PT_DSTW);
	if (t==PT_OIL && sim->pv[y/CELL][x/CELL]<-6.0f)
		sim->part_change_type(i,x,y,PT_GAS);
	if (t==PT_GAS && sim->pv[y/CELL][x/CELL]>6.0f)
		sim->part_change_type(i,x,y,PT_OIL);
	if (t==PT_DESL && sim->pv[y/CELL][x/CELL]>12.0f)
	{
		sim->part_change_type(i,x,y,PT_FIRE);
		parts[i].life = sim->rng.between(120, 169);
	}
	return 0;
}

int Element::defaultGraphics(GRAPHICS_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int t = cpart->type;
	//Property based defaults
	if(elements[t].Properties & PROP_RADIOACTIVE) *pixel_mode |= PMODE_GLOW;
	if(elements[t].Properties & TYPE_LIQUID)
	{
		*pixel_mode |= PMODE_BLUR;
	}
	if(elements[t].Properties & TYPE_GAS)
	{
		*pixel_mode &= ~PMODE;
		*pixel_mode |= FIRE_BLEND;
		*firer = *colr/2;
		*fireg = *colg/2;
		*fireb = *colb/2;
		*firea = 125;
		*pixel_mode |= DECO_FIRE;
	}
	return 1;
}

bool Element::basicCtypeDraw(CTYPEDRAW_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (sim->parts[i].type == t || elements[t].Properties & PROP_NOCTYPEDRAW)
	{
		return false;
	}
	sim->parts[i].ctype = t;
	return true;
}

bool Element::ctypeDrawVInTmp(CTYPEDRAW_FUNC_ARGS)
{
	if (!Element::basicCtypeDraw(CTYPEDRAW_FUNC_SUBCALL_ARGS))
	{
		return false;
	}
	if (t == PT_LIFE)
	{
		sim->parts[i].tmp = v;
	}
	return true;
}

bool Element::ctypeDrawVInCtype(CTYPEDRAW_FUNC_ARGS)
{
	if (!Element::basicCtypeDraw(CTYPEDRAW_FUNC_SUBCALL_ARGS))
	{
		return false;
	}
	if (t == PT_LIFE)
	{
		sim->parts[i].ctype |= PMAPID(v);
	}
	return true;
}


=== src\simulation\Element.h ===

#pragma once
#include <memory>
#include "common/Vec2.h"
#include "graphics/Pixel.h"
#include "ElementDefs.h"
#include "Particle.h"
#include "StructProperty.h"

class Simulation;
class Renderer;
struct GraphicsFuncContext;
class VideoBuffer;
struct Particle;
class Element
{
public:
	ByteString Identifier;
	String Name;
	RGB Colour;
	int MenuVisible;
	int MenuSection;
	int Enabled;

	float Advection;
	float AirDrag;
	float AirLoss;
	float Loss;
	float Collision;
	float Gravity;
	float NewtonianGravity;
	float Diffusion;
	float HotAir;
	int Falldown;
	int Flammable;
	int Explosive;
	int Meltable;
	int Hardness;
	// Photon wavelengths are ANDed with this value when a photon hits an element, meaning that only wavelengths present in both this value and the original photon will remain in the reflected photon
	unsigned int PhotonReflectWavelengths;
	int Weight;
	unsigned char HeatConduct;
	unsigned int LatentHeat;
	String Description;
	unsigned int Properties;
	unsigned int CarriesTypeIn;

	float LowPressure;
	int LowPressureTransition;
	float HighPressure;
	int HighPressureTransition;
	float LowTemperature;
	int LowTemperatureTransition;
	float HighTemperature;
	int HighTemperatureTransition;

	int (*Update) (UPDATE_FUNC_ARGS);
	int (*Graphics) (GRAPHICS_FUNC_ARGS);

	void (*Create)(ELEMENT_CREATE_FUNC_ARGS) = nullptr;
	bool (*CreateAllowed)(ELEMENT_CREATE_ALLOWED_FUNC_ARGS) = nullptr;
	void (*ChangeType)(ELEMENT_CHANGETYPE_FUNC_ARGS) = nullptr;

	bool (*CtypeDraw) (CTYPEDRAW_FUNC_ARGS);

	std::unique_ptr<VideoBuffer> (*IconGenerator)(int, Vec2<int>);

	Particle DefaultProperties;

	Element();
	static int defaultGraphics(GRAPHICS_FUNC_ARGS);
	static int legacyUpdate(UPDATE_FUNC_ARGS);
	static bool basicCtypeDraw(CTYPEDRAW_FUNC_ARGS);
	static bool ctypeDrawVInTmp(CTYPEDRAW_FUNC_ARGS);
	static bool ctypeDrawVInCtype(CTYPEDRAW_FUNC_ARGS);

	/** Returns a list of properties, their type and offset within the structure that can be changed
	 by higher-level processes referring to them by name such as Lua or the property tool **/
	static std::vector<StructProperty> const &GetProperties();

#define ELEMENT_NUMBERS_DECLARE
#include "ElementNumbers.h"
#undef ELEMENT_NUMBERS_DECLARE
};


=== src\simulation\ElementClasses.cpp ===

#include "ElementCommon.h"

std::array<Element, PT_NUM> const &GetElements()
{
	struct DoOnce
	{
		std::array<Element, PT_NUM> elements;

		DoOnce()
		{
#define ELEMENT_NUMBERS_CALL
#include "ElementNumbers.h"
#undef ELEMENT_NUMBERS_CALL
		}
	};

	static DoOnce doOnce;
	return doOnce.elements;
}


=== src\simulation\ElementClasses.h ===

#pragma once
#include <array>

#include "SimulationData.h"
#include "Element.h"

#define ELEMENT_NUMBERS_ENUMERATE
#include "ElementNumbers.h"
#undef ELEMENT_NUMBERS_ENUMERATE

std::array<Element, PT_NUM> const &GetElements();


=== src\simulation\ElementCommon.h ===

#pragma once
// This header should be included by all files in src/elements/
#include "Misc.h"
#include "common/tpt-rand.h"
#include "common/tpt-compat.h"
#include "ElementClasses.h"
#include "Particle.h"
#include "ElementGraphics.h"
#include "Simulation.h"
#include "SimulationData.h"
#include "graphics/Renderer.h"
#include "TransitionConstants.h"
#include <algorithm>
#include <cmath>


=== src\simulation\ElementDefs.h ===

#pragma once
#include "SimulationConfig.h"
#include <cstdint>

constexpr float MAX_TEMP = 9999;
constexpr float MIN_TEMP = 0;
constexpr float O_MAX_TEMP = 3500;
constexpr float O_MIN_TEMP = -273;

constexpr float MAX_PRESSURE = 256.0f;
constexpr float MIN_PRESSURE = -256.0f;

constexpr auto TYPE_PART          = UINT32_C(0x00000001);  //1 Powders
constexpr auto TYPE_LIQUID        = UINT32_C(0x00000002);  //2 Liquids
constexpr auto TYPE_SOLID         = UINT32_C(0x00000004);  //4 Solids
constexpr auto TYPE_GAS           = UINT32_C(0x00000008);  //8 Gases (Includes plasma)
constexpr auto TYPE_ENERGY        = UINT32_C(0x00000010);  //16 Energy (Thunder, Light, Neutrons etc.)
constexpr auto STATE_FLAGS        = UINT32_C(0x0000001F);
constexpr auto PROP_CONDUCTS      = UINT32_C(0x00000020);  //32 Conducts electricity
constexpr auto PROP_PHOTPASS      = UINT32_C(0x00000040);  //64 Photons pass through (may refract as in glass)
constexpr auto PROP_NEUTPENETRATE = UINT32_C(0x00000080);  //128 Penetrated by neutrons
constexpr auto PROP_NEUTABSORB    = UINT32_C(0x00000100);  //256 Absorbs neutrons, reflect is default
constexpr auto PROP_NEUTPASS      = UINT32_C(0x00000200);  //512 Neutrons pass through, such as with glass
constexpr auto PROP_DEADLY        = UINT32_C(0x00000400);  //1024 Is deadly for stickman
constexpr auto PROP_HOT_GLOW      = UINT32_C(0x00000800);  //2048 Hot Metal Glow
constexpr auto PROP_LIFE          = UINT32_C(0x00001000);  //4096 Is a GoL type
constexpr auto PROP_RADIOACTIVE   = UINT32_C(0x00002000);  //8192 Radioactive
constexpr auto PROP_LIFE_DEC      = UINT32_C(0x00004000);  //2^14 Life decreases by one every frame if > zero
constexpr auto PROP_LIFE_KILL     = UINT32_C(0x00008000);  //2^15 Kill when life value is <= zero
constexpr auto PROP_LIFE_KILL_DEC = UINT32_C(0x00010000);  //2^16 Kill when life value is decremented to <= zero
constexpr auto PROP_SPARKSETTLE   = UINT32_C(0x00020000);  //2^17 Allow Sparks/Embers to settle
constexpr auto PROP_NOAMBHEAT     = UINT32_C(0x00040000);  //2^18 Don't transfer or receive heat from ambient heat.
constexpr auto PROP_NOCTYPEDRAW   = UINT32_C(0x00100000); // 2^20 When this element is drawn upon with, do not set ctype (like BCLN for CLNE)

constexpr auto FLAG_STAGNANT      = UINT32_C(0x00000001);
constexpr auto FLAG_SKIPMOVE      = UINT32_C(0x00000002); // skip movement for one frame, only implemented for PHOT
//#define FLAG_WATEREQUAL 0x4 //if a liquid was already checked during equalization
constexpr auto FLAG_MOVABLE       = UINT32_C(0x00000008); // compatibility with old saves (moving SPNG), only applies to SPNG
constexpr auto FLAG_PHOTDECO      = UINT32_C(0x00000008); // compatibility with old saves (decorated photons), only applies to PHOT. Having the same value as FLAG_MOVABLE is fine because they apply to different elements, and this saves space for future flags,


#define UPDATE_FUNC_ARGS Simulation* sim, int i, int x, int y, int surround_space, int nt, Parts &parts, int pmap[YRES][XRES]
#define UPDATE_FUNC_SUBCALL_ARGS sim, i, x, y, surround_space, nt, parts, pmap

#define GRAPHICS_FUNC_ARGS GraphicsFuncContext &gfctx, const Particle *cpart, int nx, int ny, int *pixel_mode, int* cola, int *colr, int *colg, int *colb, int *firea, int *firer, int *fireg, int *fireb
#define GRAPHICS_FUNC_SUBCALL_ARGS gfctx, cpart, nx, ny, pixel_mode, cola, colr, colg, colb, firea, firer, fireg, fireb

#define ELEMENT_CREATE_FUNC_ARGS Simulation *sim, int i, int x, int y, int t, int v

#define ELEMENT_CREATE_ALLOWED_FUNC_ARGS Simulation *sim, int i, int x, int y, int t

#define ELEMENT_CHANGETYPE_FUNC_ARGS Simulation *sim, int i, int x, int y, int from, int to

#define CTYPEDRAW_FUNC_ARGS Simulation *sim, int i, int t, int v
#define CTYPEDRAW_FUNC_SUBCALL_ARGS sim, i, t, v

constexpr int OLD_PT_WIND = 147;

// Change this to change the amount of bits used to store type in pmap (and a few elements such as PIPE and CRAY)
constexpr int PMAPBITS = 9;
constexpr int PMAPMASK = ((1 << PMAPBITS) - 1);
constexpr int ID(int r)
{
	return r >> PMAPBITS;
}
constexpr int TYP(int r)
{
	return r & PMAPMASK;
}
constexpr int PMAP(int id, int typ)
{
	return (id << PMAPBITS) | (typ & PMAPMASK);
}
constexpr int PMAPID(int id)
{
	return id << PMAPBITS;
}
constexpr int PT_NUM = 1 << PMAPBITS;

constexpr bool InBounds(int x, int y)
{
	return RES.OriginRect().Contains({ x, y });
}

struct playerst;
struct Parts;


=== src\simulation\ElementGraphics.h ===

#pragma once
#include <cstdint>

constexpr auto PMODE           = UINT32_C(0x00000FFF);
constexpr auto PMODE_NONE      = UINT32_C(0x00000000);
constexpr auto PMODE_FLAT      = UINT32_C(0x00000001);
constexpr auto PMODE_BLOB      = UINT32_C(0x00000002);
constexpr auto PMODE_BLUR      = UINT32_C(0x00000004);
constexpr auto PMODE_GLOW      = UINT32_C(0x00000008);
constexpr auto PMODE_SPARK     = UINT32_C(0x00000010);
constexpr auto PMODE_FLARE     = UINT32_C(0x00000020);
constexpr auto PMODE_LFLARE    = UINT32_C(0x00000040);
constexpr auto PMODE_ADD       = UINT32_C(0x00000080);
constexpr auto PMODE_BLEND     = UINT32_C(0x00000100);
constexpr auto PSPEC_STICKMAN  = UINT32_C(0x00000200);

constexpr auto OPTIONS         = UINT32_C(0x0000F000);
constexpr auto NO_DECO         = UINT32_C(0x00001000);
constexpr auto DECO_FIRE       = UINT32_C(0x00002000);

constexpr auto FIREMODE        = UINT32_C(0x00FF0000);
constexpr auto FIRE_ADD        = UINT32_C(0x00010000);
constexpr auto FIRE_BLEND      = UINT32_C(0x00020000);
constexpr auto FIRE_SPARK      = UINT32_C(0x00040000);

constexpr auto EFFECT          = UINT32_C(0xFF000000);
constexpr auto EFFECT_GRAVIN   = UINT32_C(0x01000000);
constexpr auto EFFECT_GRAVOUT  = UINT32_C(0x02000000);
constexpr auto EFFECT_LINES    = UINT32_C(0x04000000);
constexpr auto EFFECT_DBGLINES = UINT32_C(0x08000000);

constexpr auto RENDER_EFFE     = OPTIONS | PSPEC_STICKMAN | EFFECT | PMODE_SPARK | PMODE_FLARE | PMODE_LFLARE;
constexpr auto RENDER_FIRE     = OPTIONS | PSPEC_STICKMAN | PMODE_ADD | PMODE_BLEND | FIRE_ADD | FIRE_BLEND;
constexpr auto RENDER_SPRK     = OPTIONS | PSPEC_STICKMAN | PMODE_ADD | PMODE_BLEND | FIRE_SPARK;
constexpr auto RENDER_GLOW     = OPTIONS | PSPEC_STICKMAN | PMODE_GLOW | PMODE_ADD | PMODE_BLEND;
constexpr auto RENDER_BLUR     = OPTIONS | PSPEC_STICKMAN | PMODE_BLUR | PMODE_ADD | PMODE_BLEND;
constexpr auto RENDER_BLOB     = OPTIONS | PSPEC_STICKMAN | PMODE_BLOB | PMODE_ADD | PMODE_BLEND;
constexpr auto RENDER_BASC     = OPTIONS | PSPEC_STICKMAN | PMODE_FLAT | PMODE_ADD | PMODE_BLEND | EFFECT_LINES;
constexpr auto RENDER_NONE     = OPTIONS | PSPEC_STICKMAN | PMODE_FLAT;

constexpr auto COLOUR_HEAT     = UINT32_C(0x00000001);
constexpr auto COLOUR_LIFE     = UINT32_C(0x00000002);
constexpr auto COLOUR_GRAD     = UINT32_C(0x00000004);
constexpr auto COLOUR_BASC     = UINT32_C(0x00000008);

constexpr auto COLOUR_DEFAULT  = UINT32_C(0x00000000);

constexpr auto DISPLAY_AIRC    = UINT32_C(0x00000001);
constexpr auto DISPLAY_AIRP    = UINT32_C(0x00000002);
constexpr auto DISPLAY_AIRV    = UINT32_C(0x00000004);
constexpr auto DISPLAY_AIRH    = UINT32_C(0x00000008);
constexpr auto DISPLAY_AIR     = UINT32_C(0x0000000F);
constexpr auto DISPLAY_WARP    = UINT32_C(0x00000010);
constexpr auto DISPLAY_PERS    = UINT32_C(0x00000020);
constexpr auto DISPLAY_EFFE    = UINT32_C(0x00000040);


=== src\simulation\ElementNumbers.template.h ===

#ifdef ELEMENT_NUMBERS_CALL
# define ELEMENT_DEFINE(name, id) elements[id].Element_ ## name ()
#endif
#ifdef ELEMENT_NUMBERS_DECLARE
# define ELEMENT_DEFINE(name, id) void Element_ ## name ()
#endif
#ifdef ELEMENT_NUMBERS_ENUMERATE
# define ELEMENT_DEFINE(name, id) constexpr int PT_ ## name = id
#endif

@element_defs@

#undef ELEMENT_DEFINE


=== src\simulation\GOLString.cpp ===

#include "GOLString.h"

int ParseGOLString(const String &value)
{
	// * Most likely a GOL string.
	auto it = value.begin() + 1;
	auto begin = 0U;
	auto stay = 0U;
	auto states = 2U;

	// Scan 'B' section, must be between 1 and 8
	for (; it != value.end() && it[0] >= '1' && it[0] <= '8'; ++it)
	{
		begin |= 1U << (it[0] - '0');
	}
	if (!begin)
	{
		return -1;
	}

	// Must have a /S immediately afterwards
	if (it < value.end() - 1 && it[0] == '/' && it[1] == 'S')
	{
		it += 2;
	}
	else
	{
		return -1;
	}

	// Scan 'S' section, must be between 0 and 8
	for (; it != value.end() && it[0] >= '0' && it[0] <= '8'; ++it)
	{
		stay |= 1U << (it[0] - '0');
	}

	// Optionally can have a 3rd section, with the number of frames to remain after dying
	if (it != value.end())
	{
		if (it[0] == '/')
		{
			it += 1;
		}
		else
		{
			return -1;
		}
		states = String(it, value.end()).ToNumber<unsigned int>(true);
		if (states < 2 || states > 17)
		{
			return -1;
		}
	}

	return stay | (begin << 8) | ((states - 2) << 17);
}

bool ValidateGOLName(const String &value)
{
	bool nameOk = true;
	for (auto ch : value)
	{
		if (!((ch >= '0' && ch < '9') || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch == '-')))
		{
			nameOk = false;
		}
	}
	return nameOk;
}

String SerialiseGOLRule(int rule)
{
	StringBuilder golName;
	golName << "B";
	for (int i = 1; i < 9; ++i)
	{
		if ((rule >> (i + 8)) & 1)
		{
			golName << char('0' + i);
		}
	}
	golName << "/S";
	for (int i = 0; i < 9; ++i)
	{
		if ((rule >> i) & 1)
		{
			golName << char('0' + i);
		}
	}
	if ((rule >> 17) & 0xF)
	{
		golName << "/" << ((rule >> 17) & 0xF) + 2;
	}
	return golName.Build();
}


=== src\simulation\GOLString.h ===

#pragma once

#include "common/String.h"
#include <exception>

bool ValidateGOLName(const String &value);
int ParseGOLString(const String &value);
String SerialiseGOLRule(int rule);


=== src\simulation\MenuSection.h ===

#pragma once
#include "common/String.h"

struct menu_section
{
	String::value_type icon;
	String name;
	int itemcount;
	int doshow;
};

constexpr int SC_WALL      =  0;
constexpr int SC_ELEC      =  1;
constexpr int SC_POWERED   =  2;
constexpr int SC_SENSOR    =  3;
constexpr int SC_FORCE     =  4;
constexpr int SC_EXPLOSIVE =  5;
constexpr int SC_GAS       =  6;
constexpr int SC_LIQUID    =  7;
constexpr int SC_POWDERS   =  8;
constexpr int SC_SOLIDS    =  9;
constexpr int SC_NUCLEAR   = 10;
constexpr int SC_SPECIAL   = 11;
constexpr int SC_LIFE      = 12;
constexpr int SC_TOOL      = 13;
constexpr int SC_FAVORITES = 14;
constexpr int SC_DECO      = 15;


=== src\simulation\meson.build ===

simulation_files = files(
	'Air.cpp',
	'AccessProperty.cpp',
	'Element.cpp',
	'ElementClasses.cpp',
	'GOLString.cpp',
	'Particle.cpp',
	'SaveRenderer.cpp',
	'Sign.cpp',
	'SimulationData.cpp',
	'Simulation.cpp',
	'StructProperty.cpp',
)

subdir('elements')
subdir('simtools')
subdir('gravity')

powder_files += files(
	'AccessPropertyParse.cpp',
	'Editing.cpp',
	'SimTool.cpp',
	'ToolClasses.cpp',
	'Snapshot.cpp',
	'SnapshotDelta.cpp',
)


=== src\simulation\MissingElements.h ===

#pragma once
#include <set>
#include <map>
#include "common/String.h"

struct MissingElements
{
	std::map<ByteString, int> identifiers;
	std::set<int> ids;

	operator bool() const
	{
		return identifiers.size() || ids.size();
	}
};


=== src\simulation\orbitalparts.h ===

#pragma once

inline void orbitalparts_get(int block1, int block2, int resblock1[], int resblock2[])
{
	resblock1[0] = (block1&0x000000FF);
	resblock1[1] = (block1&0x0000FF00)>>8;
	resblock1[2] = (block1&0x00FF0000)>>16;
	resblock1[3] = (block1&0xFF000000)>>24;

	resblock2[0] = (block2&0x000000FF);
	resblock2[1] = (block2&0x0000FF00)>>8;
	resblock2[2] = (block2&0x00FF0000)>>16;
	resblock2[3] = (block2&0xFF000000)>>24;
}

inline void orbitalparts_set(int *block1, int *block2, int resblock1[], int resblock2[])
{
	int block1tmp = 0;
	int block2tmp = 0;

	block1tmp = (resblock1[0]&0xFF);
	block1tmp |= (resblock1[1]&0xFF)<<8;
	block1tmp |= (resblock1[2]&0xFF)<<16;
	block1tmp |= (resblock1[3]&0xFF)<<24;

	block2tmp = (resblock2[0]&0xFF);
	block2tmp |= (resblock2[1]&0xFF)<<8;
	block2tmp |= (resblock2[2]&0xFF)<<16;
	block2tmp |= (resblock2[3]&0xFF)<<24;

	*block1 = block1tmp;
	*block2 = block2tmp;
}


=== src\simulation\Particle.cpp ===

#include "Particle.h"
#include <cstddef>
#include <cassert>

std::vector<StructProperty> const &Particle::GetProperties()
{
	static std::vector<StructProperty> properties = {
		{ "type"   , StructProperty::ParticleType, (intptr_t)(offsetof(Particle, type   )) },
		{ "life"   , StructProperty::Integer     , (intptr_t)(offsetof(Particle, life   )) },
		{ "ctype"  , StructProperty::ParticleType, (intptr_t)(offsetof(Particle, ctype  )) },
		{ "x"      , StructProperty::Float       , (intptr_t)(offsetof(Particle, x      )) },
		{ "y"      , StructProperty::Float       , (intptr_t)(offsetof(Particle, y      )) },
		{ "vx"     , StructProperty::Float       , (intptr_t)(offsetof(Particle, vx     )) },
		{ "vy"     , StructProperty::Float       , (intptr_t)(offsetof(Particle, vy     )) },
		{ "temp"   , StructProperty::Float       , (intptr_t)(offsetof(Particle, temp   )) },
		{ "flags"  , StructProperty::UInteger    , (intptr_t)(offsetof(Particle, flags  )) },
		{ "tmp"    , StructProperty::Integer     , (intptr_t)(offsetof(Particle, tmp    )) },
		{ "tmp2"   , StructProperty::Integer     , (intptr_t)(offsetof(Particle, tmp2   )) },
		{ "tmp3"   , StructProperty::Integer     , (intptr_t)(offsetof(Particle, tmp3   )) },
		{ "tmp4"   , StructProperty::Integer     , (intptr_t)(offsetof(Particle, tmp4   )) },
		{ "dcolour", StructProperty::UInteger    , (intptr_t)(offsetof(Particle, dcolour)) },
	};
	return properties;
}

std::vector<StructPropertyAlias> const &Particle::GetPropertyAliases()
{
	static std::vector<StructPropertyAlias> aliases = {
		{ "pavg0" , "tmp3"    },
		{ "pavg1" , "tmp4"    },
		{ "dcolor", "dcolour" },
	};
	return aliases;
}

std::vector<unsigned int> const &Particle::PossiblyCarriesType()
{
	struct DoOnce
	{
		std::vector<unsigned int> indices = {
			FIELD_LIFE,
			FIELD_CTYPE,
			FIELD_TMP,
			FIELD_TMP2,
			FIELD_TMP3,
			FIELD_TMP4,
		};

		DoOnce()
		{
			auto &properties = GetProperties();
			for (auto index : indices)
			{
				// code that depends on PossiblyCarriesType only knows how to set ints
				assert(properties[index].Type == StructProperty::Integer ||
				       properties[index].Type == StructProperty::ParticleType);
			}
		}
	};
	static DoOnce doOnce;
	return doOnce.indices;
}


=== src\simulation\Particle.h ===

#pragma once
#include "StructProperty.h"
#include <vector>

struct Particle
{
	int type;
	int life, ctype;
	float x, y, vx, vy;
	float temp;
	int tmp3;
	int tmp4;
	int flags;
	int tmp;
	int tmp2;
	unsigned int dcolour;
	/** Returns a list of properties, their type and offset within the structure that can be changed
	 by higher-level processes referring to them by name such as Lua or the property tool **/
	static std::vector<StructProperty> const &GetProperties();
	static std::vector<StructPropertyAlias> const &GetPropertyAliases();
	static std::vector<unsigned int> const &PossiblyCarriesType();
};

// important: these are indices into the vector returned by Particle::GetProperties, not indices into Particle
constexpr unsigned int FIELD_TYPE  =  0;
constexpr unsigned int FIELD_LIFE  =  1;
constexpr unsigned int FIELD_CTYPE =  2;
constexpr unsigned int FIELD_TMP   =  9;
constexpr unsigned int FIELD_TMP2  = 10;
constexpr unsigned int FIELD_TMP3  = 11;
constexpr unsigned int FIELD_TMP4  = 12;


=== src\simulation\Sample.h ===

#pragma once
#include "Particle.h"

struct SimulationSample
{
	Particle particle;
	int ParticleID = 0;
	int PositionX = 0;
	int PositionY = 0;
	float AirPressure = 0;
	float AirTemperature = 0;
	float AirVelocityX = 0;
	float AirVelocityY = 0;

	int WallType = 0;
	float GravityVelocityX = 0;
	float GravityVelocityY = 0;

	int NumParts = 0;
	bool isMouseInSim = true;
};


=== src\simulation\SaveRenderer.cpp ===

#include "SaveRenderer.h"

#include "client/GameSave.h"

#include "graphics/VideoBuffer.h"
#include "graphics/Renderer.h"

#include "Simulation.h"
#include "SimulationData.h"

SaveRenderer::SaveRenderer()
{
	sim = std::make_unique<Simulation>();
	ren = std::make_unique<Renderer>();
	ren->sim = sim.get();
}

SaveRenderer::~SaveRenderer() = default;

std::unique_ptr<VideoBuffer> SaveRenderer::Render(const GameSave *save, bool fire, RendererSettings rendererSettings)
{
	// this function usually runs on a thread different from where element info in SimulationData may be written, so we acquire a read-only lock on it
	auto &sd = SimulationData::CRef();
	std::shared_lock lk(sd.elementGraphicsMx);
	std::lock_guard<std::mutex> gx(renderMutex);

	ren->ApplySettings(rendererSettings);

	sim->clear_sim();

	sim->Load(save, true, { 0, 0 });
	ren->ClearAccumulation();
	ren->Clear();
	if (fire)
	{
		ren->ApproximateAccumulation();
	}
	ren->RenderSimulation();

	auto tempThumb = std::make_unique<VideoBuffer>(save->blockSize * CELL);
	auto &video = ren->GetVideo();
	tempThumb->BlendImage(video.data(), 0xFF, video.Size().OriginRect());

	return tempThumb;
}


=== src\simulation\SaveRenderer.h ===

#pragma once
#include <memory>
#include <mutex>
#include <utility>
#include <vector>
#include "common/ExplicitSingleton.h"
#include "graphics/RendererSettings.h"
#include "common/String.h"

class GameSave;
class VideoBuffer;
class Simulation;
class Renderer;

class SaveRenderer: public ExplicitSingleton<SaveRenderer>
{
	std::unique_ptr<Simulation> sim;
	std::unique_ptr<Renderer> ren;
	std::mutex renderMutex;

public:
	SaveRenderer();
	~SaveRenderer();
	std::unique_ptr<VideoBuffer> Render(const GameSave *save, bool fire, RendererSettings rendererSettings);
};


=== src\simulation\Sign.cpp ===

#include "Sign.h"

#include "graphics/Renderer.h"
#include "Simulation.h"
#include "SimulationData.h"

sign::sign(String text_, int x_, int y_, Justification justification_):
	x(x_),
	y(y_),
	ju(justification_),
	text(text_)
{
}

String sign::getDisplayText(const RenderableSimulation *sim, int &x0, int &y0, int &w, int &h, bool colorize, bool *v95) const
{
	auto &sd = SimulationData::CRef();
	String drawable_text;
	auto si = std::make_pair(0, Type::Normal);
	if (text.find('{') == text.npos)
	{
		drawable_text = text;
	}
	else
	{
		si = split();
		if (si.first)
		{
			drawable_text = text.Between(si.first + 1, text.size() - 1);
		}
		else
		{
			Particle const *part = nullptr;
			float pressure = 0.0f;
			float aheat = 0.0f;
			if (sim && x >= 0 && x < XRES && y >= 0 && y < YRES)
			{
				if (sim->photons[y][x])
				{
					part = &(sim->parts[ID(sim->photons[y][x])]);
				}
				else if (sim->pmap[y][x])
				{
					part = &(sim->parts[ID(sim->pmap[y][x])]);
				}
				pressure = sim->pv[y/CELL][x/CELL];
				aheat = sim->hv[y/CELL][x/CELL] - 273.15f;
			}

			String remaining_text = text;
			StringBuilder formatted_text;
			while (auto split_left_curly = remaining_text.SplitBy('{'))
			{
				String after_left_curly = split_left_curly.After();
				if (auto split_right_curly = after_left_curly.SplitBy('}'))
				{
					formatted_text << split_left_curly.Before();
					remaining_text = split_right_curly.After();
					String between_curlies = split_right_curly.Before();
					if (between_curlies == "t" || between_curlies == "temp")
					{
						formatted_text << Format::Precision(Format::ShowPoint(part ? part->temp - 273.15f : 0.0f), 2);
						// * We would really only need to do this if the sign used the new
						//   keyword "temp" or if the text was more than just "{t}", but 95.0
						//   upgrades such signs at load time anyway.
						// * The same applies to "{p}" and "{aheat}" signs.
						if (v95)
							*v95 = true;
					}
					else if (between_curlies == "p" || between_curlies == "pres")
					{
						formatted_text << Format::Precision(Format::ShowPoint(pressure), 2);
						if (v95)
							*v95 = true;
					}
					else if (between_curlies == "a" || between_curlies == "aheat")
					{
						formatted_text << Format::Precision(Format::ShowPoint(aheat), 2);
						if (v95)
							*v95 = true;
					}
					else if (between_curlies == "type")
					{
						formatted_text << (part ? sd.BasicParticleInfo(*part) : (formatted_text.Size() ? String::Build("empty") : String::Build("Empty")));
						if (v95)
							*v95 = true;
					}
					else if (between_curlies == "ctype")
					{
						formatted_text << (part ? (sd.IsElementOrNone(part->ctype) ? sd.ElementResolve(part->ctype, -1) : String::Build(part->ctype)) : (formatted_text.Size() ? String::Build("empty") : String::Build("Empty")));
						if (v95)
							*v95 = true;
					}
					else if (between_curlies == "life")
					{
						formatted_text << (part ? part->life : 0);
						if (v95)
							*v95 = true;
					}
					else if (between_curlies == "tmp")
					{
						formatted_text << (part ? part->tmp : 0);
						if (v95)
							*v95 = true;
					}
					else if (between_curlies == "tmp2")
					{
						formatted_text << (part ? part->tmp2 : 0);
						if (v95)
							*v95 = true;
					}
					else
					{
						formatted_text << '{' << between_curlies << '}';
					}
				}
				else
				{
					break;
				}
			}
			formatted_text << remaining_text;
			drawable_text = formatted_text.Build();
		}
	}

	if (colorize)
	{
		switch (si.second)
		{
		case Normal: break;
		case Save:   drawable_text = "\bt" + drawable_text; break;
		case Thread: drawable_text = "\bl" + drawable_text; break;
		case Button: drawable_text = "\bo" + drawable_text; break;
		case Search: drawable_text = "\bu" + drawable_text; break;
		}
	}

	w = Renderer::TextSize(drawable_text.c_str()).X + 4;
	h = 15;
	x0 = (ju == Right) ? x - w : (ju == Left) ? x : x - w/2;
	y0 = (y > 18) ? y - 18 : y + 4;

	return drawable_text;
}

std::pair<int, sign::Type> sign::split() const
{
	String::size_type pipe = 0;
	if (text.size() >= 4 && text.front() == '{' && text.back() == '}')
	{
		switch (text[1])
		{
		case 'c':
		case 't':
			if (text[2] == ':' && (pipe = text.find('|', 4)) != text.npos)
			{
				for (String::size_type i = 3; i < pipe; ++i)
				{
					if (text[i] < '0' || text[i] > '9')
					{
						return std::make_pair(0, Type::Normal);
					}
				}
				return std::make_pair(int(pipe), text[1] == 'c' ? Type::Save : Type::Thread);
			}
			break;

		case 'b':
			if (text[2] == '|')
			{
				return std::make_pair(2, Type::Button);
			}
			break;

		case 's':
			if (text[2] == ':' && (pipe = text.find('|', 3)) != text.npos)
			{
				return std::make_pair(int(pipe), Type::Search);
			}
			break;
		}
	}
	return std::make_pair(0, Type::Normal);
}


=== src\simulation\Sign.h ===

#pragma once
#include "common/String.h"
#include <utility>

struct RenderableSimulation;

struct sign
{
	enum Justification
	{
		Left,
		Middle,
		Right,
		None,
		Max,
	};

	enum Type
	{
		Normal,
		Save,
		Thread,
		Button,
		Search
	};

	int x, y;
	Justification ju;
	String text;

	sign(String text_, int x_, int y_, Justification justification_);
	String getDisplayText(const RenderableSimulation *sim, int &x, int &y, int &w, int &h, bool colorize = true, bool *v95 = nullptr) const;
	std::pair<int, Type> split() const;
};


=== src\simulation\SimTool.cpp ===

#include "SimTool.h"
#include "Simulation.h"
#include "gui/game/Brush.h"

void SimTool::CallPerform(Simulation *sim, ui::Point position, ui::Point brushOffset)
{
	Particle * cpart = nullptr;
	int r;
	if ((r = sim->pmap[position.Y][position.X]))
		cpart = &(sim->parts[ID(r)]);
	else if ((r = sim->photons[position.Y][position.X]))
		cpart = &(sim->parts[ID(r)]);
	if (Perform)
	{
		// TODO: maybe do something with the result
		Perform(this, sim, cpart, position.X, position.Y, brushOffset.X, brushOffset.Y, Strength);
	}
}

static void defaultPerformDraw(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position)
{
	for (ui::Point off : brush)
	{
		ui::Point coords = position + off;
		if (coords.X >= 0 && coords.Y >= 0 && coords.X < XRES && coords.Y < YRES)
		{
			tool->CallPerform(sim, coords, position);
		}
	}
}

static void defaultPerformDrawLine(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2, bool dragging)
{
	auto x1 = position1.X;
	auto y1 = position1.Y;
	auto x2 = position2.X;
	auto y2 = position2.Y;
	bool reverseXY = abs(y2-y1) > abs(x2-x1);
	int x, y, dx, dy, sy, rx = brush.GetRadius().X, ry = brush.GetRadius().Y;
	float e = 0.0f, de;
	if (reverseXY)
	{
		y = x1;
		x1 = y1;
		y1 = y;
		y = x2;
		x2 = y2;
		y2 = y;
	}
	if (x1 > x2)
	{
		y = x1;
		x1 = x2;
		x2 = y;
		y = y1;
		y1 = y2;
		y2 = y;
	}
	dx = x2 - x1;
	dy = abs(y2 - y1);
	de = dx ? dy/(float)dx : 0.0f;
	y = y1;
	sy = (y1<y2) ? 1 : -1;
	for (x=x1; x<=x2; x++)
	{
		if (reverseXY)
			defaultPerformDraw(tool, sim, brush, { y, x });
		else
			defaultPerformDraw(tool, sim, brush, { x, y });
		e += de;
		if (e >= 0.5f)
		{
			y += sy;
			if (!(rx+ry) && ((y1<y2) ? (y<=y2) : (y>=y2)))
			{
				if (reverseXY)
					defaultPerformDraw(tool, sim, brush, { y, x });
				else
					defaultPerformDraw(tool, sim, brush, { x, y });
			}
			e -= 1.0f;
		}
	}
}

static void defaultPerformDrawRect(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2)
{
	int brushX = ((position1.X + position2.X) / 2);
	int brushY = ((position1.Y + position2.Y) / 2);
	auto tl = ui::Point{ std::min(position1.X, position2.X), std::min(position1.Y, position2.Y) };
	auto br = ui::Point{ std::max(position1.X, position2.X), std::max(position1.Y, position2.Y) };
	for (auto p : RectBetween(tl, br))
	{
		tool->CallPerform(sim, p, { brushX, brushY });
	}
}

SimTool::SimTool()
{
	Perform = nullptr;
	PerformClick = nullptr;
	PerformDrag = nullptr;
	PerformDraw = defaultPerformDraw;
	PerformDrawLine = defaultPerformDrawLine;
	PerformDrawRect = defaultPerformDrawRect;
	PerformDrawFill = nullptr;
	PerformSelect = nullptr;
}

void SimTool::Click(Simulation * sim, const Brush &brush, ui::Point position)
{
	if (PerformClick)
	{
		PerformClick(this, sim, brush, position);
	}
}

void SimTool::Drag(Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2)
{
	if (PerformDrag)
	{
		PerformDrag(this, sim, brush, position1, position2);
	}
}

void SimTool::Draw(Simulation *sim, const Brush &brush, ui::Point position)
{
	if (PerformDraw)
	{
		PerformDraw(this, sim, brush, position);
	}
}

void SimTool::DrawLine(Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2, bool dragging)
{
	if (PerformDrawLine)
	{
		PerformDrawLine(this, sim, brush, position1, position2, dragging);
	}
}

void SimTool::DrawRect(Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2)
{
	if (PerformDrawRect)
	{
		PerformDrawRect(this, sim, brush, position1, position2);
	}
}

void SimTool::DrawFill(Simulation * sim, const Brush &brush, ui::Point position)
{
	if (PerformDrawFill)
	{
		PerformDrawFill(this, sim, brush, position);
	}
}

void SimTool::Select(int toolSelection)
{
	if (PerformSelect)
	{
		PerformSelect(this, toolSelection);
	}
}


=== src\simulation\SimTool.h ===

#pragma once
#include "gui/game/tool/Tool.h"
#include "common/String.h"
#include "graphics/Pixel.h"

class Simulation;
struct Particle;
class SimTool : public Tool
{
public:
	int  (*Perform        )(SimTool *tool, Simulation *sim, Particle *cpart, int x, int y, int brushX, int brushY, float strength);
	void (*PerformClick   )(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position);
	void (*PerformDrag    )(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2);
	void (*PerformDraw    )(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position);
	void (*PerformDrawLine)(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2, bool dragging);
	void (*PerformDrawRect)(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2);
	void (*PerformDrawFill)(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position);
	void (*PerformSelect  )(SimTool *tool, int toolSelection);


#define TOOL_NUMBERS_DECLARE
#include "ToolNumbers.h"
#undef TOOL_NUMBERS_DECLARE

	SimTool();
	void CallPerform(Simulation *sim, ui::Point position, ui::Point brushOffset);

	void Click(Simulation * sim, Brush const &brush, ui::Point position) override;
	void Drag(Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2) override;
	void Draw(Simulation *sim, const Brush &brush, ui::Point position) override;
	void DrawLine(Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2, bool dragging) override;
	void DrawRect(Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2) override;
	void DrawFill(Simulation * sim, Brush const &brush, ui::Point position) override;
	void Select(int toolSelection) override;
};


=== src\simulation\Simulation.cpp ===

#include "Simulation.h"
#include "Air.h"
#include "ElementClasses.h"
#include "TransitionConstants.h"
#include "gravity/Gravity.h"
#include "ToolClasses.h"
#include "SimulationData.h"
#include "client/GameSave.h"
#include "common/tpt-compat.h"
#include "common/tpt-rand.h"
#include "gui/game/Brush.h"
#include "elements/EMP.h"
#include "elements/LOLZ.h"
#include "elements/STKM.h"
#include "elements/PIPE.h"
#include "elements/FILT.h"
#include "elements/PRTI.h"
#include <iostream>
#include <set>

static float remainder_p(float x, float y)
{
	return std::fmod(x, y) + (x>=0 ? 0 : y);
}

void Simulation::Load(const GameSave *save, bool includePressure, Vec2<int> blockP) // block coordinates
{
	auto partP = blockP * CELL;

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;

	RecalcFreeParticles(false);

	struct ExistingParticle
	{
		int id;
		Vec2<int> pos;
	};
	std::vector<ExistingParticle> existingParticles;
	auto pasteArea = RES.OriginRect() & RectSized(partP, save->blockSize * CELL);
	for (int i = 0; i <= parts.lastActiveIndex; i++)
	{
		if (parts[i].type)
		{
			auto p = Vec2<int>{ int(parts[i].x + 0.5f), int(parts[i].y + 0.5f) };
			if (pasteArea.Contains(p))
			{
				existingParticles.push_back({ i, p });
			}
		}
	}
	std::sort(existingParticles.begin(), existingParticles.end(), [](const auto &lhs, const auto &rhs) {
		return std::tie(lhs.pos.Y, lhs.pos.X) < std::tie(rhs.pos.Y, rhs.pos.X);
	});
	PlaneAdapter<std::vector<size_t>> existingParticleIndices(pasteArea.size, existingParticles.size());
	{
		auto lastPos = Vec2<int>{ -1, -1 }; // not a valid pos in existingParticles
		for (auto it = existingParticles.begin(); it != existingParticles.end(); ++it)
		{
			if (lastPos != it->pos)
			{
				existingParticleIndices[it->pos - pasteArea.pos] = it - existingParticles.begin();
				lastPos = it->pos;
			}
		}
	}
	auto removeExistingParticles = [this, pasteArea, &existingParticles, &existingParticleIndices](Vec2<int> p) {
		auto rp = p - pasteArea.pos;
		if (existingParticleIndices.Size().OriginRect().Contains(rp))
		{
			auto index = existingParticleIndices[rp];
			for (auto it = existingParticles.begin() + index; it != existingParticles.end() && it->pos == p; ++it)
			{
				kill_part(it->id);
			}
			existingParticleIndices[rp] = existingParticles.size();
		}
	};

	std::map<unsigned int, unsigned int> soapList;
	for (int n = 0; n < NPART && n < save->particlesCount; n++)
	{
		Particle tempPart = save->particles[n];
		if (tempPart.type <= 0 || tempPart.type >= PT_NUM)
		{
			continue;
		}

		tempPart.x += (float)partP.X;
		tempPart.y += (float)partP.Y;
		int x = int(std::floor(tempPart.x + 0.5f));
		int y = int(std::floor(tempPart.y + 0.5f));

		// Check various scenarios where we are unable to spawn the element, and set type to 0 to block spawning later
		if (!InBounds(x, y))
		{
			continue;
		}

		// Ensure we can spawn this element
		if ((player.spwn == 1 && tempPart.type==PT_STKM) || (player2.spwn == 1 && tempPart.type==PT_STKM2))
		{
			continue;
		}
		if ((tempPart.type == PT_SPAWN || tempPart.type == PT_SPAWN2) && elementCount[tempPart.type])
		{
			continue;
		}
		if (tempPart.type == PT_FIGH && !Element_FIGH_CanAlloc(this))
		{
			continue;
		}
		if (!elements[tempPart.type].Enabled)
		{
			continue;
		}

		if (elements[tempPart.type].CreateAllowed)
		{
			if (!(*(elements[tempPart.type].CreateAllowed))(this, -3, int(tempPart.x + 0.5f), int(tempPart.y + 0.5f), tempPart.type))
			{
				continue;
			}
		}

		removeExistingParticles({ x, y });

		// Allocate particle (this location is guaranteed to be empty due to "full scan" logic above)
		auto i = create_part(-3, x, y, tempPart.type);
		if (i == -1)
		{
			continue;
		}
		if (i > parts.lastActiveIndex)
		{
			parts.lastActiveIndex = i;
		}
		parts[i] = tempPart;


		switch (parts[i].type)
		{
		case PT_STKM:
			Element_STKM_init_legs(this, &player, i);
			player.spwn = 1;
			player.elem = PT_DUST;

			if ((save->version < Version(93, 0) && parts[i].ctype == SPC_AIR) ||
			        (save->version < Version(88, 0) && parts[i].ctype == OLD_SPC_AIR))
			{
				player.fan = true;
			}
			if (save->stkm.rocketBoots1)
				player.rocketBoots = true;
			if (save->stkm.fan1)
				player.fan = true;
			break;
		case PT_STKM2:
			Element_STKM_init_legs(this, &player2, i);
			player2.spwn = 1;
			player2.elem = PT_DUST;
			if ((save->version < Version(93, 0) && parts[i].ctype == SPC_AIR) ||
			        (save->version < Version(88, 0) && parts[i].ctype == OLD_SPC_AIR))
			{
				player2.fan = true;
			}
			if (save->stkm.rocketBoots2)
				player2.rocketBoots = true;
			if (save->stkm.fan2)
				player2.fan = true;
			break;
		case PT_SPAWN:
			player.spawnID = i;
			break;
		case PT_SPAWN2:
			player2.spawnID = i;
			break;
		case PT_FIGH:
		{
			unsigned int oldTmp = parts[i].tmp;
			parts[i].tmp = Element_FIGH_Alloc(this);
			if (parts[i].tmp >= 0)
			{
				bool fan = false;
				if ((save->version < Version(93, 0) && parts[i].ctype == SPC_AIR)
						|| (save->version < Version(88, 0) && parts[i].ctype == OLD_SPC_AIR))
				{
					fan = true;
					parts[i].ctype = 0;
				}
				fighters[parts[i].tmp].elem = PT_DUST;
				Element_FIGH_NewFighter(this, parts[i].tmp, i, parts[i].ctype);
				if (fan)
					fighters[parts[i].tmp].fan = true;
				for (unsigned int fighNum : save->stkm.rocketBootsFigh)
				{
					if (fighNum == oldTmp)
						fighters[parts[i].tmp].rocketBoots = true;
				}
				for (unsigned int fighNum : save->stkm.fanFigh)
				{
					if (fighNum == oldTmp)
						fighters[parts[i].tmp].fan = true;
				}
			}
			else
			{
				// Should not be possible because we verify with CanAlloc above this
				parts[i].type = 0;
			}
			break;
		}
		case PT_SOAP:
			soapList.insert(std::pair<unsigned int, unsigned int>(n, i));
			break;
		}
		if (GameSave::PressureInTmp3(parts[i].type) && !includePressure)
		{
			parts[i].tmp3 = 0;
		}
	}
	parts.lastActiveIndex = NPART-1;
	force_stacking_check = true;
	Element_PPIP_ppip_changed = 1;

	// Sort out pmap, just to be on the safe side.
	RecalcFreeParticles(false);

	// fix SOAP links using soapList, a map of old particle ID -> new particle ID
	// loop through every old particle (loaded from save), and convert .tmp / .tmp2
	for (std::map<unsigned int, unsigned int>::iterator iter = soapList.begin(), end = soapList.end(); iter != end; ++iter)
	{
		int i = (*iter).second;
		if ((parts[i].ctype & 0x2) == 2)
		{
			std::map<unsigned int, unsigned int>::iterator n = soapList.find(parts[i].tmp);
			if (n != end)
				parts[i].tmp = n->second;
			// sometimes the proper SOAP isn't found. It should remove the link, but seems to break some saves
			// so just ignore it
		}
		if ((parts[i].ctype & 0x4) == 4)
		{
			std::map<unsigned int, unsigned int>::iterator n = soapList.find(parts[i].tmp2);
			if (n != end)
				parts[i].tmp2 = n->second;
			// sometimes the proper SOAP isn't found. It should remove the link, but seems to break some saves
			// so just ignore it
		}
	}

	for (size_t i = 0; i < save->signs.size() && signs.size() < MAXSIGNS; i++)
	{
		if (save->signs[i].text.length())
		{
			sign tempSign = save->signs[i];
			tempSign.x += partP.X;
			tempSign.y += partP.Y;
			if (!InBounds(tempSign.x, tempSign.y))
			{
				continue;
			}
			signs.push_back(tempSign);
		}
	}
	auto useGravityMaps = save->hasGravityMaps && grav;
	for (auto bpos : RectSized(blockP, save->blockSize) & CELLS.OriginRect())
	{
		auto spos = bpos - blockP;
		if (save->blockMap[spos])
		{
			bmap[bpos.Y][bpos.X] = save->blockMap[spos];
			fvx[bpos.Y][bpos.X] = save->fanVelX[spos];
			fvy[bpos.Y][bpos.X] = save->fanVelY[spos];
		}
		if (includePressure)
		{
			if (save->hasPressure)
			{
				pv[bpos.Y][bpos.X] = save->pressure[spos];
				vx[bpos.Y][bpos.X] = save->velocityX[spos];
				vy[bpos.Y][bpos.X] = save->velocityY[spos];
			}
			if (save->hasAmbientHeat)
			{
				hv[bpos.Y][bpos.X] = save->ambientHeat[spos];
			}
			if (save->hasBlockAirMaps)
			{
				air->bmap_blockair [bpos.Y][bpos.X] = save->blockAir [spos];
				air->bmap_blockairh[bpos.Y][bpos.X] = save->blockAirh[spos];
			}
		}
		if (useGravityMaps)
		{
			gravIn.mass   [bpos] = save->gravMass  [spos];
			gravIn.mask   [bpos] = save->gravMask  [spos];
			gravOut.forceX[bpos] = save->gravForceX[spos];
			gravOut.forceY[bpos] = save->gravForceY[spos];
			gravForceRecalc = true; // gravOut changed outside DispatchNewtonianGravity
		}
	}
	if (useGravityMaps)
	{
		ResetNewtonianGravity(gravIn, gravOut);
	}

	gravWallChanged = true;
	if (!save->hasBlockAirMaps)
	{
		air->ApproximateBlockAirMaps();
	}
}

std::unique_ptr<GameSave> Simulation::Save(bool includePressure, Rect<int> partR) // particle coordinates
{
	auto blockR = RectBetween(partR.TopLeft() / CELL, partR.BottomRight() / CELL);
	auto blockP = blockR.pos;

	auto newSave = std::make_unique<GameSave>(blockR.size);
	newSave->frameCount = frameCount;
	newSave->rngState = rng.state();

	int storedParts = 0;
	int elementCount[PT_NUM];
	std::fill(elementCount, elementCount+PT_NUM, 0);
	// Map of soap particles loaded into this save, old ID -> new ID
	// Now stores all particles, not just SOAP (but still only used for soap)
	std::map<unsigned int, unsigned int> particleMap;

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (int i = 0; i < NPART; i++)
	{
		int x, y;
		x = int(parts[i].x + 0.5f);
		y = int(parts[i].y + 0.5f);
		if (parts[i].type && partR.Contains({ x, y }))
		{
			Particle tempPart = parts[i];
			tempPart.x -= blockP.X * CELL;
			tempPart.y -= blockP.Y * CELL;
			if (elements[tempPart.type].Enabled)
			{
				particleMap.insert(std::pair<unsigned int, unsigned int>(i, storedParts));
				*newSave << tempPart;
				storedParts++;
				elementCount[tempPart.type]++;

			}
		}
	}

	if (storedParts && elementCount[PT_SOAP])
	{
		// fix SOAP links using particleMap, a map of old particle ID -> new particle ID
		// loop through every new particle (saved into the save), and convert .tmp / .tmp2
		for (std::map<unsigned int, unsigned int>::iterator iter = particleMap.begin(), end = particleMap.end(); iter != end; ++iter)
		{
			int i = (*iter).second;
			if (newSave->particles[i].type != PT_SOAP)
				continue;
			if ((newSave->particles[i].ctype & 0x2) == 2)
			{
				std::map<unsigned int, unsigned int>::iterator n = particleMap.find(newSave->particles[i].tmp);
				if (n != end)
					newSave->particles[i].tmp = n->second;
				else
				{
					newSave->particles[i].tmp = 0;
					newSave->particles[i].ctype ^= 2;
				}
			}
			if ((newSave->particles[i].ctype & 0x4) == 4)
			{
				std::map<unsigned int, unsigned int>::iterator n = particleMap.find(newSave->particles[i].tmp2);
				if (n != end)
					newSave->particles[i].tmp2 = n->second;
				else
				{
					newSave->particles[i].tmp2 = 0;
					newSave->particles[i].ctype ^= 4;
				}
			}
		}
	}

	for (size_t i = 0; i < MAXSIGNS && i < signs.size(); i++)
	{
		if (signs[i].text.length() && partR.Contains({ signs[i].x, signs[i].y }))
		{
			sign tempSign = signs[i];
			tempSign.x -= blockP.X * CELL;
			tempSign.y -= blockP.Y * CELL;
			*newSave << tempSign;
		}
	}

	for (auto bpos : newSave->blockSize.OriginRect())
	{
		if(bmap[bpos.Y + blockP.Y][bpos.X + blockP.X])
		{
			newSave->blockMap[bpos] = bmap[bpos.Y + blockP.Y][bpos.X + blockP.X];
			newSave->fanVelX[bpos] = fvx[bpos.Y + blockP.Y][bpos.X + blockP.X];
			newSave->fanVelY[bpos] = fvy[bpos.Y + blockP.Y][bpos.X + blockP.X];
		}
		if (includePressure)
		{
			newSave->pressure[bpos] = pv[bpos.Y + blockP.Y][bpos.X + blockP.X];
			newSave->velocityX[bpos] = vx[bpos.Y + blockP.Y][bpos.X + blockP.X];
			newSave->velocityY[bpos] = vy[bpos.Y + blockP.Y][bpos.X + blockP.X];
			newSave->ambientHeat[bpos] = hv[bpos.Y + blockP.Y][bpos.X + blockP.X];
			newSave->blockAir[bpos] = air->bmap_blockair[bpos.Y + blockP.Y][bpos.X + blockP.X];
			newSave->blockAirh[bpos] = air->bmap_blockairh[bpos.Y + blockP.Y][bpos.X + blockP.X];
		}
		if (grav)
		{
			newSave->gravMass  [bpos] = gravIn.mass   [bpos + blockP];
			newSave->gravMask  [bpos] = gravIn.mask   [bpos + blockP];
			newSave->gravForceX[bpos] = gravOut.forceX[bpos + blockP];
			newSave->gravForceY[bpos] = gravOut.forceY[bpos + blockP];
		}
	}
	if (includePressure)
	{
		newSave->hasBlockAirMaps = true;
	}
	if (grav)
	{
		newSave->hasGravityMaps = true;
	}
	if (includePressure || ensureDeterminism)
	{
		newSave->hasPressure = true;
		newSave->hasAmbientHeat = true;
	}
	newSave->ensureDeterminism = ensureDeterminism;

	newSave->stkm.rocketBoots1 = player.rocketBoots;
	newSave->stkm.rocketBoots2 = player2.rocketBoots;
	newSave->stkm.fan1 = player.fan;
	newSave->stkm.fan2 = player2.fan;
	for (unsigned char i = 0; i < MAX_FIGHTERS; i++)
	{
		if (fighters[i].rocketBoots)
			newSave->stkm.rocketBootsFigh.push_back(i);
		if (fighters[i].fan)
			newSave->stkm.fanFigh.push_back(i);
	}

	SaveSimOptions(*newSave);
	newSave->pmapbits = PMAPBITS;
	return newSave;
}

void Simulation::SaveSimOptions(GameSave &gameSave)
{
	gameSave.gravityMode = gravityMode;
	gameSave.customGravityX = customGravityX;
	gameSave.customGravityY = customGravityY;
	gameSave.airMode = air->airMode;
	gameSave.ambientAirTemp = air->ambientAirTemp;
	gameSave.edgeMode = edgeMode;
	gameSave.legacyEnable = legacy_enable;
	gameSave.waterEEnabled = water_equal_test;
	gameSave.gravityEnable = bool(grav);
	gameSave.aheatEnable = aheat_enable;
}

bool Simulation::FloodFillPmapCheck(int x, int y, int type) const
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (type == 0)
		return !pmap[y][x] && !photons[y][x];
	if (elements[type].Properties&TYPE_ENERGY)
		return TYP(photons[y][x]) == type;
	else
		return TYP(pmap[y][x]) == type;
}

CoordStack& Simulation::getCoordStackSingleton()
{
	// Future-proofing in case Simulation is later multithreaded
	thread_local CoordStack cs;
	return cs;
}

int Simulation::flood_prop(int x, int y, const AccessProperty &changeProperty)
{
	int i, x1, x2, dy = 1;
	int did_something = 0;
	int r = pmap[y][x];
	if (!r)
		r = photons[y][x];
	if (!r)
		return 0;
	int parttype = TYP(r);
	char * bitmap = (char*)malloc(XRES*YRES); //Bitmap for checking
	if (!bitmap) return -1;
	memset(bitmap, 0, XRES*YRES);
	try
	{
		CoordStack& cs = getCoordStackSingleton();
		cs.clear();

		cs.push(x, y);
		do
		{
			cs.pop(x, y);
			x1 = x2 = x;
			while (x1>=CELL)
			{
				if (!FloodFillPmapCheck(x1-1, y, parttype) || bitmap[(y*XRES)+x1-1])
					break;
				x1--;
			}
			while (x2<XRES-CELL)
			{
				if (!FloodFillPmapCheck(x2+1, y, parttype) || bitmap[(y*XRES)+x2+1])
					break;
				x2++;
			}
			for (x=x1; x<=x2; x++)
			{
				i = pmap[y][x];
				if (!i)
					i = photons[y][x];
				if (!i)
					continue;
				changeProperty.Set(this, ID(i));
				bitmap[(y*XRES)+x] = 1;
				did_something = 1;
			}
			if (y>=CELL+dy)
				for (x=x1; x<=x2; x++)
					if (FloodFillPmapCheck(x, y-dy, parttype) && !bitmap[((y-dy)*XRES)+x])
						cs.push(x, y-dy);
			if (y<YRES-CELL-dy)
				for (x=x1; x<=x2; x++)
					if (FloodFillPmapCheck(x, y+dy, parttype) && !bitmap[((y+dy)*XRES)+x])
						cs.push(x, y+dy);
		} while (cs.getSize()>0);
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		free(bitmap);
		return -1;
	}
	free(bitmap);
	return did_something;
}

int Simulation::FloodINST(int x, int y)
{
	int x1, x2;
	int created_something = 0;

	const auto isSparkableInst = [this](int x, int y) -> bool {
		return TYP(pmap[y][x])==PT_INST && parts[ID(pmap[y][x])].life==0;
	};

	const auto isInst = [this](int x, int y) -> bool {
		return TYP(pmap[y][x])==PT_INST || (TYP(pmap[y][x])==PT_SPRK  && parts[ID(pmap[y][x])].ctype==PT_INST);
	};

	if (!isSparkableInst(x,y))
		return 1;

	CoordStack& cs = getCoordStackSingleton();
	cs.clear();

	cs.push(x, y);

	try
	{
		do
		{
			cs.pop(x, y);
			x1 = x2 = x;
			// go left as far as possible
			while (x1>=CELL && isSparkableInst(x1-1, y))
			{
				x1--;
			}
			// go right as far as possible
			while (x2<XRES-CELL && isSparkableInst(x2+1, y))
			{
				x2++;
			}
			// fill span
			for (x=x1; x<=x2; x++)
			{
				if (create_part(-1, x, y, PT_SPRK)>=0)
					created_something = 1;
			}

			// add vertically adjacent pixels to stack
			// (wire crossing for INST)
			if (y>=CELL+1 && x1==x2 &&
				isInst(x1-1, y-1) && isInst(x1, y-1) && isInst(x1+1, y-1) &&
				!isInst(x1-1, y-2) && isInst(x1, y-2) && !isInst(x1+1, y-2))
			{
				// travelling vertically up, skipping a horizontal line
				if (isSparkableInst(x1, y-2))
				{
						cs.push(x1, y-2);
				}
			}
			else if (y>=CELL+1)
			{
				for (x=x1; x<=x2; x++)
				{
					if (isSparkableInst(x, y-1))
					{
						if (x==x1 || x==x2 || y>=YRES-CELL-1 || !isInst(x, y+1) || isInst(x+1, y+1) || isInst(x-1, y+1))
						{
							// if at the end of a horizontal section, or if it's a T junction or not a 1px wire crossing
							cs.push(x, y-1);
						}
					}
				}
			}

			if (y<YRES-CELL-1 && x1==x2 &&
				isInst(x1-1, y+1) && isInst(x1, y+1) && isInst(x1+1, y+1) &&
				!isInst(x1-1, y+2) && isInst(x1, y+2) && !isInst(x1+1, y+2))
			{
				// travelling vertically down, skipping a horizontal line
				if (isSparkableInst(x1, y+2))
				{
					cs.push(x1, y+2);
				}
			}
			else if (y<YRES-CELL-1)
			{
				for (x=x1; x<=x2; x++)
				{
					if (isSparkableInst(x, y+1))
					{
						if (x==x1 || x==x2 || y<0 || !isInst(x, y-1) || isInst(x+1, y-1) || isInst(x-1, y-1))
						{
							// if at the end of a horizontal section, or if it's a T junction or not a 1px wire crossing
							cs.push(x, y+1);
						}

					}
				}
			}
		} while (cs.getSize()>0);
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		return -1;
	}

	return created_something;
}

bool Simulation::flood_water(int x, int y, int i)
{
	int x1, x2, originalX = x, originalY = y;
	int r = pmap[y][x];
	if (!r)
		return false;

	// Bitmap for checking where we've already looked
	auto bitmapPtr = std::unique_ptr<char[]>(new char[XRES * YRES]);
	char *bitmap = bitmapPtr.get();
	std::fill(&bitmap[0], &bitmap[0] + XRES * YRES, 0);

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	try
	{
		CoordStack& cs = getCoordStackSingleton();
		cs.clear();

		cs.push(x, y);
		do
		{
			cs.pop(x, y);
			x1 = x2 = x;
			while (x1 >= CELL)
			{
				if (elements[TYP(pmap[y][x1 - 1])].Falldown != 2 || bitmap[(y * XRES) + x1 - 1])
					break;
				x1--;
			}
			while (x2 < XRES-CELL)
			{
				if (elements[TYP(pmap[y][x2 + 1])].Falldown != 2 || bitmap[(y * XRES) + x1 - 1])
					break;
				x2++;
			}
			for (int x = x1; x <= x2; x++)
			{
				if ((y - 1) > originalY && !pmap[y - 1][x])
				{
					// Try to move the water to a random position on this line, because there's probably a free location somewhere
					int randPos = rng.between(x, x2);
					if (!pmap[y - 1][randPos] && eval_move(parts[i].type, randPos, y - 1, nullptr))
						x = randPos;
					// Couldn't move to random position, so try the original position on the left
					else if (!eval_move(parts[i].type, x, y - 1, nullptr))
						continue;

					move(i, originalX, originalY, float(x), float(y - 1));
					return true;
				}

				bitmap[(y * XRES) + x] = 1;
			}
			if (y >= CELL + 1)
				for (int x = x1; x <= x2; x++)
					if (elements[TYP(pmap[y - 1][x])].Falldown == 2 && !bitmap[((y - 1) * XRES) + x])
						cs.push(x, y - 1);
			if (y < YRES - CELL - 1)
				for (int x = x1; x <= x2; x++)
					if (elements[TYP(pmap[y + 1][x])].Falldown == 2 && !bitmap[((y + 1) * XRES) + x])
						cs.push(x, y + 1);
		} while (cs.getSize() > 0);
	}
	catch (std::exception &e)
	{
		std::cerr << e.what() << std::endl;
		return false;
	}
	return false;
}

void Simulation::SetEdgeMode(int newEdgeMode)
{
	edgeMode = newEdgeMode;
	switch(edgeMode)
	{
	case EDGE_VOID:
	case EDGE_LOOP:
		for(int i = 0; i<XCELLS; i++)
		{
			bmap[0][i] = 0;
			bmap[YCELLS-1][i] = 0;
		}
		for(int i = 1; i<(YCELLS-1); i++)
		{
			bmap[i][0] = 0;
			bmap[i][XCELLS-1] = 0;
		}
		break;
	case EDGE_SOLID:
		int i;
		for(i=0; i<XCELLS; i++)
		{
			bmap[0][i] = WL_WALL;
			bmap[YCELLS-1][i] = WL_WALL;
		}
		for(i=1; i<(YCELLS-1); i++)
		{
			bmap[i][0] = WL_WALL;
			bmap[i][XCELLS-1] = WL_WALL;
		}
		break;
	default:
		SetEdgeMode(EDGE_VOID);
	}
}

// Now simply creates a 0 pixel radius line without all the complicated flags / other checks
// Would make sense to move to Editing.cpp but SPRK needs it.
void Simulation::CreateLine(int x1, int y1, int x2, int y2, int c)
{
	bool reverseXY = abs(y2-y1) > abs(x2-x1);
	int x, y, dx, dy, sy;
	float e, de;
	int v = ID(c);
	c = TYP(c);
	if (reverseXY)
	{
		y = x1;
		x1 = y1;
		y1 = y;
		y = x2;
		x2 = y2;
		y2 = y;
	}
	if (x1 > x2)
	{
		y = x1;
		x1 = x2;
		x2 = y;
		y = y1;
		y1 = y2;
		y2 = y;
	}
	dx = x2 - x1;
	dy = abs(y2 - y1);
	e = 0.0f;
	de = dx ? dy/(float)dx : 0.0f;
	y = y1;
	sy = (y1<y2) ? 1 : -1;
	for (x=x1; x<=x2; x++)
	{
		if (reverseXY)
			create_part(-1, y, x, c, v);
		else
			create_part(-1, x, y, c, v);
		e += de;
		if (e >= 0.5f)
		{
			y += sy;
			if ((y1<y2) ? (y<=y2) : (y>=y2))
			{
				if (reverseXY)
					create_part(-1, y, x, c, v);
				else
					create_part(-1, x, y, c, v);
			}
			e -= 1.0f;
		}
	}
}

inline int Simulation::is_wire(int x, int y)
{
	return bmap[y][x]==WL_DETECT || bmap[y][x]==WL_EWALL || bmap[y][x]==WL_ALLOWLIQUID || bmap[y][x]==WL_WALLELEC || bmap[y][x]==WL_ALLOWALLELEC || bmap[y][x]==WL_EHOLE || bmap[y][x]==WL_STASIS;
}

inline int Simulation::is_wire_off(int x, int y)
{
	return (bmap[y][x]==WL_DETECT || bmap[y][x]==WL_EWALL || bmap[y][x]==WL_ALLOWLIQUID || bmap[y][x]==WL_WALLELEC || bmap[y][x]==WL_ALLOWALLELEC || bmap[y][x]==WL_EHOLE || bmap[y][x]==WL_STASIS) && emap[y][x]<8;
}

// implement __builtin_ctz and __builtin_clz on msvc
#ifdef _MSC_VER
unsigned msvc_ctz(unsigned a)
{
	unsigned long i;
	_BitScanForward(&i, a);
	return i;
}

unsigned msvc_clz(unsigned a)
{
	unsigned long i;
	_BitScanReverse(&i, a);
	return 31 - i;
}

#define __builtin_ctz msvc_ctz
#define __builtin_clz msvc_clz
#endif

int Simulation::get_wavelength_bin(int *wm)
{
	int i, w0, wM, r;

	if (!(*wm & 0x3FFFFFFF))
		return -1;

#if defined(__GNUC__) || defined(_MSVC_VER)
	w0 = __builtin_ctz(*wm | 0xC0000000);
	wM = 31 - __builtin_clz(*wm & 0x3FFFFFFF);
#else
	w0 = 30;
	wM = 0;
	for (i = 0; i < 30; i++)
		if (*wm & (1<<i))
		{
			if (i < w0)
				w0 = i;
			if (i > wM)
				wM = i;
		}
#endif

	if (wM - w0 < 5)
		return wM + w0;

	r = rng.gen();
	i = (r >> 1) % (wM-w0-4);
	i += w0;

	if (r & 1)
	{
		*wm &= 0x1F << i;
		return (i + 2) * 2;
	}
	else
	{
		*wm &= 0xF << i;
		return (i + 2) * 2 - 1;
	}
}

void Simulation::set_emap(int x, int y)
{
	int x1, x2;

	if (!is_wire_off(x, y))
		return;

	// go left as far as possible
	x1 = x2 = x;
	while (x1>0)
	{
		if (!is_wire_off(x1-1, y))
			break;
		x1--;
	}
	while (x2<XCELLS-1)
	{
		if (!is_wire_off(x2+1, y))
			break;
		x2++;
	}

	// fill span
	for (x=x1; x<=x2; x++)
		emap[y][x] = 16;

	// fill children

	if (y>1 && x1==x2 &&
	        is_wire(x1-1, y-1) && is_wire(x1, y-1) && is_wire(x1+1, y-1) &&
	        !is_wire(x1-1, y-2) && is_wire(x1, y-2) && !is_wire(x1+1, y-2))
		set_emap(x1, y-2);
	else if (y>0)
		for (x=x1; x<=x2; x++)
			if (is_wire_off(x, y-1))
			{
				if (x==x1 || x==x2 || y>=YCELLS-1 ||
				        is_wire(x-1, y-1) || is_wire(x+1, y-1) ||
				        is_wire(x-1, y+1) || !is_wire(x, y+1) || is_wire(x+1, y+1))
					set_emap(x, y-1);
			}

	if (y<YCELLS-2 && x1==x2 &&
	        is_wire(x1-1, y+1) && is_wire(x1, y+1) && is_wire(x1+1, y+1) &&
	        !is_wire(x1-1, y+2) && is_wire(x1, y+2) && !is_wire(x1+1, y+2))
		set_emap(x1, y+2);
	else if (y<YCELLS-1)
		for (x=x1; x<=x2; x++)
			if (is_wire_off(x, y+1))
			{
				if (x==x1 || x==x2 || y<0 ||
				        is_wire(x-1, y+1) || is_wire(x+1, y+1) ||
				        is_wire(x-1, y-1) || !is_wire(x, y-1) || is_wire(x+1, y-1))
					set_emap(x, y+1);
			}
}

int Simulation::parts_avg(int ci, int ni,int t)
{
	if (t==PT_INSL)//to keep electronics working
	{
		int pmr = pmap[((int)(parts[ci].y+0.5f) + (int)(parts[ni].y+0.5f))/2][((int)(parts[ci].x+0.5f) + (int)(parts[ni].x+0.5f))/2];
		if (pmr)
			return parts[ID(pmr)].type;
		else
			return PT_NONE;
	}
	else
	{
		int pmr2 = pmap[(int)((parts[ci].y + parts[ni].y)/2+0.5f)][(int)((parts[ci].x + parts[ni].x)/2+0.5f)];//seems to be more accurate.
		if (pmr2)
		{
			if (parts[ID(pmr2)].type==t)
				return t;
		}
		else
			return PT_NONE;
	}
	return PT_NONE;
}

void Parts::Reset()
{
	memset(data.data(), 0, sizeof(Particle)*NPART);
	lastActiveIndex = 0;
}

void Simulation::clear_sim(void)
{
	for (auto i = 0; i <= parts.lastActiveIndex; i++)
	{
		if (parts[i].type)
		{
			kill_part(i);
		}
	}
	ensureDeterminism = false;
	frameCount = 0;
	debug_nextToUpdate = 0;
	debug_mostRecentlyUpdated = -1;
	emp_decor = 0;
	emp_trigger_count = 0;
	signs.clear();
	memset(bmap, 0, sizeof(bmap));
	memset(emap, 0, sizeof(emap));
	parts.Reset();
	for (int i = 0; i < NPART-1; i++)
		parts[i].life = i+1;
	parts[NPART-1].life = -1;
	pfree = 0;
	NUM_PARTS = 0;
	memset(pmap, 0, sizeof(pmap));
	memset(fvx, 0, sizeof(fvx));
	memset(fvy, 0, sizeof(fvy));
	memset(photons, 0, sizeof(photons));
	memset(wireless, 0, sizeof(wireless));
	memset(gol, 0, sizeof(gol));
	memset(portalp, 0, sizeof(portalp));
	memset(fighters, 0, sizeof(fighters));
	memset(&player, 0, sizeof(player));
	memset(&player2, 0, sizeof(player2));
	std::fill(elementCount, elementCount+PT_NUM, 0);
	elementRecount = true;
	fighcount = 0;
	player.spwn = 0;
	player.spawnID = -1;
	player.rocketBoots = false;
	player.fan = false;
	player2.spwn = 0;
	player2.spawnID = -1;
	player2.rocketBoots = false;
	player2.fan = false;
	//memset(pers_bg, 0, WINDOWW*YRES*PIXELSIZE);
	//memset(fire_r, 0, sizeof(fire_r));
	//memset(fire_g, 0, sizeof(fire_g));
	//memset(fire_b, 0, sizeof(fire_b));
	//if(gravmask)
		//memset(gravmask, 0xFFFFFFFF, NCELL*sizeof(unsigned));
	ResetNewtonianGravity({}, {});
	if(air)
	{
		air->Clear();
		air->ClearAirH();
	}
	SetEdgeMode(edgeMode);
}

bool Simulation::IsWallBlocking(int x, int y, int type) const
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (bmap[y/CELL][x/CELL])
	{
		int wall = bmap[y/CELL][x/CELL];
		if (wall == WL_ALLOWGAS && !(elements[type].Properties&TYPE_GAS))
			return true;
		else if (wall == WL_ALLOWENERGY && !(elements[type].Properties&TYPE_ENERGY))
			return true;
		else if (wall == WL_ALLOWLIQUID && !(elements[type].Properties&TYPE_LIQUID))
			return true;
		else if (wall == WL_ALLOWPOWDER && !(elements[type].Properties&TYPE_PART))
			return true;
		else if (wall == WL_ALLOWAIR || wall == WL_WALL || wall == WL_WALLELEC)
			return true;
		else if (wall == WL_EWALL && !emap[y/CELL][x/CELL])
			return true;
		else if (wall == WL_DETECT && (elements[type].Properties&TYPE_SOLID))
			return true;
	}
	return false;
}

/*
   RETURN-value explanation
1 = Swap
0 = No move/Bounce
2 = Both particles occupy the same space.
 */
int Simulation::eval_move(int pt, int nx, int ny, unsigned *rr) const
{
	unsigned r;
	int result;

	if (nx<0 || ny<0 || nx>=XRES || ny>=YRES)
		return 0;

	r = pmap[ny][nx];
	if (r)
		r = (r&~PMAPMASK) | parts[ID(r)].type;
	if (rr)
		*rr = r;
	if (pt>=PT_NUM || TYP(r)>=PT_NUM)
		return 0;
	auto &sd = SimulationData::CRef();
	auto &can_move = sd.can_move;
	auto &elements = sd.elements;
	result = can_move[pt][TYP(r)];
	if (result == 3)
	{
		switch (TYP(r))
		{
		case PT_LCRY:
			if (pt==PT_PHOT)
				result = (parts[ID(r)].life > 5)? 2 : 0;
			break;
		case PT_GPMP:
			if (pt == PT_PHOT)
				result = (parts[ID(r)].life < 10) ? 2 : 0;
			break;
		case PT_INVIS:
		{
			float pressureResistance = 0.0f;
			if (parts[ID(r)].tmp > 0)
				pressureResistance = (float)parts[ID(r)].tmp;
			else
				pressureResistance = 4.0f;

			if (pv[ny/CELL][nx/CELL] < -pressureResistance || pv[ny/CELL][nx/CELL] > pressureResistance)
				result = 2;
			else
				result = 0;
			break;
		}
		case PT_PVOD:
			if (parts[ID(r)].life == 10)
			{
				if (!parts[ID(r)].ctype || (parts[ID(r)].ctype==pt)!=(parts[ID(r)].tmp&1))
					result = 1;
				else
					result = 0;
			}
			else result = 0;
			break;
		case PT_VOID:
			if (!parts[ID(r)].ctype || (parts[ID(r)].ctype==pt)!=(parts[ID(r)].tmp&1))
				result = 1;
			else
				result = 0;
			break;
		case PT_SWCH:
			if (pt == PT_TRON)
			{
				if (parts[ID(r)].life >= 10)
					return 2;
				else
					return 0;
			}
			break;
		default:
			// This should never happen
			// If it were to happen, try_move would interpret a 3 as a 1
			result =  1;
		}
	}
	if (bmap[ny/CELL][nx/CELL])
	{
		if (IsWallBlocking(nx, ny, pt))
			return 0;
		if (bmap[ny/CELL][nx/CELL]==WL_EHOLE && !emap[ny/CELL][nx/CELL] && !(elements[pt].Properties&TYPE_SOLID) && !(elements[TYP(r)].Properties&TYPE_SOLID))
			return 2;
	}
	return result;
}

int Simulation::try_move(int i, int x, int y, int nx, int ny)
{
	unsigned r = 0, e;

	if (x==nx && y==ny)
		return 1;
	if (nx<0 || ny<0 || nx>=XRES || ny>=YRES)
		return 1;

	e = eval_move(parts[i].type, nx, ny, &r);

	/* half-silvered mirror */
	if (!e && parts[i].type==PT_PHOT && ((TYP(r)==PT_BMTL && rng.chance(1, 2)) || TYP(pmap[y][x])==PT_BMTL))
		e = 2;

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (!e) //if no movement
	{
		int rt = TYP(r);
		if (rt == PT_WOOD)
		{
			float vel = std::sqrt(std::pow(parts[i].vx, 2) + std::pow(parts[i].vy, 2));
			if (vel > 5)
				part_change_type(ID(r), nx, ny, PT_SAWD);
		}
		if (!(elements[parts[i].type].Properties & TYPE_ENERGY))
			return 0;
		if (!legacy_enable && parts[i].type==PT_PHOT && r)//PHOT heat conduction
		{
			if (rt == PT_COAL || rt == PT_BCOL)
				parts[ID(r)].temp = parts[i].temp;

			if (rt < PT_NUM && !IsHeatInsulator(parts[ID(r)]) && rt != PT_FILT)
				parts[i].temp = parts[ID(r)].temp = restrict_flt((parts[ID(r)].temp+parts[i].temp)/2, MIN_TEMP, MAX_TEMP);
		}
		else if ((parts[i].type==PT_NEUT || parts[i].type==PT_ELEC) && (rt==PT_CLNE || rt==PT_PCLN || rt==PT_BCLN || rt==PT_PBCN))
		{
			if (!parts[ID(r)].ctype)
				parts[ID(r)].ctype = parts[i].type;
		}
		if (rt==PT_PRTI && (elements[parts[i].type].Properties & TYPE_ENERGY))
		{
			int nnx, count;
			for (count=0; count<8; count++)
			{
				if (isign(x-nx)==isign(portal_rx[count]) && isign(y-ny)==isign(portal_ry[count]))
					break;
			}
			count = count%8;
			parts[ID(r)].tmp = (int)((parts[ID(r)].temp-73.15f)/100+1);
			if (parts[ID(r)].tmp>=CHANNELS) parts[ID(r)].tmp = CHANNELS-1;
			else if (parts[ID(r)].tmp<0) parts[ID(r)].tmp = 0;
			for ( nnx=0; nnx<80; nnx++)
				if (!portalp[parts[ID(r)].tmp][count][nnx].type)
				{
					portalp[parts[ID(r)].tmp][count][nnx] = parts[i];
					kill_part(i);
					break;
				}
		}
		return 0;
	}

	if (e == 2) //if occupy same space
	{
		switch (parts[i].type)
		{
		case PT_PHOT:
		{
			switch (TYP(r))
			{
			case PT_GLOW:
				if (!parts[ID(r)].life && rng.chance(1, 30))
				{
					parts[ID(r)].life = 120;
					create_gain_photon(i);
				}
				break;
			case PT_FILT:
				parts[i].ctype = Element_FILT_interactWavelengths(this, &parts[ID(r)], parts[i].ctype);
				break;
			case PT_C5:
				if (parts[ID(r)].life > 0 && (parts[ID(r)].ctype & parts[i].ctype & 0xFFFFFFC0))
				{
					float vx = ((parts[ID(r)].tmp << 16) >> 16) / 255.0f;
					float vy = (parts[ID(r)].tmp >> 16) / 255.0f;
					float vn = parts[i].vx * parts[i].vx + parts[i].vy * parts[i].vy;
					// if the resulting velocity would be 0, that would cause division by 0 inside the else
					// shoot the photon off at a 90 degree angle instead (probably particle order dependent)
					if (parts[i].vx + vx == 0 && parts[i].vy + vy == 0)
					{
						parts[i].vx = vy;
						parts[i].vy = -vx;
					}
					else
					{
						parts[i].ctype = (parts[ID(r)].ctype & parts[i].ctype) >> 6;
						// add momentum of photons to each other
						parts[i].vx += vx;
						parts[i].vy += vy;
						// normalize velocity to original value
						vn /= parts[i].vx * parts[i].vx + parts[i].vy * parts[i].vy;
						vn = sqrtf(vn);
						parts[i].vx *= vn;
						parts[i].vy *= vn;
					}
					parts[ID(r)].life = 0;
					parts[ID(r)].ctype = 0;
				}
				else if(!parts[ID(r)].ctype && parts[i].ctype & 0xFFFFFFC0)
				{
					parts[ID(r)].life = 1;
					parts[ID(r)].ctype = parts[i].ctype;
					parts[ID(r)].tmp = (0xFFFF & (int)(parts[i].vx * 255.0f)) | (0xFFFF0000 & (int)(parts[i].vy * 16711680.0f));
					parts[ID(r)].tmp2 = (0xFFFF & (int)((parts[i].x - x) * 255.0f)) | (0xFFFF0000 & (int)((parts[i].y - y) * 16711680.0f));
					kill_part(i);
				}
				break;
			case PT_INVIS:
			{
				float pressureResistance = 0.0f;
				pressureResistance = (parts[ID(r)].tmp > 0) ? (float)parts[ID(r)].tmp : 4.0f;

				if (pv[ny/CELL][nx/CELL] >= -pressureResistance && pv[ny/CELL][nx/CELL] <= pressureResistance)
				{
					part_change_type(i,x,y,PT_NEUT);
					parts[i].ctype = 0;
				}
				break;
			}
			case PT_BIZR:
			case PT_BIZRG:
			case PT_BIZRS:
				part_change_type(i, x, y, PT_ELEC);
				parts[i].ctype = 0;
				break;
			case PT_H2:
				if (!(parts[i].tmp&0x1))
				{
					part_change_type(i, x, y, PT_PROT);
					parts[i].ctype = 0;
					parts[i].tmp2 = 0x1;

					create_part(ID(r), x, y, PT_ELEC);
					return 1;
				}
				break;
			case PT_GPMP:
				if (parts[ID(r)].life == 0)
				{
					part_change_type(i, x, y, PT_GRVT);
					parts[i].tmp = int(parts[ID(r)].temp - 273.15f);
				}
				break;
			}
			break;
		}
		case PT_NEUT:
			if (TYP(r) == PT_GLAS || TYP(r) == PT_BGLA)
				if (rng.chance(1, 10))
					create_cherenkov_photon(i);
			break;
		case PT_ELEC:
			if (TYP(r) == PT_GLOW)
			{
				part_change_type(i, x, y, PT_PHOT);
				parts[i].ctype = 0x3FFFFFFF;
			}
			break;
		case PT_PROT:
			if (TYP(r) == PT_INVIS)
				part_change_type(i, x, y, PT_NEUT);
			break;
		case PT_BIZR:
		case PT_BIZRG:
			if (TYP(r) == PT_FILT)
				parts[i].ctype = Element_FILT_interactWavelengths(this, &parts[ID(r)], parts[i].ctype);
			break;
		}
		return 1;
	}
	//else e=1 , we are trying to swap the particles, return 0 no swap/move, 1 is still overlap/move, because the swap takes place later

	switch (TYP(r))
	{
	case PT_VOID:
	case PT_PVOD:
		// this is where void eats particles
		// void ctype already checked in eval_move
		kill_part(i);
		return 0;
	case PT_BHOL:
	case PT_NBHL:
		// this is where blackhole eats particles
		if (!legacy_enable)
		{
			parts[ID(r)].temp = restrict_flt(parts[ID(r)].temp+parts[i].temp/2, MIN_TEMP, MAX_TEMP);//3.0f;
		}
		kill_part(i);
		return 0;
	case PT_WHOL:
	case PT_NWHL:
		// whitehole eats anar
		if (parts[i].type == PT_ANAR)
		{
			if (!legacy_enable)
			{
				parts[ID(r)].temp = restrict_flt(parts[ID(r)].temp - (MAX_TEMP-parts[i].temp)/2, MIN_TEMP, MAX_TEMP);
			}
			kill_part(i);
			return 0;
		}
		break;
	case PT_DEUT:
		if (parts[i].type == PT_ELEC)
		{
			if(parts[ID(r)].life < 6000)
				parts[ID(r)].life += 1;
			parts[ID(r)].temp = 0;
			kill_part(i);
			return 0;
		}
		break;
	case PT_VIBR:
	case PT_BVBR:
		if ((elements[parts[i].type].Properties & TYPE_ENERGY))
		{
			parts[ID(r)].tmp += 20;
			kill_part(i);
			return 0;
		}
		break;
	}

	switch (parts[i].type)
	{
	case PT_NEUT:
		if (elements[TYP(r)].Properties & PROP_NEUTABSORB)
		{
			kill_part(i);
			return 0;
		}
		break;
	case PT_CNCT:
		{
			float cnctGravX, cnctGravY; // Calculate offset from gravity
			GetGravityField(x, y, elements[PT_CNCT].Gravity, elements[PT_CNCT].Gravity, cnctGravX, cnctGravY);
			int offsetX = 0, offsetY = 0;
			if (cnctGravX > 0.0f) offsetX++;
			else if (cnctGravX < 0.0f) offsetX--;
			if (cnctGravY > 0.0f) offsetY++;
			else if (cnctGravY < 0.0f) offsetY--;
			if ((offsetX != 0) != (offsetY != 0) && // Is this a different position (avoid diagonals, doesn't work well)
				((nx - x) * offsetX > 0 || (ny - y) * offsetY > 0) && // Is the destination particle below the moving particle
				(TYP(pmap[y+offsetY][x+offsetX]) == PT_CNCT || TYP(pmap[y+offsetY][x+offsetX]) == PT_ROCK)) //check below CNCT for another CNCT or ROCK
				return 0;
		}
		break;
	case PT_GBMB:
		if (parts[i].life > 0)
			return 0;
		break;
	}

	if ((bmap[y/CELL][x/CELL]==WL_EHOLE && !emap[y/CELL][x/CELL]) && !(bmap[ny/CELL][nx/CELL]==WL_EHOLE && !emap[ny/CELL][nx/CELL]))
		return 0;

	int ri = ID(r); //ri is the particle number at r (pmap[ny][nx])
	if (r)//the swap part, if we make it this far, swap
	{
		if (parts[i].type==PT_NEUT) {
			// target material is NEUTPENETRATE, meaning it gets moved around when neutron passes
			unsigned s = pmap[y][x];
			if (s && !(elements[TYP(s)].Properties&PROP_NEUTPENETRATE))
				return 1; // if the element currently underneath neutron isn't NEUTPENETRATE, don't move anything except the neutron
			// if nothing is currently underneath neutron, only move target particle
			if(bmap[y/CELL][x/CELL] == WL_ALLOWENERGY)
				return 1; // do not drag target particle into an energy only wall
			if (s)
			{
				pmap[ny][nx] = (s&~PMAPMASK)|parts[ID(s)].type;
				parts[ID(s)].x = float(nx);
				parts[ID(s)].y = float(ny);
			}
			else
				pmap[ny][nx] = 0;
			parts[ri].x = float(x);
			parts[ri].y = float(y);
			pmap[y][x] = PMAP(ri, parts[ri].type);
			return 1;
		}

		if (pmap[ny][nx] && ID(pmap[ny][nx]) == ri)
			pmap[ny][nx] = 0;
		parts[ri].x = parts[i].x;
		parts[ri].y = parts[i].y;
		int rx = int(parts[ri].x + 0.5f);
		int ry = int(parts[ri].y + 0.5f);
		pmap[ry][rx] = PMAP(ri, parts[ri].type);
	}
	return 1;
}

// try to move particle, and if successful update pmap and parts[i].x,y
int Simulation::do_move(int i, int x, int y, float nxf, float nyf)
{
	int nx = (int)(nxf+0.5f), ny = (int)(nyf+0.5f), result;
	if (edgeMode == EDGE_LOOP)
	{
		bool x_ok = (nx >= CELL && nx < XRES-CELL);
		bool y_ok = (ny >= CELL && ny < YRES-CELL);
		if (!x_ok)
			nxf = remainder_p(nxf-CELL+.5f, XRES-CELL*2.0f)+CELL-.5f;
		if (!y_ok)
			nyf = remainder_p(nyf-CELL+.5f, YRES-CELL*2.0f)+CELL-.5f;
		nx = (int)(nxf+0.5f);
		ny = (int)(nyf+0.5f);

		/*if (!x_ok || !y_ok)
		{
			//make sure there isn't something blocking it on the other side
			//only needed if this if statement is moved after the try_move (like my mod)
			//if (!eval_move(t, nx, ny, NULL) || (t == PT_PHOT && pmap[ny][nx]))
			//	return -1;
		}*/
	}
	if (parts[i].type == PT_NONE)
		return 0;
	result = try_move(i, x, y, nx, ny);
	if (result)
	{
		if (!move(i, x, y, nxf, nyf))
			return -1;
	}
	return result;
}

bool Simulation::move(int i, int x, int y, float nxf, float nyf)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int nx = (int)(nxf+0.5f), ny = (int)(nyf+0.5f);
	int t = parts[i].type;
	parts[i].x = nxf;
	parts[i].y = nyf;
	if (ny != y || nx != x)
	{
		if (pmap[y][x] && ID(pmap[y][x]) == i)
			pmap[y][x] = 0;
		if (photons[y][x] && ID(photons[y][x]) == i)
			photons[y][x] = 0;
		// kill_part if particle is out of bounds
		if (nx < CELL || nx >= XRES - CELL || ny < CELL || ny >= YRES - CELL)
		{
			kill_part(i);
			return false;
		}
		if (elements[t].Properties & TYPE_ENERGY)
			photons[ny][nx] = PMAP(i, t);
		else if (t)
			pmap[ny][nx] = PMAP(i, t);
	}

	return true;
}

void Simulation::photoelectric_effect(int nx, int ny)//create sparks from PHOT when hitting PSCN and NSCN
{
	unsigned r = pmap[ny][nx];

	if (TYP(r) == PT_PSCN && !parts[ID(r)].life)
	{
		if (TYP(pmap[ny][nx-1]) == PT_NSCN || TYP(pmap[ny][nx+1]) == PT_NSCN ||
		        TYP(pmap[ny-1][nx]) == PT_NSCN ||  TYP(pmap[ny+1][nx]) == PT_NSCN)
		{
			parts[ID(r)].ctype = PT_PSCN;
			part_change_type(ID(r), nx, ny, PT_SPRK);
			parts[ID(r)].life = 4;
		}
	}
}

unsigned static direction_to_map(float dx, float dy, int t)
{
	// TODO:
	// Adding extra directions causes some inaccuracies.
	// Not adding them causes problems with some diagonal surfaces (photons absorbed instead of reflected).
	// For now, don't add them.
	// Solution may involve more intelligent setting of initial i0 value in find_next_boundary?
	// or rewriting normal/boundary finding code

	return (dx >= 0) |
		   (((dx + dy) >= 0) << 1) |     /*  567  */
		   ((dy >= 0) << 2) |            /*  4+0  */
		   (((dy - dx) >= 0) << 3) |     /*  321  */
		   ((dx <= 0) << 4) |
		   (((dx + dy) <= 0) << 5) |
		   ((dy <= 0) << 6) |
		   (((dy - dx) <= 0) << 7);
	/*
	return (dx >= -0.001) |
		   (((dx + dy) >= -0.001) << 1) |     //  567
		   ((dy >= -0.001) << 2) |            //  4+0
		   (((dy - dx) >= -0.001) << 3) |     //  321
		   ((dx <= 0.001) << 4) |
		   (((dx + dy) <= 0.001) << 5) |
		   ((dy <= 0.001) << 6) |
		   (((dy - dx) <= 0.001) << 7);
	}*/
}

int Simulation::is_blocking(int t, int x, int y) const
{
	if (t & REFRACT) {
		if (x<0 || y<0 || x>=XRES || y>=YRES)
			return 0;
		if (TYP(pmap[y][x]) == PT_GLAS || TYP(pmap[y][x]) == PT_BGLA)
			return 1;
		return 0;
	}

	return !eval_move(t, x, y, nullptr);
}

int Simulation::is_boundary(int pt, int x, int y) const
{
	if (!is_blocking(pt,x,y))
		return 0;
	if (is_blocking(pt,x,y-1) && is_blocking(pt,x,y+1) && is_blocking(pt,x-1,y) && is_blocking(pt,x+1,y))
		return 0;
	return 1;
}

int Simulation::find_next_boundary(int pt, int *x, int *y, int dm, int *em, bool reverse) const
{
	static int dx[8] = {1,1,0,-1,-1,-1,0,1};
	static int dy[8] = {0,1,1,1,0,-1,-1,-1};
	static int de[8] = {0x83,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC1};

	if (*x <= 0 || *x >= XRES-1 || *y <= 0 || *y >= YRES-1)
	{
		return 0;
	}

	if (*em != -1)
	{
		dm &= de[*em];
	}

	unsigned int mask = 0;
	for (int i = 0; i < 8; ++i)
	{
		if ((dm & (1U << i)) && is_blocking(pt, *x + dx[i], *y + dy[i]))
		{
			mask |= (1U << i);
		}
	}
	for (int i = 0; i < 8; ++i)
	{
		int n = (i + (reverse ? 1 : -1)) & 7;
		if (((mask & (1U << i))) && !(mask & (1U << n)))
		{
			*x += dx[i];
			*y += dy[i];
			*em = i;
			return 1;
		}
	}

	return 0;
}

Simulation::GetNormalResult Simulation::get_normal(int pt, int x, int y, float dx, float dy) const
{
	int ldm, rdm, lm, rm;
	int lx, ly, lv, rx, ry, rv;
	int i, j;
	float r, ex, ey;

	if (!dx && !dy)
		return { false };

	if (!is_boundary(pt, x, y))
		return { false };

	ldm = (pt & REFRACT) ? 0xFF : direction_to_map(-dy, dx, pt);
	rdm = (pt & REFRACT) ? 0xFF : direction_to_map(dy, -dx, pt);
	lx = rx = x;
	ly = ry = y;
	lv = rv = 1;
	lm = rm = -1;

	j = 0;
	for (i=0; i<SURF_RANGE; i++) {
		if (lv)
			lv = find_next_boundary(pt, &lx, &ly, ldm, &lm, true);
		if (rv)
			rv = find_next_boundary(pt, &rx, &ry, rdm, &rm, false);
		j += lv + rv;
		if (!lv && !rv)
			break;
	}

	if (j < NORMAL_MIN_EST)
		return { false };

	if ((lx == rx) && (ly == ry))
		return { false };
	ex = float(rx - lx);
	ey = float(ry - ly);
	r = 1.0f/hypot(ex, ey);
	auto nx =  ey * r;
	auto ny = -ex * r;

	return { true, nx, ny, lx, ly, rx, ry };
}



template<bool PhotoelectricEffect, class Sim>
void PhotoelectricEffectHelper(Sim &sim, int x, int y);

template<>
void PhotoelectricEffectHelper<false, const Simulation>(const Simulation &sim, int x, int y)
{
}

template<>
void PhotoelectricEffectHelper<true, Simulation>(Simulation &sim, int x, int y)
{
	sim.photoelectric_effect(x, y);
}

template<bool PhotoelectricEffect, class Sim>
Simulation::GetNormalResult Simulation::get_normal_interp(Sim &sim, int pt, float x0, float y0, float dx, float dy)
{
	int x, y, i;

	dx /= NORMAL_FRAC;
	dy /= NORMAL_FRAC;

	for (i=0; i<NORMAL_INTERP; i++) {
		x = (int)(x0 + 0.5f);
		y = (int)(y0 + 0.5f);
		if (x < 0 || y < 0 || x >= XRES || y >= YRES)
		{
			return { false };
		}
		if (sim.is_boundary(pt, x, y))
			break;
		x0 += dx;
		y0 += dy;
	}
	if (i >= NORMAL_INTERP)
		return { false };

	if (pt == PT_PHOT)
		PhotoelectricEffectHelper<PhotoelectricEffect, Sim>(sim, x, y);

	return sim.get_normal(pt, x, y, dx, dy);
}

template
Simulation::GetNormalResult Simulation::get_normal_interp<false, const Simulation>(const Simulation &sim, int pt, float x0, float y0, float dx, float dy);

void Simulation::kill_part(int i)//kills particle number i
{
	if (i < 0 || i >= NPART)
		return;
	
	int x = (int)(parts[i].x + 0.5f);
	int y = (int)(parts[i].y + 0.5f);

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int t = parts[i].type;
	if (t && elements[t].ChangeType)
	{
		(*(elements[t].ChangeType))(this, i, x, y, t, PT_NONE);
	}

	if (x >= 0 && y >= 0 && x < XRES && y < YRES)
	{
		if (pmap[y][x] && ID(pmap[y][x]) == i)
			pmap[y][x] = 0;
		else if (photons[y][x] && ID(photons[y][x]) == i)
			photons[y][x] = 0;
	}

	// This shouldn't happen but ... you never know?
	if (t == PT_NONE)
		return;

	elementCount[t]--;

	parts[i].type = PT_NONE;
	parts[i].life = pfree;
	pfree = i;
	NUM_PARTS -= 1;
}

// Changes the type of particle number i, to t.  This also changes pmap at the same time
// Returns true if the particle was killed
bool Simulation::part_change_type(int i, int x, int y, int t)
{
	if (x<0 || y<0 || x>=XRES || y>=YRES || i>=NPART || t<0 || t>=PT_NUM || !parts[i].type)
		return false;

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (!elements[t].Enabled || t == PT_NONE)
	{
		kill_part(i);
		return true;
	}
	if (elements[t].CreateAllowed)
	{
		if (!(*(elements[t].CreateAllowed))(this, i, x, y, t))
			return false;
	}

	if (elements[parts[i].type].ChangeType)
		(*(elements[parts[i].type].ChangeType))(this, i, x, y, parts[i].type, t);
	if (elements[t].ChangeType)
		(*(elements[t].ChangeType))(this, i, x, y, parts[i].type, t);

	if (parts[i].type > 0 && parts[i].type < PT_NUM && elementCount[parts[i].type])
		elementCount[parts[i].type]--;
	elementCount[t]++;

	parts[i].type = t;
	if (elements[t].Properties & TYPE_ENERGY)
	{
		photons[y][x] = PMAP(i, t);
		if (pmap[y][x] && ID(pmap[y][x]) == i)
			pmap[y][x] = 0;
	}
	else
	{
		pmap[y][x] = PMAP(i, t);
		if (photons[y][x] && ID(photons[y][x]) == i)
			photons[y][x] = 0;
	}
	return false;
}

//the function for creating a particle, use p=-1 for creating a new particle, -2 is from a brush, or a particle number to replace a particle.
//tv = Type (PMAPBITS bits) + Var (32-PMAPBITS bits), var is usually 0
int Simulation::create_part(int p, int x, int y, int t, int v)
{
	int i, oldType = PT_NONE;

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (x<0 || y<0 || x>=XRES || y>=YRES || t<=0 || t>=PT_NUM || !elements[t].Enabled)
		return -1;

	if (t == PT_SPRK && p != -3 && !(p == -2 && elements[TYP(pmap[y][x])].CtypeDraw))
	{
		int type = TYP(pmap[y][x]);
		int index = ID(pmap[y][x]);
		if(type == PT_WIRE)
		{
			parts[index].ctype = PT_DUST;
			return index;
		}
		if (!(type == PT_INST || (elements[type].Properties&PROP_CONDUCTS)) || parts[index].life!=0)
			return -1;
		if (p == -2 && type == PT_INST)
		{
			FloodINST(x, y);
			return index;
		}
		parts[index].type = PT_SPRK;
		parts[index].life = 4;
		parts[index].ctype = type;
		pmap[y][x] = (pmap[y][x]&~PMAPMASK) | PT_SPRK;
		if (parts[index].temp+10.0f < 673.0f && !legacy_enable && (type==PT_METL || type == PT_BMTL || type == PT_BRMT || type == PT_PSCN || type == PT_NSCN || type == PT_ETRD || type == PT_NBLE || type == PT_IRON))
			parts[index].temp = parts[index].temp+10.0f;
		return index;
	}

	if (p == -2)
	{
		if (pmap[y][x])
		{
			int drawOn = TYP(pmap[y][x]);
			if (elements[drawOn].CtypeDraw)
				elements[drawOn].CtypeDraw(this, ID(pmap[y][x]), t, v);
			return -1;
		}
		else if (IsWallBlocking(x, y, t))
			return -1;
		else if (photons[y][x] && (elements[t].Properties & TYPE_ENERGY))
			return -1;
	}

	if (elements[t].CreateAllowed)
	{
		if (!(*(elements[t].CreateAllowed))(this, p, x, y, t))
			return -1;
	}

	if (p == -1 || //creating from anything but brush
	    p == -2 || //creating from brush
	    p == -3) //skip pmap checks, e.g. for sing explosion
	{
		if (p == -1)
		{
			// If there is a particle, only allow creation if the new particle can occupy the same space as the existing particle
			// If there isn't a particle but there is a wall, check whether the new particle is allowed to be in it
			//   (not "!=2" for wall check because eval_move returns 1 for moving into empty space)
			// If there's no particle and no wall, assume creation is allowed
			if (pmap[y][x] ? (eval_move(t, x, y, nullptr) != 2) : (bmap[y/CELL][x/CELL] && eval_move(t, x, y, nullptr) == 0))
			{
				return -1;
			}
		}
		if (pfree == -1)
			return -1;
		i = pfree;
		pfree = parts[i].life;
		NUM_PARTS += 1;
	}
	else
	{
		int oldX = (int)(parts[p].x + 0.5f);
		int oldY = (int)(parts[p].y + 0.5f);
		if (pmap[oldY][oldX] && ID(pmap[oldY][oldX]) == p)
			pmap[oldY][oldX] = 0;
		if (photons[oldY][oldX] && ID(photons[oldY][oldX]) == p)
			photons[oldY][oldX] = 0;

		oldType = parts[p].type;

		if (elements[oldType].ChangeType)
			(*(elements[oldType].ChangeType))(this, p, oldX, oldY, oldType, t);
		if (oldType)
			elementCount[oldType]--;

		i = p;
	}

	if (i>parts.lastActiveIndex) parts.lastActiveIndex = i;

	parts[i] = elements[t].DefaultProperties;
	parts[i].type = t;
	parts[i].x = (float)x;
	parts[i].y = (float)y;

	//and finally set the pmap/photon maps to the newly created particle
	if (elements[t].Properties & TYPE_ENERGY)
		photons[y][x] = PMAP(i, t);
	else if (t!=PT_STKM && t!=PT_STKM2 && t!=PT_FIGH)
		pmap[y][x] = PMAP(i, t);

	//Fancy dust effects for powder types
	if((elements[t].Properties & TYPE_PART) && pretty_powder)
	{
		int colr, colg, colb;
		int sandcolourToUse = p == -2 ? sandcolour_interface : sandcolour;
		RGB colour = elements[t].Colour;
		colr = colour.Red   + int(sandcolourToUse * 1.3) + rng.between(-20, 20) + rng.between(-15, 15);
		colg = colour.Green + int(sandcolourToUse * 1.3) + rng.between(-20, 20) + rng.between(-15, 15);
		colb = colour.Blue  + int(sandcolourToUse * 1.3) + rng.between(-20, 20) + rng.between(-15, 15);
		colr = std::clamp(colr, 0, 255);
		colg = std::clamp(colg, 0, 255);
		colb = std::clamp(colb, 0, 255);
		parts[i].dcolour = (rng.between(0, 149)<<24) | (colr<<16) | (colg<<8) | colb;
	}

	// Set non-static properties (such as randomly generated ones)
	if (elements[t].Create)
		(*(elements[t].Create))(this, i, x, y, t, v);

	if (elements[t].ChangeType)
		(*(elements[t].ChangeType))(this, i, x, y, oldType, t);

	elementCount[t]++;
	return i;
}

void Simulation::create_gain_photon(int pp)//photons from PHOT going through GLOW
{
	if (MaxPartsReached())
	{
		return;
	}
	auto lr = 2 * rng.between(0, 1) - 1; // -1 or 1
	auto xx = parts[pp].x - lr * 0.3f * parts[pp].vy;
	auto yy = parts[pp].y + lr * 0.3f * parts[pp].vx;
	auto nx = int(xx + 0.5f);
	auto ny = int(yy + 0.5f);
	if (nx < 0 || ny < 0 || nx >= XRES || ny >= YRES)
	{
		return;
	}
	auto g = pmap[ny][nx];
	if (TYP(g) != PT_GLOW)
	{
		return;
	}
	auto oldTemp = parts[ID(g)].temp;
	auto i = create_part(-3, nx, ny, PT_PHOT);
	if (i == -1)
	{
		return;
	}
	parts[i].x = xx;
	parts[i].y = yy;
	parts[i].vx = parts[pp].vx;
	parts[i].vy = parts[pp].vy;
	parts[i].temp = oldTemp;
	auto temp_bin = int((parts[i].temp - 273.0f) * 0.25f);
	if (temp_bin < 0) temp_bin = 0;
	if (temp_bin > 25) temp_bin = 25;
	parts[i].ctype = 0x1F << temp_bin;
}

void Simulation::create_cherenkov_photon(int pp)//photons from NEUT going through GLAS
{
	if (MaxPartsReached())
	{
		return;
	}
	auto nx = int(parts[pp].x + 0.5f);
	auto ny = int(parts[pp].y + 0.5f);
	auto g = pmap[ny][nx];
	if (TYP(g) != PT_GLAS && TYP(g) != PT_BGLA)
	{
		return;
	}
	if (std::hypot(parts[pp].vx, parts[pp].vy) < 1.44f)
	{
		return;
	}
	auto oldTemp = parts[ID(g)].temp;
	auto i = create_part(-3, nx, ny, PT_PHOT);
	if (i == -1)
	{
		return;
	}
	auto lr = 2 * rng.between(0, 1) - 1; // -1 or 1
	parts[i].ctype = 0x00000F80;
	parts[i].x = parts[pp].x;
	parts[i].y = parts[pp].y;
	parts[i].temp = oldTemp;
	parts[i].vx = parts[pp].vx - lr * 2.5f * parts[pp].vy;
	parts[i].vy = parts[pp].vy + lr * 2.5f * parts[pp].vx;
	/* photons have speed of light. no discussion. */
	auto r = 1.269f / std::hypot(parts[i].vx, parts[i].vy);
	parts[i].vx *= r;
	parts[i].vy *= r;
}

void Simulation::GetGravityField(int x, int y, float particleGrav, float newtonGrav, float & pGravX, float & pGravY)
{
	switch (gravityMode)
	{
	default:
	case GRAV_VERTICAL: //normal, vertical gravity
		pGravX = 0;
		pGravY = particleGrav;
		break;
	case GRAV_OFF: //no gravity
		pGravX = 0;
		pGravY = 0;
		break;
	case GRAV_RADIAL: //radial gravity
		{
			pGravX = 0;
			pGravY = 0;
			auto dx = float(x - XCNTR);
			auto dy = float(y - YCNTR);
			if (dx || dy)
			{
				auto pGravD = 0.01f - hypotf(dx, dy);
				pGravX = particleGrav * (dx / pGravD);
				pGravY = particleGrav * (dy / pGravD);
			}
		}
		break;
	case GRAV_CUSTOM: //custom gravity
		pGravX = particleGrav * customGravityX;
		pGravY = particleGrav * customGravityY;
		break;
	}
	if (newtonGrav)
	{
		pGravX += newtonGrav * gravOut.forceX[Vec2{ x, y } / CELL];
		pGravY += newtonGrav * gravOut.forceY[Vec2{ x, y } / CELL];
	}
}

void Simulation::delete_part(int x, int y)//calls kill_part with the particle located at x,y
{
	unsigned i;

	if (x<0 || y<0 || x>=XRES || y>=YRES)
		return;

	i = photons[y][x] ? photons[y][x] : pmap[y][x];

	if (!i)
		return;
	kill_part(ID(i));
}

template<bool UpdateEmap, class Sim>
void UpdateEmapHelper(Sim &sim, int fin_x, int fin_y);

template<>
void UpdateEmapHelper<false, const Simulation>(const Simulation &sim, int fin_x, int fin_y)
{
}

template<>
void UpdateEmapHelper<true, Simulation>(Simulation &sim, int fin_x, int fin_y)
{
	if (sim.bmap[fin_y/CELL][fin_x/CELL]==WL_DETECT && sim.emap[fin_y/CELL][fin_x/CELL]<8)
		sim.set_emap(fin_x/CELL, fin_y/CELL);
}

template<bool UpdateEmap, class Sim>
Simulation::PlanMoveResult Simulation::PlanMove(Sim &sim, int i, int x, int y)
{
	auto &parts = sim.parts;
	auto &bmap = sim.bmap;
	auto &emap = sim.emap;
	auto &pmap = sim.pmap;
	auto edgeMode = sim.edgeMode;
	auto &sd = SimulationData::CRef();
	auto &can_move = sd.can_move;
	auto t = parts[i].type;
	int fin_x, fin_y, clear_x, clear_y;
	float fin_xf, fin_yf, clear_xf, clear_yf;
	auto vx = parts[i].vx;
	auto vy = parts[i].vy;
	auto mv = fmaxf(fabsf(vx), fabsf(vy));
	if (mv < ISTP || std::isnan(mv))
	{
		clear_x = x;
		clear_y = y;
		clear_xf = parts[i].x;
		clear_yf = parts[i].y;
		fin_xf = clear_xf + vx;
		fin_yf = clear_yf + vy;
		fin_x = (int)(fin_xf+0.5f);
		fin_y = (int)(fin_yf+0.5f);
	}
	else
	{
		if (mv > MAX_VELOCITY)
		{
			vx *= MAX_VELOCITY/mv;
			vy *= MAX_VELOCITY/mv;
			mv = MAX_VELOCITY;
		}
		// interpolate to see if there is anything in the way
		auto dx = vx*ISTP/mv;
		auto dy = vy*ISTP/mv;
		fin_xf = parts[i].x;
		fin_yf = parts[i].y;
		fin_x = (int)(fin_xf+0.5f);
		fin_y = (int)(fin_yf+0.5f);
		bool closedEholeStart = InBounds(fin_x, fin_y) && (bmap[fin_y/CELL][fin_x/CELL] == WL_EHOLE && !emap[fin_y/CELL][fin_x/CELL]);
		while (1)
		{
			mv -= ISTP;
			fin_xf += dx;
			fin_yf += dy;
			fin_x = (int)(fin_xf+0.5f);
			fin_y = (int)(fin_yf+0.5f);
			if (edgeMode == EDGE_LOOP)
			{
				bool x_ok = (fin_xf >= CELL-.5f && fin_xf < XRES-CELL-.5f);
				bool y_ok = (fin_yf >= CELL-.5f && fin_yf < YRES-CELL-.5f);
				if (!x_ok)
					fin_xf = remainder_p(fin_xf-CELL+.5f, XRES-CELL*2.0f)+CELL-.5f;
				if (!y_ok)
					fin_yf = remainder_p(fin_yf-CELL+.5f, YRES-CELL*2.0f)+CELL-.5f;
				fin_x = (int)(fin_xf+0.5f);
				fin_y = (int)(fin_yf+0.5f);
			}
			if (mv <= 0.0f)
			{
				// nothing found
				fin_xf = parts[i].x + vx;
				fin_yf = parts[i].y + vy;
				if (edgeMode == EDGE_LOOP)
				{
					bool x_ok = (fin_xf >= CELL-.5f && fin_xf < XRES-CELL-.5f);
					bool y_ok = (fin_yf >= CELL-.5f && fin_yf < YRES-CELL-.5f);
					if (!x_ok)
						fin_xf = remainder_p(fin_xf-CELL+.5f, XRES-CELL*2.0f)+CELL-.5f;
					if (!y_ok)
						fin_yf = remainder_p(fin_yf-CELL+.5f, YRES-CELL*2.0f)+CELL-.5f;
				}
				fin_x = (int)(fin_xf+0.5f);
				fin_y = (int)(fin_yf+0.5f);
				clear_xf = fin_xf-dx;
				clear_yf = fin_yf-dy;
				clear_x = (int)(clear_xf+0.5f);
				clear_y = (int)(clear_yf+0.5f);
				break;
			}
			//block if particle can't move (0), or some special cases where it returns 1 (can_move = 3 but returns 1 meaning particle will be eaten)
			//also photons are still blocked (slowed down) by any particle (even ones it can move through), and absorb wall also blocks particles
			int eval = sim.eval_move(t, fin_x, fin_y, nullptr);
			if (!eval || (can_move[t][TYP(pmap[fin_y][fin_x])] == 3 && eval == 1) || (t == PT_PHOT && pmap[fin_y][fin_x]) || bmap[fin_y/CELL][fin_x/CELL]==WL_DESTROYALL || closedEholeStart!=(bmap[fin_y/CELL][fin_x/CELL] == WL_EHOLE && !emap[fin_y/CELL][fin_x/CELL]))
			{
				// found an obstacle
				clear_xf = fin_xf-dx;
				clear_yf = fin_yf-dy;
				clear_x = (int)(clear_xf+0.5f);
				clear_y = (int)(clear_yf+0.5f);
				break;
			}
			UpdateEmapHelper<UpdateEmap, Sim>(sim, fin_x, fin_y);
		}
	}
	return {
		fin_x,
		fin_y,
		clear_x,
		clear_y,
		fin_xf,
		fin_yf,
		clear_xf,
		clear_yf,
		vx,
		vy,
	};
}

template
Simulation::PlanMoveResult Simulation::PlanMove<false, const Simulation>(const Simulation &sim, int i, int x, int y);

bool Simulation::IsHeatInsulator(Particle p) const
{
	return SimulationData::CRef().elements[p.type].HeatConduct == 0 || (p.type == PT_HSWC && p.life != 10) || ((p.type == PT_PIPE || p.type == PT_PPIP) && (p.tmp & PFLAG_CAN_CONDUCT) == 0);
}

void Simulation::UpdateParticles(int start, int end)
{
	//the main particle loop function, goes over all particles.
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (auto i = start; i < end && i <= parts.lastActiveIndex; i++)
	{
		if (parts[i].type)
		{
			debug_mostRecentlyUpdated = i;
			auto t = parts[i].type;

			auto x = (int)(parts[i].x+0.5f);
			auto y = (int)(parts[i].y+0.5f);

			// Kill a particle off screen
			if (x<CELL || y<CELL || x>=XRES-CELL || y>=YRES-CELL)
			{
				kill_part(i);
				continue;
			}

			// Kill a particle in a wall where it isn't supposed to go
			if (bmap[y/CELL][x/CELL] &&
			   (bmap[y/CELL][x/CELL]==WL_WALL ||
			    bmap[y/CELL][x/CELL]==WL_WALLELEC ||
			    bmap[y/CELL][x/CELL]==WL_ALLOWAIR ||
			    (bmap[y/CELL][x/CELL]==WL_DESTROYALL) ||
			    (bmap[y/CELL][x/CELL]==WL_ALLOWLIQUID && !(elements[t].Properties&TYPE_LIQUID)) ||
			    (bmap[y/CELL][x/CELL]==WL_ALLOWPOWDER && !(elements[t].Properties&TYPE_PART)) ||
			    (bmap[y/CELL][x/CELL]==WL_ALLOWGAS && !(elements[t].Properties&TYPE_GAS)) || //&& elements[t].Falldown!=0 && parts[i].type!=PT_FIRE && parts[i].type!=PT_SMKE && parts[i].type!=PT_CFLM) ||
			            (bmap[y/CELL][x/CELL]==WL_ALLOWENERGY && !(elements[t].Properties&TYPE_ENERGY)) ||
			    (bmap[y/CELL][x/CELL]==WL_EWALL && !emap[y/CELL][x/CELL])) && (t!=PT_STKM) && (t!=PT_STKM2) && (t!=PT_FIGH))
			{
				kill_part(i);
				continue;
			}

			// Make sure that STASIS'd particles don't tick.
			if (bmap[y/CELL][x/CELL] == WL_STASIS && emap[y/CELL][x/CELL]<8) {
				continue;
			}

			if (bmap[y/CELL][x/CELL]==WL_DETECT && emap[y/CELL][x/CELL]<8)
				set_emap(x/CELL, y/CELL);

			//adding to velocity from the particle's velocity
			vx[y/CELL][x/CELL] = vx[y/CELL][x/CELL]*elements[t].AirLoss + elements[t].AirDrag*parts[i].vx;
			vy[y/CELL][x/CELL] = vy[y/CELL][x/CELL]*elements[t].AirLoss + elements[t].AirDrag*parts[i].vy;

			if (elements[t].HotAir)
			{
				if (t==PT_GAS||t==PT_NBLE)
				{
					if (pv[y/CELL][x/CELL]<3.5f)
						pv[y/CELL][x/CELL] += elements[t].HotAir*(3.5f-pv[y/CELL][x/CELL]);
					if (y+CELL<YRES && pv[y/CELL+1][x/CELL]<3.5f)
						pv[y/CELL+1][x/CELL] += elements[t].HotAir*(3.5f-pv[y/CELL+1][x/CELL]);
					if (x+CELL<XRES)
					{
						if (pv[y/CELL][x/CELL+1]<3.5f)
							pv[y/CELL][x/CELL+1] += elements[t].HotAir*(3.5f-pv[y/CELL][x/CELL+1]);
						if (y+CELL<YRES && pv[y/CELL+1][x/CELL+1]<3.5f)
							pv[y/CELL+1][x/CELL+1] += elements[t].HotAir*(3.5f-pv[y/CELL+1][x/CELL+1]);
					}
				}
				else//add the hotair variable to the pressure map, like black hole, or white hole.
				{
					pv[y/CELL][x/CELL] += elements[t].HotAir;
					if (y+CELL<YRES)
						pv[y/CELL+1][x/CELL] += elements[t].HotAir;
					if (x+CELL<XRES)
					{
						pv[y/CELL][x/CELL+1] += elements[t].HotAir;
						if (y+CELL<YRES)
							pv[y/CELL+1][x/CELL+1] += elements[t].HotAir;
					}
				}
			}

			float pGravX = 0, pGravY = 0;
			if (!(elements[t].Properties & TYPE_SOLID) && (elements[t].Gravity || elements[t].NewtonianGravity))
			{
				GetGravityField(x, y, elements[t].Gravity, elements[t].NewtonianGravity, pGravX, pGravY);
			}

			//velocity updates for the particle
			if (t != PT_SPNG || !(parts[i].flags&FLAG_MOVABLE))
			{
				parts[i].vx *= elements[t].Loss;
				parts[i].vy *= elements[t].Loss;
			}
			//particle gets velocity from the vx and vy maps
			parts[i].vx += elements[t].Advection*vx[y/CELL][x/CELL] + pGravX;
			parts[i].vy += elements[t].Advection*vy[y/CELL][x/CELL] + pGravY;


			if (elements[t].Diffusion)//the random diffusion that gasses have
			{
				parts[i].vx += elements[t].Diffusion*(2.0f*rng.uniform01()-1.0f);
				parts[i].vy += elements[t].Diffusion*(2.0f*rng.uniform01()-1.0f);
			}

			auto transitionOccurred = false;

			int surround[8];
			auto surround_space = 0;
			auto nt = 0; //if nt is greater than 1 after this, then there is a particle around the current particle, that is NOT the current particle's type, for water movement.
			{
				auto j = 0;
				for (auto nx=-1; nx<2; nx++)
				{
					for (auto ny=-1; ny<2; ny++)
					{
						if (nx||ny)
						{
							auto r = pmap[y+ny][x+nx];
							surround[j] = r;
							j++;
							surround_space += (!TYP(r)); // count empty space
							nt += (TYP(r)!=t); // count empty space and particles of different type
						}
					}
				}
			}

			float gel_scale = 1.0f;
			if (t==PT_GEL)
				gel_scale = parts[i].tmp*2.55f;

			if (!legacy_enable)
			{
				if ((elements[t].Properties&TYPE_LIQUID) && (t!=PT_GEL || gel_scale > (1 + rng.between(0, 254))))
				{
					float convGravX, convGravY;
					GetGravityField(x, y, -2.0f, -2.0f, convGravX, convGravY);
					auto offsetX = std::clamp(int(std::round(convGravX + x)), x-1, x+1);
					auto offsetY = std::clamp(int(std::round(convGravY + y)), y-1, y+1);
					// Some heat convection for liquids
					if (offsetX != x || offsetY != y)
					{
						auto r = pmap[offsetY][offsetX];
						if (r && parts[i].type == TYP(r))
						{
							if (parts[i].temp>parts[ID(r)].temp)
							{
								auto swappage = parts[i].temp;
								parts[i].temp = parts[ID(r)].temp;
								parts[ID(r)].temp = swappage;
							}
						}
					}
				}

				//heat transfer code
				auto h_count = 0;
				bool cond;
				cond = t && !IsHeatInsulator(parts[i]) && rng.chance(int(elements[t].HeatConduct*gel_scale), 250);

				if (cond)
				{
					if (aheat_enable && !(elements[t].Properties&PROP_NOAMBHEAT))
					{
						auto c_heat = (hv[y/CELL][x/CELL]-parts[i].temp)*0.04;
						c_heat = restrict_flt(c_heat, -MAX_TEMP+MIN_TEMP, MAX_TEMP-MIN_TEMP);
						parts[i].temp += c_heat;
						hv[y/CELL][x/CELL] -= c_heat;
					}
					auto c_heat = 0.0f;
					int surround_hconduct[8];
					for (auto j=0; j<8; j++)
					{
						surround_hconduct[j] = i;
						auto r = surround[j];

						if (!r)
							continue;

						auto rt = TYP(r);

						if (!rt || IsHeatInsulator(parts[ID(r)])
						        || (t == PT_FILT && (rt == PT_BRAY || rt == PT_BIZR || rt == PT_BIZRG))
						        || (rt == PT_FILT && (t == PT_BRAY || t == PT_PHOT || t == PT_BIZR || t == PT_BIZRG))
						        || (t == PT_ELEC && rt == PT_DEUT)
						        || (t == PT_DEUT && rt == PT_ELEC)
						        || (t == PT_HSWC && rt == PT_FILT && parts[i].tmp == 1)
						        || (t == PT_FILT && rt == PT_HSWC && parts[ID(r)].tmp == 1))
							continue;

						surround_hconduct[j] = ID(r);
						c_heat += parts[ID(r)].temp;

						if ((rt == PT_PIPE || rt == PT_PPIP) && parts[ID(r)].ctype != 0)
						{
							c_heat += parts[ID(r)].temp; // double count the particle to account for the heat capacity of both the PIPE/PPIP and its contents
						}

						h_count++;

						if ((rt == PT_PIPE || rt == PT_PPIP) && parts[ID(r)].ctype != 0)
						{
							h_count++; // double count the particle to account for the heat capacity of both the PIPE/PPIP and its contents
						}
					}
					float pt = R_TEMP;

					if ((t == PT_PIPE || t == PT_PPIP) && parts[i].ctype != 0)
						pt = (c_heat+parts[i].temp*2.0f)/(h_count+2); // double count the particle to account for the heat capacity of both the PIPE/PPIP and its contents
					else
						pt = (c_heat+parts[i].temp)/(h_count+1);

					pt = parts[i].temp = restrict_flt(pt, MIN_TEMP, MAX_TEMP);
					for (auto j=0; j<8; j++)
					{
						parts[surround_hconduct[j]].temp = pt;
					}

					auto ctemph = pt;
					auto ctempl = pt;
					// change boiling point with pressure
					if (((elements[t].Properties&TYPE_LIQUID) && sd.IsElementOrNone(elements[t].HighTemperatureTransition) && (elements[elements[t].HighTemperatureTransition].Properties&TYPE_GAS))
					        || t==PT_LNTG || t==PT_SLTW)
						ctemph -= 2.0f*pv[y/CELL][x/CELL];
					else if (((elements[t].Properties&TYPE_GAS) && sd.IsElementOrNone(elements[t].LowTemperatureTransition) && (elements[elements[t].LowTemperatureTransition].Properties&TYPE_LIQUID))
					         || t==PT_WTRV)
						ctempl -= 2.0f*pv[y/CELL][x/CELL];
					auto s = 1;

					//A fix for ice with ctype = 0
					if ((t==PT_ICEI || t==PT_SNOW) && (!sd.IsElement(parts[i].ctype) || parts[i].ctype==PT_ICEI || parts[i].ctype==PT_SNOW))
						parts[i].ctype = PT_WATR;

					if (elements[t].HighTemperatureTransition != NT && ctemph>=elements[t].HighTemperature)
					{
						// particle type change due to high temperature
						if (elements[t].HighTemperatureTransition != ST)
						{
							t = elements[t].HighTemperatureTransition;
						}
						else if (t == PT_ICEI || t == PT_SNOW)
						{
							if (parts[i].ctype > 0 && parts[i].ctype < PT_NUM && parts[i].ctype != t)
							{
								if (elements[parts[i].ctype].LowTemperatureTransition==PT_ICEI || elements[parts[i].ctype].LowTemperatureTransition==PT_SNOW)
								{
									if (pt<elements[parts[i].ctype].LowTemperature)
										s = 0;
								}
								else if (pt<273.15f)
									s = 0;

								if (s)
								{
									t = parts[i].ctype;
									parts[i].ctype = PT_NONE;
									parts[i].life = 0;
								}
							}
							else
								s = 0;
						}
						else if (t == PT_SLTW)
						{
							t = rng.chance(1, 4) ? PT_SALT : PT_WTRV;
						}
						else if (t == PT_BRMT)
						{
							if (parts[i].ctype == PT_TUNG)
							{
								if (ctemph < elements[parts[i].ctype].HighTemperature)
									s = 0;
								else
								{
									t = PT_LAVA;
									parts[i].type = PT_TUNG;
								}
							}
							else if (ctemph >= elements[t].HighTemperature)
								t = PT_LAVA;
							else
								s = 0;
						}
						else if (t == PT_CRMC)
						{
							float pres = std::max((pv[y/CELL][x/CELL]+pv[(y-2)/CELL][x/CELL]+pv[(y+2)/CELL][x/CELL]+pv[y/CELL][(x-2)/CELL]+pv[y/CELL][(x+2)/CELL])*2.0f, 0.0f);
							if (ctemph < pres+elements[PT_CRMC].HighTemperature)
								s = 0;
							else
								t = PT_LAVA;
						}
						else if (t == PT_RIME)
						{
							if (parts[i].tmp > 5)
							{
								t = PT_ACID;
								parts[i].life = 25 + 5 * parts[i].tmp;
								parts[i].tmp = 0;
							}
							else
							{
								t = PT_WATR;
							}
						}
						else
							s = 0;
					}
					else if (elements[t].LowTemperatureTransition != NT && ctempl<elements[t].LowTemperature)
					{
						// particle type change due to low temperature
						if (elements[t].LowTemperatureTransition != ST)
						{
							t = elements[t].LowTemperatureTransition;
						}
						else if (t == PT_WTRV)
						{
							t = (pt < 273.0f) ? PT_RIME : PT_DSTW;
						}
						else if (t == PT_LAVA)
						{
							if (parts[i].ctype > 0 && parts[i].ctype < PT_NUM && parts[i].ctype != PT_LAVA && elements[parts[i].ctype].Enabled)
							{
								if (parts[i].ctype == PT_THRM && pt >= elements[PT_BMTL].HighTemperature)
									s = 0;
								else if ((parts[i].ctype == PT_VIBR || parts[i].ctype == PT_BVBR) && pt >= 273.15f)
									s = 0;
								else if (parts[i].ctype == PT_TUNG)
								{
									// TUNG does its own melting in its update function, so HighTemperatureTransition is not LAVA so it won't be handled by the code for HighTemperatureTransition==PT_LAVA below
									// However, the threshold is stored in HighTemperature to allow it to be changed from Lua
									if (pt >= elements[parts[i].ctype].HighTemperature)
										s = 0;
								}
								else if (parts[i].ctype == PT_CRMC)
								{
									float pres = std::max((pv[y/CELL][x/CELL]+pv[(y-2)/CELL][x/CELL]+pv[(y+2)/CELL][x/CELL]+pv[y/CELL][(x-2)/CELL]+pv[y/CELL][(x+2)/CELL])*2.0f, 0.0f);
									if (ctemph >= pres+elements[PT_CRMC].HighTemperature)
										s = 0;
								}
								else if (elements[parts[i].ctype].HighTemperatureTransition == PT_LAVA || parts[i].ctype == PT_HEAC)
								{
									if (pt >= elements[parts[i].ctype].HighTemperature)
										s = 0;
								}
								else if (pt>=973.0f)
									s = 0; // freezing point for lava with any other (not listed in ptransitions as turning into lava) ctype
								if (s)
								{
									t = parts[i].ctype;
									parts[i].ctype = PT_NONE;
									if (t == PT_THRM)
									{
										parts[i].tmp = 0;
										t = PT_BMTL;
									}
									if (t == PT_PLUT)
									{
										parts[i].tmp = 0;
										t = PT_LAVA;
									}
								}
							}
							else if (pt<973.0f)
								t = PT_STNE;
							else
								s = 0;
						}
						else
							s = 0;
					}
					else
						s = 0;

					if (s) // particle type change occurred
					{
						if (t==PT_ICEI || t==PT_LAVA || t==PT_SNOW)
							parts[i].ctype = parts[i].type;
						if (!(t==PT_ICEI && parts[i].ctype==PT_FRZW) && t!=PT_ACID)
							parts[i].life = 0;
						if (t == PT_FIRE)
						{
							//hackish, if tmp isn't 0 the FIRE might turn into DSTW later
							//idealy transitions should use create_part(i) but some elements rely on properties staying constant
							//and I don't feel like checking each one right now
							parts[i].tmp = 0;
						}
						if ((elements[t].Properties&TYPE_GAS) && !(elements[parts[i].type].Properties&TYPE_GAS))
							pv[y/CELL][x/CELL] += 0.50f;

						if (t == PT_NONE)
						{
							kill_part(i);
							goto killed;
						}
						// part_change_type could refuse to change the type and kill the particle
						// for example, changing type to STKM but one already exists
						// we need to account for that to not cause simulation corruption issues
						if (part_change_type(i,x,y,t))
							goto killed;

						if (t==PT_FIRE || t==PT_PLSM || t==PT_CFLM)
							parts[i].life = rng.between(120, 169);
						if (t == PT_LAVA)
						{
							if (parts[i].ctype == PT_BRMT) parts[i].ctype = PT_BMTL;
							else if (parts[i].ctype == PT_SAND) parts[i].ctype = PT_GLAS;
							else if (parts[i].ctype == PT_BGLA) parts[i].ctype = PT_GLAS;
							else if (parts[i].ctype == PT_PQRT) parts[i].ctype = PT_QRTZ;
							else if (parts[i].ctype == PT_LITH && parts[i].tmp2 > 3) parts[i].ctype = PT_GLAS;
							parts[i].life = rng.between(240, 359);
						}
						transitionOccurred = true;
					}

					pt = parts[i].temp = restrict_flt(parts[i].temp, MIN_TEMP, MAX_TEMP);
					if (t == PT_LAVA)
					{
						parts[i].life = int(restrict_flt((parts[i].temp-700)/7, 0, 400));
						if (parts[i].ctype==PT_THRM&&parts[i].tmp>0)
						{
							parts[i].tmp--;
							parts[i].temp = 3500;
						}
						if (parts[i].ctype==PT_PLUT&&parts[i].tmp>0)
						{
							parts[i].tmp--;
							parts[i].temp = MAX_TEMP;
						}
					}
				}
				else
				{
					if (!(air->bmap_blockairh[y/CELL][x/CELL]&0x8))
						air->bmap_blockairh[y/CELL][x/CELL]++;
					parts[i].temp = restrict_flt(parts[i].temp, MIN_TEMP, MAX_TEMP);
				}
			}

			if (t==PT_LIFE)
			{
				parts[i].temp = restrict_flt(parts[i].temp-50.0f, MIN_TEMP, MAX_TEMP);
			}
			if (t==PT_WIRE)
			{
				//wire_placed = 1;
			}
			//spark updates from walls
			if ((elements[t].Properties&PROP_CONDUCTS) || t==PT_SPRK)
			{
				auto nx = x % CELL;
				if (nx == 0)
					nx = x/CELL - 1;
				else if (nx == CELL-1)
					nx = x/CELL + 1;
				else
					nx = x/CELL;
				auto ny = y % CELL;
				if (ny == 0)
					ny = y/CELL - 1;
				else if (ny == CELL-1)
					ny = y/CELL + 1;
				else
					ny = y/CELL;
				if (nx>=0 && ny>=0 && nx<XCELLS && ny<YCELLS)
				{
					if (t!=PT_SPRK)
					{
						if (emap[ny][nx]==12 && !parts[i].life && bmap[ny][nx] != WL_STASIS)
						{
							part_change_type(i,x,y,PT_SPRK);
							parts[i].life = 4;
							parts[i].ctype = t;
							t = PT_SPRK;
						}
					}
					else if (bmap[ny][nx]==WL_DETECT || bmap[ny][nx]==WL_EWALL || bmap[ny][nx]==WL_ALLOWLIQUID || bmap[ny][nx]==WL_WALLELEC || bmap[ny][nx]==WL_ALLOWALLELEC || bmap[ny][nx]==WL_EHOLE)
						set_emap(nx, ny);
				}
			}

			//the basic explosion, from the .explosive variable
			if ((elements[t].Explosive&2) && pv[y/CELL][x/CELL]>2.5f)
			{
				parts[i].life = rng.between(180, 259);
				parts[i].temp = restrict_flt(elements[PT_FIRE].DefaultProperties.temp + (elements[t].Flammable/2), MIN_TEMP, MAX_TEMP);
				t = PT_FIRE;
				part_change_type(i,x,y,t);
				pv[y/CELL][x/CELL] += 0.25f * CFDS;
			}

			{
				auto s = 1;
				auto gravtot = std::abs(gravOut.forceX[Vec2{ x, y } / CELL]) +
				               std::abs(gravOut.forceY[Vec2{ x, y } / CELL]);
				if (elements[t].HighPressureTransition != NT && pv[y/CELL][x/CELL]>elements[t].HighPressure) {
					// particle type change due to high pressure
					if (elements[t].HighPressureTransition != ST)
						t = elements[t].HighPressureTransition;
					else if (t==PT_BMTL) {
						if (pv[y/CELL][x/CELL]>2.5f)
							t = PT_BRMT;
						else if (pv[y/CELL][x/CELL]>1.0f && parts[i].tmp==1)
							t = PT_BRMT;
						else s = 0;
					}
					else s = 0;
				} else if (elements[t].LowPressureTransition != NT && pv[y/CELL][x/CELL]<elements[t].LowPressure && gravtot<=(elements[t].LowPressure/4.0f)) {
					// particle type change due to low pressure
					if (elements[t].LowPressureTransition != ST)
						t = elements[t].LowPressureTransition;
					else s = 0;
				} else if (elements[t].HighPressureTransition != NT && gravtot>(elements[t].HighPressure/4.0f)) {
					// particle type change due to high gravity
					if (elements[t].HighPressureTransition != ST)
						t = elements[t].HighPressureTransition;
					else if (t==PT_BMTL) {
						if (gravtot>0.625f)
							t = PT_BRMT;
						else if (gravtot>0.25f && parts[i].tmp==1)
							t = PT_BRMT;
						else s = 0;
					}
					else s = 0;
				} else s = 0;

				// particle type change occurred
				if (s)
				{
					if (t == PT_NONE)
					{
						kill_part(i);
						goto killed;
					}
					parts[i].life = 0;
					// part_change_type could refuse to change the type and kill the particle
					// for example, changing type to STKM but one already exists
					// we need to account for that to not cause simulation corruption issues
					if (part_change_type(i,x,y,t))
						goto killed;
					if (t == PT_FIRE)
						parts[i].life = rng.between(120, 169);
					transitionOccurred = true;
				}
			}

			//call the particle update function, if there is one
			if (elements[t].Update)
			{
				if ((*(elements[t].Update))(this, i, x, y, surround_space, nt, parts, pmap))
					continue;
				x = (int)(parts[i].x+0.5f);
				y = (int)(parts[i].y+0.5f);
			}

			if(legacy_enable)//if heat sim is off
				Element::legacyUpdate(this, i,x,y,surround_space,nt, parts, pmap);

killed:
			if (parts[i].type == PT_NONE)//if its dead, skip to next particle
				continue;

			if (transitionOccurred)
				continue;

			if (!parts[i].vx&&!parts[i].vy)//if its not moving, skip to next particle, movement code it next
				continue;

			int fin_x, fin_y, clear_x, clear_y;
			float fin_xf, fin_yf, clear_xf, clear_yf;
			{
				auto mr = PlanMove<true>(*this, i, x, y);
				fin_x    = mr.fin_x;
				fin_y    = mr.fin_y;
				clear_x  = mr.clear_x;
				clear_y  = mr.clear_y;
				fin_xf   = mr.fin_xf;
				fin_yf   = mr.fin_yf;
				clear_xf = mr.clear_xf;
				clear_yf = mr.clear_yf;
				parts[i].vx = mr.vx;
				parts[i].vy = mr.vy;
			}

			auto stagnant = parts[i].flags & FLAG_STAGNANT;
			parts[i].flags &= ~FLAG_STAGNANT;

			if (t==PT_STKM || t==PT_STKM2 || t==PT_FIGH)
			{
				//head movement, let head pass through anything
				parts[i].x += parts[i].vx;
				parts[i].y += parts[i].vy;
				int nx = (int)((float)parts[i].x+0.5f);
				int ny = (int)((float)parts[i].y+0.5f);
				if (edgeMode == EDGE_LOOP)
				{
					bool x_ok = (nx >= CELL && nx < XRES-CELL);
					bool y_ok = (ny >= CELL && ny < YRES-CELL);
					int oldnx = nx, oldny = ny;
					if (!x_ok)
					{
						parts[i].x = remainder_p(parts[i].x-CELL+.5f, XRES-CELL*2.0f)+CELL-.5f;
						nx = (int)((float)parts[i].x+0.5f);
					}
					if (!y_ok)
					{
						parts[i].y = remainder_p(parts[i].y-CELL+.5f, YRES-CELL*2.0f)+CELL-.5f;
						ny = (int)((float)parts[i].y+0.5f);
					}

					if (!x_ok || !y_ok) //when moving from left to right stickmen might be able to fall through solid things, fix with "eval_move(t, nx+diffx, ny+diffy, NULL)" but then they die instead
					{
						//adjust stickmen legs
						playerst* stickman = nullptr;
						int t = parts[i].type;
						if (t == PT_STKM)
							stickman = &player;
						else if (t == PT_STKM2)
							stickman = &player2;
						else if (t == PT_FIGH && parts[i].tmp >= 0 && parts[i].tmp < MAX_FIGHTERS)
							stickman = &fighters[parts[i].tmp];

						if (stickman)
							for (int i = 0; i < 16; i+=2)
							{
								stickman->legs[i] += (nx-oldnx);
								stickman->legs[i+1] += (ny-oldny);
								stickman->accs[i/2] *= .95f;
							}
						parts[i].vy *= .95f;
						parts[i].vx *= .95f;
					}
				}
				if (ny!=y || nx!=x)
				{
					if (pmap[y][x] && ID(pmap[y][x]) == i)
						pmap[y][x] = 0;
					else if (photons[y][x] && ID(photons[y][x]) == i)
						photons[y][x] = 0;
					if (nx<CELL || nx>=XRES-CELL || ny<CELL || ny>=YRES-CELL)
					{
						kill_part(i);
						continue;
					}
					if (elements[t].Properties & TYPE_ENERGY)
						photons[ny][nx] = PMAP(i, t);
					else if (t)
						pmap[ny][nx] = PMAP(i, t);
				}
			}
			else if (elements[t].Properties & TYPE_ENERGY)
			{
				if (t == PT_PHOT)
				{
					if (parts[i].flags&FLAG_SKIPMOVE)
					{
						parts[i].flags &= ~FLAG_SKIPMOVE;
						continue;
					}

					if (eval_move(PT_PHOT, fin_x, fin_y, nullptr))
					{
						int rt = TYP(pmap[fin_y][fin_x]);
						int lt = TYP(pmap[y][x]);
						int rt_glas = (rt == PT_GLAS) || (rt == PT_BGLA);
						int lt_glas = (lt == PT_GLAS) || (lt == PT_BGLA);
						if ((rt_glas && !lt_glas) || (lt_glas && !rt_glas))
						{
							auto gn = get_normal_interp<true>(*this, REFRACT|t, parts[i].x, parts[i].y, parts[i].vx, parts[i].vy);
							if (!gn.success) {
								kill_part(i);
								continue;
							}
							auto nrx = gn.nx;
							auto nry = gn.ny;
							auto r = get_wavelength_bin(&parts[i].ctype);
							if (r == -1 || !(parts[i].ctype&0x3FFFFFFF))
							{
								kill_part(i);
								continue;
							}
							auto nn = GLASS_IOR - GLASS_DISP*(r-30)/30.0f;
							nn *= nn;

							auto enter = rt_glas && !lt_glas;
							nrx = enter ? -nrx : nrx;
							nry = enter ? -nry : nry;
							nn = enter ? 1.0f/nn : nn;
							auto ct1 = parts[i].vx*nrx + parts[i].vy*nry;
							auto ct2 = 1.0f - (nn*nn)*(1.0f-(ct1*ct1));
							if (ct2 < 0.0f) {
								// total internal reflection
								parts[i].vx -= 2.0f*ct1*nrx;
								parts[i].vy -= 2.0f*ct1*nry;
								fin_xf = parts[i].x;
								fin_yf = parts[i].y;
								fin_x = x;
								fin_y = y;
							} else {
								// refraction
								ct2 = sqrtf(ct2);
								ct2 = ct2 - nn*ct1;
								parts[i].vx = nn*parts[i].vx + ct2*nrx;
								parts[i].vy = nn*parts[i].vy + ct2*nry;
							}
						}
					}
				}
				if (stagnant)//FLAG_STAGNANT set, was reflected on previous frame
				{
					// cast coords as int then back to float for compatibility with existing saves
					if (!do_move(i, x, y, (float)fin_x, (float)fin_y) && parts[i].type) {
						kill_part(i);
						continue;
					}
				}
				else if (!do_move(i, x, y, fin_xf, fin_yf))
				{
					if (parts[i].type == PT_NONE)
						continue;
					// reflection
					parts[i].flags |= FLAG_STAGNANT;
					if (t==PT_NEUT && rng.chance(1, 10))
					{
						kill_part(i);
						continue;
					}
					auto r = pmap[fin_y][fin_x];

					if ((TYP(r)==PT_PIPE || TYP(r) == PT_PPIP) && !TYP(parts[ID(r)].ctype))
					{
						Element_PIPE_transfer_part_to_pipe(parts+i, parts+(ID(r)));
						continue;
					}

					if (t == PT_PHOT)
					{
						auto mask = elements[TYP(r)].PhotonReflectWavelengths;
						if (TYP(r) == PT_LITH)
						{
							int wl_bin = parts[ID(r)].ctype / 4;
							if (wl_bin < 0) wl_bin = 0;
							if (wl_bin > 25) wl_bin = 25;
							mask = (0x1F << wl_bin);
						}
						parts[i].ctype &= mask;
					}

					auto gn = get_normal_interp<true>(*this, t, parts[i].x, parts[i].y, parts[i].vx, parts[i].vy);
					if (gn.success)
					{
						auto nrx = gn.nx;
						auto nry = gn.ny;
						if (TYP(r) == PT_CRMC)
						{
							float r = rng.between(-50, 50) * 0.01f, rx, ry, anrx, anry;
							r = r * r * r;
							rx = cosf(r); ry = sinf(r);
							anrx = rx * nrx + ry * nry;
							anry = rx * nry - ry * nrx;
							auto dp = anrx*parts[i].vx + anry*parts[i].vy;
							parts[i].vx -= 2.0f*dp*anrx;
							parts[i].vy -= 2.0f*dp*anry;
						}
						else
						{
							auto dp = nrx*parts[i].vx + nry*parts[i].vy;
							parts[i].vx -= 2.0f*dp*nrx;
							parts[i].vy -= 2.0f*dp*nry;
						}
						// leave the actual movement until next frame so that reflection of fast particles and refraction happen correctly
					}
					else
					{
						if (t!=PT_NEUT)
							kill_part(i);
						continue;
					}
					if (!(parts[i].ctype&0x3FFFFFFF) && t == PT_PHOT)
					{
						kill_part(i);
						continue;
					}
				}
			}
			else if (elements[t].Falldown==0)
			{
				// gasses and solids (but not powders)
				if (!do_move(i, x, y, fin_xf, fin_yf))
				{
					if (parts[i].type == PT_NONE)
						continue;
					// can't move there, so bounce off
					// TODO
					// TODO: Work out what previous TODO was for
					if (fin_x>x+ISTP) fin_x=x+ISTP;
					if (fin_x<x-ISTP) fin_x=x-ISTP;
					if (fin_y>y+ISTP) fin_y=y+ISTP;
					if (fin_y<y-ISTP) fin_y=y-ISTP;
					if (do_move(i, x, y, 0.25f+(float)(2*x-fin_x), 0.25f+fin_y))
					{
						parts[i].vx *= elements[t].Collision;
					}
					else if (do_move(i, x, y, 0.25f+fin_x, 0.25f+(float)(2*y-fin_y)))
					{
						parts[i].vy *= elements[t].Collision;
					}
					else
					{
						parts[i].vx *= elements[t].Collision;
						parts[i].vy *= elements[t].Collision;
					}
				}
			}
			else
			{
				// Checking stagnant is cool, but then it doesn't update when you change it later.
				if (water_equal_test && elements[t].Falldown == 2 && rng.chance(1, 200))
				{
					if (flood_water(x, y, i))
						goto movedone;
				}
				// liquids and powders
				if (!do_move(i, x, y, fin_xf, fin_yf))
				{
					if (parts[i].type == PT_NONE)
						continue;
					if (fin_x!=x && do_move(i, x, y, fin_xf, clear_yf))
					{
						parts[i].vx *= elements[t].Collision;
						parts[i].vy *= elements[t].Collision;
					}
					else if (fin_y!=y && do_move(i, x, y, clear_xf, fin_yf))
					{
						parts[i].vx *= elements[t].Collision;
						parts[i].vy *= elements[t].Collision;
					}
					else
					{
						auto r = rng.between(0, 1) * 2 - 1;// position search direction (left/right first)
						if ((clear_x!=x || clear_y!=y || nt || surround_space) &&
							(fabsf(parts[i].vx)>0.01f || fabsf(parts[i].vy)>0.01f))
						{
							// allow diagonal movement if target position is blocked
							// but no point trying this if particle is stuck in a block of identical particles
							auto dx = parts[i].vx - parts[i].vy*r;
							auto dy = parts[i].vy + parts[i].vx*r;

							auto mv = std::max(fabsf(dx), fabsf(dy));
							dx /= mv;
							dy /= mv;
							if (do_move(i, x, y, clear_xf+dx, clear_yf+dy))
							{
								parts[i].vx *= elements[t].Collision;
								parts[i].vy *= elements[t].Collision;
								goto movedone;
							}
							{
								auto swappage = dx;
								dx = dy*r;
								dy = -swappage*r;
							}
							if (do_move(i, x, y, clear_xf+dx, clear_yf+dy))
							{
								parts[i].vx *= elements[t].Collision;
								parts[i].vy *= elements[t].Collision;
								goto movedone;
							}
						}
						if (elements[t].Falldown>1 && !grav && gravityMode==GRAV_VERTICAL && parts[i].vy>fabsf(parts[i].vx))
						{
							auto s = 0;
							// stagnant is true if FLAG_STAGNANT was set for this particle in previous frame
							int rt;
							if (!stagnant || nt) //nt is if there is an something else besides the current particle type, around the particle
								rt = 30;//slight less water lag, although it changes how it moves a lot
							else
								rt = 10;

							if (t==PT_GEL)
								rt = int(parts[i].tmp*0.20f+5.0f);

							auto nx = -1, ny = -1;
							for (auto j=clear_x+r; j>=0 && j>=clear_x-rt && j<clear_x+rt && j<XRES; j+=r)
							{
								if ((TYP(pmap[fin_y][j])!=t || bmap[fin_y/CELL][j/CELL])
									&& (s=do_move(i, x, y, (float)j, fin_yf)))
								{
									nx = (int)(parts[i].x+0.5f);
									ny = (int)(parts[i].y+0.5f);
									break;
								}
								if (fin_y!=clear_y && (TYP(pmap[clear_y][j])!=t || bmap[clear_y/CELL][j/CELL])
									&& (s=do_move(i, x, y, (float)j, clear_yf)))
								{
									nx = (int)(parts[i].x+0.5f);
									ny = (int)(parts[i].y+0.5f);
									break;
								}
								if (TYP(pmap[clear_y][j])!=t || (bmap[clear_y/CELL][j/CELL] && bmap[clear_y/CELL][j/CELL]!=WL_STREAM))
									break;
							}

							r = (parts[i].vy>0) ? 1 : -1;

							if (s==1)
								for (auto j=ny+r; j>=0 && j<YRES && j>=ny-rt && j<ny+rt; j+=r)
								{
									if ((TYP(pmap[j][nx])!=t || bmap[j/CELL][nx/CELL]) && do_move(i, nx, ny, (float)nx, (float)j))
										break;
									if (TYP(pmap[j][nx])!=t || (bmap[j/CELL][nx/CELL] && bmap[j/CELL][nx/CELL]!=WL_STREAM))
										break;
								}
							else if (s==-1) {} // particle is out of bounds
							else if ((clear_x!=x||clear_y!=y) && do_move(i, x, y, clear_xf, clear_yf)) {}
							else parts[i].flags |= FLAG_STAGNANT;
							parts[i].vx *= elements[t].Collision;
							parts[i].vy *= elements[t].Collision;
						}
						else if (elements[t].Falldown>1 && fabsf(pGravX*parts[i].vx+pGravY*parts[i].vy)>fabsf(pGravY*parts[i].vx-pGravX*parts[i].vy))
						{
							float nxf, nyf, prev_pGravX, prev_pGravY, ptGrav = elements[t].Gravity;
							auto s = 0;
							// stagnant is true if FLAG_STAGNANT was set for this particle in previous frame
							// nt is if there is something else besides the current particle type around the particle
							// 30 gives slightly less water lag, although it changes how it moves a lot
							auto rt = (!stagnant || nt) ? 30 : 10;

							// clear_xf, clear_yf is the last known position that the particle should almost certainly be able to move to
							nxf = clear_xf;
							nyf = clear_yf;
							auto nx = clear_x;
							auto ny = clear_y;
							// Look for spaces to move horizontally (perpendicular to gravity direction), keep going until a space is found or the number of positions examined = rt
							for (auto j=0;j<rt;j++)
							{
								// Calculate overall gravity direction
								GetGravityField(nx, ny, ptGrav, 1.0f, pGravX, pGravY);
								// Scale gravity vector so that the largest component is 1 pixel
								auto mv = std::max(fabsf(pGravX), fabsf(pGravY));
								if (mv<0.0001f) break;
								pGravX /= mv;
								pGravY /= mv;
								// Move 1 pixel perpendicularly to gravity
								// r is +1/-1, to try moving left or right at random
								if (j)
								{
									// Not quite the gravity direction
									// Gravity direction + last change in gravity direction
									// This makes liquid movement a bit less frothy, particularly for balls of liquid in radial gravity. With radial gravity, instead of just moving along a tangent, the attempted movement will follow the curvature a bit better.
									nxf += r*(pGravY*2.0f-prev_pGravY);
									nyf += -r*(pGravX*2.0f-prev_pGravX);
								}
								else
								{
									nxf += r*pGravY;
									nyf += -r*pGravX;
								}
								prev_pGravX = pGravX;
								prev_pGravY = pGravY;
								// Check whether movement is allowed
								nx = (int)(nxf+0.5f);
								ny = (int)(nyf+0.5f);
								if (nx<0 || ny<0 || nx>=XRES || ny >=YRES)
									break;
								if (TYP(pmap[ny][nx])!=t || bmap[ny/CELL][nx/CELL])
								{
									s = do_move(i, x, y, nxf, nyf);
									if (s)
									{
										// Movement was successful
										nx = (int)(parts[i].x+0.5f);
										ny = (int)(parts[i].y+0.5f);
										break;
									}
									// A particle of a different type, or a wall, was found. Stop trying to move any further horizontally unless the wall should be completely invisible to particles.
									if (TYP(pmap[ny][nx])!=t || bmap[ny/CELL][nx/CELL]!=WL_STREAM)
										break;
								}
							}
							if (s==1)
							{
								// The particle managed to move horizontally, now try to move vertically (parallel to gravity direction)
								// Keep going until the particle is blocked (by something that isn't the same element) or the number of positions examined = rt
								clear_x = nx;
								clear_y = ny;
								for (auto j=0;j<rt;j++)
								{
									// Calculate overall gravity direction
									GetGravityField(nx, ny, ptGrav, 1.0f, pGravX, pGravY);
									// Scale gravity vector so that the largest component is 1 pixel
									auto mv = std::max(fabsf(pGravX), fabsf(pGravY));
									if (mv<0.0001f) break;
									pGravX /= mv;
									pGravY /= mv;
									// Move 1 pixel in the direction of gravity
									nxf += pGravX;
									nyf += pGravY;
									nx = (int)(nxf+0.5f);
									ny = (int)(nyf+0.5f);
									if (nx<0 || ny<0 || nx>=XRES || ny>=YRES)
										break;
									// If the space is anything except the same element (a wall, empty space, or occupied by a particle of a different element), try to move into it
									if (TYP(pmap[ny][nx])!=t || bmap[ny/CELL][nx/CELL])
									{
										s = do_move(i, clear_x, clear_y, nxf, nyf);
										if (s || TYP(pmap[ny][nx])!=t || bmap[ny/CELL][nx/CELL]!=WL_STREAM)
											break; // found the edge of the liquid and movement into it succeeded, so stop moving down
									}
								}
							}
							else if (s==-1) {} // particle is out of bounds
							else if ((clear_x!=x||clear_y!=y) && do_move(i, x, y, clear_xf, clear_yf)) {} // try moving to the last clear position
							else parts[i].flags |= FLAG_STAGNANT;
							parts[i].vx *= elements[t].Collision;
							parts[i].vy *= elements[t].Collision;
						}
						else
						{
							// if interpolation was done, try moving to last clear position
							if ((clear_x!=x||clear_y!=y) && do_move(i, x, y, clear_xf, clear_yf)) {}
							else parts[i].flags |= FLAG_STAGNANT;
							parts[i].vx *= elements[t].Collision;
							parts[i].vy *= elements[t].Collision;
						}
					}
				}
			}
movedone:
			continue;
		}
	}

	//'f' was pressed (single frame)
	if (framerender)
	{
		framerender--;
	}
}

void Simulation::RecalcFreeParticles(bool do_life_dec)
{
	int x, y, t;
	int lastPartUsed = 0;
	int lastPartUnused = -1;

	memset(pmap, 0, sizeof(pmap));
	memset(pmap_count, 0, sizeof(pmap_count));
	memset(photons, 0, sizeof(photons));

	NUM_PARTS = 0;
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	//the particle loop that resets the pmap/photon maps every frame, to update them.
	for (int i = 0; i <= parts.lastActiveIndex; i++)
	{
		if (parts[i].type)
		{
			t = parts[i].type;
			x = (int)(parts[i].x+0.5f);
			y = (int)(parts[i].y+0.5f);
			bool inBounds = false;
			if (x>=0 && y>=0 && x<XRES && y<YRES)
			{
				if (elements[t].Properties & TYPE_ENERGY)
					photons[y][x] = PMAP(i, t);
				else
				{
					// Particles are sometimes allowed to go inside INVS and FILT
					// To make particles collide correctly when inside these elements, these elements must not overwrite an existing pmap entry from particles inside them
					if (!pmap[y][x] || (t!=PT_INVIS && t!= PT_FILT))
						pmap[y][x] = PMAP(i, t);
					// (there are a few exceptions, including energy particles - currently no limit on stacking those)
					if (t!=PT_THDR && t!=PT_EMBR && t!=PT_FIGH && t!=PT_PLSM)
						pmap_count[y][x]++;
				}
				inBounds = true;
			}
			lastPartUsed = i;
			NUM_PARTS ++;

			if (elementRecount && t >= 0 && t < PT_NUM && elements[t].Enabled)
				elementCount[t]++;

			//decrease particle life
			if (do_life_dec && (!sys_pause || framerender))
			{
				if (t<0 || t>=PT_NUM || !elements[t].Enabled)
				{
					kill_part(i);
					continue;
				}

				unsigned int elem_properties = elements[t].Properties;
				if (parts[i].life>0 && (elem_properties&PROP_LIFE_DEC) && !(inBounds && bmap[y/CELL][x/CELL] == WL_STASIS && emap[y/CELL][x/CELL]<8))
				{
					// automatically decrease life
					parts[i].life--;
					if (parts[i].life<=0 && (elem_properties&(PROP_LIFE_KILL_DEC|PROP_LIFE_KILL)))
					{
						// kill on change to no life
						kill_part(i);
						continue;
					}
				}
				else if (parts[i].life<=0 && (elem_properties&PROP_LIFE_KILL) && !(inBounds && bmap[y/CELL][x/CELL] == WL_STASIS && emap[y/CELL][x/CELL]<8))
				{
					// kill if no life
					kill_part(i);
					continue;
				}
			}
		}
		else
		{
			if (lastPartUnused<0) pfree = i;
			else parts[lastPartUnused].life = i;
			lastPartUnused = i;
		}
	}
	if (lastPartUnused == -1)
	{
		pfree = (parts.lastActiveIndex>=(NPART-1)) ? -1 : parts.lastActiveIndex+1;
	}
	else
	{
		parts[lastPartUnused].life = (parts.lastActiveIndex>=(NPART-1)) ? -1 : parts.lastActiveIndex+1;
	}
	parts.lastActiveIndex = lastPartUsed;
	if (elementRecount)
		elementRecount = false;
}

void Simulation::SimulateGoL()
{
	auto &builtinGol = SimulationData::builtinGol;
	CGOL = 0;
	for (int i = 0; i <= parts.lastActiveIndex; ++i)
	{
		auto &part = parts[i];
		if (part.type != PT_LIFE)
		{
			continue;
		}
		auto x = int(part.x + 0.5f);
		auto y = int(part.y + 0.5f);
		if (x < CELL || y < CELL || x >= XRES - CELL || y >= YRES - CELL)
		{
			continue;
		}
		unsigned int golnum = part.ctype;
		unsigned int ruleset = golnum;
		if (golnum < NGOL)
		{
			ruleset = builtinGol[golnum].ruleset;
			golnum += 1;
		}
		if (part.tmp2 == int((ruleset >> 17) & 0xF) + 1)
		{
			for (int yy = -1; yy <= 1; ++yy)
			{
				for (int xx = -1; xx <= 1; ++xx)
				{
					if (xx || yy)
					{
						// * Calculate address of the neighbourList, taking wraparound
						//   into account. The fact that the GOL space is 2 CELL's worth
						//   narrower in both dimensions than the simulation area makes
						//   this a bit awkward.
						int ax = ((x + xx + XRES - 3 * CELL) % (XRES - 2 * CELL)) + CELL;
						int ay = ((y + yy + YRES - 3 * CELL) % (YRES - 2 * CELL)) + CELL;
						if (pmap[ay][ax] && TYP(pmap[ay][ax]) != PT_LIFE)
						{
							continue;
						}
						unsigned int (&neighbourList)[5] = gol[ay][ax];
						// * Bump overall neighbour counter (bits 30..28) for the entire list.
						neighbourList[0] += 1U << 28;
						for (int l = 0; l < 5; ++l)
						{
							auto neighbourRuleset = neighbourList[l] & 0x001FFFFFU;
							if (neighbourRuleset == golnum)
							{
								// * Bump population counter (bits 23..21) of the
								//   same kind of cell.
								neighbourList[l] += 1U << 21;
								break;
							}
							if (neighbourRuleset == 0)
							{
								// * Add the new kind of cell to the population. Both counters
								//   have a bias of -1, so they're intentionally initialised
								//   to 0 instead of 1 here. This is all so they can both
								//   fit in 3 bits.
								neighbourList[l] = ((yy & 3) << 26) | ((xx & 3) << 24) | golnum;
								break;
							}
							// * If after 5 iterations the cell still hasn't contributed
							//   to a list entry, it's surely a 6th kind of cell, meaning
							//   there could be at most 3 of it in the neighbourhood,
							//   as there are already 5 other kinds of cells present in
							//   the list. This in turn means that it couldn't possibly
							//   win the population ratio-based contest later on.
						}
					}
				}
			}
		}
		else
		{
			if (!(bmap[y / CELL][x / CELL] == WL_STASIS && emap[y / CELL][x / CELL] < 8))
			{
				part.tmp2 -= 1;
			}
		}
	}
	for (int y = CELL; y < YRES - CELL; ++y)
	{
		for (int x = CELL; x < XRES - CELL; ++x)
		{
			int r = pmap[y][x];
			if (r && TYP(r) != PT_LIFE)
			{
				continue;
			}
			unsigned int (&neighbourList)[5] = gol[y][x];
			auto nl0 = neighbourList[0];
			if (r || nl0)
			{
				// * Get overall neighbour count (bits 30..28).
				unsigned int neighbours = nl0 ? ((nl0 >> 28) & 7) + 1 : 0;
				if (!(bmap[y / CELL][x / CELL] == WL_STASIS && emap[y / CELL][x / CELL] < 8))
				{
					if (r)
					{
						auto &part = parts[ID(r)];
						unsigned int ruleset = part.ctype;
						if (ruleset < NGOL)
						{
							ruleset = builtinGol[ruleset].ruleset;
						}
						if (!((ruleset >> neighbours) & 1) && part.tmp2 == int(ruleset >> 17) + 1)
						{
							// * Start death sequence.
							part.tmp2 -= 1;
						}
					}
					else
					{
						unsigned int golnumToCreate = 0xFFFFFFFFU;
						unsigned int createFromEntry = 0U;
						unsigned int majority = neighbours / 2 + neighbours % 2;
						for (int l = 0; l < 5; ++l)
						{
							auto golnum = neighbourList[l] & 0x001FFFFFU;
							if (!golnum)
							{
								break;
							}
							auto ruleset = golnum;
							if (golnum - 1 < NGOL)
							{
								ruleset = builtinGol[golnum - 1].ruleset;
								golnum -= 1;
							}
							if ((ruleset >> (neighbours + 8)) & 1 && ((neighbourList[l] >> 21) & 7) + 1 >= majority && golnum < golnumToCreate)
							{
								golnumToCreate = golnum;
								createFromEntry = neighbourList[l];
							}
						}
						if (golnumToCreate != 0xFFFFFFFFU)
						{
							// * 0x200000: No need to look for colours, they'll be set later anyway.
							int i = create_part(-1, x, y, PT_LIFE, golnumToCreate | 0x200000);
							if (i >= 0)
							{
								int xx = (createFromEntry >> 24) & 3;
								int yy = (createFromEntry >> 26) & 3;
								if (xx == 3) xx = -1;
								if (yy == 3) yy = -1;
								int ax = ((x - xx + XRES - 3 * CELL) % (XRES - 2 * CELL)) + CELL;
								int ay = ((y - yy + YRES - 3 * CELL) % (YRES - 2 * CELL)) + CELL;
								auto &sample = parts[ID(pmap[ay][ax])];
								parts[i].dcolour = sample.dcolour;
								parts[i].tmp = sample.tmp;
							}
						}
					}
				}
				for (int l = 0; l < 5 && neighbourList[l]; ++l)
				{
					neighbourList[l] = 0;
				}
			}
		}
	}
	for (int y = CELL; y < YRES - CELL; ++y)
	{
		for (int x = CELL; x < XRES - CELL; ++x)
		{
			int r = pmap[y][x];
			if (r && TYP(r) == PT_LIFE && parts[ID(r)].tmp2 <= 0)
			{
				kill_part(ID(r));
			}
		}
	}
}

void Simulation::CheckStacking()
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	bool excessive_stacking_found = false;
	force_stacking_check = false;
	for (int y = 0; y < YRES; y++)
	{
		for (int x = 0; x < XRES; x++)
		{
			// Use a threshold, since some particle stacking can be normal (e.g. BIZR + FILT)
			// Setting pmap_count[y][x] > NPART means BHOL will form in that spot
			if (pmap_count[y][x]>5)
			{
				if (bmap[y/CELL][x/CELL]==WL_EHOLE)
				{
					// Allow more stacking in E-hole
					if (pmap_count[y][x]>1500)
					{
						pmap_count[y][x] = pmap_count[y][x] + NPART;
						excessive_stacking_found = 1;
					}
				}
				else if (pmap_count[y][x]>1500 || (unsigned int)rng.between(0, 1599) <= (pmap_count[y][x]+100))
				{
					pmap_count[y][x] = pmap_count[y][x] + NPART;
					excessive_stacking_found = true;
				}
			}
		}
	}
	if (excessive_stacking_found)
	{
		for (int i = 0; i <= parts.lastActiveIndex; i++)
		{
			if (parts[i].type)
			{
				int t = parts[i].type;
				int x = (int)(parts[i].x+0.5f);
				int y = (int)(parts[i].y+0.5f);
				if (x>=0 && y>=0 && x<XRES && y<YRES && !(elements[t].Properties&TYPE_ENERGY))
				{
					if (pmap_count[y][x]>=NPART)
					{
						if (pmap_count[y][x]>NPART)
						{
							create_part(i, x, y, PT_NBHL);
							parts[i].temp = MAX_TEMP;
							parts[i].tmp = pmap_count[y][x]-NPART;//strength of grav field
							if (parts[i].tmp>51200) parts[i].tmp = 51200;
							pmap_count[y][x] = NPART;
						}
						else
						{
							kill_part(i);
						}
					}
				}
			}
		}
	}
}

void Simulation::UpdateGravityMask()
{
	for (auto p : CELLS.OriginRect())
	{
		gravIn.mask[p] = 0;
	}
	std::stack<Vec2<int>> toCheck;
	auto check = [this, &toCheck](Vec2<int> p) {
		if (!(bmap[p.Y][p.X] == WL_GRAV || gravIn.mask[p]))
		{
			gravIn.mask[p] = UINT32_C(0xFFFFFFFF);
			for (auto o : RectSized<int>({ -1, -1 }, { 3, 3 }))
			{
				if ((o.X + o.Y) & 1) // i.e. immediate neighbours but not diagonal ones
				{
					auto q = p + o;
					if (CELLS.OriginRect().Contains(q))
					{
						toCheck.push(q);
					}
				}
			}
		}
	};
	for (auto x = 0; x < CELLS.X; ++x)
	{
		check({ x, 0           });
		check({ x, CELLS.Y - 1 });
	}
	for (auto y = 1; y < CELLS.Y - 1; ++y) // corners already checked in the previous loop
	{
		check({ 0          , y });
		check({ CELLS.X - 1, y });
	}
	while (!toCheck.empty())
	{
		auto p = toCheck.top();
		toCheck.pop();
		check(p);
	}
}

//updates pmap, gol, and some other simulation stuff (but not particles)
void Simulation::BeforeSim()
{
	if (!sys_pause||framerender)
	{
		air->update_air();

		if(aheat_enable)
			air->update_airh();

		DispatchNewtonianGravity();
		// gravIn::mass is now potentially garbage, which is ok, we were going to clear it for the frame anyway
		for (auto p : gravIn.mass.Size().OriginRect())
		{
			gravIn.mass[p] = 0.f;
		}

		if(emp_decor>0)
			emp_decor -= emp_decor/25+2;
		if(emp_decor < 0)
			emp_decor = 0;
		etrd_count_valid = false;
		etrd_life0_count = 0;

		currentTick++;

		elementRecount |= !(currentTick%180);
		if (elementRecount)
			std::fill(elementCount, elementCount+PT_NUM, 0);
	}
	sandcolour_interface = (int)(20.0f*sin((float)sandcolour_frame*(TPT_PI_FLT/180.0f)));
	sandcolour_frame = (sandcolour_frame+1)%360;
	sandcolour = (int)(20.0f*sin((float)(frameCount)*(TPT_PI_FLT/180.0f)));

	if (gravWallChanged)
	{
		UpdateGravityMask();
		gravWallChanged = false;
	}

	if (debug_nextToUpdate == 0)
		RecalcFreeParticles(true);

	if (!sys_pause || framerender)
	{
		// decrease wall conduction, make walls block air and ambient heat
		for (int y = 0; y < YCELLS; y++)
		{
			for (int x = 0; x < XCELLS; x++)
			{
				if (emap[y][x])
					emap[y][x] --;
				air->bmap_blockair[y][x] = (bmap[y][x]==WL_WALL || bmap[y][x]==WL_WALLELEC || bmap[y][x]==WL_BLOCKAIR || (bmap[y][x]==WL_EWALL && !emap[y][x]));
				air->bmap_blockairh[y][x] = (air->bmap_blockair[y][x] || bmap[y][x]==WL_GRAV) ? 0x8 : 0;
			}
		}

		// check for stacking and create BHOL if found
		if (force_stacking_check || rng.chance(1, 10))
		{
			CheckStacking();
		}

		// LOVE and LOLZ element handling
		if (elementCount[PT_LOVE] > 0 || elementCount[PT_LOLZ] > 0)
		{
			int nx, nnx, ny, nny, r, rt;
			for (ny=0; ny<YRES-4; ny++)
			{
				for (nx=0; nx<XRES-4; nx++)
				{
					r=pmap[ny][nx];
					if (!r)
					{
						continue;
					}
					else if ((ny<9||nx<9||ny>YRES-7||nx>XRES-10)&&(parts[ID(r)].type==PT_LOVE||parts[ID(r)].type==PT_LOLZ))
						kill_part(ID(r));
					else if (parts[ID(r)].type==PT_LOVE)
					{
						Element_LOVE_love[nx/9][ny/9] = 1;
					}
					else if (parts[ID(r)].type==PT_LOLZ)
					{
						Element_LOLZ_lolz[nx/9][ny/9] = 1;
					}
				}
			}
			for (nx=9; nx<=XRES-18; nx++)
			{
				for (ny=9; ny<=YRES-7; ny++)
				{
					if (Element_LOVE_love[nx/9][ny/9]==1)
					{
						for ( nnx=0; nnx<9; nnx++)
							for ( nny=0; nny<9; nny++)
							{
								if (ny+nny>0&&ny+nny<YRES&&nx+nnx>=0&&nx+nnx<XRES)
								{
									rt=pmap[ny+nny][nx+nnx];
									if (!rt&&Element_LOVE_RuleTable[nnx][nny]==1)
										create_part(-1,nx+nnx,ny+nny,PT_LOVE);
									else if (!rt)
										continue;
									else if (parts[ID(rt)].type==PT_LOVE&&Element_LOVE_RuleTable[nnx][nny]==0)
										kill_part(ID(rt));
								}
							}
					}
					Element_LOVE_love[nx/9][ny/9]=0;
					if (Element_LOLZ_lolz[nx/9][ny/9]==1)
					{
						for ( nnx=0; nnx<9; nnx++)
							for ( nny=0; nny<9; nny++)
							{
								if (ny+nny>0&&ny+nny<YRES&&nx+nnx>=0&&nx+nnx<XRES)
								{
									rt=pmap[ny+nny][nx+nnx];
									if (!rt&&Element_LOLZ_RuleTable[nny][nnx]==1)
										create_part(-1,nx+nnx,ny+nny,PT_LOLZ);
									else if (!rt)
										continue;
									else if (parts[ID(rt)].type==PT_LOLZ&&Element_LOLZ_RuleTable[nny][nnx]==0)
										kill_part(ID(rt));

								}
							}
					}
					Element_LOLZ_lolz[nx/9][ny/9]=0;
				}
			}
		}

		// make WIRE work
		if(elementCount[PT_WIRE] > 0)
		{
			for (int nx = 0; nx < XRES; nx++)
			{
				for (int ny = 0; ny < YRES; ny++)
				{
					int r = pmap[ny][nx];
					if (!r)
						continue;
					if(parts[ID(r)].type == PT_WIRE)
						parts[ID(r)].tmp = parts[ID(r)].ctype;
				}
			}
		}

		// update PPIP tmp?
		if (Element_PPIP_ppip_changed)
		{
			for (int i = 0; i <= parts.lastActiveIndex; i++)
			{
				if (parts[i].type==PT_PPIP)
				{
					parts[i].tmp |= (parts[i].tmp&0xE0000000)>>3;
					parts[i].tmp &= ~0xE0000000;
				}
			}
			Element_PPIP_ppip_changed = 0;
		}

		// Simulate GoL
		// GSPEED is frames per generation
		if (elementCount[PT_LIFE]>0 && ++CGOL>=GSPEED)
		{
			SimulateGoL();
		}

		// wifi channel reseting
		if (ISWIRE > 0)
		{
			for (int q = 0; q < (int)(MAX_TEMP-73.15f)/100+2; q++)
			{
				wireless[q][0] = wireless[q][1];
				wireless[q][1] = 0;
			}
			ISWIRE--;
		}

		// spawn STKM and STK2
		if (!player.spwn && player.spawnID >= 0)
			create_part(-1, (int)parts[player.spawnID].x, (int)parts[player.spawnID].y, PT_STKM);
		if (!player2.spwn && player2.spawnID >= 0)
			create_part(-1, (int)parts[player2.spawnID].x, (int)parts[player2.spawnID].y, PT_STKM2);

		// particle update happens right after this function (called separately)
	}
}

void Simulation::AfterSim()
{
	debug_mostRecentlyUpdated = -1;

	if (emp_trigger_count)
	{
		// pitiful attempt at trying to keep code relating to a given element in the same file
		Element_EMP_Trigger(this, emp_trigger_count);
		emp_trigger_count = 0;
	}

	frameCount += 1;
}

Simulation::~Simulation() = default;

Simulation::Simulation()
{
	std::fill(elementCount, elementCount+PT_NUM, 0);
	elementRecount = true;

	//Create and attach air simulation
	air = std::make_unique<Air>(*this);

	player.comm = 0;
	player2.comm = 0;

	clear_sim();

	UpdateGravityMask();
}

void Simulation::DispatchNewtonianGravity()
{
	if (grav)
	{
		grav->Exchange(gravOut, gravIn, gravForceRecalc);
		gravForceRecalc = false;
	}
}

void Simulation::ResetNewtonianGravity(GravityInput newGravIn, GravityOutput newGravOut)
{
	gravIn = newGravIn;
	DispatchNewtonianGravity();
	// gravIn is now potentially garbage, set it again
	gravIn = newGravIn;
	if (grav)
	{
		gravOut = newGravOut;
		gravForceRecalc = true; // gravOut changed outside DispatchNewtonianGravity
		gravWallChanged = true;
	}
}

void Simulation::EnableNewtonianGravity(bool enable)
{
	if (grav && !enable)
	{
		grav.reset();
		gravOut = {}; // reset as per the invariant
		gravForceRecalc = true; // gravOut changed outside DispatchNewtonianGravity
	}
	if (!grav && enable)
	{
		grav = Gravity::Create();
		auto oldGravIn = gravIn;
		DispatchNewtonianGravity();
		// gravIn is now potentially garbage, set it again
		gravIn = std::move(oldGravIn);
	}
}

// we want XRES * YRES <= (1 << (31 - PMAPBITS)), but we do a division because multiplication could silently overflow
static_assert(uint32_t(XRES) <= (UINT32_C(1) << (31 - PMAPBITS)) / uint32_t(YRES), "not enough space in pmap");


=== src\simulation\Simulation.h ===

#pragma once
#include "Particle.h"
#include "Stickman.h"
#include "WallType.h"
#include "Sign.h"
#include "ElementDefs.h"
#include "BuiltinGOL.h"
#include "MenuSection.h"
#include "AccessProperty.h"
#include "CoordStack.h"
#include "common/tpt-rand.h"
#include "gravity/Gravity.h"
#include "graphics/RendererFrame.h"
#include "Element.h"
#include "SimulationConfig.h"
#include "SimulationSettings.h"
#include <cstring>
#include <cstddef>
#include <vector>
#include <array>
#include <memory>
#include <optional>

constexpr int CHANNELS = int(MAX_TEMP - 73) / 100 + 2;

class Snapshot;
class Brush;
struct SimulationSample;
struct matrix2d;
struct vector2d;

class Simulation;
class Renderer;
class Air;
class GameSave;

struct Parts
{
	std::array<Particle, NPART> data;
	// initialized in clear_sim
	int lastActiveIndex;

	operator const Particle *() const
	{
		return data.data();
	}

	operator Particle *()
	{
		return data.data();
	}

	Parts()
	{
		Reset();
	}

	Parts(const Parts &other) = default;

	Parts &operator =(const Parts &other)
	{
		std::copy(other.data.begin(), other.data.begin() + other.lastActiveIndex + 1, data.begin());
		lastActiveIndex = other.lastActiveIndex;
		return *this;
	}

	void Reset();
};

struct RenderableSimulation
{
	GravityInput gravIn;
	GravityOutput gravOut; // invariant: when grav is empty, this is in its default-constructed state
	bool gravForceRecalc = true;
	std::vector<sign> signs;

	int currentTick = 0;
	int emp_decor = 0;

	playerst player;
	playerst player2;
	playerst fighters[MAX_FIGHTERS]; //Defined in Stickman.h

	float vx[YCELLS][XCELLS];
	float vy[YCELLS][XCELLS];
	float pv[YCELLS][XCELLS];
	float hv[YCELLS][XCELLS];

	unsigned char bmap[YCELLS][XCELLS];
	unsigned char emap[YCELLS][XCELLS];

	Parts parts;
	int pmap[YRES][XRES];
	int photons[YRES][XRES];

	int aheat_enable = 0;

	bool useLuaCallbacks = false;
};

class Simulation : public RenderableSimulation
{
public:
	GravityPtr grav;
	std::unique_ptr<Air> air;

	RNG rng;

	int replaceModeSelected = 0;
	int replaceModeFlags = 0;
	int debug_nextToUpdate = 0;
	int debug_mostRecentlyUpdated = -1; // -1 when between full update loops
	int elementCount[PT_NUM];
	int ISWIRE = 0;
	bool force_stacking_check = false;
	int emp_trigger_count = 0;
	bool etrd_count_valid = false;
	int etrd_life0_count = 0;
	int lightningRecreate = 0;
	bool gravWallChanged = false;

	Particle portalp[CHANNELS][8][80];
	int wireless[CHANNELS][2];

	int CGOL = 0;
	int GSPEED = 1;
	unsigned int gol[YRES][XRES][5];

	float fvx[YCELLS][XCELLS];
	float fvy[YCELLS][XCELLS];

	unsigned int pmap_count[YRES][XRES];

	int edgeMode = EDGE_VOID;
	int gravityMode = GRAV_VERTICAL;
	float customGravityX = 0;
	float customGravityY = 0;
	int legacy_enable = 0;
	int water_equal_test = 0;
	int sys_pause = 0;
	int framerender = 0;
	int pretty_powder = 0;
	int sandcolour_frame = 0;
	int deco_space = DECOSPACE_SRGB;

	// initialized in clear_sim
	bool elementRecount;
	unsigned char fighcount; //Contains the number of fighters
	uint64_t frameCount;
	bool ensureDeterminism;

	// initialized very late >_>
	int NUM_PARTS;
	int sandcolour;
	int sandcolour_interface;

	void Load(const GameSave *save, bool includePressure, Vec2<int> blockP); // block coordinates
	std::unique_ptr<GameSave> Save(bool includePressure, Rect<int> partR); // particle coordinates
	void SaveSimOptions(GameSave &gameSave);
	SimulationSample GetSample(int x, int y);

	std::unique_ptr<Snapshot> CreateSnapshot() const;
	void Restore(const Snapshot &snap);

	int is_blocking(int t, int x, int y) const;
	int is_boundary(int pt, int x, int y) const;
	int find_next_boundary(int pt, int *x, int *y, int dm, int *em, bool reverse) const;
	void photoelectric_effect(int nx, int ny);
	int do_move(int i, int x, int y, float nxf, float nyf);
	bool move(int i, int x, int y, float nxf, float nyf);
	int try_move(int i, int x, int y, int nx, int ny);
	int eval_move(int pt, int nx, int ny, unsigned *rr) const;

	struct PlanMoveResult
	{
		int fin_x, fin_y, clear_x, clear_y;
		float fin_xf, fin_yf, clear_xf, clear_yf;
		float vx, vy;
	};
	template<bool UpdateEmap, class Sim>
	static PlanMoveResult PlanMove(Sim &sim, int i, int x, int y);

	bool IsWallBlocking(int x, int y, int type) const;
	void create_cherenkov_photon(int pp);
	void create_gain_photon(int pp);
	void kill_part(int i);
	bool FloodFillPmapCheck(int x, int y, int type) const;
	int flood_prop(int x, int y, const AccessProperty &changeProperty);
	bool flood_water(int x, int y, int i);
	int FloodINST(int x, int y);
	void detach(int i);
	bool part_change_type(int i, int x, int y, int t);
	//int InCurrentBrush(int i, int j, int rx, int ry);
	//int get_brush_flags();
	int create_part(int p, int x, int y, int t, int v = -1);
	void delete_part(int x, int y);
	void get_sign_pos(int i, int *x0, int *y0, int *w, int *h);
	int is_wire(int x, int y);
	int is_wire_off(int x, int y);
	void set_emap(int x, int y);
	int parts_avg(int ci, int ni, int t);
	bool IsHeatInsulator(Particle) const;
	void UpdateParticles(int start, int end); // Dispatches an update to the range [start, end).
	void SimulateGoL();
	void RecalcFreeParticles(bool do_life_dec);
	void CheckStacking();
	void BeforeSim();
	void AfterSim();
	void clear_area(int area_x, int area_y, int area_w, int area_h);

	void SetEdgeMode(int newEdgeMode);
	void SetDecoSpace(int newDecoSpace);

	//Drawing Deco
	void ApplyDecoration(int x, int y, int colR, int colG, int colB, int colA, int mode);
	void ApplyDecorationPoint(int x, int y, int colR, int colG, int colB, int colA, int mode, Brush const &cBrush);
	void ApplyDecorationLine(int x1, int y1, int x2, int y2, int colR, int colG, int colB, int colA, int mode, Brush const &cBrush);
	void ApplyDecorationBox(int x1, int y1, int x2, int y2, int colR, int colG, int colB, int colA, int mode);
	bool ColorCompare(const RendererFrame &frame, int x, int y, int replaceR, int replaceG, int replaceB);
	void ApplyDecorationFill(const RendererFrame &frame, int x, int y, int colR, int colG, int colB, int colA, int replaceR, int replaceG, int replaceB);

	//Drawing Walls
	int CreateWalls(int x, int y, int rx, int ry, int wall, Brush const *cBrush);
	void CreateWallLine(int x1, int y1, int x2, int y2, int rx, int ry, int wall, Brush const *cBrush);
	void CreateWallBox(int x1, int y1, int x2, int y2, int wall);
	int FloodWalls(int x, int y, int wall, int bm);

	//Drawing Particles
	int CreateParts(int p, int positionX, int positionY, int c, Brush const &cBrush, int flags);
	int CreateParts(int p, int x, int y, int rx, int ry, int c, int flags);
	int CreatePartFlags(int p, int x, int y, int c, int flags);
	void CreateLine(int x1, int y1, int x2, int y2, int c, Brush const &cBrush, int flags);
	void CreateLine(int x1, int y1, int x2, int y2, int c);
	void CreateBox(int p, int x1, int y1, int x2, int y2, int c, int flags);
	int FloodParts(int x, int y, int c, int cm, int flags);

	void GetGravityField(int x, int y, float particleGrav, float newtonGrav, float & pGravX, float & pGravY);

	int get_wavelength_bin(int *wm);
	struct GetNormalResult
	{
		bool success;
		float nx, ny;
		int lx, ly, rx, ry;
	};
	GetNormalResult get_normal(int pt, int x, int y, float dx, float dy) const;
	template<bool PhotoelectricEffect, class Sim>
	static GetNormalResult get_normal_interp(Sim &sim, int pt, float x0, float y0, float dx, float dy);
	void clear_sim();
	Simulation();
	~Simulation();

	void EnableNewtonianGravity(bool enable);

	bool MaxPartsReached() const
	{
		return pfree == -1;
	}

private:
	CoordStack& getCoordStackSingleton();

	void ResetNewtonianGravity(GravityInput newGravIn, GravityOutput newGravOut);
	void DispatchNewtonianGravity();
	void UpdateGravityMask();

	int pfree;
};


=== src\simulation\SimulationData.cpp ===

#include "SimulationData.h"
#include "ElementGraphics.h"
#include "ElementDefs.h"
#include "ElementClasses.h"
#include "GOLString.h"
#include "BuiltinGOL.h"
#include "WallType.h"
#include "MenuSection.h"
#include "Misc.h"
#include "graphics/Renderer.h"

const std::array<BuiltinGOL, NGOL> SimulationData::builtinGol = {{
	// * Ruleset:
	//   * bits x = 8..0: stay if x neighbours present
	//   * bits x = 16..9: begin if x-8 neighbours present
	//   * bits 20..17: 4-bit unsigned int encoding the number of states minus 2; 2 states is
	//     encoded as 0, 3 states as 1, etc.
	//   * states are kind of long until a cell dies; normal ones use two states (living and dead),
	//     for others the intermediate states live but do nothing
	//   * the ruleset constants below look 20-bit, but rulesets actually consist of 21
	//     bits of data; bit 20 just happens to not be set for any of the built-in types,
	//     as none of them have 10 or more states
	{ "GOL",  GT_GOL , 0x0080C, 0x0CAC00_rgb, 0x0CAC00_rgb, NGT_GOL,  String("Game Of Life: Begin 3/Stay 23") },
	{ "HLIF", GT_HLIF, 0x0480C, 0xFF0000_rgb, 0xFF0000_rgb, NGT_HLIF, String("High Life: B36/S23") },
	{ "ASIM", GT_ASIM, 0x038F0, 0x0000FF_rgb, 0x0000FF_rgb, NGT_ASIM, String("Assimilation: B345/S4567") },
	{ "2X2",  GT_2x2 , 0x04826, 0xFFFF00_rgb, 0xFFFF00_rgb, NGT_2x2,  String("2X2: B36/S125") },
	{ "DANI", GT_DANI, 0x1C9D8, 0x00FFFF_rgb, 0x00FFFF_rgb, NGT_DANI, String("Day and Night: B3678/S34678") },
	{ "AMOE", GT_AMOE, 0x0A92A, 0xFF00FF_rgb, 0xFF00FF_rgb, NGT_AMOE, String("Amoeba: B357/S1358") },
	{ "MOVE", GT_MOVE, 0x14834, 0xFFFFFF_rgb, 0xFFFFFF_rgb, NGT_MOVE, String("'Move' particles. Does not move things.. it is a life type: B368/S245") },
	{ "PGOL", GT_PGOL, 0x0A90C, 0xE05010_rgb, 0xE05010_rgb, NGT_PGOL, String("Pseudo Life: B357/S238") },
	{ "DMOE", GT_DMOE, 0x1E9E0, 0x500000_rgb, 0x500000_rgb, NGT_DMOE, String("Diamoeba: B35678/S5678") },
	{ "3-4",  GT_34  , 0x01818, 0x500050_rgb, 0x500050_rgb, NGT_34,   String("3-4: B34/S34") },
	{ "LLIF", GT_LLIF, 0x03820, 0x505050_rgb, 0x505050_rgb, NGT_LLIF, String("Long Life: B345/S5") },
	{ "STAN", GT_STAN, 0x1C9EC, 0x5000FF_rgb, 0x5000FF_rgb, NGT_STAN, String("Stains: B3678/S235678") },
	{ "SEED", GT_SEED, 0x00400, 0xFBEC7D_rgb, 0xFBEC7D_rgb, NGT_SEED, String("Seeds: B2/S") },
	{ "MAZE", GT_MAZE, 0x0083E, 0xA8E4A0_rgb, 0xA8E4A0_rgb, NGT_MAZE, String("Maze: B3/S12345") },
	{ "COAG", GT_COAG, 0x189EC, 0x9ACD32_rgb, 0x9ACD32_rgb, NGT_COAG, String("Coagulations: B378/S235678") },
	{ "WALL", GT_WALL, 0x1F03C, 0x0047AB_rgb, 0x0047AB_rgb, NGT_WALL, String("Walled cities: B45678/S2345") },
	{ "GNAR", GT_GNAR, 0x00202, 0xE5B73B_rgb, 0xE5B73B_rgb, NGT_GNAR, String("Gnarl: B1/S1") },
	{ "REPL", GT_REPL, 0x0AAAA, 0x259588_rgb, 0x259588_rgb, NGT_REPL, String("Replicator: B1357/S1357") },
	{ "MYST", GT_MYST, 0x139E1, 0x0C3C00_rgb, 0x0C3C00_rgb, NGT_MYST, String("Mystery: B3458/S05678") },
	{ "LOTE", GT_LOTE, 0x48938, 0xFF0000_rgb, 0xFFFF00_rgb, NGT_LOTE, String("Living on the Edge: B37/S3458/4") },
	{ "FRG2", GT_FRG2, 0x20816, 0x006432_rgb, 0x00FF5A_rgb, NGT_FRG2, String("Like Frogs rule: B3/S124/3") },
	{ "STAR", GT_STAR, 0x98478, 0x000040_rgb, 0x0000E6_rgb, NGT_STAR, String("Like Star Wars rule: B278/S3456/6") },
	{ "FROG", GT_FROG, 0x21806, 0x006400_rgb, 0x00FF00_rgb, NGT_FROG, String("Frogs: B34/S12/3") },
	{ "BRAN", GT_BRAN, 0x25440, 0xFFFF00_rgb, 0x969600_rgb, NGT_BRAN, String("Brian 6: B246/S6/3" )}
}};

static std::vector<wall_type> LoadWalls()
{
	return
	std::vector<wall_type>{
		{0x808080_rgb, 0x000000_rgb, 0, Renderer::WallIcon, String("ERASE"),           "DEFAULT_WL_ERASE",  String("Erases walls.")},
		{0xC0C0C0_rgb, 0x101010_rgb, 0, Renderer::WallIcon, String("CONDUCTIVE WALL"), "DEFAULT_WL_CNDTW",  String("Blocks everything. Conductive.")},
		{0x808080_rgb, 0x808080_rgb, 0, Renderer::WallIcon, String("EWALL"),           "DEFAULT_WL_EWALL",  String("E-Wall. Becomes transparent when electricity is connected.")},
		{0xFF8080_rgb, 0xFF2008_rgb, 1, Renderer::WallIcon, String("DETECTOR"),        "DEFAULT_WL_DTECT",  String("Detector. Generates electricity when a particle is inside.")},
		{0x808080_rgb, 0x000000_rgb, 0, Renderer::WallIcon, String("STREAMLINE"),      "DEFAULT_WL_STRM",   String("Streamline. Creates a line that follows air movement.")},
		{0x8080FF_rgb, 0x000000_rgb, 1, Renderer::WallIcon, String("FAN"),             "DEFAULT_WL_FAN",    String("Fan. Accelerates air. Use the line tool to set direction and strength.")},
		{0xC0C0C0_rgb, 0x101010_rgb, 2, Renderer::WallIcon, String("LIQUID WALL"),     "DEFAULT_WL_LIQD",   String("Allows liquids, blocks all other particles. Conductive.")},
		{0x808080_rgb, 0x000000_rgb, 1, Renderer::WallIcon, String("ABSORB WALL"),     "DEFAULT_WL_ABSRB",  String("Absorbs particles but lets air currents through.")},
		{0x808080_rgb, 0x000000_rgb, 3, Renderer::WallIcon, String("WALL"),            "DEFAULT_WL_WALL",   String("Basic wall, blocks everything.")},
		{0x3C3C3C_rgb, 0x000000_rgb, 1, Renderer::WallIcon, String("AIRONLY WALL"),    "DEFAULT_WL_AIR",    String("Allows air, but blocks all particles.")},
		{0x575757_rgb, 0x000000_rgb, 1, Renderer::WallIcon, String("POWDER WALL"),     "DEFAULT_WL_POWDR",  String("Allows powders, blocks all other particles.")},
		{0xFFFF22_rgb, 0x101010_rgb, 2, Renderer::WallIcon, String("CONDUCTOR"),       "DEFAULT_WL_CNDTR",  String("Conductor. Allows all particles to pass through and conducts electricity.")},
		{0x242424_rgb, 0x101010_rgb, 0, Renderer::WallIcon, String("EHOLE"),           "DEFAULT_WL_EHOLE",  String("E-Hole. absorbs particles, releases them when powered.")},
		{0x579777_rgb, 0x000000_rgb, 1, Renderer::WallIcon, String("GAS WALL"),        "DEFAULT_WL_GAS",    String("Allows gases, blocks all other particles.")},
		{0xFFEE00_rgb, 0xAA9900_rgb, 4, Renderer::WallIcon, String("GRAVITY WALL"),    "DEFAULT_WL_GRVTY",  String("Gravity wall. Newtonian Gravity has no effect inside a box drawn with this.")},
		{0xFFAA00_rgb, 0xAA5500_rgb, 4, Renderer::WallIcon, String("ENERGY WALL"),     "DEFAULT_WL_ENRGY",  String("Allows energy particles, blocks all other particles.")},
		{0xDCDCDC_rgb, 0x000000_rgb, 1, Renderer::WallIcon, String("AIRBLOCK WALL"),   "DEFAULT_WL_NOAIR",  String("Allows all particles, but blocks air.")},
		{0x808080_rgb, 0x000000_rgb, 0, Renderer::WallIcon, String("ERASEALL"),        "DEFAULT_WL_ERASEA", String("Erases walls, particles, and signs.")},
		{0x800080_rgb, 0x000000_rgb, 0, Renderer::WallIcon, String("STASIS WALL"),     "DEFAULT_WL_STASIS", String("Freezes particles inside the wall in place until powered.")},
	};
}

static std::vector<menu_section> LoadMenus()
{
	return
	std::vector<menu_section>{
		{0xE041, String("Walls"), 0, 1},
		{0xE042, String("Electronics"), 0, 1},
		{0xE056, String("Powered Materials"), 0, 1},
		{0xE019, String("Sensors"), 0, 1},
		{0xE062, String("Force"), 0, 1},
		{0xE043, String("Explosives"), 0, 1},
		{0xE045, String("Gases"), 0, 1},
		{0xE044, String("Liquids"), 0, 1},
		{0xE050, String("Powders"), 0, 1},
		{0xE051, String("Solids"), 0, 1},
		{0xE046, String("Radioactive"), 0, 1},
		{0xE04C, String("Special"), 0, 1},
		{0xE052, String("Game Of Life"), 0, 1},
		{0xE057, String("Tools"), 0, 1},
		{0xE067, String("Favorites"), 0, 1},
		{0xE064, String("Decoration tools"), 0, 1},
	};
}

void SimulationData::init_can_move()
{
	int movingType, destinationType;
	// can_move[moving type][type at destination]
	//  0 = No move/Bounce
	//  1 = Swap
	//  2 = Both particles occupy the same space.
	//  3 = Varies, go run some extra checks

	//particles that don't exist shouldn't move...
	for (destinationType = 0; destinationType < PT_NUM; destinationType++)
		can_move[0][destinationType] = 0;

	//initialize everything else to swapping by default
	for (movingType = 1; movingType < PT_NUM; movingType++)
		for (destinationType = 0; destinationType < PT_NUM; destinationType++)
			can_move[movingType][destinationType] = 1;

	//photons go through everything by default
	for (destinationType = 1; destinationType < PT_NUM; destinationType++)
		can_move[PT_PHOT][destinationType] = 2;

	for (movingType = 1; movingType < PT_NUM; movingType++)
	{
		for (destinationType = 1; destinationType < PT_NUM; destinationType++)
		{
			//weight check, also prevents particles of same type displacing each other
			if (elements[movingType].Weight <= elements[destinationType].Weight || destinationType == PT_GEL)
				can_move[movingType][destinationType] = 0;

			//other checks for NEUT and energy particles
			if (movingType == PT_NEUT && (elements[destinationType].Properties&PROP_NEUTPASS))
				can_move[movingType][destinationType] = 2;
			if (movingType == PT_NEUT && (elements[destinationType].Properties&PROP_NEUTABSORB))
				can_move[movingType][destinationType] = 1;
			if (movingType == PT_NEUT && (elements[destinationType].Properties&PROP_NEUTPENETRATE))
				can_move[movingType][destinationType] = 1;
			if (destinationType == PT_NEUT && (elements[movingType].Properties&PROP_NEUTPENETRATE))
				can_move[movingType][destinationType] = 0;
			if ((elements[movingType].Properties&TYPE_ENERGY) && (elements[destinationType].Properties&TYPE_ENERGY))
				can_move[movingType][destinationType] = 2;
		}
	}
	for (destinationType = 0; destinationType < PT_NUM; destinationType++)
	{
		//set what stickmen can move through
		int stkm_move = 0;
		if (elements[destinationType].Properties & (TYPE_LIQUID | TYPE_GAS))
			stkm_move = 2;
		if (!destinationType || destinationType == PT_PRTO || destinationType == PT_SPAWN || destinationType == PT_SPAWN2)
			stkm_move = 2;
		can_move[PT_STKM][destinationType] = stkm_move;
		can_move[PT_STKM2][destinationType] = stkm_move;
		can_move[PT_FIGH][destinationType] = stkm_move;

		//spark shouldn't move
		can_move[PT_SPRK][destinationType] = 0;
	}
	for (movingType = 1; movingType < PT_NUM; movingType++)
	{
		//everything "swaps" with VACU and BHOL to make them eat things
		can_move[movingType][PT_BHOL] = 1;
		can_move[movingType][PT_NBHL] = 1;
		//nothing goes through stickmen
		can_move[movingType][PT_STKM] = 0;
		can_move[movingType][PT_STKM2] = 0;
		can_move[movingType][PT_FIGH] = 0;
		//INVS behaviour varies with pressure
		can_move[movingType][PT_INVIS] = 3;
		//stop CNCT from being displaced by other particles
		can_move[movingType][PT_CNCT] = 0;
		//VOID and PVOD behaviour varies with powered state and ctype
		can_move[movingType][PT_PVOD] = 3;
		can_move[movingType][PT_VOID] = 3;
		//nothing moves through EMBR (not sure why, but it's killed when it touches anything)
		can_move[movingType][PT_EMBR] = 0;
		can_move[PT_EMBR][movingType] = 0;
		//Energy particles move through VIBR and BVBR, so it can absorb them
		if (elements[movingType].Properties & TYPE_ENERGY)
		{
			can_move[movingType][PT_VIBR] = 1;
			can_move[movingType][PT_BVBR] = 1;
		}

		//SAWD cannot be displaced by other powders
		if (elements[movingType].Properties & TYPE_PART)
			can_move[movingType][PT_SAWD] = 0;
	}

	for (destinationType = 0; destinationType < PT_NUM; destinationType++)
	{
		//a list of lots of things PHOT can move through
		if (elements[destinationType].Properties & PROP_PHOTPASS)
			can_move[PT_PHOT][destinationType] = 2;

		//Things PROT and GRVT cannot move through
		if (destinationType != PT_DMND && destinationType != PT_INSL && destinationType != PT_VOID && destinationType != PT_PVOD && destinationType != PT_VIBR && destinationType != PT_BVBR && destinationType != PT_PRTI && destinationType != PT_PRTO)
		{
			can_move[PT_PROT][destinationType] = 2;
			can_move[PT_GRVT][destinationType] = 2;
		}
	}

	//other special cases that weren't covered above
	can_move[PT_DEST][PT_DMND] = 0;
	can_move[PT_DEST][PT_CLNE] = 0;
	can_move[PT_DEST][PT_PCLN] = 0;
	can_move[PT_DEST][PT_BCLN] = 0;
	can_move[PT_DEST][PT_PBCN] = 0;
	can_move[PT_DEST][PT_ROCK] = 0;

	can_move[PT_NEUT][PT_INVIS] = 2;
	can_move[PT_ELEC][PT_LCRY] = 2;
	can_move[PT_ELEC][PT_EXOT] = 2;
	can_move[PT_ELEC][PT_GLOW] = 2;
	can_move[PT_PHOT][PT_LCRY] = 3; //varies according to LCRY life
	can_move[PT_PHOT][PT_GPMP] = 3;

	can_move[PT_PHOT][PT_BIZR] = 2;
	can_move[PT_ELEC][PT_BIZR] = 2;
	can_move[PT_PHOT][PT_BIZRG] = 2;
	can_move[PT_ELEC][PT_BIZRG] = 2;
	can_move[PT_PHOT][PT_BIZRS] = 2;
	can_move[PT_ELEC][PT_BIZRS] = 2;
	can_move[PT_BIZR][PT_FILT] = 2;
	can_move[PT_BIZRG][PT_FILT] = 2;

	can_move[PT_ANAR][PT_WHOL] = 1; //WHOL eats ANAR
	can_move[PT_ANAR][PT_NWHL] = 1;
	can_move[PT_ELEC][PT_DEUT] = 1;
	can_move[PT_THDR][PT_THDR] = 2;
	can_move[PT_EMBR][PT_EMBR] = 2;
	can_move[PT_TRON][PT_SWCH] = 3;
	can_move[PT_ELEC][PT_RSST] = 2;
	can_move[PT_ELEC][PT_RSSS] = 2;
}

const CustomGOLData *SimulationData::GetCustomGOLByRule(int rule) const
{
	// * Binary search. customGol is already sorted, see SetCustomGOL.
	auto it = std::lower_bound(customGol.begin(), customGol.end(), rule, [](const CustomGOLData &item, int rule) {
		return item.rule < rule;
	});
	if (it != customGol.end() && !(rule < it->rule))
	{
		return &*it;
	}
	return nullptr;
}

void SimulationData::SetCustomGOL(std::vector<CustomGOLData> newCustomGol)
{
	std::sort(newCustomGol.begin(), newCustomGol.end());
	customGol = newCustomGol;
}

String SimulationData::ElementResolve(int type, int ctype) const
{
	if (type == PT_LIFE)
	{
		if (ctype >= 0 && ctype < NGOL)
		{
			return builtinGol[ctype].name; 
		}
		auto *cgol = GetCustomGOLByRule(ctype);
		if (cgol)
		{
			return cgol->nameString;
		}
		return SerialiseGOLRule(ctype);
	}
	else if (type >= 0 && type < PT_NUM)
		return elements[type].Name;
	return "Empty";
}

String SimulationData::BasicParticleInfo(Particle const &sample_part) const
{
	StringBuilder sampleInfo;
	int type = sample_part.type;
	int ctype = sample_part.ctype;
	int storedCtype = sample_part.tmp4;
	if (type == PT_LAVA && IsElement(ctype))
	{
		sampleInfo << "Molten " << ElementResolve(ctype, -1);
	}
	else if ((type == PT_PIPE || type == PT_PPIP) && IsElement(ctype))
	{
		if (ctype == PT_LAVA && IsElement(storedCtype))
		{
			sampleInfo << ElementResolve(type, -1) << " with molten " << ElementResolve(storedCtype, -1);
		}
		else
		{
			sampleInfo << ElementResolve(type, -1) << " with " << ElementResolve(ctype, storedCtype);
		}
	}
	else
	{
		sampleInfo << ElementResolve(type, ctype);
	}
	return sampleInfo.Build();
}

int SimulationData::GetParticleType(ByteString type) const
{
	type = type.ToUpper();

	// alternative names for some elements
	if (byteStringEqualsLiteral(type, "C4"))
	{
		return PT_PLEX;
	}
	else if (byteStringEqualsLiteral(type, "C5"))
	{
		return PT_C5;
	}
	else if (byteStringEqualsLiteral(type, "NONE"))
	{
		return PT_NONE;
	}
	for (int i = 1; i < PT_NUM; i++)
	{
		if (elements[i].Name.size() && elements[i].Enabled && type == elements[i].Name.ToUtf8().ToUpper())
		{
			return i;
		}
	}
	return -1;
}

SimulationData::SimulationData()
{
	msections = LoadMenus();
	wtypes = LoadWalls();
	elements = GetElements();
	init_can_move();
}


=== src\simulation\SimulationData.h ===

#pragma once
#include "SimulationConfig.h"
#include "ElementDefs.h"
#include "common/ExplicitSingleton.h"
#include "common/String.h"
#include "MenuSection.h"
#include "BuiltinGOL.h"
#include "Element.h"
#include "Particle.h"
#include "WallType.h"
#include "graphics/gcache_item.h"
#include "CustomGOLData.h"
#include <cstdint>
#include <vector>
#include <array>
#include <shared_mutex>

constexpr int O_WL_WALLELEC     = 122;
constexpr int O_WL_EWALL        = 123;
constexpr int O_WL_DETECT       = 124;
constexpr int O_WL_STREAM       = 125;
constexpr int O_WL_SIGN         = 126;
constexpr int O_WL_FAN          = 127;
constexpr int O_WL_FANHELPER    = 255;
constexpr int O_WL_ALLOWLIQUID  = 128;
constexpr int O_WL_DESTROYALL   = 129;
constexpr int O_WL_ERASE        = 130;
constexpr int O_WL_WALL         = 131;
constexpr int O_WL_ALLOWAIR     = 132;
constexpr int O_WL_ALLOWSOLID   = 133;
constexpr int O_WL_ALLOWALLELEC = 134;
constexpr int O_WL_EHOLE        = 135;
constexpr int O_WL_ALLOWGAS     = 140;
constexpr int O_WL_GRAV         = 142;
constexpr int O_WL_ALLOWENERGY  = 145;

constexpr int WL_ERASE        =  0;
constexpr int WL_WALLELEC     =  1;
constexpr int WL_EWALL        =  2;
constexpr int WL_DETECT       =  3;
constexpr int WL_STREAM       =  4;
constexpr int WL_FAN          =  5;
constexpr int WL_ALLOWLIQUID  =  6;
constexpr int WL_DESTROYALL   =  7;
constexpr int WL_WALL         =  8;
constexpr int WL_ALLOWAIR     =  9;
constexpr int WL_ALLOWPOWDER  = 10;
constexpr int WL_ALLOWALLELEC = 11;
constexpr int WL_EHOLE        = 12;
constexpr int WL_ALLOWGAS     = 13;
constexpr int WL_GRAV         = 14;
constexpr int WL_ALLOWENERGY  = 15;
constexpr int WL_BLOCKAIR     = 16;
constexpr int WL_ERASEALL     = 17;
constexpr int WL_STASIS       = 18;
constexpr int WL_FLOODHELPER  =255;

constexpr int UI_WALLCOUNT = 19;

constexpr int OLD_SPC_AIR = 236;
constexpr int SPC_AIR     = 256;

constexpr int DECO_DRAW     = 0;
constexpr int DECO_CLEAR    = 1;
constexpr int DECO_ADD      = 2;
constexpr int DECO_SUBTRACT = 3;
constexpr int DECO_MULTIPLY = 4;
constexpr int DECO_DIVIDE   = 5;
constexpr int DECO_SMUDGE   = 6;

//Old IDs for GOL types
constexpr int GT_GOL  =  78;
constexpr int GT_HLIF =  79;
constexpr int GT_ASIM =  80;
constexpr int GT_2x2  =  81;
constexpr int GT_DANI =  82;
constexpr int GT_AMOE =  83;
constexpr int GT_MOVE =  84;
constexpr int GT_PGOL =  85;
constexpr int GT_DMOE =  86;
constexpr int GT_34   =  87;
constexpr int GT_LLIF =  88;
constexpr int GT_STAN =  89;
constexpr int GT_SEED = 134;
constexpr int GT_MAZE = 135;
constexpr int GT_COAG = 136;
constexpr int GT_WALL = 137;
constexpr int GT_GNAR = 138;
constexpr int GT_REPL = 139;
constexpr int GT_MYST = 140;
constexpr int GT_LOTE = 142;
constexpr int GT_FRG2 = 143;
constexpr int GT_STAR = 144;
constexpr int GT_FROG = 145;
constexpr int GT_BRAN = 146;

//New IDs for GOL types
constexpr int NGT_GOL  =  0;
constexpr int NGT_HLIF =  1;
constexpr int NGT_ASIM =  2;
constexpr int NGT_2x2  =  3;
constexpr int NGT_DANI =  4;
constexpr int NGT_AMOE =  5;
constexpr int NGT_MOVE =  6;
constexpr int NGT_PGOL =  7;
constexpr int NGT_DMOE =  8;
constexpr int NGT_34   =  9;
constexpr int NGT_LLIF = 10;
constexpr int NGT_STAN = 11;
constexpr int NGT_SEED = 12;
constexpr int NGT_MAZE = 13;
constexpr int NGT_COAG = 14;
constexpr int NGT_WALL = 15;
constexpr int NGT_GNAR = 16;
constexpr int NGT_REPL = 17;
constexpr int NGT_MYST = 18;
constexpr int NGT_LOTE = 19;
constexpr int NGT_FRG2 = 20;
constexpr int NGT_STAR = 21;
constexpr int NGT_FROG = 22;
constexpr int NGT_BRAN = 23;

//replace mode / specific delete flags
constexpr auto REPLACE_MODE    = UINT32_C(0x00000001);
constexpr auto SPECIFIC_DELETE = UINT32_C(0x00000002);

class SimulationData : public ExplicitSingleton<SimulationData>
{
public:
	std::array<Element, PT_NUM> elements;
	std::array<gcache_item, PT_NUM> graphicscache;
	std::vector<wall_type> wtypes;
	std::vector<menu_section> msections;
	char can_move[PT_NUM][PT_NUM];
	static const std::array<BuiltinGOL, NGOL> builtinGol;

	// Element properties that enable basic graphics (i.e. every property that has to do with graphics other than
	// the graphics callback itself) are only ever written by the main thread, but they are read by some other
	// threads that use Renderer to render thumbnails and such. Take this std::shared_mutex with an std::unique_lock
	// when writing such properties in the main thread, and with an std::shared_lock when reading such properties
	// in these secondary Renderer threads. Don't take it with an std::shared_lock when reading such properties in
	// the main thread; the main thread doesn't race with itself.
	mutable std::shared_mutex elementGraphicsMx;

private:
	std::vector<CustomGOLData> customGol;

public:
	SimulationData();
	void InitElements();

	void init_can_move();

	const CustomGOLData *GetCustomGOLByRule(int rule) const;
	const std::vector<CustomGOLData> &GetCustomGol() const { return customGol; }
	void SetCustomGOL(std::vector<CustomGOLData> newCustomGol);

	String ElementResolve(int type, int ctype) const;
	String BasicParticleInfo(Particle const &sample_part) const;
	int GetParticleType(ByteString type) const;

	bool IsElement(int type) const
	{
		return (type > 0 && type < PT_NUM && elements[type].Enabled);
	}

	bool IsElementOrNone(int type) const
	{
		return (type >= 0 && type < PT_NUM && elements[type].Enabled);
	}

};


=== src\simulation\SimulationSettings.h ===

#pragma once

enum EdgeMode
{
	EDGE_VOID,
	EDGE_SOLID,
	EDGE_LOOP,
	NUM_EDGEMODES,
};

enum AirMode
{
	AIR_ON,
	AIR_PRESSUREOFF,
	AIR_VELOCITYOFF,
	AIR_OFF,
	AIR_NOUPDATE,
	NUM_AIRMODES,
};

enum GravityMode
{
	GRAV_VERTICAL,
	GRAV_OFF,
	GRAV_RADIAL,
	GRAV_CUSTOM,
	NUM_GRAVMODES,
};

enum DecoSpace
{
	DECOSPACE_SRGB,
	DECOSPACE_LINEAR,
	DECOSPACE_GAMMA22,
	DECOSPACE_GAMMA18,
	NUM_DECOSPACES,
};


=== src\simulation\Snapshot.cpp ===

#include "Snapshot.h"

uint32_t Snapshot::Hash() const
{
	// http://www.isthe.com/chongo/tech/comp/fnv/
	auto hash = UINT32_C(2166136261);
	auto take = [&hash](const uint8_t *data, size_t size) {
		for (auto i = 0U; i < size; ++i)
		{
			hash ^= data[i];
			hash *= UINT32_C(16777619);
		}
	};
	auto takeThing = [&take](auto &thing) {
		take(reinterpret_cast<const uint8_t *>(&thing), sizeof(thing));
	};
	auto takeVector = [&take](auto &vec) {
		take(reinterpret_cast<const uint8_t *>(vec.data()), vec.size() * sizeof(vec[0]));
	};
	takeVector(AirPressure);
	takeVector(AirVelocityX);
	takeVector(AirVelocityY);
	takeVector(AmbientHeat);
	takeVector(Particles);
	takeVector(GravMass);
	takeVector(GravMask);
	takeVector(GravForceX);
	takeVector(GravForceY);
	takeVector(BlockMap);
	takeVector(ElecMap);
	takeVector(BlockAir);
	takeVector(BlockAirH);
	takeVector(FanVelocityX);
	takeVector(FanVelocityY);
	takeVector(PortalParticles);
	takeVector(WirelessData);
	takeVector(stickmen);
	takeThing(FrameCount);
	takeThing(RngState[0]);
	takeThing(RngState[1]);
	// signs and Authors are excluded on purpose, as they aren't POD and don't have much effect on the simulation.
	return hash;
}


=== src\simulation\Snapshot.h ===

#pragma once
#include "Particle.h"
#include "Sign.h"
#include "Stickman.h"
#include "common/tpt-rand.h"
#include <vector>
#include <array>
#include <cstdint>
#include <json/json.h>

class Snapshot
{
public:
	std::vector<float> AirPressure;
	std::vector<float> AirVelocityX;
	std::vector<float> AirVelocityY;
	std::vector<float> AmbientHeat;

	std::vector<Particle> Particles;

	std::vector<float> GravForceX;
	std::vector<float> GravForceY;
	std::vector<float> GravMass;
	std::vector<uint32_t> GravMask;

	std::vector<unsigned char> BlockMap;
	std::vector<unsigned char> ElecMap;
	std::vector<unsigned char> BlockAir;
	std::vector<unsigned char> BlockAirH;

	std::vector<float> FanVelocityX;
	std::vector<float> FanVelocityY;


	std::vector<Particle> PortalParticles;
	std::vector<int> WirelessData;
	std::vector<playerst> stickmen;
	std::vector<sign> signs;

	uint64_t FrameCount;
	RNG::State RngState;

	uint32_t Hash() const;

	Json::Value Authors;

	virtual ~Snapshot() = default;
};


=== src\simulation\SnapshotDelta.cpp ===

#include "SnapshotDelta.h"
#include <algorithm>
#include <utility>

// * A SnapshotDelta is a bidirectional difference type between Snapshots, defined such
//   that SnapshotDelta d = SnapshotDelta::FromSnapshots(A, B) yields a SnapshotDelta which can be
//   used to construct a Snapshot identical to A via d.Restore(B) and a Snapshot identical
//   to B via d.Forward(A). Thus, d = B - A, A = B - d and B = A + d.
// * Fields in Snapshot can be classified into two groups:
//   * Fields of static size, whose sizes are identical to the size of the corresponding field
//     in all other Snapshots. Example of these fields include AmbientHeat (whose size depends
//     on XRES, YRES and CELL, all compile-time constants) and WirelessData (whose size depends
//     on CHANNELS, another compile-time constant). Note that these fields would be of "static
//     size" even if their sizes weren't derived from compile-time constants, as they'd still
//     be the same size throughout the life of a Simulation, and thus any Snapshot created from it.
//   * Fields of dynamic size, whose sizes may be different between Snapshots. These are, fortunately,
//     the minority: Particles, signs, etc.
// * Each field in Snapshot has a mirror set of fields in SnapshotDelta. Fields of static size
//   have mirror fields whose type is HunkVector, templated by the item type of the
//   corresponding field; these fields are handled in a uniform manner. Fields of dynamic size are
//   handled in a non-uniform, case-by-case manner. 
// * A HunkVector is generated from two streams of identical size and is a collection
//   of Hunks, a Hunk is an offset combined with a collection of Diffs, and a Diff is a pair of values,
//   one originating from one stream and the other from the other. Thus, Hunks represent contiguous
//   sequences of differences between the two streams, and a HunkVector is a compact way to represent
//   all differences between the two streams it's generated from. In this case, these streams are
//   the data in corresponding fields of static size in two Snapshots, and the HunkVector is the
//   respective field in the SnapshotDelta that is the difference between the two Snapshots.
//   * FillHunkVectorPtr is the d = B - A operation, which takes two Snapshot fields of static size and
//     the corresponding SnapshotDelta field, and fills the latter with the HunkVector generated
//     from the former streams.
//   * ApplyHunkVector<true> is the A = B - d operation, which takes a field of a SnapshotDelta and
//     the corresponding field of a "newer" Snapshot, and fills the latter with the "old" values.
//   * ApplyHunkVector<false> is the B = A + d operation, which takes a field of a SnapshotDelta and
//     the corresponding field of an "older" Snapshot, and fills the latter with the "new" values.
//   * This difference type is intended for fields of static size. This covers all fields in Snapshot
//     except for Particles, signs, Authors, FrameCount, and RngState.
// * A SingleDiff is, unsurprisingly enough, a single Diff, with an accompanying bool that signifies
//   whether the Diff does in fact hold the "old" value of a field in the "old" Snapshot and the "new"
//   value of the same field in the "new" Snapshot. If this bool is false, the data in the fields
//   of both Snapshots are equivalent and the SingleDiff should be ignored. If it's true, the
//   SingleDiff represents the difference between these fields.
//   * FillSingleDiff is the d = B - A operation, while ApplySingleDiff<false> and ApplySingleDiff<true>
//     are the A = B - d and B = A + d operations. These are self-explanatory.
//   * This difference type is intended for fields of dynamic size whose data doesn't change often and
//     doesn't consume too much memory. This covers the Snapshot fields signs and Authors, FrameCount,
//     and RngState.
// * This leaves Snapshot::Particles. This field mirrors Simulation::parts, which is actually also
//   a field of static size, but since most of the time most of this array is empty, it doesn't make
//   sense to store all of it in a Snapshot (unlike Air::hv, which can be fairly chaotic (i.e. may have
//   a lot of interesting data in all of its cells) when ambient heat simulation is enabled, or
//   Simulation::wireless, which is not big enough to need compression). This makes Snapshots smaller,
//   but the life of a SnapshotDelta developer harder. The following, relatively simple approach is
//   taken, as a sort of compromise between simplicity and memory usage:
//   * The common part of the Particles arrays in the old and the new Snapshots is identified: this is
//     the overlapping part, i.e. the first size cells of both arrays, where
//     size = min(old.Particles.size(), new.Particles.size()), and a HunkVector is generated from it,
//     as though it was a field of static size. For our purposes, it is indeed Static Enough:tm:, for
//     it only needs to be the same size as the common part of the Particles arrays of the two Snapshots.
//   * The rest of both Particles arrays is copied to the extra fields extraPartsOld and extraPartsNew.
// * One more trick is at work here: Particle structs are actually compared property-by-property rather
//   than as a whole. This ends up being beneficial to memory usage, as many properties (e.g. type
//   and ctype) don't often change over time, while others (e.g. x and y) do. Currently, all Particle
//   properties are 4-byte integral values, which makes it feasible to just reinterpret_cast Particle
//   structs as arrays of uint32_t values and generate HunkVectors from the resulting streams instead.
//   This assumption is enforced by the following static_asserts. The same trick is used for playerst
//   structs, even though Snapshot::stickmen is not big enough for us to benefit from this. The
//   alternative would have been to implement operator ==(const playerst &, const playerst &), which
//   would have been tedious.

constexpr size_t ParticleUint32Count = sizeof(Particle) / sizeof(uint32_t);
static_assert(sizeof(Particle) % sizeof(uint32_t) == 0, "fix me");

constexpr size_t playerstUint32Count = sizeof(playerst) / sizeof(uint32_t);
static_assert(sizeof(playerst) % sizeof(uint32_t) == 0, "fix me");

// * Needed by FillHunkVector for handling Snapshot::stickmen.
bool operator ==(const playerst &lhs, const playerst &rhs)
{
	auto match = true;
	for (auto i = 0U; i < 16U; ++i)
	{
		match = match && lhs.legs[i] == rhs.legs[i];
	}
	for (auto i = 0U; i < 8U; ++i)
	{
		match = match && lhs.accs[i] == rhs.accs[i];
	}
	return match                              &&
	       lhs.comm        == rhs.comm        &&
	       lhs.pcomm       == rhs.pcomm       &&
	       lhs.elem        == rhs.elem        &&
	       lhs.spwn        == rhs.spwn        &&
	       lhs.frames      == rhs.frames      &&
	       lhs.rocketBoots == rhs.rocketBoots &&
	       lhs.fan         == rhs.fan         &&
	       lhs.spawnID     == rhs.spawnID;
}

// * Needed by FillSingleDiff for handling Snapshot::signs.
bool operator ==(const std::vector<sign> &lhs, const std::vector<sign> &rhs)
{
	if (lhs.size() != rhs.size())
	{
		return false;
	}
	for (auto i = 0U; i < lhs.size(); ++i)
	{
		if (!(lhs[i].x    == rhs[i].x    &&
		      lhs[i].y    == rhs[i].y    &&
		      lhs[i].ju   == rhs[i].ju   &&
		      lhs[i].text == rhs[i].text))
		{
			return false;
		}
	}
	return true;
}

template<class Item>
void FillHunkVectorPtr(const Item *oldItems, const Item *newItems, SnapshotDelta::HunkVector<Item> &out, size_t size)
{
	auto i = 0U;
	bool different = false;
	auto offset = 0U;
	auto markDifferent = [oldItems, newItems, &out, &i, &different, &offset](bool mark) {
		if (mark && !different)
		{
			different = true;
			offset = i;
		}
		else if (!mark && different)
		{
			different = false;
			auto size = i - offset;
			out.emplace_back();
			auto &hunk = out.back();
			hunk.offset = offset;
			auto &diffs = hunk.diffs;
			diffs.resize(size);
			for (auto j = 0U; j < size; ++j)
			{
				diffs[j].oldItem = oldItems[offset + j];
				diffs[j].newItem = newItems[offset + j];
			}
		}
	};
	while (i < size)
	{
		markDifferent(!(oldItems[i] == newItems[i]));
		i += 1U;
	}
	markDifferent(false);
}

template<class Item>
void FillHunkVector(const std::vector<Item> &oldItems, const std::vector<Item> &newItems, SnapshotDelta::HunkVector<Item> &out)
{
	FillHunkVectorPtr<Item>(oldItems.data(), newItems.data(), out, std::min(oldItems.size(), newItems.size()));
}

template<class Item>
void FillSingleDiff(const Item &oldItem, const Item &newItem, SnapshotDelta::SingleDiff<Item> &out)
{
	if (oldItem != newItem)
	{
		out.valid = true;
		out.diff.oldItem = oldItem;
		out.diff.newItem = newItem;
	}
}

template<bool UseOld, class Item>
void ApplyHunkVectorPtr(const SnapshotDelta::HunkVector<Item> &in, Item *items)
{
	for (auto &hunk : in)
	{
		auto offset = hunk.offset;
		auto &diffs = hunk.diffs;
		for (auto j = 0U; j < diffs.size(); ++j)
		{
			items[offset + j] = UseOld ? diffs[j].oldItem : diffs[j].newItem;
		}
	}
}

template<bool UseOld, class Item>
void ApplyHunkVector(const SnapshotDelta::HunkVector<Item> &in, std::vector<Item> &items)
{
	ApplyHunkVectorPtr<UseOld, Item>(in, items.data());
}

template<bool UseOld, class Item>
void ApplySingleDiff(const SnapshotDelta::SingleDiff<Item> &in, Item &item)
{
	if (in.valid)
	{
		item = UseOld ? in.diff.oldItem : in.diff.newItem;
	}
}

std::unique_ptr<SnapshotDelta> SnapshotDelta::FromSnapshots(const Snapshot &oldSnap, const Snapshot &newSnap)
{
	auto ptr = std::make_unique<SnapshotDelta>();
	auto &delta = *ptr;
	FillHunkVector(oldSnap.AirPressure    , newSnap.AirPressure    , delta.AirPressure    );
	FillHunkVector(oldSnap.AirVelocityX   , newSnap.AirVelocityX   , delta.AirVelocityX   );
	FillHunkVector(oldSnap.AirVelocityY   , newSnap.AirVelocityY   , delta.AirVelocityY   );
	FillHunkVector(oldSnap.AmbientHeat    , newSnap.AmbientHeat    , delta.AmbientHeat    );
	FillHunkVector(oldSnap.GravMass       , newSnap.GravMass       , delta.GravMass       );
	FillHunkVector(oldSnap.GravMask       , newSnap.GravMask       , delta.GravMask       );
	FillHunkVector(oldSnap.GravForceX     , newSnap.GravForceX     , delta.GravForceX     );
	FillHunkVector(oldSnap.GravForceY     , newSnap.GravForceY     , delta.GravForceY     );
	FillHunkVector(oldSnap.BlockMap       , newSnap.BlockMap       , delta.BlockMap       );
	FillHunkVector(oldSnap.ElecMap        , newSnap.ElecMap        , delta.ElecMap        );
	FillHunkVector(oldSnap.BlockAir       , newSnap.BlockAir       , delta.BlockAir       );
	FillHunkVector(oldSnap.BlockAirH      , newSnap.BlockAirH      , delta.BlockAirH      );
	FillHunkVector(oldSnap.FanVelocityX   , newSnap.FanVelocityX   , delta.FanVelocityX   );
	FillHunkVector(oldSnap.FanVelocityY   , newSnap.FanVelocityY   , delta.FanVelocityY   );
	FillHunkVector(oldSnap.WirelessData   , newSnap.WirelessData   , delta.WirelessData   );
	FillSingleDiff(oldSnap.signs          , newSnap.signs          , delta.signs          );
	FillSingleDiff(oldSnap.Authors        , newSnap.Authors        , delta.Authors        );
	FillSingleDiff(oldSnap.FrameCount     , newSnap.FrameCount     , delta.FrameCount     );
	FillSingleDiff(oldSnap.RngState       , newSnap.RngState       , delta.RngState       );
	FillHunkVectorPtr(reinterpret_cast<const uint32_t *>(oldSnap.PortalParticles.data()), reinterpret_cast<const uint32_t *>(newSnap.PortalParticles.data()), delta.PortalParticles, newSnap.PortalParticles.size() * ParticleUint32Count);
	FillHunkVectorPtr(reinterpret_cast<const uint32_t *>(oldSnap.stickmen.data())       , reinterpret_cast<const uint32_t *>(newSnap.stickmen.data()       ), delta.stickmen       , newSnap.stickmen       .size() * playerstUint32Count);

	// * Slightly more interesting; this will only diff the common parts, the rest is copied separately.
	auto commonSize = std::min(oldSnap.Particles.size(), newSnap.Particles.size());
	FillHunkVectorPtr(reinterpret_cast<const uint32_t *>(oldSnap.Particles.data()), reinterpret_cast<const uint32_t *>(newSnap.Particles.data()), delta.commonParticles, commonSize * ParticleUint32Count);
	delta.extraPartsOld.resize(oldSnap.Particles.size() - commonSize);
	std::copy(oldSnap.Particles.begin() + commonSize, oldSnap.Particles.end(), delta.extraPartsOld.begin());
	delta.extraPartsNew.resize(newSnap.Particles.size() - commonSize);
	std::copy(newSnap.Particles.begin() + commonSize, newSnap.Particles.end(), delta.extraPartsNew.begin());

	return ptr;
}

std::unique_ptr<Snapshot> SnapshotDelta::Forward(const Snapshot &oldSnap)
{
	auto ptr = std::make_unique<Snapshot>(oldSnap);
	auto &newSnap = *ptr;
	ApplyHunkVector<false>(AirPressure    , newSnap.AirPressure    );
	ApplyHunkVector<false>(AirVelocityX   , newSnap.AirVelocityX   );
	ApplyHunkVector<false>(AirVelocityY   , newSnap.AirVelocityY   );
	ApplyHunkVector<false>(AmbientHeat    , newSnap.AmbientHeat    );
	ApplyHunkVector<false>(GravMass       , newSnap.GravMass       );
	ApplyHunkVector<false>(GravMask       , newSnap.GravMask       );
	ApplyHunkVector<false>(GravForceX     , newSnap.GravForceX     );
	ApplyHunkVector<false>(GravForceY     , newSnap.GravForceY     );
	ApplyHunkVector<false>(BlockMap       , newSnap.BlockMap       );
	ApplyHunkVector<false>(ElecMap        , newSnap.ElecMap        );
	ApplyHunkVector<false>(BlockAir       , newSnap.BlockAir       );
	ApplyHunkVector<false>(BlockAirH      , newSnap.BlockAirH      );
	ApplyHunkVector<false>(FanVelocityX   , newSnap.FanVelocityX   );
	ApplyHunkVector<false>(FanVelocityY   , newSnap.FanVelocityY   );
	ApplyHunkVector<false>(WirelessData   , newSnap.WirelessData   );
	ApplySingleDiff<false>(signs          , newSnap.signs          );
	ApplySingleDiff<false>(Authors        , newSnap.Authors        );
	ApplySingleDiff<false>(FrameCount     , newSnap.FrameCount     );
	ApplySingleDiff<false>(RngState       , newSnap.RngState       );
	ApplyHunkVectorPtr<false>(PortalParticles, reinterpret_cast<uint32_t *>(newSnap.PortalParticles.data()));
	ApplyHunkVectorPtr<false>(stickmen       , reinterpret_cast<uint32_t *>(newSnap.stickmen.data()       ));

	// * Slightly more interesting; apply the common hunk vector, copy the extra portion separaterly.
	ApplyHunkVectorPtr<false>(commonParticles, reinterpret_cast<uint32_t *>(newSnap.Particles.data()));
	auto commonSize = oldSnap.Particles.size() - extraPartsOld.size();
	newSnap.Particles.resize(commonSize + extraPartsNew.size());
	std::copy(extraPartsNew.begin(), extraPartsNew.end(), newSnap.Particles.begin() + commonSize);

	return ptr;
}

std::unique_ptr<Snapshot> SnapshotDelta::Restore(const Snapshot &newSnap)
{
	auto ptr = std::make_unique<Snapshot>(newSnap);
	auto &oldSnap = *ptr;
	ApplyHunkVector<true>(AirPressure    , oldSnap.AirPressure    );
	ApplyHunkVector<true>(AirVelocityX   , oldSnap.AirVelocityX   );
	ApplyHunkVector<true>(AirVelocityY   , oldSnap.AirVelocityY   );
	ApplyHunkVector<true>(AmbientHeat    , oldSnap.AmbientHeat    );
	ApplyHunkVector<true>(GravMass       , oldSnap.GravMass       );
	ApplyHunkVector<true>(GravMask       , oldSnap.GravMask       );
	ApplyHunkVector<true>(GravForceX     , oldSnap.GravForceX     );
	ApplyHunkVector<true>(GravForceY     , oldSnap.GravForceY     );
	ApplyHunkVector<true>(BlockMap       , oldSnap.BlockMap       );
	ApplyHunkVector<true>(ElecMap        , oldSnap.ElecMap        );
	ApplyHunkVector<true>(BlockAir       , oldSnap.BlockAir       );
	ApplyHunkVector<true>(BlockAirH      , oldSnap.BlockAirH      );
	ApplyHunkVector<true>(FanVelocityX   , oldSnap.FanVelocityX   );
	ApplyHunkVector<true>(FanVelocityY   , oldSnap.FanVelocityY   );
	ApplyHunkVector<true>(WirelessData   , oldSnap.WirelessData   );
	ApplySingleDiff<true>(signs          , oldSnap.signs          );
	ApplySingleDiff<true>(Authors        , oldSnap.Authors        );
	ApplySingleDiff<true>(FrameCount     , oldSnap.FrameCount     );
	ApplySingleDiff<true>(RngState       , oldSnap.RngState       );
	ApplyHunkVectorPtr<true>(PortalParticles, reinterpret_cast<uint32_t *>(oldSnap.PortalParticles.data()));
	ApplyHunkVectorPtr<true>(stickmen       , reinterpret_cast<uint32_t *>(oldSnap.stickmen.data()       ));

	// * Slightly more interesting; apply the common hunk vector, copy the extra portion separaterly.
	ApplyHunkVectorPtr<true>(commonParticles, reinterpret_cast<uint32_t *>(oldSnap.Particles.data()));
	auto commonSize = newSnap.Particles.size() - extraPartsNew.size();
	oldSnap.Particles.resize(commonSize + extraPartsOld.size());
	std::copy(extraPartsOld.begin(), extraPartsOld.end(), oldSnap.Particles.begin() + commonSize);

	return ptr;
}


=== src\simulation\SnapshotDelta.h ===

#pragma once
#include <memory>
#include <cstdint>
#include "Snapshot.h"

struct SnapshotDelta
{
	template<class Item>
	struct Diff
	{
		Item oldItem, newItem;
	};

	template<class Item>
	struct Hunk
	{
		int offset;
		std::vector<Diff<Item>> diffs;
	};

	template<class Item>
	struct SingleDiff
	{
		bool valid = false;
		Diff<Item> diff;
	};

	template<class Item>
	struct HalfHunk
	{
		int offset;
		std::vector<Item> items;
	};

	template<class Item>
	using HunkVector = std::vector<Hunk<Item>>;

	template<class Item>
	struct HalfHunkVectorPair
	{
		std::vector<HalfHunk<Item>> oldHunks, newHunks;
	};

	HunkVector<float> AirPressure;
	HunkVector<float> AirVelocityX;
	HunkVector<float> AirVelocityY;
	HunkVector<float> AmbientHeat;

	HunkVector<uint32_t> commonParticles;
	std::vector<Particle> extraPartsOld, extraPartsNew;

	HunkVector<float> GravMass;
	HunkVector<uint32_t> GravMask;
	HunkVector<float> GravForceX;
	HunkVector<float> GravForceY;

	HunkVector<unsigned char> BlockMap;
	HunkVector<unsigned char> ElecMap;
	HunkVector<unsigned char> BlockAir;
	HunkVector<unsigned char> BlockAirH;

	HunkVector<float> FanVelocityX;
	HunkVector<float> FanVelocityY;


	HunkVector<uint32_t> PortalParticles;
	HunkVector<int> WirelessData;
	HunkVector<uint32_t> stickmen;
	SingleDiff<std::vector<sign>> signs;
	SingleDiff<uint64_t> FrameCount;
	SingleDiff<RNG::State> RngState;

	SingleDiff<Json::Value> Authors;

	static std::unique_ptr<SnapshotDelta> FromSnapshots(const Snapshot &oldSnap, const Snapshot &newSnap);
	std::unique_ptr<Snapshot> Forward(const Snapshot &oldSnap);
	std::unique_ptr<Snapshot> Restore(const Snapshot &newSnap);
};


=== src\simulation\Stickman.h ===

#pragma once

constexpr auto MAX_FIGHTERS = 100;
struct playerst
{
	char comm;           //command cell
	char pcomm;          //previous command
	int elem;            //element power
	float legs[16];      //legs' positions
	float accs[8];       //accelerations
	char spwn;           //if stick man was spawned
	unsigned int frames; //frames since last particle spawn - used when spawning LIGH
	bool rocketBoots;
	bool fan;
	int spawnID;         //id of the SPWN particle that spawns it
};


=== src\simulation\StructProperty.cpp ===

#include "StructProperty.h"
#include <cassert>

StructProperty::StructProperty(ByteString name, PropertyType type, intptr_t offset):
Name(name),
Type(type),
Offset(offset)
{

}

StructProperty::StructProperty():
Name(""),
Type(Integer),
Offset(0)
{

}

bool StructProperty::operator ==(const StructProperty &other) const
{
	return Name == other.Name &&
	       Type == other.Type &&
	       Offset == other.Offset;
}

String StructProperty::ToString(const PropertyValue &value) const
{
	::String str;
	switch (Type)
	{
	case StructProperty::Float:
		str = String::Build(std::get<float>(value));
		break;

	case StructProperty::ParticleType:
	case StructProperty::Integer:
		str = String::Build(std::get<int>(value));
		break;

	case StructProperty::UInteger:
		str = String::Build(std::get<unsigned int>(value));
		break;

	default:
		assert(false);
		break;
	}
	return str;
}


=== src\simulation\StructProperty.h ===

#pragma once
#include "common/String.h"
#include <cstdint>
#include <variant>

using PropertyValue = std::variant<
	int,
	unsigned int,
	float
>;

struct StructProperty
{
	enum PropertyType
	{
		TransitionType,
		ParticleType,
		Colour,
		Integer,
		UInteger,
		Float,
		BString,
		String,
		UChar,
		Removed
	};
	ByteString Name;
	PropertyType Type;
	intptr_t Offset;

	StructProperty();
	StructProperty(ByteString name, PropertyType type, intptr_t offset);

	bool operator ==(const StructProperty &other) const;
	::String ToString(const PropertyValue &value) const;
};

struct StructPropertyAlias
{
	ByteString from, to;
};


=== src\simulation\ToolClasses.cpp ===

#include "ToolClasses.h"

std::vector<SimTool> const &GetTools()
{
	struct DoOnce
	{
		std::vector<SimTool> tools;

		DoOnce()
		{
#define TOOL_NUMBERS_CALL
#include "ToolNumbers.h"
#undef TOOL_NUMBERS_CALL
		}
	};

	static DoOnce doOnce;
	return doOnce.tools;
}


=== src\simulation\ToolClasses.h ===

#pragma once
#include <vector>
#include <memory>

#include "SimTool.h"

#define TOOL_NUMBERS_ENUMERATE
#include "ToolNumbers.h"
#undef TOOL_NUMBERS_ENUMERATE

std::vector<SimTool> const &GetTools();


=== src\simulation\ToolCommon.h ===

#pragma once
#include "ToolClasses.h"
#include "Simulation.h"
#include "graphics/Renderer.h"
#include "ElementDefs.h"
#include "ElementClasses.h"


=== src\simulation\ToolNumbers.template.h ===

#ifdef TOOL_NUMBERS_CALL
# define TOOL_DEFINE(name, id) tools.push_back(SimTool()), tools.back().Tool_ ## name ()
#endif
#ifdef TOOL_NUMBERS_DECLARE
# define TOOL_DEFINE(name, id) void Tool_ ## name ()
#endif
#ifdef TOOL_NUMBERS_ENUMERATE
# define TOOL_DEFINE(name, id) constexpr int TOOL_ ## name = id
#endif

@tool_defs@

#undef TOOL_DEFINE


=== src\simulation\TransitionConstants.h ===

#pragma once
#include "ElementDefs.h"

constexpr float IPL = MIN_PRESSURE - 1;
constexpr float IPH = MAX_PRESSURE + 1;
constexpr float ITL = MIN_TEMP - 1;
constexpr float ITH = MAX_TEMP + 1;

// no transition (PT_NONE means kill part)
constexpr int NT = -1;

// special transition - lava ctypes etc need extra code, which is only found and run if ST is given
constexpr int ST = PT_NUM;


=== src\simulation\WallType.h ===

#pragma once
#include <memory>
#include "common/String.h"
#include "common/Vec2.h"
#include "graphics/Pixel.h"
class VideoBuffer;

struct wall_type
{
	RGB colour;
	RGB eglow; // if emap set, add this to fire glow
	int drawstyle;
	std::unique_ptr<VideoBuffer> (*textureGen)(int, Vec2<int>);
	String name;
	ByteString identifier;
	String descs;
};


=== src\simulation\elements\ACEL.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_ACEL()
{
	Identifier = "DEFAULT_PT_ACEL";
	Name = "ACEL";
	Colour = 0x0099CC_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Accelerator, speeds up nearby elements.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	float multiplier;
	if (parts[i].life!=0)
	{
		auto change = parts[i].life > 1000 ? 1000 : (parts[i].life < 0 ? 0 : parts[i].life);
		multiplier = 1.0f+(change/100.0f);
	}
	else
	{
		multiplier = 1.1f;
	}
	parts[i].tmp = 0;
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (!rx != !ry)
			{
				auto r = pmap[y+ry][x+rx];
				if(!r)
					r = sim->photons[y+ry][x+rx];
				if (!r)
					continue;
				if(elements[TYP(r)].Properties & (TYPE_PART | TYPE_LIQUID | TYPE_GAS | TYPE_ENERGY))
				{
					parts[ID(r)].vx *= multiplier;
					parts[ID(r)].vy *= multiplier;
					parts[i].tmp = 1;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->tmp)
		*pixel_mode |= PMODE_GLOW;
	return 0;
}


=== src\simulation\elements\ACID.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_ACID()
{
	Identifier = "DEFAULT_PT_ACID";
	Name = "ACID";
	Colour = 0xED55FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 40;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;
	PhotonReflectWavelengths = 0x1FE001FE;

	Weight = 10;

	HeatConduct = 34;
	Description = "Dissolves almost everything.";

	Properties = TYPE_LIQUID|PROP_DEADLY;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 75;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				int rt = TYP(r);
				if (rt != PT_ACID && rt != PT_CAUS)
				{
					if (rt == PT_PLEX || rt == PT_NITR || rt == PT_GUNP || rt == PT_RBDM || rt == PT_LRBD)
					{
						sim->part_change_type(i,x,y,PT_FIRE);
						sim->part_change_type(ID(r),x+rx,y+ry,PT_FIRE);
						parts[i].life = 4;
						parts[ID(r)].life = 4;
					}
					else if (rt == PT_WTRV)
					{
						if (sim->rng.chance(1, 250))
						{
							sim->part_change_type(i, x, y, PT_CAUS);
							parts[i].life = sim->rng.between(25, 74);
							sim->kill_part(ID(r));
						}
					}
					else if (rt != PT_CLNE && rt != PT_PCLN && ((rt != PT_FOG && rt != PT_RIME) || parts[ID(r)].tmp <= 5) && parts[i].life > 50 && sim->rng.chance(elements[rt].Hardness, 1000))
					{
						if (sim->parts_avg(i, ID(r),PT_GLAS)!= PT_GLAS)//GLAS protects stuff from acid
						{
							float newtemp = ((60.0f-(float)elements[rt].Hardness))*7.0f;
							if(newtemp < 0){
								newtemp = 0;
							}
							parts[i].temp += newtemp;
							parts[i].life--;
							switch (rt)
							{
							case PT_LITH:
								sim->part_change_type(ID(r), x + rx, y + ry, PT_H2);
								break;

							default:
								sim->kill_part(ID(r));
								break;
							}
						}
					}
					else if (parts[i].life<=50)
					{
						sim->kill_part(i);
						return 1;
					}
				}
			}
		}
	}
	for (auto trade = 0; trade<2; trade++)
	{
		auto rx = sim->rng.between(-2, 2);
		auto ry = sim->rng.between(-2, 2);
		if (rx || ry)
		{
			auto r = pmap[y+ry][x+rx];
			if (!r)
				continue;
			if (TYP(r) == PT_ACID && (parts[i].life > parts[ID(r)].life) && parts[i].life>0)//diffusion
			{
				int temp = parts[i].life - parts[ID(r)].life;
				if (temp == 1)
				{
					parts[ID(r)].life++;
					parts[i].life--;
				}
				else if (temp>0)
				{
					parts[ID(r)].life += temp/2;
					parts[i].life -= temp/2;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int s = cpart->life;
	if (s>75) s = 75; //These two should not be here.
	if (s<49) s = 49;
	s = (s-49)*3;
	if (s==0) s = 1;
	*colr += s*4;
	*colg += s*1;
	*colb += s*2;
	*pixel_mode |= PMODE_BLUR;
	return 0;
}


=== src\simulation\elements\AMTR.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_AMTR()
{
	Identifier = "DEFAULT_PT_AMTR";
	Name = "AMTR";
	Colour = 0x808080_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.00f;
	Gravity = 0.10f;
	Diffusion = 1.00f;
	HotAir = 0.0000f * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 70;
	Description = "Anti-Matter, destroys a majority of particles.";

	Properties = TYPE_GAS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if (rt!=PT_AMTR && rt!=PT_DMND && rt!=PT_CLNE && rt!=PT_PCLN && rt!=PT_VOID && rt!=PT_BHOL && rt!=PT_NBHL && rt!=PT_PRTI && rt!=PT_PRTO)
				{
					parts[i].life++;
					if (parts[i].life==4)
					{
						sim->kill_part(i);
						return 1;
					}
					if (sim->rng.chance(1, 10))
						sim->create_part(ID(r), x+rx, y+ry, PT_PHOT);
					else
						sim->kill_part(ID(r));
					sim->pv[y/CELL][x/CELL] -= 2.0f;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	// don't render AMTR as a gas
	// this function just overrides the default graphics
	return 1;
}


=== src\simulation\elements\ANAR.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_ANAR()
{
	Identifier = "DEFAULT_PT_ANAR";
	Name = "ANAR";
	Colour = 0xFFFFEE_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = -0.7f;
	AirDrag = -0.02f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.1f;
	Gravity = -0.1f;
	NewtonianGravity = -1.f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 85;

	HeatConduct = 70;
	Description = "Anti-air. Very light gravity-defying dust. Burns cold instead of hot.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_CFLM && sim->rng.chance(1, 4))
				{
					sim->part_change_type(i,x,y,PT_CFLM);
					parts[i].life = sim->rng.between(50, 199);
					parts[ID(r)].temp = parts[i].temp = 0;
					sim->pv[y/CELL][x/CELL] -= 0.5;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\ARAY.cpp ===

#include "simulation/ElementCommon.h"
#include "FILT.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_ARAY()
{
	Identifier = "DEFAULT_PT_ARAY";
	Name = "ARAY";
	Colour = 0xFFBB00_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Ray Emitter. Rays create points when they collide.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int short_bray_life = parts[i].life > 0 ? parts[i].life : 30;
	int long_bray_life = parts[i].life > 0 ? parts[i].life : 1020;
	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r) == PT_SPRK && parts[ID(r)].life == 3)
				{
					bool isBlackDeco = false;
					int destroy = (parts[ID(r)].ctype==PT_PSCN) ? 1 : 0;
					int nostop = (parts[ID(r)].ctype==PT_INST) ? 1 : 0;
					int colored = 0, rt;
					for (int docontinue = 1, nxx = 0, nyy = 0, nxi = rx*-1, nyi = ry*-1; docontinue; nyy+=nyi, nxx+=nxi)
					{
						if (!(x+nxi+nxx<XRES && y+nyi+nyy<YRES && x+nxi+nxx >= 0 && y+nyi+nyy >= 0))
							break;

						r = pmap[y+nyi+nyy][x+nxi+nxx];
						rt = TYP(r);
						r = ID(r);
						if (!rt)
						{
							int nr = sim->create_part(-1, x+nxi+nxx, y+nyi+nyy, PT_BRAY);
							if (nr != -1)
							{
								// if it came from PSCN
								if (destroy)
								{
									parts[nr].tmp = 2;
									parts[nr].life = 2;
								}
								else
								{
									parts[nr].ctype = colored;
									parts[nr].life = short_bray_life;
								}
								parts[nr].temp = parts[i].temp;
								if (isBlackDeco)
									parts[nr].dcolour = 0xFF000000;
							}
						}
						else if (!destroy)
						{
							if (rt == PT_BRAY)
							{
								// cases for hitting different BRAY modes
								switch(parts[r].tmp)
								{
								// normal white
								case 0:
									if (nyy != 0 || nxx !=0)
									{
										parts[r].life = long_bray_life; // makes it last a while
										parts[r].tmp = 1;
										if (!parts[r].ctype) // and colors it if it isn't already
											parts[r].ctype = colored;
									}
								// red bray or any other random tmp mode, stop
								case 2:
								default:
									docontinue = 0;
									break;
								// long life, reset it
								case 1:
									parts[r].life = long_bray_life;
									//docontinue = 1;
									break;
								}
								if (isBlackDeco)
									parts[r].dcolour = 0xFF000000;
							}
							// get color if passed through FILT
							else if (rt == PT_FILT)
							{
								if (parts[r].tmp != 6)
								{
									colored = Element_FILT_interactWavelengths(sim, &parts[r], colored);
									if (!colored)
										break;
								}
								isBlackDeco = (parts[r].dcolour==0xFF000000);
								parts[r].life = 4;
							}
							else if (rt == PT_STOR)
							{
								if (parts[r].tmp)
								{
									//Cause STOR to release
									for (int ry1 = 1; ry1 >= -1; ry1--)
									{
										for (int rx1 = 0; rx1 >= -1 && rx1 <= 1; rx1 = -rx1 - rx1 + 1)
										{
											int np = sim->create_part(-1, x + nxi + nxx + rx1, y + nyi + nyy + ry1, TYP(parts[r].tmp));
											if (np != -1)
											{
												parts[np].temp = parts[r].temp;
												parts[np].life = parts[r].tmp2;
												parts[np].tmp = parts[r].tmp3;
												parts[np].ctype = parts[r].tmp4;
												parts[r].tmp = 0;
												parts[r].life = 10;
												break;
											}
										}
									}
								}
								else
								{
									parts[r].life = 10;
								}
							// this if prevents BRAY from stopping on certain materials
							}
							else if (rt != PT_INWR && (rt != PT_SPRK || parts[r].ctype != PT_INWR) && rt != PT_ARAY && rt != PT_WIFI && !(rt == PT_SWCH && parts[r].life >= 10))
							{
								if (nyy!=0 || nxx!=0)
									sim->create_part(-1, x+nxi+nxx, y+nyi+nyy, PT_SPRK);

								if (!(nostop && parts[r].type==PT_SPRK && parts[r].ctype >= 0 && parts[r].ctype < PT_NUM && (elements[parts[r].ctype].Properties&PROP_CONDUCTS)))
									docontinue = 0;
								else
									docontinue = 1;
							}
						}
						else if (destroy)
						{
							if (rt == PT_BRAY)
							{
								parts[r].tmp = 2;
								parts[r].life = 1;
								docontinue = 1;
								if (isBlackDeco)
									parts[r].dcolour = 0xFF000000;
							//this if prevents red BRAY from stopping on certain materials
							}
							else if (rt==PT_STOR || rt==PT_INWR || (rt==PT_SPRK && parts[r].ctype==PT_INWR) || rt==PT_ARAY || rt==PT_WIFI || rt==PT_FILT || (rt==PT_SWCH && parts[r].life>=10))
							{
								if (rt == PT_STOR)
								{
									parts[r].tmp = 0;
									parts[r].life = 0;
								}
								else if (rt == PT_FILT)
								{
									isBlackDeco = (parts[r].dcolour==0xFF000000);
									parts[r].life = 2;
								}
								docontinue = 1;
							}
							else
							{
								docontinue = 0;
							}
						}
					}
				}
				//parts[i].life = 4;
			}
		}
	}
	return 0;
}


=== src\simulation\elements\BANG.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_BANG()
{
	Identifier = "DEFAULT_PT_BANG";
	Name = "TNT";
	Colour = 0xC05050_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 88;
	Description = "TNT, explodes all at once.";

	Properties = TYPE_SOLID | PROP_NEUTPENETRATE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if(parts[i].tmp==0)
	{
		if(parts[i].temp>=673.0f)
			parts[i].tmp = 1;
		else
		{
			for (auto rx = -1; rx <= 1; rx++)
			{
				for (auto ry = -1; ry <= 1; ry++)
				{
					if (rx || ry)
					{
						auto r = pmap[y+ry][x+rx];
						if (!r)
							continue;
						if (TYP(r)==PT_FIRE || TYP(r)==PT_PLSM || TYP(r)==PT_SPRK || TYP(r)==PT_LIGH)
						{
							parts[i].tmp = 1;
						}
					}
				}
			}
		}
	}
	else if(parts[i].tmp==1)
	{
		if (pmap[y][x] && ID(pmap[y][x]) == i)
		{
			sim->flood_prop(x, y, AccessProperty{ FIELD_TMP, 2 });
		}
		parts[i].tmp = 2;
	}
	else if(parts[i].tmp==2)
	{
		parts[i].tmp = 3;
	}
	else
	{
		float otemp = parts[i].temp-273.15f;
		//Explode!!
		sim->pv[y/CELL][x/CELL] += 0.5f;
		parts[i].tmp = 0;
		if (sim->rng.chance(1, 3))
		{
			if (sim->rng.chance(1, 2))
			{
				sim->create_part(i, x, y, PT_FIRE);
			}
			else
			{
				sim->create_part(i, x, y, PT_SMKE);
				parts[i].life = sim->rng.between(500, 549);
			}
			parts[i].temp = restrict_flt((MAX_TEMP/4)+otemp, MIN_TEMP, MAX_TEMP);
		}
		else
		{
			if (sim->rng.chance(1, 15))
			{
				sim->create_part(i, x, y, PT_EMBR);
				parts[i].tmp = 0;
				parts[i].life = 50;
				parts[i].temp = restrict_flt((MAX_TEMP/3)+otemp, MIN_TEMP, MAX_TEMP);
				parts[i].vx = float(sim->rng.between(-10, 10));
				parts[i].vy = float(sim->rng.between(-10, 10));
			}
			else
			{
				sim->kill_part(i);
			}
		}
		return 1;
	}
	return 0;
}


=== src\simulation\elements\BCLN.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_BCLN()
{
	Identifier = "DEFAULT_PT_BCLN";
	Name = "BCLN";
	Colour = 0xFFD040_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.97f;
	Loss = 0.50f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 12;

	Weight = 100;

	HeatConduct = 251;
	Description = "Breakable Clone.";

	Properties = TYPE_SOLID | PROP_PHOTPASS | PROP_LIFE_DEC | PROP_LIFE_KILL_DEC | PROP_NOCTYPEDRAW;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	CtypeDraw = &Element::ctypeDrawVInTmp;
}

constexpr float ADVECTION = 0.1f;

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (!parts[i].life && sim->pv[y/CELL][x/CELL]>4.0f)
		parts[i].life = sim->rng.between(80, 119);
	if (parts[i].life)
	{
		parts[i].vx += ADVECTION*sim->vx[y/CELL][x/CELL];
		parts[i].vy += ADVECTION*sim->vy[y/CELL][x/CELL];
	}
	if (parts[i].ctype<=0 || parts[i].ctype>=PT_NUM || !elements[parts[i].ctype].Enabled)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				auto r = sim->photons[y+ry][x+rx];
				if (!r)
					r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if (rt!=PT_CLNE && rt!=PT_PCLN &&
					rt!=PT_BCLN && rt!=PT_STKM &&
					rt!=PT_PBCN && rt!=PT_STKM2 &&
					rt<PT_NUM)
				{
					parts[i].ctype = rt;
					if (rt==PT_LIFE || rt==PT_LAVA)
						parts[i].tmp = parts[ID(r)].ctype;
				}
			}
		}
	}
	else
	{
		if (parts[i].ctype==PT_LIFE) sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), PT_LIFE, parts[i].tmp);
		else if (parts[i].ctype!=PT_LIGH || sim->rng.chance(1, 30))
		{
			int np = sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), TYP(parts[i].ctype));
			if (np>=0)
			{
				if (parts[i].ctype==PT_LAVA && parts[i].tmp>0 && parts[i].tmp<PT_NUM && elements[parts[i].tmp].HighTemperatureTransition==PT_LAVA)
					parts[np].ctype = parts[i].tmp;
			}
		}
	}
	return 0;
}


=== src\simulation\elements\BCOL.cpp ===

#include "simulation/ElementCommon.h"
#include "COAL.h"

void Element::Element_BCOL()
{
	Identifier = "DEFAULT_PT_BCOL";
	Name = "BCOL";
	Colour = 0x333333_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 2;
	PhotonReflectWavelengths = 0x00000000;

	Weight = 90;

	HeatConduct = 150;
	Description = "Broken Coal. Heavy particles, burns slowly.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 110;

	Update = &Element_COAL_update;
	Graphics = &Element_COAL_graphics;
}


=== src\simulation\elements\BGLA.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_BGLA()
{
	Identifier = "DEFAULT_PT_BGLA";
	Name = "BGLA";
	Colour = 0x606060_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 5;
	Hardness = 0;

	Weight = 90;

	HeatConduct = 150;
	Description = "Broken Glass, heavy particles formed when glass breaks under pressure. Meltable. Bagels.";

	Properties = TYPE_PART | PROP_NEUTPASS | PROP_PHOTPASS | PROP_HOT_GLOW | PROP_DEADLY;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1973.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\BHOL.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_BHOL()
{
	Identifier = "DEFAULT_PT_BHOL";
	Name = "VACU";
	Colour = 0x303030_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = -0.01f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = R_TEMP + 70.0f + 273.15f;
	HeatConduct = 255;
	Description = "Vacuum, sucks in other particles and heats up.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}


=== src\simulation\elements\BIZR.cpp ===

#include "simulation/ElementCommon.h"
#include "BIZR.h"

void Element::Element_BIZR()
{
	Identifier = "DEFAULT_PT_BIZR";
	Name = "BIZR";
	Colour = 0x00FF77_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	HeatConduct = 29;
	Description = "Bizarre... contradicts the normal state changes. Paints other elements with its deco color.";

	Properties = TYPE_LIQUID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 100.0f;
	LowTemperatureTransition = PT_BIZRG;
	HighTemperature = 400.0f;
	HighTemperatureTransition = PT_BIZRS;

	DefaultProperties.ctype = 0x47FFFF;

	Update = &Element_BIZR_update;
	Graphics = &Element_BIZR_graphics;
}

constexpr float BLEND = 0.95f;

int Element_BIZR_update(UPDATE_FUNC_ARGS)
{
	if(parts[i].dcolour)
	{
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r)!=PT_BIZR && TYP(r)!=PT_BIZRG  && TYP(r)!=PT_BIZRS)
					{
						auto tr = float((parts[ID(r)].dcolour>>16)&0xFF);
						auto tg = float((parts[ID(r)].dcolour>>8)&0xFF);
						auto tb = float((parts[ID(r)].dcolour)&0xFF);
						auto ta = float((parts[ID(r)].dcolour>>24)&0xFF);

						auto mr = float((parts[i].dcolour>>16)&0xFF);
						auto mg = float((parts[i].dcolour>>8)&0xFF);
						auto mb = float((parts[i].dcolour)&0xFF);
						auto ma = float((parts[i].dcolour>>24)&0xFF);

						auto nr = int((tr*BLEND) + (mr*(1 - BLEND)));
						auto ng = int((tg*BLEND) + (mg*(1 - BLEND)));
						auto nb = int((tb*BLEND) + (mb*(1 - BLEND)));
						auto na = int((ta*BLEND) + (ma*(1 - BLEND)));

						parts[ID(r)].dcolour = nr<<16 | ng<<8 | nb | na<<24;
					}
				}
			}
		}
	}
	return 0;
}

int Element_BIZR_graphics(GRAPHICS_FUNC_ARGS)
 //BIZR, BIZRG, BIZRS
{
	int x = 0;
	float brightness = fabs(cpart->vx) + fabs(cpart->vy);
	if (cpart->ctype&0x3FFFFFFF)
	{
		*colg = 0;
		*colb = 0;
		*colr = 0;
		for (x=0; x<12; x++) {
			*colr += (cpart->ctype >> (x+18)) & 1;
			*colb += (cpart->ctype >>  x)     & 1;
		}
		for (x=0; x<12; x++)
			*colg += (cpart->ctype >> (x+9))  & 1;
		x = 624 / (*colr + *colg + *colb + 1);
		*colr *= x;
		*colg *= x;
		*colb *= x;
	}

	if(brightness>0)
	{
		brightness /= 5;
		*firea = 255;
		*fireg = int(*colg * brightness);
		*fireb = int(*colb * brightness);
		*firer = int(*colr * brightness);
		*pixel_mode |= FIRE_ADD;
	}
	*pixel_mode |= PMODE_BLUR;
	return 0;
}


=== src\simulation\elements\BIZR.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_BIZR_graphics(GRAPHICS_FUNC_ARGS);
int Element_BIZR_update(UPDATE_FUNC_ARGS);


=== src\simulation\elements\BIZRG.cpp ===

#include "simulation/ElementCommon.h"
#include "BIZR.h"

void Element::Element_BIZRG()
{
	Identifier = "DEFAULT_PT_BIZRG";
	Name = "BIZG";
	Colour = 0x00FFBB_rgb;
	MenuVisible = 0;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 1.0f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 2.75f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 1;

	DefaultProperties.temp = R_TEMP - 200.0f + 273.15f;
	HeatConduct = 42;
	Description = "Bizarre gas.";

	Properties = TYPE_GAS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 100.0f;
	HighTemperatureTransition = PT_BIZR;

	DefaultProperties.ctype = 0x47FFFF;

	Update = &Element_BIZR_update;
	Graphics = &Element_BIZR_graphics;
}


=== src\simulation\elements\BIZRS.cpp ===

#include "simulation/ElementCommon.h"
#include "BIZR.h"

void Element::Element_BIZRS()
{
	Identifier = "DEFAULT_PT_BIZRS";
	Name = "BIZS";
	Colour = 0x00E455_rgb;
	MenuVisible = 0;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = R_TEMP + 300.0f + 273.15f;
	HeatConduct = 251;
	Description = "Bizarre solid.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 400.0f;
	LowTemperatureTransition = PT_BIZR;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.ctype = 0x47FFFF;

	Update = &Element_BIZR_update;
	Graphics = &Element_BIZR_graphics;
}


=== src\simulation\elements\BMTL.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_BMTL()
{
	Identifier = "DEFAULT_PT_BMTL";
	Name = "BMTL";
	Colour = 0x505070_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Breakable metal. Common conductive building material, can melt and break under pressure.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC|PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 1.0f;
	HighPressureTransition = ST;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1273.0f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].tmp>1)
	{
		parts[i].tmp--;
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if ((TYP(r)==PT_METL || TYP(r)==PT_IRON) && sim->rng.chance(1, 100))
					{
						sim->part_change_type(ID(r),x+rx,y+ry,PT_BMTL);
						parts[ID(r)].tmp = (parts[i].tmp<=7) ? parts[i].tmp=1 : parts[i].tmp - sim->rng.between(0, 4);
					}
				}
			}
		}
	}
	else if (parts[i].tmp==1 && sim->rng.chance(1, 1000))
	{
		parts[i].tmp = 0;
		sim->part_change_type(i,x,y,PT_BRMT);
	}
	return 0;
}


=== src\simulation\elements\BOMB.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_BOMB()
{
	Identifier = "DEFAULT_PT_BOMB";
	Name = "BOMB";
	Colour = 0xFFF288_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	Description = "Bomb. Explodes and destroys all surrounding particles when it touches something.";

	Properties = TYPE_PART|PROP_SPARKSETTLE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if (rt!=PT_BOMB && rt!=PT_EMBR && rt!=PT_DMND && rt!=PT_CLNE && rt!=PT_PCLN && rt!=PT_BCLN && rt!=PT_VIBR)
				{
					int rad = 8, nt;
					sim->kill_part(i);
					for (auto nxj=-rad; nxj<=rad; nxj++)
					{
						for (auto nxi=-rad; nxi<=rad; nxi++)
						{
							if ((pow((float)nxi,2))/(pow((float)rad,2))+(pow((float)nxj,2))/(pow((float)rad,2))<=1)
							{
								int ynxj = y + nxj, xnxi = x + nxi;

								if ((ynxj < 0) || (ynxj >= YRES) || (xnxi <= 0) || (xnxi >= XRES))
									continue;

								nt = TYP(pmap[ynxj][xnxi]);
								if (nt!=PT_DMND && nt!=PT_CLNE && nt!=PT_PCLN && nt!=PT_BCLN && nt!=PT_VIBR)
								{
									if (nt)
										sim->kill_part(ID(pmap[ynxj][xnxi]));
									sim->pv[(ynxj)/CELL][(xnxi)/CELL] += 0.1f;
									auto nb = sim->create_part(-3, xnxi, ynxj, PT_EMBR);
									if (nb!=-1)
									{
										parts[nb].tmp = 2;
										parts[nb].life = 2;
										parts[nb].temp = MAX_TEMP;
									}
								}
							}
						}
					}
					for (auto nxj=-(rad+1); nxj<=(rad+1); nxj++)
					{
						for (auto nxi=-(rad+1); nxi<=(rad+1); nxi++)
						{
							if ((pow((float)nxi,2))/(pow((float)(rad+1),2))+(pow((float)nxj,2))/(pow((float)(rad+1),2))<=1 && !TYP(pmap[y+nxj][x+nxi]))
							{
								auto nb = sim->create_part(-3, x+nxi, y+nxj, PT_EMBR);
								if (nb!=-1)
								{
									parts[nb].tmp = 0;
									parts[nb].life = 50;
									parts[nb].temp = MAX_TEMP;
									parts[nb].vx = float(sim->rng.between(-20, 20));
									parts[nb].vy = float(sim->rng.between(-20, 20));
								}
							}
						}
					}
					return 1;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*pixel_mode |= PMODE_FLARE;
	return 1;
}


=== src\simulation\elements\BOYL.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_BOYL()
{
	Identifier = "DEFAULT_PT_BOYL";
	Name = "BOYL";
	Colour = 0x0A3200_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 1.0f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 0.18f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 1;

	DefaultProperties.temp = R_TEMP + 2.0f + 273.15f;
	HeatConduct = 42;
	Description = "Boyle, variable pressure gas. Expands when heated.";

	Properties = TYPE_GAS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	float limit = parts[i].temp / 100;
	if (sim->pv[y / CELL][x / CELL] < limit)
		sim->pv[y / CELL][x / CELL] += 0.001f*(limit - sim->pv[y / CELL][x / CELL]);
	if (sim->pv[y / CELL + 1][x / CELL] < limit)
		sim->pv[y / CELL + 1][x / CELL] += 0.001f*(limit - sim->pv[y / CELL + 1][x / CELL]);
	if (sim->pv[y / CELL - 1][x / CELL] < limit)
		sim->pv[y / CELL - 1][x / CELL] += 0.001f*(limit - sim->pv[y / CELL - 1][x / CELL]);

	sim->pv[y / CELL][x / CELL + 1]	+= 0.001f*(limit - sim->pv[y / CELL][x / CELL + 1]);
	sim->pv[y / CELL + 1][x / CELL + 1] += 0.001f*(limit - sim->pv[y / CELL + 1][x / CELL + 1]);
	sim->pv[y / CELL][x / CELL - 1]	+= 0.001f*(limit - sim->pv[y / CELL][x / CELL - 1]);
	sim->pv[y / CELL - 1][x / CELL - 1] += 0.001f*(limit - sim->pv[y / CELL - 1][x / CELL - 1]);

	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_WATR)
				{
					if (sim->rng.chance(1, 30))
						sim->part_change_type(ID(r),x+rx,y+ry,PT_FOG);
				}
				else if (TYP(r)==PT_O2)
				{
					if (sim->rng.chance(1, 9))
					{
						sim->kill_part(ID(r));
						sim->part_change_type(i,x,y,PT_WATR);
						sim->pv[y/CELL][x/CELL] += 4.0;
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\BRAY.cpp ===

#include "simulation/ElementCommon.h"

static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_BRAY()
{
	Identifier = "DEFAULT_PT_BRAY";
	Name = "BRAY";
	Colour = 0xFFFFFF_rgb;
	MenuVisible = 0;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Ray Point. Rays create points when they collide.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC|PROP_LIFE_KILL;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 30;

	Graphics = &graphics;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int x, trans = 255;
	if(cpart->tmp==0)
	{
		trans = cpart->life * 7;
		if (trans>255) trans = 255;
		if (cpart->ctype&0x3FFFFFFF) {
			*colg = 0;
			*colb = 0;
			*colr = 0;
			for (x=0; x<12; x++) {
				*colr += (cpart->ctype >> (x+18)) & 1;
				*colb += (cpart->ctype >>  x)	 & 1;
			}
			for (x=0; x<12; x++)
				*colg += (cpart->ctype >> (x+9))  & 1;
			x = 624/(*colr+*colg+*colb+1);
			*colr *= x;
			*colg *= x;
			*colb *= x;
		}
	}
	else if(cpart->tmp==1)
	{
		trans = cpart->life/4;
		if (trans>255) trans = 255;
		if (cpart->ctype&0x3FFFFFFF) {
			*colg = 0;
			*colb = 0;
			*colr = 0;
			for (x=0; x<12; x++) {
				*colr += (cpart->ctype >> (x+18)) & 1;
				*colb += (cpart->ctype >>  x)	 & 1;
			}
			for (x=0; x<12; x++)
				*colg += (cpart->ctype >> (x+9))  & 1;
			x = 624/(*colr+*colg+*colb+1);
			*colr *= x;
			*colg *= x;
			*colb *= x;
		}
	}
	else if(cpart->tmp==2)
	{
		trans = cpart->life*100;
		if (trans>255) trans = 255;
		*colr = 255;
		*colg = 150;
		*colb = 50;
	}
	*cola = trans;
	*pixel_mode &= ~PMODE;
	*pixel_mode |= PMODE_BLEND | PMODE_GLOW;
	return 0;
}


=== src\simulation\elements\BRCK.cpp ===

#include "simulation/ElementCommon.h"

static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_BRCK()
{
	Identifier = "DEFAULT_PT_BRCK";
	Name = "BRCK";
	Colour = 0x808080_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Brick, breakable building material.";

	Properties = TYPE_SOLID|PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 8.8f;
	HighPressureTransition = PT_STNE;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1223.0f;
	HighTemperatureTransition = PT_LAVA;

	Graphics = &graphics;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if (cpart->tmp == 1)
	{
		*pixel_mode |= FIRE_ADD;
		*colb += 100;

		*firea = 40;
		*firer = *colr;
		*fireg = *colg;
		*fireb = *colb;
	}
	return 0;
}


=== src\simulation\elements\BREC.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_BREC()
{
	Identifier = "DEFAULT_PT_BREC";
	Name = "BREL";
	Colour = 0x707060_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.18f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 2;
	Hardness = 2;

	Weight = 90;

	HeatConduct = 211;
	Description = "Broken electronics. Formed from EMP blasts, and when constantly sparked while under pressure, turns to EXOT.";

	Properties = TYPE_PART|PROP_CONDUCTS|PROP_LIFE_DEC|PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life)
	{
		if (sim->pv[y/CELL][x/CELL]>10.0f)
		{
			if (parts[i].temp>9000 && sim->pv[y/CELL][x/CELL]>30.0f && sim->rng.chance(1, 200))
			{
				sim->part_change_type(i, x ,y ,PT_EXOT);
				parts[i].life = 1000;
			}
			parts[i].temp += (sim->pv[y/CELL][x/CELL])/8;
		}

	}
	return 0;
}


=== src\simulation\elements\BRMT.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_BRMT()
{
	Identifier = "DEFAULT_PT_BRMT";
	Name = "BRMT";
	Colour = 0x705060_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 2;
	Hardness = 2;

	Weight = 90;

	HeatConduct = 211;
	Description = "Broken metal. Created when iron rusts or when metals break from pressure.";

	Properties = TYPE_PART|PROP_CONDUCTS|PROP_LIFE_DEC|PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1273.0f;
	HighTemperatureTransition = ST;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].temp > 523.15f)//250.0f+273.15f
	{
		auto tempFactor = int(1000 - ((523.15f-parts[i].temp)*2));
		if(tempFactor < 2)
			tempFactor = 2;
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r)==PT_BREC && sim->rng.chance(1, tempFactor))
					{
						if (sim->rng.chance(1, 2))
						{
							sim->create_part(ID(r), x+rx, y+ry, PT_THRM);
						}
						else
							sim->create_part(i, x, y, PT_THRM);
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\BTRY.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_BTRY()
{
	Identifier = "DEFAULT_PT_BTRY";
	Name = "BTRY";
	Colour = 0x858505_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Battery. Generates infinite electricity.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 2273.0f;
	HighTemperatureTransition = PT_PLSM;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if ((rx || ry) && abs(rx)+abs(ry)<4)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				auto pavg = sim->parts_avg(i,ID(r),PT_INSL);
				if (pavg!=PT_INSL && pavg!=PT_RSSS)
				{
					if ((elements[rt].Properties&PROP_CONDUCTS) && !(rt==PT_WATR||rt==PT_SLTW||rt==PT_NTCT||rt==PT_PTCT||rt==PT_INWR) && parts[ID(r)].life==0)
					{
						parts[ID(r)].life = 4;
						parts[ID(r)].ctype = rt;
						sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\BVBR.cpp ===

#include "simulation/ElementCommon.h"
#include "VIBR.h"

void Element::Element_BVBR()
{
	Identifier = "DEFAULT_PT_BVBR";
	Name = "BVBR";
	Colour = 0x005000_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.3f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.15f;
	Diffusion = 0.00f;
	HotAir = 0.0000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 67;

	DefaultProperties.temp = 273.15f;
	HeatConduct = 164;
	Description = "Broken vibranium.";

	Properties = TYPE_PART|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &Element_VIBR_update;
	Graphics = &Element_VIBR_graphics;
}


=== src\simulation\elements\C5.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_C5()
{
	Identifier = "DEFAULT_PT_C5";
	Name = "C-5";
	Colour = 0x2050E0_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 88;
	Description = "Cold explosive, set off by anything cold.";

	Properties = TYPE_SOLID | PROP_NEUTPENETRATE | PROP_PHOTPASS | PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if ((TYP(r)!=PT_C5 && parts[ID(r)].temp<100 && !sim->IsHeatInsulator(parts[ID(r)])) || TYP(r)==PT_CFLM)
				{
					if (sim->rng.chance(1, 6))
					{
						sim->part_change_type(i,x,y,PT_CFLM);
						parts[ID(r)].temp = parts[i].temp = 0;
						parts[i].life = sim->rng.between(50, 199);
						sim->pv[y/CELL][x/CELL] += 1.5;
					}
				}
			}
		}
	}
	if (parts[i].ctype && !parts[i].life)
	{
		float vx = ((parts[i].tmp << 16) >> 16) / 255.0f;
		float vy = (parts[i].tmp >> 16) / 255.0f;
		float dx = ((parts[i].tmp2 << 16) >> 16) / 255.0f;
		float dy = (parts[i].tmp2 >> 16) / 255.0f;
		auto r = sim->create_part(-3, x, y, PT_PHOT);
		if (r != -1)
		{
			parts[r].ctype = parts[i].ctype;
			parts[r].x += dx;
			parts[r].y += dy;
			parts[r].vx = vx;
			parts[r].vy = vy;
			parts[r].temp = parts[i].temp;
		}
		parts[i].ctype = 0;
		parts[i].tmp = 0;
		parts[i].tmp2 = 0;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(!cpart->ctype)
		return 0;

	int x = 0;
	*colr = *colg = *colb = 0;
	for (x=0; x<12; x++) {
		*colr += (cpart->ctype >> (x+18)) & 1;
		*colb += (cpart->ctype >>  x)     & 1;
	}
	for (x=0; x<12; x++)
		*colg += (cpart->ctype >> (x+9))  & 1;
	x = 624/(*colr+*colg+*colb+1);
	*colr *= x;
	*colg *= x;
	*colb *= x;

	*firea = 100;
	*firer = *colr;
	*fireg = *colg;
	*fireb = *colb;

	*pixel_mode &= ~PMODE_FLAT;
	*pixel_mode |= FIRE_ADD | PMODE_ADD | NO_DECO;
	return 0;
}


=== src\simulation\elements\CAUS.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_CAUS()
{
	Identifier = "DEFAULT_PT_CAUS";
	Name = "CAUS";
	Colour = 0x80FFA0_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 2.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 1.50f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 1;

	HeatConduct = 70;
	Description = "Caustic Gas, acts like ACID.";

	Properties = TYPE_GAS|PROP_DEADLY;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 75;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	bool converted = false;
	for (int rx = -2; rx <= 2; rx++)
	{
		for (int ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r) == PT_GAS)
				{
					if (sim->pv[(y+ry)/CELL][(x+rx)/CELL] > 3)
					{
						sim->part_change_type(ID(r), x+rx, y+ry, PT_RFRG);
						sim->part_change_type(i, x, y, PT_RFRG);
						converted = true;
					}
				}
				else if (TYP(r) != PT_ACID && TYP(r) != PT_CAUS && TYP(r) != PT_RFRG && TYP(r) != PT_RFGL)
				{
					if ((TYP(r) != PT_CLNE && TYP(r) != PT_PCLN && ((TYP(r) != PT_FOG && TYP(r) != PT_RIME) || parts[ID(r)].tmp <= 5) && sim->rng.chance(elements[TYP(r)].Hardness, 1000)) && parts[i].life > 50)
					{
						// GLAS protects stuff from acid
						if (sim->parts_avg(i, ID(r),PT_GLAS) != PT_GLAS)
						{
							float newtemp = ((60.0f - (float)elements[TYP(r)].Hardness)) * 7.0f;
							if (newtemp < 0)
								newtemp = 0;
							parts[i].temp += newtemp;
							parts[i].life--;
							sim->kill_part(ID(r));
						}
					}
					else if (parts[i].life <= 50)
					{
						sim->kill_part(i);
						return 1;
					}
				}
			}
		}
	}
	return converted;
}


=== src\simulation\elements\CBNW.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_CBNW()
{
	Identifier = "DEFAULT_PT_CBNW";
	Name = "BUBW";
	Colour = 0x2030D0_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	LatentHeat = 7500;
	Description = "Carbonated water. Slowly releases CO2.";

	Properties = TYPE_LIQUID|PROP_CONDUCTS|PROP_LIFE_DEC|PROP_NEUTPENETRATE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 273.15f;
	LowTemperatureTransition = PT_ICEI;
	HighTemperature = 373.0f;
	HighTemperatureTransition = PT_WTRV;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (sim->pv[y/CELL][x/CELL]<=3)
	{
		if (sim->pv[y/CELL][x/CELL] <= -0.5 || sim->rng.chance(1, 4000))
		{
			sim->part_change_type(i,x,y,PT_CO2);
			parts[i].ctype = 5;
			sim->pv[y/CELL][x/CELL] += 0.5f;
		}
	}
	if (parts[i].tmp2!=20) {
		parts[i].tmp2 -= (parts[i].tmp2>20)?1:-1;
	}
	else if (sim->rng.chance(1, 200))
	{
		parts[i].tmp2 = sim->rng.between(0, 39);
	}

	if(parts[i].tmp>0)
	{
		//Explode
		if(parts[i].tmp==1 && sim->rng.chance(3, 4))
		{
			sim->part_change_type(i,x,y,PT_CO2);
			parts[i].ctype = 5;
			sim->pv[y/CELL][x/CELL] += 0.2f;
		}
		parts[i].tmp--;
	}
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if ((elements[TYP(r)].Properties&TYPE_PART) && parts[i].tmp == 0 && sim->rng.chance(1, 83))
				{
					//Start explode
					parts[i].tmp = sim->rng.between(0, 24);
				}
				else if((elements[TYP(r)].Properties&TYPE_SOLID) && TYP(r)!=PT_DMND && TYP(r)!=PT_GLAS && parts[i].tmp == 0 && sim->rng.chance(int(2 - sim->pv[y/CELL][x/CELL]), 6667))
				{
					sim->part_change_type(i,x,y,PT_CO2);
					parts[i].ctype = 5;
					sim->pv[y/CELL][x/CELL] += 0.2f;
				}
				if (TYP(r)==PT_CBNW)
				{
					if(!parts[i].tmp)
					{
						if (parts[ID(r)].tmp)
						{
							parts[i].tmp = parts[ID(r)].tmp;
							if((ID(r))>i) //If the other particle hasn't been life updated
								parts[i].tmp--;
						}
					}
					else if(!parts[ID(r)].tmp)
					{
						parts[ID(r)].tmp = parts[i].tmp;
						if((ID(r))>i) //If the other particle hasn't been life updated
							parts[ID(r)].tmp++;
					}
				}
				else if (TYP(r)==PT_RBDM||TYP(r)==PT_LRBD)
				{
					if ((sim->legacy_enable||parts[i].temp>(273.15f+12.0f)) && sim->rng.chance(1, 166))
					{
						sim->part_change_type(i,x,y,PT_FIRE);
						parts[i].life = 4;
						parts[i].ctype = PT_WATR;
					}
				}
				else if (TYP(r)==PT_FIRE && parts[ID(r)].ctype!=PT_WATR){
					sim->kill_part(ID(r));
					if (sim->rng.chance(1, 50))
					{
						sim->kill_part(i);
						return 1;
					}
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int z = cpart->tmp2 - 20;//speckles!
	*colr += z * 1;
	*colg += z * 2;
	*colb += z * 8;
	return 0;
}


=== src\simulation\elements\CFLM.cpp ===

#include "simulation/ElementCommon.h"

static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_CFLM()
{
	Identifier = "DEFAULT_PT_HFLM";
	Name = "CFLM";
	Colour = 0x8080FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.9f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.97f;
	Loss = 0.20f;
	Collision = 0.0f;
	Gravity = -0.1f;
	Diffusion = 0.00f;
	HotAir = 0.0005f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 2;

	DefaultProperties.temp = 0.0f;
	HeatConduct = 88;
	Description = "Sub-zero flame.";

	Properties = TYPE_GAS|PROP_LIFE_DEC|PROP_LIFE_KILL;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Graphics = &graphics;
	Create = &create;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	RGB color = Renderer::clfmTableAt(cpart->life / 2);
	*colr = color.Red;
	*colg = color.Green;
	*colb = color.Blue;

	*firea = 255;
	*firer = *colr;
	*fireg = *colg;
	*fireb = *colb;

	*pixel_mode = PMODE_NONE; //Clear default, don't draw pixel
	*pixel_mode |= FIRE_ADD;
	//Returning 0 means dynamic, do not cache
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].life = sim->rng.between(50, 199);
}


=== src\simulation\elements\CLNE.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_CLNE()
{
	Identifier = "DEFAULT_PT_CLNE";
	Name = "CLNE";
	Colour = 0xFFD010_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Clone. Duplicates any particles it touches.";

	Properties = TYPE_SOLID | PROP_PHOTPASS | PROP_NOCTYPEDRAW;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	CtypeDraw = &Element::ctypeDrawVInTmp;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].ctype<=0 || parts[i].ctype>=PT_NUM || !elements[parts[i].ctype].Enabled)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				auto r = sim->photons[y+ry][x+rx];
				if (!r)
					r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if (rt!=PT_CLNE && rt!=PT_PCLN &&
				    rt!=PT_BCLN && rt!=PT_STKM &&
				    rt!=PT_PBCN && rt!=PT_STKM2 &&
				    rt<PT_NUM)
				{
					parts[i].ctype = rt;
					if (rt==PT_LIFE || rt==PT_LAVA)
						parts[i].tmp = parts[ID(r)].ctype;
				}
			}
		}
	}
	else
	{
		if (parts[i].ctype==PT_LIFE) sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), PT_LIFE, parts[i].tmp);
		else if (parts[i].ctype!=PT_LIGH || sim->rng.chance(1, 30))
		{
			int np = sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), TYP(parts[i].ctype));
			if (np>=0)
			{
				if (parts[i].ctype==PT_LAVA && parts[i].tmp>0 && parts[i].tmp<PT_NUM && elements[parts[i].tmp].HighTemperatureTransition==PT_LAVA)
					parts[np].ctype = parts[i].tmp;
			}
		}
	}
	return 0;
}


=== src\simulation\elements\CLST.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_CLST()
{
	Identifier = "DEFAULT_PT_CLST";
	Name = "CLST";
	Colour = 0xE4A4A4_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.2f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 2;
	Hardness = 2;

	Weight = 55;

	HeatConduct = 70;
	Description = "Clay dust. Produces paste when mixed with water.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1256.0f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_WATR)
				{
					if (sim->rng.chance(1, 1500))
					{
						sim->create_part(i, x, y, PT_PSTS);
						sim->kill_part(ID(r));
					}
				}
				else if (TYP(r)==PT_NITR)
				{
					sim->create_part(i, x, y, PT_BANG);
					sim->create_part(ID(r), x+rx, y+ry, PT_BANG);
				}
				else if (TYP(r)==PT_CLST)
				{
					float cxy;
					if(parts[i].temp <195)
						cxy = 0.05f;
					else if(parts[i].temp <295)
						cxy = 0.015f;
					else if(parts[i].temp <350)
						cxy = 0.01f;
					else
						cxy = 0.005f;
					parts[i].vx += cxy*rx;
					parts[i].vy += cxy*ry;//These two can be set not to calculate over 350 later. They do virtually nothing over 0.005.
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int z = (cpart->tmp - 5) * 16;//speckles!
	*colr += z;
	*colg += z;
	*colb += z;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].tmp = sim->rng.between(0, 6);
}


=== src\simulation\elements\CNCT.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_CNCT()
{
	Identifier = "DEFAULT_PT_CNCT";
	Name = "CNCT";
	Colour = 0xC0C0C0_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 2;
	Hardness = 2;

	Weight = 55;

	HeatConduct = 100;
	Description = "Concrete. Can stack on itself or ROCK, collapses with pressure.";

	Properties = TYPE_PART|PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1123.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\CO2.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_CO2()
{
	Identifier = "DEFAULT_PT_CO2";
	Name = "CO2";
	Colour = 0x666666_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 2.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.1f;
	Diffusion = 1.0f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 1;

	HeatConduct = 88;
	Description = "Carbon Dioxide. Heavy gas, drifts downwards. Carbonates water and turns to dry ice when cold.";

	Properties = TYPE_GAS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 194.65f;
	LowTemperatureTransition = PT_DRIC;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
				{
					if (parts[i].ctype==5 && sim->rng.chance(1, 2000))
					{
						if (sim->create_part(-1, x+rx, y+ry, PT_WATR)>=0)
							parts[i].ctype = 0;
					}
					continue;
				}
				if (TYP(r)==PT_FIRE)
				{
					sim->kill_part(ID(r));
					if (sim->rng.chance(1, 30))
					{
						sim->kill_part(i);
						return 1;
					}
				}
				else if ((TYP(r)==PT_WATR || TYP(r)==PT_DSTW) && sim->rng.chance(1, 50))
				{
					sim->part_change_type(ID(r), x+rx, y+ry, PT_CBNW);
					if (parts[i].ctype==5) //conserve number of water particles - ctype=5 means this CO2 hasn't released the water particle from BUBW yet
					{
						sim->create_part(i, x, y, PT_WATR);
						return 0;
					}
					else
					{
						sim->kill_part(i);
						return 1;
					}
				}
			}
		}
	}
	if (parts[i].temp > 9773.15 && sim->pv[y/CELL][x/CELL] > 200.0f)
	{
		if (sim->rng.chance(1, 5))
		{
			int j;
			sim->create_part(i,x,y,PT_O2);
			j = sim->create_part(-3,x,y,PT_NEUT);
			if (j != -1)
				parts[j].temp = MAX_TEMP;
			if (sim->rng.chance(1, 50))
			{
				j = sim->create_part(-3,x,y,PT_ELEC);
				if (j != -1)
					parts[j].temp = MAX_TEMP;
			}
			parts[i].temp = MAX_TEMP;
			sim->pv[y/CELL][x/CELL] += 100;
		}
	}
	return 0;
}


=== src\simulation\elements\COAL.cpp ===

#include "simulation/ElementCommon.h"
#include "COAL.h"

void Element::Element_COAL()
{
	Identifier = "DEFAULT_PT_COAL";
	Name = "COAL";
	Colour = 0x222222_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.0f;
	HotAir = 0.0f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;
	PhotonReflectWavelengths = 0x00000000;

	Weight = 100;

	HeatConduct = 200;
	Description = "Coal, Burns very slowly. Gets red when hot.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 110;
	DefaultProperties.tmp = 50;

	Update = &Element_COAL_update;
	Graphics = &Element_COAL_graphics;
}

int Element_COAL_update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life<=0) {
		sim->create_part(i, x, y, PT_FIRE);
		return 1;
	} else if (parts[i].life < 100) {
		parts[i].life--;
		sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), PT_FIRE);
	}
	if (parts[i].type == PT_COAL)
	{
		if ((sim->pv[y/CELL][x/CELL] > 4.3f)&&parts[i].tmp>40)
			parts[i].tmp=39;
		else if (parts[i].tmp<40&&parts[i].tmp>0)
			parts[i].tmp--;
		else if (parts[i].tmp<=0) {
			sim->part_change_type(i, x, y, PT_BCOL);
			return 1;
		}
	}
	if(parts[i].temp > parts[i].tmp2)
		parts[i].tmp2 = int(parts[i].temp);
	return 0;
}

constexpr float FREQUENCY = 3.1415f/(2*300.0f-(300.0f-200.0f));

int Element_COAL_graphics(GRAPHICS_FUNC_ARGS)
 //Both COAL and Broken Coal
{
	*colr += int((cpart->tmp2-295.15f)/3);

	if (*colr > 170)
		*colr = 170;
	if (*colr < *colg)
		*colr = *colg;

	*colg = *colb = *colr;

	// ((cpart->temp-295.15f) > 300.0f-200.0f)
	if (cpart->temp > 395.15f)
	{
		//  q = ((cpart->temp-295.15f)>300.0f)?300.0f-(300.0f-200.0f):(cpart->temp-295.15f)-(300.0f-200.0f);
		auto q = int((cpart->temp > 595.15f) ? 200.0f : cpart->temp - 395.15f);

		*colr += int(sin(FREQUENCY*q) * 226);
		*colg += int(sin(FREQUENCY*q*4.55 + TPT_PI_DBL) * 34);
		*colb += int(sin(FREQUENCY*q*2.22 + TPT_PI_DBL) * 64);
	}
	return 0;
}


=== src\simulation\elements\COAL.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_COAL_graphics(GRAPHICS_FUNC_ARGS);
int Element_COAL_update(UPDATE_FUNC_ARGS);


=== src\simulation\elements\CONV.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_CONV()
{
	Identifier = "DEFAULT_PT_CONV";
	Name = "CONV";
	Colour = 0x0AAB0A_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Converter. Converts everything into whatever it first touches.";

	Properties = TYPE_SOLID | PROP_NOCTYPEDRAW;
	CarriesTypeIn = (1U << FIELD_CTYPE) | (1U << FIELD_TMP);

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	CtypeDraw = &Element::ctypeDrawVInCtype;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int ctype = TYP(parts[i].ctype);
	if (ctype<=0 || ctype>=PT_NUM || !elements[ctype].Enabled || ctype==PT_CONV)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				auto r = sim->photons[y+ry][x+rx];
				if (!r)
					r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				int rt = TYP(r);
				if (rt != PT_CLNE && rt != PT_PCLN &&
				    rt != PT_BCLN && rt != PT_STKM &&
				    rt != PT_PBCN && rt != PT_STKM2 &&
				    rt != PT_CONV && rt < PT_NUM)
				{
					parts[i].ctype = rt;
					if (rt == PT_LIFE)
						parts[i].ctype |= PMAPID(parts[ID(r)].ctype);
				}
			}
		}
	}
	else
	{
		int restrictElement = sd.IsElement(parts[i].tmp) ? parts[i].tmp : 0;
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (x+rx>=0 && y+ry>=0 && x+rx<XRES && y+ry<YRES)
				{
					auto r = sim->photons[y+ry][x+rx];
					if (!r || (restrictElement && ((TYP(r) == restrictElement) == (parts[i].tmp2 == 1))))
						r = pmap[y+ry][x+rx];
					if (!r || (restrictElement && ((TYP(r) == restrictElement) == (parts[i].tmp2 == 1))))
						continue;
					if (TYP(r) != PT_CONV && TYP(r) != PT_DMND && TYP(r) != ctype)
					{
						sim->create_part(ID(r), x+rx, y+ry, TYP(parts[i].ctype), ID(parts[i].ctype));
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\CRAY.cpp ===

#include "simulation/ElementCommon.h"
#include "FILT.h"

static int update(UPDATE_FUNC_ARGS);
static bool ctypeDraw(CTYPEDRAW_FUNC_ARGS);
static unsigned int wavelengthToDecoColour(int wavelength);

void Element::Element_CRAY()
{
	Identifier = "DEFAULT_PT_CRAY";
	Name = "CRAY";
	Colour = 0xBBFF00_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Particle Ray Emitter. Creates a beam of particles set by its ctype, with a range set by tmp.";

	Properties = TYPE_SOLID;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	CtypeDraw = &ctypeDraw;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int nxx, nyy, docontinue, nxi, nyi;
	// set ctype to things that touch it if it doesn't have one already
	if (parts[i].ctype<=0 || !elements[TYP(parts[i].ctype)].Enabled)
	{
		for (int rx = -1; rx <= 1; rx++)
		{
			for (int ry = -1; ry <= 1; ry++)
			{
				int r = sim->photons[y+ry][x+rx];
				if (!r)
					r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)!=PT_CRAY && TYP(r)!=PT_PSCN && TYP(r)!=PT_INST && TYP(r)!=PT_METL && TYP(r)!=PT_SPRK && TYP(r)<PT_NUM)
				{
					parts[i].ctype = TYP(r);
					parts[i].temp = parts[ID(r)].temp;
				}
			}
		}
	}
	else
	{
		for (int rx =-1; rx <= 1; rx++)
		{
			for (int ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					int r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r)==PT_SPRK && parts[ID(r)].life==3) { //spark found, start creating
						unsigned int colored = 0;
						bool destroy = parts[ID(r)].ctype==PT_PSCN;
						bool nostop = parts[ID(r)].ctype==PT_INST;
						bool createSpark = (parts[ID(r)].ctype==PT_INWR);
						int partsRemaining = 255;
						if (parts[i].tmp) //how far it shoots
							partsRemaining = parts[i].tmp;
						int spacesRemaining = parts[i].tmp2;
						for (docontinue = 1, nxi = rx*-1, nyi = ry*-1, nxx = spacesRemaining*nxi, nyy = spacesRemaining*nyi; docontinue; nyy+=nyi, nxx+=nxi)
						{
							if (!(x+nxi+nxx<XRES && y+nyi+nyy<YRES && x+nxi+nxx >= 0 && y+nyi+nyy >= 0)) {
								break;
							}
							r = pmap[y+nyi+nyy][x+nxi+nxx];
							if (!sim->IsWallBlocking(x+nxi+nxx, y+nyi+nyy, TYP(parts[i].ctype)) && (!sim->pmap[y+nyi+nyy][x+nxi+nxx] || createSpark)) { // create, also set color if it has passed through FILT
								int nr = sim->create_part(-1, x+nxi+nxx, y+nyi+nyy, TYP(parts[i].ctype), ID(parts[i].ctype));
								if (nr!=-1) {
									if (colored)
										parts[nr].dcolour = colored;
									parts[nr].temp = parts[i].temp;
									if (parts[i].life>0)
										parts[nr].life = parts[i].life;
									if(!--partsRemaining)
										docontinue = 0;
								}
							} else if (TYP(r)==PT_FILT) { // get color if passed through FILT
								if (parts[ID(r)].dcolour == 0xFF000000)
									colored = 0xFF000000;
								else if (parts[ID(r)].tmp==0)
								{
									colored = wavelengthToDecoColour(Element_FILT_getWavelengths(&parts[ID(r)]));
								}
								else if (colored==0xFF000000)
									colored = 0;
								parts[ID(r)].life = 4;
							} else if (TYP(r) == PT_CRAY || nostop) {
								docontinue = 1;
							} else if(destroy && r && (TYP(r) != PT_DMND)) {
								sim->kill_part(ID(r));
								if(!--partsRemaining)
									docontinue = 0;
							}
							else
								docontinue = 0;
							if(!partsRemaining)
								docontinue = 0;
						}
					}
				}
			}
		}
	}
	return 0;
}

static unsigned int wavelengthToDecoColour(int wavelength)
{
	int colr = 0, colg = 0, colb = 0, x;
	for (x=0; x<12; x++) {
		colr += (wavelength >> (x+18)) & 1;
		colb += (wavelength >>  x)     & 1;
	}
	for (x=0; x<12; x++)
		colg += (wavelength >> (x+9))  & 1;
	x = 624/(colr+colg+colb+1);
	colr *= x;
	colg *= x;
	colb *= x;

	if(colr > 255) colr = 255;
	else if(colr < 0) colr = 0;
	if(colg > 255) colg = 255;
	else if(colg < 0) colg = 0;
	if(colb > 255) colb = 255;
	else if(colb < 0) colb = 0;

	return (255<<24) | (colr<<16) | (colg<<8) | colb;
}

static bool ctypeDraw(CTYPEDRAW_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (!Element::ctypeDrawVInCtype(CTYPEDRAW_FUNC_SUBCALL_ARGS))
	{
		return false;
	}
	if (t == PT_LIGH)
	{
		sim->parts[i].ctype |= PMAPID(30);
	}
	sim->parts[i].temp = elements[t].DefaultProperties.temp;
	return true;
}


=== src\simulation\elements\CRMC.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_CRMC()
{
	Identifier = "DEFAULT_PT_CRMC";
	Name = "CRMC";
	Colour = 0xD6D1D4_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 35;
	Description = "Ceramic. Gets stronger under pressure.";

	Properties = TYPE_SOLID | PROP_NEUTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 2887.15f;
	HighTemperatureTransition = ST;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	float origTemp = parts[i].temp;
	if (sim->pv[y/CELL][x/CELL] < -30.0f)
		sim->create_part(i, x, y, PT_CLST);
	parts[i].temp = origTemp;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int z = (cpart->tmp2 - 2) * 8;
	*colr += z;
	*colg += z;
	*colb += z;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].tmp2 = sim->rng.between(0, 4);
}


=== src\simulation\elements\DCEL.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_DCEL()
{
	Identifier = "DEFAULT_PT_DCEL";
	Name = "DCEL";
	Colour = 0x99CC00_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Decelerator, slows down nearby elements.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	float multiplier = 1.0f/1.1f;
	if (parts[i].life!=0)
	{
		multiplier = 1.0f - ((parts[i].life > 100 ? 100 : (parts[i].life < 0 ? 0 : parts[i].life)) / 100.0f);
	}
	parts[i].tmp = 0;
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if ((rx || ry) && !(rx && ry))
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					r = sim->photons[y+ry][x+rx];
				if (!r)
					continue;
				if (elements[TYP(r)].Properties & (TYPE_PART | TYPE_LIQUID | TYPE_GAS | TYPE_ENERGY))
				{
					parts[ID(r)].vx *= multiplier;
					parts[ID(r)].vy *= multiplier;
					parts[i].tmp = 1;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->tmp)
		*pixel_mode |= PMODE_GLOW;
	return 0;
}


=== src\simulation\elements\DESL.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_DESL()
{
	Identifier = "DEFAULT_PT_DESL";
	Name = "DESL";
	Colour = 0x440000_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 1.0f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.0f;
	HotAir = 0.0f	* CFDS;
	Falldown = 2;

	Flammable = 2;
	Explosive = 0;
	Meltable = 0;
	Hardness = 5;

	Weight = 15;

	HeatConduct = 42;
	Description = "Liquid diesel. Explodes under high pressure and temperatures.";

	Properties = TYPE_LIQUID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 5.0f;
	HighPressureTransition = PT_FIRE;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 335.0f;
	HighTemperatureTransition = PT_FIRE;
}


=== src\simulation\elements\DEST.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_DEST()
{
	Identifier = "DEFAULT_PT_DEST";
	Name = "DEST";
	Colour = 0xFF3311_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = -0.05f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.4f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 101;

	HeatConduct = 150;
	Description = "More destructive Bomb, can break through virtually anything.";

	Properties = TYPE_PART|PROP_LIFE_DEC|PROP_LIFE_KILL_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int rx = sim->rng.between(-2, 2);
	int ry = sim->rng.between(-2, 2);
	int r = pmap[y+ry][x+rx];
	if (!r)
		return 0;
	int rt = TYP(r);
	if (rt == PT_DEST || rt == PT_DMND || rt == PT_BCLN  || rt == PT_CLNE  || rt == PT_PCLN  || rt == PT_PBCN)
		return 0;

	if (parts[i].life<=0 || parts[i].life>37)
	{
		parts[i].life = sim->rng.between(30, 49);
		sim->pv[y/CELL][x/CELL]+=60.0f;
	}
	if (rt == PT_PLUT || rt == PT_DEUT)
	{
		sim->pv[y/CELL][x/CELL]+=20.0f;
		if (sim->rng.chance(1, 2))
		{
			sim->create_part(ID(r), x+rx, y+ry, PT_NEUT);
			parts[ID(r)].temp = MAX_TEMP;
			sim->pv[y/CELL][x/CELL] += 10.0f;
			parts[i].life-=4;
		}
	}
	else if (rt == PT_INSL)
	{
		sim->create_part(ID(r), x+rx, y+ry, PT_PLSM);
	}
	else if (sim->rng.chance(1, 3))
	{
		sim->kill_part(ID(r));
		parts[i].life -= 4*((elements[rt].Properties&TYPE_SOLID)?3:1);
		if (parts[i].life<=0)
			parts[i].life=1;
	}
	else if (!sim->IsHeatInsulator(parts[ID(r)]))
		parts[ID(r)].temp = MAX_TEMP;
	parts[i].temp=MAX_TEMP;
	sim->pv[y/CELL][x/CELL]+=80.0f;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->life)
	{
		*pixel_mode |= PMODE_LFLARE;
	}
	else
	{
		*pixel_mode |= PMODE_SPARK;
	}
	return 0;
}


=== src\simulation\elements\DEUT.cpp ===

#include "simulation/ElementCommon.h"
#include <algorithm>

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_DEUT()
{
	Identifier = "DEFAULT_PT_DEUT";
	Name = "DEUT";
	Colour = 0x00153F_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 31;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 251;
	Description = "Deuterium oxide. Gets more concentrated when cold, explodes with neutrons or protons.";

	Properties = TYPE_LIQUID|PROP_NEUTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 10;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto gravtot = std::abs(sim->gravOut.forceX[Vec2{ x, y } / CELL]) +
	               std::abs(sim->gravOut.forceY[Vec2{ x, y } / CELL]);
	// Prevent division by 0
	float temp = std::max(1.0f, (parts[i].temp + 1));
	auto maxlife = int(((10000/(temp + 1))-1));
	if (sim->rng.chance(10000 % static_cast<int>(temp + 1), static_cast<int>(temp + 1)))
		maxlife++;
	// Compress when Newtonian gravity is applied
	// multiplier=1 when gravtot=0, multiplier -> 5 as gravtot -> inf
	maxlife = maxlife*int(5.0f - 8.0f/(gravtot+2.0f));
	if (parts[i].life < maxlife)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r || (parts[i].life >=maxlife))
						continue;
					if (TYP(r)==PT_DEUT&& sim->rng.chance(1, 3))
					{
						// If neighbour life+1 fits in the free capacity for this particle, absorb neighbour
						// Condition is written in this way so that large neighbour life values don't cause integer overflow
						if (parts[ID(r)].life <= maxlife - parts[i].life - 1)
						{
							parts[i].life += parts[ID(r)].life + 1;
							sim->kill_part(ID(r));
						}
					}
				}
			}
		}
	}
	else
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					//Leave if there is nothing to do
					if (parts[i].life <= maxlife)
						goto trade;
					auto r = pmap[y+ry][x+rx];
					if ((!r)&&parts[i].life>=1)//if nothing then create deut
					{
						auto np = sim->create_part(-1,x+rx,y+ry,PT_DEUT);
						if (np<0) continue;
						parts[i].life--;
						parts[np].temp = parts[i].temp;
						parts[np].life = 0;
					}
				}
			}
		}
	}
trade:
	for (auto trade = 0; trade<4; trade ++)
	{
		auto rx = sim->rng.between(-2, 2);
		auto ry = sim->rng.between(-2, 2);
		if (rx || ry)
		{
			auto r = pmap[y+ry][x+rx];
			if (!r)
				continue;
			if (TYP(r)==PT_DEUT&&(parts[i].life>parts[ID(r)].life)&&parts[i].life>0)//diffusion
			{
				int temp = parts[i].life - parts[ID(r)].life;
				if (temp ==1)
				{
					parts[ID(r)].life ++;
					parts[i].life --;
				}
				else if (temp>0)
				{
					parts[ID(r)].life += temp/2;
					parts[i].life -= temp/2;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->life>=240)
	{
		*firea = 60;
		*firer = *colr += 255;
		*fireg = *colg += 255;
		*fireb = *colb += 255;
		*pixel_mode |= PMODE_GLOW | FIRE_ADD;
	}
	else if(cpart->life>0)
	{
		*colr += cpart->life*1;
		*colg += cpart->life*2;
		*colb += cpart->life*3;
		*pixel_mode |= PMODE_BLUR;
	}
	else
	{
		*pixel_mode |= PMODE_BLUR;
	}
	return 0;
}


=== src\simulation\elements\DLAY.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_DLAY()
{
	Identifier = "DEFAULT_PT_DLAY";
	Name = "DLAY";
	Colour = 0x753590_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = 4.0f + 273.15f;
	HeatConduct = 0;
	Description = "Conducts with temperature-dependent delay. (use HEAT/COOL).";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto oldl = parts[i].life;
	if (parts[i].life>0)
		parts[i].life--;
	if (parts[i].temp<= 1.0f+273.15f)
		parts[i].temp = 1.0f+273.15f;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				auto pavg = sim->parts_avg(ID(r), i, PT_INSL);
				if (!r || pavg==PT_INSL || pavg==PT_RSSS)
					continue;
				if (TYP(r)==PT_SPRK && parts[i].life==0 && parts[ID(r)].life>0 && parts[ID(r)].life<4 && parts[ID(r)].ctype==PT_PSCN)
				{
					parts[i].life = (int)(parts[i].temp-273.15f+0.5f);
				}
				else if (TYP(r)==PT_DLAY)
				{
					if (!parts[i].life)
					{
						if (parts[ID(r)].life)
						{
							parts[i].life = parts[ID(r)].life;
							if((ID(r))>i) //If the other particle hasn't been life updated
								parts[i].life--;
						}
					}
					else if (!parts[ID(r)].life)
					{
						parts[ID(r)].life = parts[i].life;
						if((ID(r))>i) //If the other particle hasn't been life updated
							parts[ID(r)].life++;
					}
				}
				else if(TYP(r)==PT_NSCN && oldl==1)
				{
					sim->create_part(-1, x+rx, y+ry, PT_SPRK);
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int stage = (int)(((float)cpart->life/(cpart->temp-273.15))*100.0f);
	*colr += stage;
	*colg += stage;
	*colb += stage;
	return 0;
}


=== src\simulation\elements\DMG.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_DMG()
{
	Identifier = "DEFAULT_PT_DMG";
	Name = "DMG";
	Colour = 0x88FF88_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	Description = "Generates damaging pressure and breaks any elements it hits.";

	Properties = TYPE_PART|PROP_SPARKSETTLE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int rad = 25;
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)!=PT_DMG && TYP(r)!=PT_EMBR && TYP(r)!=PT_DMND && TYP(r)!=PT_CLNE && TYP(r)!=PT_PCLN && TYP(r)!=PT_BCLN)
				{
					sim->kill_part(i);
					for (auto nxj=-rad; nxj<=rad; nxj++)
					{
						for (auto nxi=-rad; nxi<=rad; nxi++)
						{
							if (x+nxi>=0 && y+nxj>=0 && x+nxi<XRES && y+nxj<YRES && (nxi || nxj))
							{
								auto dist = int(sqrt(pow(nxi, 2.0f)+pow(nxj, 2.0f)));//;(pow((float)nxi,2))/(pow((float)rad,2))+(pow((float)nxj,2))/(pow((float)rad,2));
								if (!dist || (dist <= rad))
								{
									auto rr = pmap[y+nxj][x+nxi];
									if (rr)
									{
										auto angle = atan2((float)nxj, nxi);
										auto fx = cos(angle) * 7.0f;
										auto fy = sin(angle) * 7.0f;
										parts[ID(rr)].vx += fx;
										parts[ID(rr)].vy += fy;
										sim->vx[(y+nxj)/CELL][(x+nxi)/CELL] += fx;
										sim->vy[(y+nxj)/CELL][(x+nxi)/CELL] += fy;
										sim->pv[(y+nxj)/CELL][(x+nxi)/CELL] += 1.0f;
										auto t = TYP(rr);
										if (t && elements[t].HighPressureTransition>-1 && elements[t].HighPressureTransition<PT_NUM)
											sim->part_change_type(ID(rr), x+nxi, y+nxj, elements[t].HighPressureTransition);
										else if (t == PT_BMTL)
											sim->part_change_type(ID(rr), x+nxi, y+nxj, PT_BRMT);
										else if (t == PT_GLAS)
											sim->part_change_type(ID(rr), x+nxi, y+nxj, PT_BGLA);
										else if (t == PT_COAL)
											sim->part_change_type(ID(rr), x+nxi, y+nxj, PT_BCOL);
										else if (t == PT_QRTZ)
											sim->part_change_type(ID(rr), x+nxi, y+nxj, PT_PQRT);
										else if (t == PT_TUNG)
										{
											sim->part_change_type(ID(rr), x+nxi, y+nxj, PT_BRMT);
											parts[ID(rr)].ctype = PT_TUNG;
										}
										else if (t == PT_WOOD)
											sim->part_change_type(ID(rr), x+nxi, y+nxj, PT_SAWD);
									}
								}
							}
						}
					}
					return 1;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*pixel_mode |= PMODE_FLARE;
	return 1;
}


=== src\simulation\elements\DMND.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_DMND()
{
	Identifier = "DEFAULT_PT_DMND";
	Name = "DMND";
	Colour = 0xCCFFFF_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 186;
	Description = "Diamond. Indestructible.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}


=== src\simulation\elements\DRAY.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_DRAY()
{
	Identifier = "DEFAULT_PT_DRAY";
	Name = "DRAY";
	Colour = 0xFFAA22_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Duplicator ray. Replicates a line of particles in front of it.";

	Properties = TYPE_SOLID;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = nullptr; // is this needed?
	CtypeDraw = &Element::ctypeDrawVInCtype;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int ctype = TYP(parts[i].ctype), ctypeExtra = ID(parts[i].ctype), copyLength = parts[i].tmp, copySpaces = parts[i].tmp2;
	if (copySpaces < 0)
		copySpaces = parts[i].tmp2 = 0;
	if (copyLength < 0)
		copyLength = parts[i].tmp = 0;
	else if (copyLength > 0)
		copySpaces++; //strange hack

	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y+ry][x+rx];
				if (TYP(r) == PT_SPRK && parts[ID(r)].life == 3) //spark found, start creating
				{
					bool overwrite = parts[ID(r)].ctype == PT_PSCN;
					int partsRemaining = copyLength, xCopyTo = -1, yCopyTo = -1; //positions where the line will start being copied at
					int localCopyLength = copyLength;

					if (parts[ID(r)].ctype == PT_INWR && rx && ry) // INWR doesn't spark from diagonals
						continue;

					//figure out where the copying will start/end
					bool foundParticle = false;
					bool isEnergy = false;
					for (int xStep = rx*-1, yStep = ry*-1, xCurrent = x+xStep, yCurrent = y+yStep; ; xCurrent+=xStep, yCurrent+=yStep)
					{
						// Out of bounds, stop looking and don't copy anything
						if (!InBounds(xCurrent, yCurrent))
							break;
						int rr;
						// haven't found a particle yet, keep looking for one
						// the first particle it sees decides whether it will copy energy particles or not
						if (!foundParticle)
						{
							rr = pmap[yCurrent][xCurrent];
							if (!rr)
							{
								rr = sim->photons[yCurrent][xCurrent];
								if (rr)
									foundParticle = isEnergy = true;
							}
							else
								foundParticle = true;
						}
						// now that it knows what kind of particle it is copying, do some extra stuff here so we can determine when to stop
						if ((ctype && elements[ctype].Properties&TYPE_ENERGY) || isEnergy)
							rr = sim->photons[yCurrent][xCurrent];
						else
							rr = pmap[yCurrent][xCurrent];

						// Checks for when to stop:
						//  1: if .tmp isn't set, and the element in this spot is the ctype, then stop
						//  2: if .tmp is set, stop when the length limit reaches 0
						if ((!localCopyLength && TYP(rr) == ctype && (ctype != PT_LIFE || parts[ID(rr)].ctype == ctypeExtra))
								|| !--partsRemaining)
						{
							localCopyLength -= partsRemaining;
							xCopyTo = xCurrent + xStep*copySpaces;
							yCopyTo = yCurrent + yStep*copySpaces;
							break;
						}
					}

					// now, actually copy the particles
					partsRemaining = localCopyLength + 1;
					int type, p;
					for (int xStep = rx*-1, yStep = ry*-1, xCurrent = x+xStep, yCurrent = y+yStep; InBounds(xCopyTo, yCopyTo) && --partsRemaining; xCurrent+=xStep, yCurrent+=yStep, xCopyTo+=xStep, yCopyTo+=yStep)
					{
						// get particle to copy
						if (isEnergy)
							type = TYP(sim->photons[yCurrent][xCurrent]);
						else
							type = TYP(pmap[yCurrent][xCurrent]);

						// if sparked by PSCN, overwrite whatever is in the target location, instead of just ignoring it
						if (overwrite)
						{
							if (isEnergy)
							{
								if (sim->photons[yCopyTo][xCopyTo])
									sim->kill_part(ID(sim->photons[yCopyTo][xCopyTo]));
							}
							else
							{
								if (pmap[yCopyTo][xCopyTo])
									sim->kill_part(ID(pmap[yCopyTo][xCopyTo]));
							}
						}
						if (type == PT_SPRK) // spark hack
							p = sim->create_part(-1, xCopyTo, yCopyTo, PT_METL);
						else if (type)
							p = sim->create_part(-1, xCopyTo, yCopyTo, type);
						else
							continue;

						// if new particle was created successfully
						if (p >= 0)
						{
							if (type == PT_SPRK) // spark hack
								sim->part_change_type(p, xCopyTo, yCopyTo, PT_SPRK);
							if (isEnergy)
								parts[p] = parts[ID(sim->photons[yCurrent][xCurrent])];
							else
								parts[p] = parts[ID(pmap[yCurrent][xCurrent])];
							parts[p].x = float(xCopyTo);
							parts[p].y = float(yCopyTo);
						}
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\DRIC.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_DRIC()
{
	Identifier = "DEFAULT_PT_DRIC";
	Name = "DRIC";
	Colour = 0xE0E0E0_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = -0.0005f* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 100;

	DefaultProperties.temp = 172.65f;
	HeatConduct = 2;
	Description = "Dry Ice, formed when CO2 is cooled.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 195.65f;
	HighTemperatureTransition = PT_CO2;
}


=== src\simulation\elements\DSTW.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_DSTW()
{
	Identifier = "DEFAULT_PT_DSTW";
	Name = "DSTW";
	Colour = 0x1020C0_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 23;
	LatentHeat = 7500;
	Description = "Distilled water, does not conduct electricity.";

	Properties = TYPE_LIQUID | PROP_NEUTPASS | PROP_PHOTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 273.15f;
	LowTemperatureTransition = PT_ICEI;
	HighTemperature = 373.0f;
	HighTemperatureTransition = PT_WTRV;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				switch (TYP(r))
				{
				case PT_SALT:
					if (sim->rng.chance(1, 50))
					{
						sim->part_change_type(i,x,y,PT_SLTW);
						// on average, convert 3 DSTW to SLTW before SALT turns into SLTW
						if (sim->rng.chance(1, 3))
							sim->part_change_type(ID(r),x+rx,y+ry,PT_SLTW);
					}
					break;
				case PT_SLTW:
					if (sim->rng.chance(1, 2000))
					{
						sim->part_change_type(i,x,y,PT_SLTW);
						break;
					}
				case PT_WATR:
					if (sim->rng.chance(1, 100))
					{
						sim->part_change_type(i,x,y,PT_WATR);
					}
					break;
				case PT_RBDM:
				case PT_LRBD:
					if ((sim->legacy_enable||parts[i].temp>12.0f) && sim->rng.chance(1, 100))
					{
						sim->part_change_type(i,x,y,PT_FIRE);
						parts[i].life = 4;
					}
					break;
				case PT_FIRE:
					sim->kill_part(ID(r));
					if (sim->rng.chance(1, 30))
					{
						sim->kill_part(i);
						return 1;
					}
					break;
				default:
					continue;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\DTEC.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_DTEC()
{
	Identifier = "DEFAULT_PT_DTEC";
	Name = "DTEC";
	Colour = 0xFD9D18_rgb;
	MenuVisible = 1;
	MenuSection = SC_SENSOR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Detector, creates a spark when something with its ctype is nearby.";

	Properties = TYPE_SOLID;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.tmp2 = 2;

	Update = &update;
	CtypeDraw = &Element::ctypeDrawVInTmp;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int rd = parts[i].tmp2;
	if (rd > 25) parts[i].tmp2 = rd = 25;
	if (parts[i].life)
	{
		parts[i].life = 0;
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					auto rt = TYP(r);
					auto pavg = sim->parts_avg(i,ID(r),PT_INSL);
					if (pavg != PT_INSL && pavg != PT_RSSS)
					{
						if ((elements[rt].Properties&PROP_CONDUCTS) && !(rt==PT_WATR||rt==PT_SLTW||rt==PT_NTCT||rt==PT_PTCT||rt==PT_INWR) && parts[ID(r)].life==0)
						{
							parts[ID(r)].life = 4;
							parts[ID(r)].ctype = rt;
							sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
						}
					}
				}
			}
		}
	}
	bool setFilt = false;
	int photonWl = 0;
	for (auto rx=-rd; rx<rd+1; rx++)
	{
		for (auto ry=-rd; ry<rd+1; ry++)
		{
			if (x+rx>=0 && y+ry>=0 && x+rx<XRES && y+ry<YRES && (rx || ry))
			{
				auto r = pmap[y+ry][x+rx];
				if(!r)
					r = sim->photons[y+ry][x+rx];
				if(!r)
					continue;
				if (TYP(r) == parts[i].ctype && (parts[i].ctype != PT_LIFE || parts[i].tmp == parts[ID(r)].ctype || !parts[i].tmp))
					parts[i].life = 1;
				if (TYP(r) == PT_PHOT || (TYP(r) == PT_BRAY && parts[ID(r)].tmp!=2) || TYP(r) == PT_BIZR || TYP(r) == PT_BIZRG || TYP(r) == PT_BIZRS)
				{
					setFilt = true;
					photonWl = parts[ID(r)].ctype;
				}
			}
		}
	}
	if (setFilt)
	{
		int nx, ny;
		for (auto rx=-1; rx<2; rx++)
		{
			for (auto ry=-1; ry<2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					nx = x+rx;
					ny = y+ry;
					while (TYP(r)==PT_FILT)
					{
						parts[ID(r)].ctype = photonWl;
						nx += rx;
						ny += ry;
						if (nx<0 || ny<0 || nx>=XRES || ny>=YRES)
							break;
						r = pmap[ny][nx];
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\DUST.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_DUST()
{
	Identifier = "DEFAULT_PT_DUST";
	Name = "DUST";
	Colour = 0xFFE0A0_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 10;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;
	PhotonReflectWavelengths = 0x3FFFFFC0;

	Weight = 85;

	HeatConduct = 70;
	Description = "Very light dust. Flammable.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Graphics = nullptr; // it this needed?
}


=== src\simulation\elements\DYST.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_DYST()
{
	Identifier = "DEFAULT_PT_DYST";
	Name = "DYST";
	Colour = 0xBBB0A0_rgb;
	MenuVisible = 0;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 20;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 80;

	HeatConduct = 70;
	Description = "Dead Yeast.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 473.0f;
	HighTemperatureTransition = PT_DUST;
}


=== src\simulation\elements\E116.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_E116()
{
	Identifier = "DEFAULT_PT_116";
	Name = "EQVE";
	Colour = 0xFFE0A0_rgb;
	MenuVisible = 0;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 85;

	HeatConduct = 70;
	Description = "A failed shared velocity test.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}


=== src\simulation\elements\ELEC.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_ELEC()
{
	Identifier = "DEFAULT_PT_ELEC";
	Name = "ELEC";
	Colour = 0xDFEFFF_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 1.00f;
	Collision = -0.99f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = -1;

	DefaultProperties.temp = R_TEMP + 200.0f + 273.15f;
	HeatConduct = 251;
	Description = "Electrons. Sparks electronics, reacts with NEUT and WATR.";

	Properties = TYPE_ENERGY|PROP_LIFE_DEC|PROP_LIFE_KILL_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			auto r = pmap[y+ry][x+rx];
			if (!r)
				r = sim->photons[y+ry][x+rx];
			if (!r)
				continue;
			auto rt = TYP(r);
			switch (rt)
			{
			case PT_GLAS:
				for (auto rrx=-1; rrx<=1; rrx++)
				{
					for (auto rry=-1; rry<=1; rry++)
					{
						if (x+rx+rrx>=0 && y+ry+rry>=0 && x+rx+rrx<XRES && y+ry+rry<YRES) {
							auto nb = sim->create_part(-1, x+rx+rrx, y+ry+rry, PT_EMBR);
							if (nb!=-1) {
								parts[nb].tmp = 0;
								parts[nb].life = 50;
								parts[nb].temp = parts[i].temp*0.8f;
								parts[nb].vx = float(sim->rng.between(-10, 10));
								parts[nb].vy = float(sim->rng.between(-10, 10));
							}
						}
					}
				}
				sim->kill_part(i);
				return 1;
			case PT_LCRY:
				parts[ID(r)].tmp2 = sim->rng.between(5, 9);
				break;
			case PT_WATR:
			case PT_DSTW:
			case PT_SLTW:
			case PT_CBNW:
				if (sim->rng.chance(1, 3))
					sim->create_part(ID(r), x+rx, y+ry, PT_O2);
				else
					sim->create_part(ID(r), x+rx, y+ry, PT_H2);
				sim->kill_part(i);
				return 1;
			case PT_PROT: // this is the correct reaction, not NEUT, but leaving NEUT in anyway
				if (parts[ID(r)].tmp2 & 0x1)
					break;
			case PT_NEUT:
				sim->part_change_type(ID(r), x+rx, y+ry, PT_H2);
				parts[ID(r)].life = 0;
				parts[ID(r)].ctype = 0;
				sim->kill_part(i);
				break;
			case PT_DEUT:
				if(parts[ID(r)].life < 6000)
					parts[ID(r)].life += 1;
				parts[ID(r)].temp = 0;
				sim->kill_part(i);
				return 1;
			case PT_EXOT:
				parts[ID(r)].tmp2 += 5;
				parts[ID(r)].life = 1000;
				break;
			case PT_RSST: //Destroy RSST
				if(!rx && !ry)
				{
					sim->kill_part(ID(r));
					sim->kill_part(i);

					return 1;
				}
				break;
			case PT_NONE: //seems to speed up ELEC even if it isn't used
				break;
			default:
				if ((elements[rt].Properties & PROP_CONDUCTS) && (rt!=PT_NBLE||parts[i].temp<2273.15))
				{
					sim->create_part(-1, x+rx, y+ry, PT_SPRK);
					sim->kill_part(i);
					return 1;
				}
				break;
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 70;
	*firer = *colr;
	*fireg = *colg;
	*fireb = *colb;

	*pixel_mode |= FIRE_ADD;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	float a = sim->rng.between(0, 359) * 3.14159f / 180.0f;
	sim->parts[i].life = 680;
	sim->parts[i].vx = 2.0f * cosf(a);
	sim->parts[i].vy = 2.0f * sinf(a);
}


=== src\simulation\elements\EMBR.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_EMBR()
{
	Identifier = "DEFAULT_PT_EMBR";
	Name = "EMBR";
	Colour = 0xFFF288_rgb;
	MenuVisible = 0;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.001f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.90f;
	Collision = 0.0f;
	Gravity = 0.07f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	DefaultProperties.temp = 500.0f + 273.15f;
	HeatConduct = 29;
	Description = "Sparks. Formed by explosions.";

	Properties = TYPE_PART|PROP_LIFE_DEC|PROP_LIFE_KILL|PROP_SPARKSETTLE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 50;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if ((elements[TYP(r)].Properties & (TYPE_SOLID | TYPE_PART | TYPE_LIQUID)) && !(elements[TYP(r)].Properties & PROP_SPARKSETTLE))
				{
					sim->kill_part(i);
					return 1;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if (cpart->ctype&0xFFFFFF)
	{
		int maxComponent;
		*colr = (cpart->ctype&0xFF0000)>>16;
		*colg = (cpart->ctype&0x00FF00)>>8;
		*colb = (cpart->ctype&0x0000FF);
		maxComponent = *colr;

		if (*colg>maxComponent) maxComponent = *colg;
		if (*colb>maxComponent) maxComponent = *colb;
		if (maxComponent<60)//make sure it isn't too dark to see
		{
			float multiplier = 60.0f/maxComponent;
			*colr = int(*colr * multiplier);
			*colg = int(*colg * multiplier);
			*colb = int(*colb * multiplier);
		}
	}
	else if (cpart->tmp != 0)
	{
		*colr = *colg = *colb = 255;
	}

	bool deco = false;
	if (gfctx.ren->decorationLevel != RendererSettings::decorationDisabled && cpart->dcolour && (cpart->dcolour&0xFF000000))
	{
		if (gfctx.ren->decorationLevel == RendererSettings::decorationEnabled) // if blackDecorations is off, always show deco
			deco = true;
		else if (((cpart->dcolour>>24)&0xFF) >= 250 && ((cpart->dcolour>>16)&0xFF) <= 5 && ((cpart->dcolour>>8)&0xFF) <= 5 && ((cpart->dcolour)&0xFF) <= 5) // else only render black deco
			deco = true;
	}
	if (deco)
	{
		int a = (cpart->dcolour>>24)&0xFF;
		*colr = (a*((cpart->dcolour>>16)&0xFF) + (255-a)**colr) >> 8;
		*colg = (a*((cpart->dcolour>>8)&0xFF) + (255-a)**colg) >> 8;
		*colb = (a*((cpart->dcolour)&0xFF) + (255-a)**colb) >> 8;
	}
	*firer = *colr;
	*fireg = *colg;
	*fireb = *colb;
	if (cpart->tmp==1)
	{
		*pixel_mode = FIRE_ADD | PMODE_BLEND | PMODE_GLOW;
		*firea = (cpart->life-15)*4;
		*cola = (cpart->life+15)*4;
	}
	else if (cpart->tmp==2)
	{
		*pixel_mode = PMODE_FLAT | FIRE_ADD;
		*firea = 255;
	}
	else
	{
		*pixel_mode = PMODE_SPARK | PMODE_ADD;
		if (cpart->life<64) *cola = 4*cpart->life;
	}
	return 0;
}


=== src\simulation\elements\EMP.cpp ===

#include "simulation/ElementCommon.h"
#include "Probability.h"
#include "EMP.h"

static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_EMP()
{
	Identifier = "DEFAULT_PT_EMP";
	Name = "EMP";
	Colour = 0x66AAFF_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.0f;
	HotAir = 0.0f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 3;

	Weight = 100;

	HeatConduct = 121;
	Description = "Electromagnetic pulse. Breaks activated electronics.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Graphics = &graphics;
}

class DeltaTempGenerator
{
protected:
	float stepSize;
	unsigned int maxStepCount;
	Probability::SmallKBinomialGenerator binom;
public:
	DeltaTempGenerator(int n, float p, float tempStep) :
		stepSize(tempStep),
		// hardcoded limit of 10, to avoid massive lag if someone adds a few zeroes to MAX_TEMP
		maxStepCount((MAX_TEMP/stepSize < 10) ? ((unsigned int)(MAX_TEMP/stepSize)+1) : 10),
		binom(n, p, maxStepCount)
	{}
	float getDelta(float randFloat)
	{
		// randFloat should be a random float between 0 and 1
		return binom.calc(randFloat) * stepSize;
	}
	void apply(Simulation *sim, Particle &p)
	{
		p.temp = restrict_flt(p.temp+getDelta(sim->rng.uniform01()), MIN_TEMP, MAX_TEMP);
	}
};

void Element_EMP_Trigger(Simulation *sim, int triggerCount)
{
	/* Known differences from original one-particle-at-a-time version:
	 * - SPRK that disappears during a frame (such as SPRK with life==0 on that frame) will not cause destruction around it.
	 * - SPRK neighbour effects are calculated assuming the SPRK exists and causes destruction around it for the entire frame (so was not turned into BREL/NTCT partway through). This means mass EMP will be more destructive.
	 * - The chance of a METL particle near sparked semiconductor turning into BRMT within 1 frame is different if triggerCount>2. See comment for prob_breakMETLMore.
	 * - Probability of centre isElec particle breaking is slightly different (1/48 instead of 1-(1-1/80)*(1-1/120) = just under 1/48).
	 */

	Particle *parts = sim->parts;

	float prob_changeCenter = Probability::binomial_gte1(triggerCount, 1.0f/48);
	DeltaTempGenerator temp_center(triggerCount, 1.0f/100, 3000.0f);

	float prob_breakMETL = Probability::binomial_gte1(triggerCount, 1.0f/300);
	float prob_breakBMTL = Probability::binomial_gte1(triggerCount, 1.0f/160);
	DeltaTempGenerator temp_metal(triggerCount, 1.0f/280, 3000.0f);
	/* Probability of breaking from BMTL to BRMT, given that the particle has just broken from METL to BMTL. There is no mathematical reasoning for the numbers used, other than:
	 * - larger triggerCount should make this more likely, so it should depend on triggerCount instead of being a constant probability
	 * - triggerCount==1 should make this a chance of 0 (matching previous behaviour)
	 * - triggerCount==2 should make this a chance of 1/160 (matching previous behaviour)
	 */
	// TODO: work out in a more mathematical way what this should be?
	float prob_breakMETLMore = Probability::binomial_gte1(triggerCount/2, 1.0f/160);

	float prob_randWIFI = Probability::binomial_gte1(triggerCount, 1.0f/8);
	float prob_breakWIFI = Probability::binomial_gte1(triggerCount, 1.0f/16);

	float prob_breakSWCH = Probability::binomial_gte1(triggerCount, 1.0f/100);
	DeltaTempGenerator temp_SWCH(triggerCount, 1.0f/100, 2000.0f);

	float prob_breakARAY = Probability::binomial_gte1(triggerCount, 1.0f/60);

	float prob_randDLAY = Probability::binomial_gte1(triggerCount, 1.0f/70);

	for (int r = 0; r <=sim->parts.lastActiveIndex; r++)
	{
		int t = parts[r].type;
		auto rx = int(parts[r].x);
		auto ry = int(parts[r].y);
		if (t==PT_SPRK || (t==PT_SWCH && parts[r].life!=0 && parts[r].life!=10) || (t==PT_WIRE && parts[r].ctype>0))
		{
			bool is_elec = false;
			if (parts[r].ctype==PT_PSCN || parts[r].ctype==PT_NSCN || parts[r].ctype==PT_PTCT ||
			    parts[r].ctype==PT_NTCT || parts[r].ctype==PT_INST || parts[r].ctype==PT_SWCH || t==PT_WIRE || t==PT_SWCH)
			{
				is_elec = true;
				temp_center.apply(sim, parts[r]);
				if (sim->rng.uniform01() < prob_changeCenter)
				{
					if (sim->rng.chance(2, 5))
						sim->part_change_type(r, rx, ry, PT_BREC);
					else
						sim->part_change_type(r, rx, ry, PT_NTCT);
				}
			}
			for (int nx =-2; nx <= 2; nx++)
				for (int ny =-2; ny <= 2; ny++)
					if (rx+nx>=0 && ry+ny>=0 && rx+nx<XRES && ry+ny<YRES && (rx || ry))
					{
						int n = sim->pmap[ry+ny][rx+nx];
						if (!n)
							continue;
						int ntype = TYP(n);
						n = ID(n);
						//Some elements should only be affected by wire/swch, or by a spark on inst/semiconductor
						//So not affected by spark on metl, watr etc
						if (is_elec)
						{
							switch (ntype)
							{
							case PT_METL:
								temp_metal.apply(sim, parts[n]);
								if (sim->rng.uniform01() < prob_breakMETL)
								{
									sim->part_change_type(n, rx+nx, ry+ny, PT_BMTL);
									if (sim->rng.uniform01() < prob_breakMETLMore)
									{
										sim->part_change_type(n, rx+nx, ry+ny, PT_BRMT);
										parts[n].temp = restrict_flt(parts[n].temp+1000.0f, MIN_TEMP, MAX_TEMP);
									}
								}
								break;
							case PT_BMTL:
								temp_metal.apply(sim, parts[n]);
								if (sim->rng.uniform01() < prob_breakBMTL)
								{
									sim->part_change_type(n, rx+nx, ry+ny, PT_BRMT);
									parts[n].temp = restrict_flt(parts[n].temp+1000.0f, MIN_TEMP, MAX_TEMP);
								}
								break;
							case PT_WIFI:
								if (sim->rng.uniform01() < prob_randWIFI)
								{
									// Randomize channel
									parts[n].temp = float(sim->rng.between(0, int(MAX_TEMP)-1));
								}
								if (sim->rng.uniform01() < prob_breakWIFI)
								{
									sim->create_part(n, rx+nx, ry+ny, PT_BREC);
									parts[n].temp = restrict_flt(parts[n].temp+1000.0f, MIN_TEMP, MAX_TEMP);
								}
								continue;
							default:
								break;
							}
						}
						switch (ntype)
						{
						case PT_SWCH:
							if (sim->rng.uniform01() < prob_breakSWCH)
								sim->part_change_type(n, rx+nx, ry+ny, PT_BREC);
							temp_SWCH.apply(sim, parts[n]);
							break;
						case PT_ARAY:
							if (sim->rng.uniform01() < prob_breakARAY)
							{
								sim->create_part(n, rx+nx, ry+ny, PT_BREC);
								parts[n].temp = restrict_flt(parts[n].temp+1000.0f, MIN_TEMP, MAX_TEMP);
							}
							break;
						case PT_DLAY:
							if (sim->rng.uniform01() < prob_randDLAY)
							{
								// Randomize delay
								parts[n].temp = sim->rng.between(0, 255) + 273.15f;
							}
							break;
						default:
							break;
						}
					}
		}
	}
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->life)
	{
		*colr = int(cpart->life*1.5);
		*colg = int(cpart->life*1.5);
		*colb = 200-(cpart->life);
	}
	return 0;
}


=== src\simulation\elements\EMP.h ===

#pragma once
#include "simulation/ElementDefs.h"

void Element_EMP_Trigger(Simulation *sim, int triggerCount);


=== src\simulation\elements\ETRD.cpp ===

#include "simulation/ElementCommon.h"
#include "ETRD.h"
#include <algorithm>

static void initDeltaPos();
static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS);

void Element::Element_ETRD()
{
	Identifier = "DEFAULT_PT_ETRD";
	Name = "ETRD";
	Colour = 0x404040_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Electrode. Creates plasma arcs with electricity. (Use sparingly)";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	ChangeType = &changeType;

	initDeltaPos();
}

static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS)
{
	if (sim->etrd_count_valid)
	{
		if (from == PT_ETRD && sim->parts[i].life == 0)
			sim->etrd_life0_count--;
		if (to == PT_ETRD && sim->parts[i].life == 0)
			sim->etrd_life0_count++;
	}
}

class ETRD_deltaWithLength
{
public:
	ETRD_deltaWithLength(ui::Point a, int b):
		d(a),
		length(b)
	{

	}

	ui::Point d;
	int length;
};

const int maxLength = 12;
std::vector<ETRD_deltaWithLength> deltaPos;

static void initDeltaPos()
{
	deltaPos.clear();
	for (int ry = -maxLength; ry <= maxLength; ry++)
		for (int rx = -maxLength; rx <= maxLength; rx++)
		{
			ui::Point d(rx, ry);
			if (std::abs(d.X) + std::abs(d.Y) <= maxLength)
				deltaPos.push_back(ETRD_deltaWithLength(d, int(std::hypot(d.X, d.Y))));
		}
	std::stable_sort(deltaPos.begin(), deltaPos.end(), [](const ETRD_deltaWithLength &a, const ETRD_deltaWithLength &b) {
		return a.length < b.length;
	});
}

int Element_ETRD_nearestSparkablePart(Simulation *sim, int targetId)
{
	if (!sim->elementCount[PT_ETRD])
		return -1;
	if (sim->etrd_count_valid && sim->etrd_life0_count <= 0)
		return -1;

	Particle *parts = sim->parts;
	if (parts[targetId].tmp2 && parts[targetId].tmp > parts[targetId].tmp2) // Invalid range if max is set
		return -1;

	const int maxDistance = int(std::hypot(XRES, YRES));
	int foundDistance = parts[targetId].tmp2 ? std::min(parts[targetId].tmp2, maxDistance) : maxDistance; // tmp2 sets max distance
	int foundI = -1;
	ui::Point targetPos = ui::Point(int(parts[targetId].x), int(parts[targetId].y));

	if (sim->etrd_count_valid)
	{
		// countLife0 doesn't need recalculating, so just focus on finding the nearest particle

		// If the simulation contains lots of particles, check near the target position first since going through all particles will be slow.
		// Threshold = number of positions checked, *2 because it's likely to access memory all over the place (less cache friendly) and there's extra logic needed
		// TODO: probably not optimal if excessive stacking is used
		if (sim->parts.lastActiveIndex > (int)deltaPos.size()*2)
		{
			for (std::vector<ETRD_deltaWithLength>::iterator iter = deltaPos.begin(), end = deltaPos.end(); iter != end; ++iter)
			{
				ETRD_deltaWithLength delta = (*iter);
				ui::Point checkPos = targetPos + delta.d;
				int checkDistance = delta.length;
				if (parts[targetId].tmp >= checkDistance) // tmp sets min distance
				{
					continue;
				}
				if (foundDistance < checkDistance)
				{
					// deltaPos is sorted in order of ascending length, so foundDistance < checkDistance means all later items are further away.
					break;
				}
				if (InBounds(checkPos.X, checkPos.Y) && checkDistance <= foundDistance)
				{
					int r = sim->pmap[checkPos.Y][checkPos.X];
					if (r && TYP(r) == PT_ETRD && !parts[ID(r)].life && ID(r) != targetId && checkDistance < foundDistance)
					{
						foundDistance = checkDistance;
						foundI = ID(r);
					}
				}
			}
		}
		// If neighbor search didn't find a suitable particle, search all particles
		if (foundI < 0)
		{
			for (int i = 0; i <= sim->parts.lastActiveIndex; i++)
			{
				if (parts[i].type == PT_ETRD && !parts[i].life)
				{
					ui::Point checkPos = ui::Point(int(parts[i].x)-targetPos.X, int(parts[i].y)-targetPos.Y);
					int checkDistance = int(std::hypot(checkPos.X, checkPos.Y));
					if (checkDistance < foundDistance && checkDistance > parts[targetId].tmp && i != targetId) // tmp sets min distance
					{
						foundDistance = checkDistance;
						foundI = i;
					}
				}
			}
		}
	}
	else
	{
		// Recalculate countLife0, and search for the closest suitable particle
		int countLife0 = 0;
		for (int i = 0; i <= sim->parts.lastActiveIndex; i++)
		{
			if (parts[i].type == PT_ETRD && !parts[i].life)
			{
				countLife0++;
				ui::Point checkPos = ui::Point(int(parts[i].x)-targetPos.X, int(parts[i].y)-targetPos.Y);
				int checkDistance = int(std::hypot(checkPos.X, checkPos.Y));
				if (checkDistance < foundDistance && checkDistance > parts[targetId].tmp && i != targetId) // tmp sets min distance
				{
					foundDistance = checkDistance;
					foundI = i;
				}
			}
		}
		sim->etrd_life0_count = countLife0;
		sim->etrd_count_valid = true;
	}
	return foundI;
}


=== src\simulation\elements\ETRD.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_ETRD_nearestSparkablePart(Simulation *sim, int targetId);


=== src\simulation\elements\EXOT.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_EXOT()
{
	Identifier = "DEFAULT_PT_EXOT";
	Name = "EXOT";
	Colour = 0x247BFE_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.3f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.15f;
	Diffusion = 0.00f;
	HotAir = 0.0003f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 2;

	Weight = 46;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 250;
	Description = "Exotic matter. Explodes with excess exposure to electrons. Has many other odd reactions.";

	Properties = TYPE_LIQUID|PROP_NEUTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 1000;
	DefaultProperties.tmp = 244;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if (rt == PT_WARP)
				{
					if (parts[ID(r)].tmp2>2000 && sim->rng.chance(1, 100))
					{
						parts[i].tmp2 += 100;
					}
				}
				else if (rt == PT_EXOT)
				{
					if (parts[ID(r)].ctype == PT_PROT)
						parts[i].ctype = PT_PROT;
					if (parts[ID(r)].life == 1500 && sim->rng.chance(1, 1000))
						parts[i].life = 1500;
				}
				else if (rt == PT_LAVA)
				{
					//turn molten TTAN or molten GOLD to molten VIBR
					if (parts[ID(r)].ctype == PT_TTAN || parts[ID(r)].ctype == PT_GOLD)
					{
						if (sim->rng.chance(1, 10))
						{
							parts[ID(r)].ctype = PT_VIBR;
							sim->kill_part(i);
							return 1;
						}
					}
					//molten VIBR will kill the leftover EXOT though, so the VIBR isn't killed later
					else if (parts[ID(r)].ctype == PT_VIBR)
					{
						if (sim->rng.chance(1, 1000))
						{
							sim->kill_part(i);
							return 1;
						}
					}
				}
				if (parts[i].tmp > 245 && parts[i].life > 1337)
					if (rt!=PT_EXOT && rt!=PT_BREC && rt!=PT_DMND && rt!=PT_CLNE && rt!=PT_PRTI && rt!=PT_PRTO && rt!=PT_PCLN && rt!=PT_VOID && rt!=PT_NBHL && rt!=PT_WARP)
					{
						if (sim->create_part(i, x, y, rt) != -1)
						{
							return 1;
						}
					}
			}
		}
	}

	parts[i].tmp--;
	parts[i].tmp2--;
	//reset tmp every 250 frames, gives EXOT it's slow flashing effect
	if (parts[i].tmp < 1 || parts[i].tmp > 250)
		parts[i].tmp = 250;

	if (parts[i].tmp2 < 1)
		parts[i].tmp2 = 1;
	else if (parts[i].tmp2 > 6000)
	{
		parts[i].tmp2 = 10000;
		if (parts[i].life < 1001)
		{
			sim->part_change_type(i, x, y, PT_WARP);
			return 1;
		}
	}
	else if(parts[i].life < 1001)
		sim->pv[y/CELL][x/CELL] += (parts[i].tmp2*CFDS)/160000;

	if (sim->pv[y/CELL][x/CELL]>200 && parts[i].temp>9000 && parts[i].tmp2>200)
	{
		parts[i].tmp2 = 6000;
		sim->part_change_type(i, x, y, PT_WARP);
		return 1;
	}
	if (parts[i].tmp2 > 100)
	{
		for (auto trade = 0; trade < 9; trade++)
		{
			auto rx = sim->rng.between(-2, 2);
			auto ry = sim->rng.between(-2, 2);
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_EXOT && (parts[i].tmp2 > parts[ID(r)].tmp2) && parts[ID(r)].tmp2 >= 0) //diffusion
				{
					auto tym = parts[i].tmp2 - parts[ID(r)].tmp2;
					if (tym == 1)
					{
						parts[ID(r)].tmp2++;
						parts[i].tmp2--;
						break;
					}
					if (tym > 0)
					{
						parts[ID(r)].tmp2 += tym/2;
						parts[i].tmp2 -= tym/2;
						break;
					}
				}
			}
		}
	}
	if (parts[i].ctype == PT_PROT)
	{
		if (parts[i].temp < 50.0f)
		{
			if (sim->create_part(i, x, y, PT_CFLM) != -1) // I don't see how this could fail but whatever
			{
				return 1;
			}
		}
		else
			parts[i].temp -= 1.0f;
	}
	else if (parts[i].temp < 273.15f)
	{
		parts[i].vx = 0;
		parts[i].vy = 0;
		sim->pv[y/CELL][x/CELL] -= 0.01f;
		parts[i].tmp--;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	auto q = cpart->temp;
	auto b = cpart->tmp;
	auto c = cpart->tmp2;
	if (cpart->life < 1001)
	{
		if (gfctx.rng.chance(cpart->tmp2 - 1, 1000))
		{
			float frequency = 0.04045f;
			*colr = int(sin(frequency*c + 4) * 127 + 150);
			*colg = int(sin(frequency*c + 6) * 127 + 150);
			*colb = int(sin(frequency*c + 8) * 127 + 150);

			*firea = 100;
			*firer = 0;
			*fireg = 0;
			*fireb = 0;

			*pixel_mode |= PMODE_FLAT;
			*pixel_mode |= PMODE_FLARE;
		}
		else
		{
			float frequency = 0.00045f;
			*colr = int(sin(frequency*q + 4) * 127 + (b/1.7));
			*colg = int(sin(frequency*q + 6) * 127 + (b/1.7));
			*colb = int(sin(frequency*q + 8) * 127 + (b/1.7));
			*cola = cpart->tmp / 6;

			*firea = *cola;
			*firer = *colr;
			*fireg = *colg;
			*fireb = *colb;

			*pixel_mode |= FIRE_ADD;
			*pixel_mode |= PMODE_BLUR;
		}
	}
	else
	{
		float frequency = 0.01300f;
		*colr = int(sin(frequency*q + 6.00) * 127 + ((b/2.9) + 80));
		*colg = int(sin(frequency*q + 6.00) * 127 + ((b/2.9) + 80));
		*colb = int(sin(frequency*q + 6.00) * 127 + ((b/2.9) + 80));
		*cola = cpart->tmp / 6;
		*firea = *cola;
		*firer = *colr;
		*fireg = *colg;
		*fireb = *colb;
		*pixel_mode |= FIRE_ADD;
		*pixel_mode |= PMODE_BLUR;
	}
	return 0;
}


=== src\simulation\elements\FIGH.cpp ===

#include "simulation/ElementCommon.h"
#include "STKM.h"

static int update(UPDATE_FUNC_ARGS);
static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS);
static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS);
static void Free(Simulation *sim, unsigned char i);

void Element::Element_FIGH()
{
	Identifier = "DEFAULT_PT_FIGH";
	Name = "FIGH";
	Colour = 0xFFE0A0_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.5f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.2f;
	Loss = 1.0f;
	Collision = 0.0f;
	Gravity = 0.0f;
	NewtonianGravity = 0.0f;
	Diffusion = 0.0f;
	HotAir = 0.00f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 50;

	DefaultProperties.temp = R_TEMP + 14.6f + 273.15f;
	HeatConduct = 0;
	Description = "Fighter. Tries to kill stickmen. You must first give it an element to kill him with.";

	Properties = PROP_NOCTYPEDRAW;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 620.0f;
	HighTemperatureTransition = PT_FIRE;

	DefaultProperties.life = 100;

	Update = &update;
	Graphics = &Element_STKM_graphics;
	CreateAllowed = &createAllowed;
	ChangeType = &changeType;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].tmp < 0 || parts[i].tmp >= MAX_FIGHTERS)
	{
		sim->kill_part(i);
		return 1;
	}
	playerst* figh = &sim->fighters[(unsigned char)parts[i].tmp];

	int tarx = 0, tary = 0;

	parts[i].tmp2 = 0; //0 - stay in place, 1 - seek a stick man

	//Set target cords
	if (sim->player2.spwn)
	{
		if (sim->player.spwn && (pow((float)sim->player.legs[2]-x, 2) + pow((float)sim->player.legs[3]-y, 2))<=
		   (pow((float)sim->player2.legs[2]-x, 2) + pow((float)sim->player2.legs[3]-y, 2)))
		{
			tarx = (int)sim->player.legs[2];
			tary = (int)sim->player.legs[3];
		}
		else
		{
			tarx = (int)sim->player2.legs[2];
			tary = (int)sim->player2.legs[3];
		}
		parts[i].tmp2 = 1;
	}
	else if (sim->player.spwn)
	{
		tarx = (int)sim->player.legs[2];
		tary = (int)sim->player.legs[3];
		parts[i].tmp2 = 1;
	}

	switch (parts[i].tmp2)
	{
	case 1:
		if ((pow(float(tarx-x), 2) + pow(float(tary-y), 2))<600)
		{
			if (figh->elem == PT_LIGH || figh->elem == PT_NEUT
			    || elements[figh->elem].Properties & (PROP_DEADLY | PROP_RADIOACTIVE)
			    || elements[figh->elem].DefaultProperties.temp >= 323 || elements[figh->elem].DefaultProperties.temp <= 243)
				figh->comm = (int)figh->comm | 0x08;
		}
		else if (tarx<x)
		{
			if(figh->rocketBoots || !(sim->eval_move(PT_FIGH, int(figh->legs[4])-10, int(figh->legs[5])+6, nullptr)
			     && sim->eval_move(PT_FIGH, int(figh->legs[4])-10, int(figh->legs[5])+3, nullptr)))
				figh->comm = 0x01;
			else
				figh->comm = 0x02;

			if (figh->rocketBoots)
			{
				if (tary<y)
					figh->comm = (int)figh->comm | 0x04;
			}
			else if (!sim->eval_move(PT_FIGH, int(figh->legs[4])-4, int(figh->legs[5])-1, nullptr)
			    || !sim->eval_move(PT_FIGH, int(figh->legs[12])-4, int(figh->legs[13])-1, nullptr)
			    || sim->eval_move(PT_FIGH, 2*int(figh->legs[4])-int(figh->legs[6]), int(figh->legs[5])+5, nullptr))
				figh->comm = (int)figh->comm | 0x04;
		}
		else
		{
			if (figh->rocketBoots || !(sim->eval_move(PT_FIGH, int(figh->legs[12])+10, int(figh->legs[13])+6, nullptr)
			      && sim->eval_move(PT_FIGH, int(figh->legs[12])+10, int(figh->legs[13])+3, nullptr)))
				figh->comm = 0x02;
			else
				figh->comm = 0x01;

			if (figh->rocketBoots)
			{
				if (tary<y)
					figh->comm = (int)figh->comm | 0x04;
			}
			else if (!sim->eval_move(PT_FIGH, int(figh->legs[4])+4, int(figh->legs[5])-1, nullptr)
			    || !sim->eval_move(PT_FIGH, int(figh->legs[4])+4, int(figh->legs[5])-1, nullptr)
			    || sim->eval_move(PT_FIGH, 2*int(figh->legs[12])-int(figh->legs[14]), int(figh->legs[13])+5, nullptr))
				figh->comm = (int)figh->comm | 0x04;
		}
		break;
	default:
		figh->comm = 0;
		break;
	}

	figh->pcomm = figh->comm;

	Element_STKM_run_stickman(figh, UPDATE_FUNC_SUBCALL_ARGS);
	return 0;
}

static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS)
{
	return Element_FIGH_CanAlloc(sim);
}

static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS)
{
	if (to == PT_FIGH)
	{
		sim->parts[i].tmp = Element_FIGH_Alloc(sim);
		if (sim->parts[i].tmp >= 0)
			Element_FIGH_NewFighter(sim, sim->parts[i].tmp, i, PT_DUST);
	}
	else
	{
		Free(sim, (unsigned char)sim->parts[i].tmp);
	}
}

bool Element_FIGH_CanAlloc(Simulation *sim)
{
	return sim->fighcount < MAX_FIGHTERS;
}

int Element_FIGH_Alloc(Simulation *sim)
{
	if (sim->fighcount >= MAX_FIGHTERS)
		return -1;
	int i = 0;
	while (i < MAX_FIGHTERS && sim->fighters[i].spwn==1)
		i++;
	if (i < MAX_FIGHTERS)
	{
		sim->fighters[i].spwn = 1;
		sim->fighters[i].elem = PT_DUST;
		sim->fighcount++;
		return i;
	}
	else return -1;
}

static void Free(Simulation *sim, unsigned char i)
{
	if (sim->fighters[i].spwn)
	{
		sim->fighters[i].spwn = 0;
		sim->fighcount--;
	}
}

void Element_FIGH_NewFighter(Simulation *sim, int fighterID, int i, int elem)
{
	Element_STKM_init_legs(sim, &sim->fighters[fighterID], i);
	if (elem > 0 && elem < PT_NUM)
		sim->fighters[fighterID].elem = elem;
	sim->fighters[fighterID].spwn = 1;
}


=== src\simulation\elements\FILT.cpp ===

#include "simulation/ElementCommon.h"
#include "FILT.h"

static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_FILT()
{
	Identifier = "DEFAULT_PT_FILT";
	Name = "FILT";
	Colour = 0x000056_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Filter. Changes color of PHOT and BIZR. Color depends on temperature.";

	Properties = TYPE_SOLID | PROP_PHOTPASS | PROP_NOAMBHEAT | PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Graphics = &graphics;
	Create = &create;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int x, wl = Element_FILT_getWavelengths(cpart);
	*colg = 0;
	*colb = 0;
	*colr = 0;
	for (x=0; x<12; x++) {
		*colr += (wl >> (x+18)) & 1;
		*colb += (wl >>  x)     & 1;
	}
	for (x=0; x<12; x++)
		*colg += (wl >> (x+9))  & 1;
	x = 624/(*colr+*colg+*colb+1);
	if (cpart->life>0 && cpart->life<=4)
		*cola = 127+cpart->life*30;
	else
		*cola = 127;
	*colr *= x;
	*colg *= x;
	*colb *= x;
	*pixel_mode &= ~PMODE;
	*pixel_mode |= PMODE_BLEND;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].tmp = v;
}

// Returns the wavelengths in a particle after FILT interacts with it (e.g. a photon)
// cpart is the FILT particle, origWl the original wavelengths in the interacting particle
int Element_FILT_interactWavelengths(Simulation *sim, Particle* cpart, int origWl)
{
	const int mask = 0x3FFFFFFF;
	int filtWl = Element_FILT_getWavelengths(cpart);
	switch (cpart->tmp)
	{
		case 0:
			return filtWl; //Assign Colour
		case 1:
			return origWl & filtWl; //Filter Colour
		case 2:
			return origWl | filtWl; //Add Colour
		case 3:
			return origWl & (~filtWl); //Subtract colour of filt from colour of photon
		case 4:
		{
			int shift = int((cpart->temp-273.0f)*0.025f);
			if (shift<=0) shift = 1;
			return (origWl << shift) & mask; // red shift
		}
		case 5:
		{
			int shift = int((cpart->temp-273.0f)*0.025f);
			if (shift<=0) shift = 1;
			return (origWl >> shift) & mask; // blue shift
		}
		case 6:
			return origWl; // No change
		case 7:
			return origWl ^ filtWl; // XOR colours
		case 8:
			return (~origWl) & mask; // Invert colours
		case 9:
		{
			int t1 = (origWl & 0x0000FF) + sim->rng.between(-2, 2);
			int t2 = ((origWl & 0x00FF00)>>8) + sim->rng.between(-2, 2);
			int t3 = ((origWl & 0xFF0000)>>16) + sim->rng.between(-2, 2);
			return (origWl & 0xFF000000) | (t3<<16) | (t2<<8) | t1;
		}
		case 10:
		{
			long long int lsb = filtWl & (-filtWl);
			return (origWl * lsb) & 0x3FFFFFFF; //red shift
		}
		case 11:
		{
			long long int lsb = filtWl & (-filtWl);
			return (origWl / lsb) & 0x3FFFFFFF; // blue shift
		}
		default:
			return filtWl;
	}
}

int Element_FILT_getWavelengths(const Particle* cpart)
{
	if (cpart->ctype&0x3FFFFFFF)
	{
		return cpart->ctype;
	}
	else
	{
		int temp_bin = (int)((cpart->temp-273.0f)*0.025f);
		if (temp_bin < 0) temp_bin = 0;
		if (temp_bin > 25) temp_bin = 25;
		return (0x1F << temp_bin);
	}
}


=== src\simulation\elements\FILT.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_FILT_getWavelengths(const Particle* cpart);
int Element_FILT_interactWavelengths(Simulation *sim, Particle* cpart, int origWl);


=== src\simulation\elements\FIRE.cpp ===

#include "simulation/ElementCommon.h"
#include "FIRE.h"
#include <algorithm>

static int updateLegacy(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_FIRE()
{
	Identifier = "DEFAULT_PT_FIRE";
	Name = "FIRE";
	Colour = 0xFF1000_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.9f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.97f;
	Loss = 0.20f;
	Collision = 0.0f;
	Gravity = -0.1f;
	Diffusion = 0.00f;
	HotAir = 0.001f  * CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 2;

	DefaultProperties.temp = R_TEMP + 400.0f + 273.15f;
	HeatConduct = 88;
	Description = "Ignites flammable materials. Heats air.";

	Properties = TYPE_GAS|PROP_LIFE_DEC|PROP_LIFE_KILL;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 2773.0f;
	HighTemperatureTransition = PT_PLSM;

	Update = &Element_FIRE_update;
	Graphics = &graphics;
	Create = &create;
}

int Element_FIRE_update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int t = parts[i].type;
	switch (t)
	{
	case PT_PLSM:
		if (parts[i].life <=1)
		{
			if (parts[i].ctype == PT_NBLE)
			{
				sim->part_change_type(i,x,y,PT_NBLE);
				parts[i].life = 0;
			}
			else if ((parts[i].tmp&0x3) == 3){
				sim->part_change_type(i,x,y,PT_WTRV);
				parts[i].life = 0;
				parts[i].ctype = PT_FIRE;
			}
		}
		break;
	case PT_FIRE:
		if (parts[i].life <=1)
		{
			if ((parts[i].tmp&0x3) == 3){
				sim->part_change_type(i,x,y,PT_WTRV);
				parts[i].life = 0;
				parts[i].ctype = PT_FIRE;
			}
			else if (parts[i].temp<625)
			{
				sim->part_change_type(i,x,y,PT_SMKE);
				parts[i].life = sim->rng.between(250, 269);
			}
		}
		break;
	case PT_LAVA: {
		float pres = sim->pv[y / CELL][x / CELL];
		if (parts[i].ctype == PT_ROCK)
		{			
			if (pres <= -9)
			{
				parts[i].ctype = PT_STNE;
				break;
			}

			if (pres >= 25 && sim->rng.chance(1, 12500))
			{
				if (pres <= 50)
				{
					if (sim->rng.chance(1, 2))
						parts[i].ctype = PT_BRMT;
					else
						parts[i].ctype = PT_CNCT;
				}
				else if (pres <= 75)
				{
					if (pres >= 73 || sim->rng.chance(1, 8))
						parts[i].ctype = PT_GOLD;
					else
						parts[i].ctype = PT_QRTZ;
				}
				else if (pres <= 100 && parts[i].temp >= 5000)
				{
					if (sim->rng.chance(1, 5)) // 1 in 5 chance IRON to TTAN
						parts[i].ctype = PT_TTAN;
					else
						parts[i].ctype = PT_IRON;
				}
				else if (parts[i].temp >= 5000 && sim->rng.chance(1, 5))
				{
					if (sim->rng.chance(1, 5))
						parts[i].ctype = PT_URAN;
					else if (sim->rng.chance(1, 5))
						parts[i].ctype = PT_PLUT;
					else
						parts[i].ctype = PT_TUNG;
				}
			}
		}
		else if ((parts[i].ctype == PT_STNE || !parts[i].ctype) && pres >= 30.0f && (parts[i].temp > elements[PT_ROCK].HighTemperature || pres < elements[PT_ROCK].HighPressure)) // Form ROCK with pressure, if it will stay molten or not immediately break
		{
			parts[i].tmp2 = sim->rng.between(0, 10); // Provide tmp2 for color noise
			parts[i].ctype = PT_ROCK;
		}
		break;
	}
	default:
		break;
	}
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);

				//THRM burning
				if (rt==PT_THRM && (t==PT_FIRE || t==PT_PLSM || t==PT_LAVA))
				{
					if (sim->rng.chance(1, 500)) {
						sim->part_change_type(ID(r),x+rx,y+ry,PT_LAVA);
						parts[ID(r)].ctype = PT_BMTL;
						parts[ID(r)].temp = 3500.0f;
						sim->pv[(y+ry)/CELL][(x+rx)/CELL] += 50.0f;
					} else {
						sim->part_change_type(ID(r),x+rx,y+ry,PT_LAVA);
						parts[ID(r)].life = 400;
						parts[ID(r)].ctype = PT_THRM;
						parts[ID(r)].temp = 3500.0f;
						parts[ID(r)].tmp = 20;
					}
					continue;
				}

				if ((rt==PT_COAL) || (rt==PT_BCOL))
				{
					if ((t==PT_FIRE || t==PT_PLSM))
					{
						if (parts[ID(r)].life>100 && sim->rng.chance(1, 500))
						{
							parts[ID(r)].life = 99;
						}
					}
					else if (t==PT_LAVA)
					{
						if (parts[i].ctype == PT_IRON && sim->rng.chance(1, 500))
						{
							parts[i].ctype = PT_METL;
							sim->kill_part(ID(r));
							continue;
						}
						if ((parts[i].ctype == PT_STNE || parts[i].ctype == PT_NONE) && sim->rng.chance(1, 60))
						{
							parts[i].ctype = PT_SLCN;
							sim->kill_part(ID(r));
							continue;
						}
					}
				}

				if (t == PT_LAVA)
				{
					// LAVA(CLST) + LAVA(PQRT) + high enough temp = LAVA(CRMC) + LAVA(CRMC)
					if (parts[i].ctype == PT_QRTZ && rt == PT_LAVA && parts[ID(r)].ctype == PT_CLST)
					{
						float pres = std::max(sim->pv[y/CELL][x/CELL]*10.0f, 0.0f);
						if (parts[i].temp >= pres+elements[PT_CRMC].HighTemperature+50.0f)
						{
							parts[i].ctype = PT_CRMC;
							parts[ID(r)].ctype = PT_CRMC;
						}
					}
					else if (rt == PT_O2 && parts[i].ctype == PT_SLCN)
					{
						switch (sim->rng.between(0, 2))
						{
						case 0:
							parts[i].ctype = PT_SAND;
							break;

						case 1:
							parts[i].ctype = PT_CLST;
							// avoid creating CRMC.
							if (parts[i].temp >= elements[PT_PQRT].HighTemperature * 3)
							{
								parts[i].ctype = PT_PQRT;
							}
							break;

						case 2:
							parts[i].ctype = PT_STNE;
							break;
						}
						parts[i].tmp = 0;
						sim->kill_part(ID(r));
						continue;
					}
					else if (rt == PT_LAVA && (parts[ID(r)].ctype == PT_METL || parts[ID(r)].ctype == PT_BMTL) && parts[i].ctype == PT_SLCN)
					{
						parts[i].tmp = 0;
						parts[i].ctype = PT_NSCN;
						parts[ID(r)].ctype = PT_PSCN;
					}
					else if (rt == PT_HEAC && parts[i].ctype == PT_HEAC)
					{
						if (parts[ID(r)].temp > elements[PT_HEAC].HighTemperature)
						{
							sim->part_change_type(ID(r), x+rx, y+ry, PT_LAVA);
							parts[ID(r)].ctype = PT_HEAC;
						}
					}
					else if (parts[i].ctype == PT_ROCK && rt == PT_LAVA && parts[ID(r)].ctype == PT_GOLD && parts[ID(r)].tmp == 0 &&
						sim->pv[y / CELL][x / CELL] >= 50 && sim->rng.chance(1, 10000)) // Produce GOLD veins/clusters
					{
						parts[i].ctype = PT_GOLD;
						if (rx > 1 || rx < -1) // Trend veins vertical
							parts[i].tmp = 1;
					}
					else if (parts[i].ctype == PT_SALT && rt == PT_GLAS && parts[ID(r)].life < 234 * 120)
					{
						parts[ID(r)].life++;
					}
				}

				if ((surround_space || elements[rt].Explosive) &&
				    elements[rt].Flammable && sim->rng.chance(int(elements[rt].Flammable + (sim->pv[(y+ry)/CELL][(x+rx)/CELL] * 10.0f)), 1000) &&
				    //exceptions, t is the thing causing the spark and rt is what's burning
				    (t != PT_SPRK || (rt != PT_RBDM && rt != PT_LRBD && rt != PT_INSL)) &&
				    (t != PT_PHOT || rt != PT_INSL) &&
				    (rt != PT_SPNG || parts[ID(r)].life == 0))
				{
					sim->part_change_type(ID(r), x+rx, y+ry, PT_FIRE);
					parts[ID(r)].temp = restrict_flt(elements[PT_FIRE].DefaultProperties.temp + (elements[rt].Flammable/2), MIN_TEMP, MAX_TEMP);
					parts[ID(r)].life = sim->rng.between(180, 259);
					parts[ID(r)].tmp = parts[ID(r)].ctype = 0;
					if (elements[rt].Explosive)
						sim->pv[y/CELL][x/CELL] += 0.25f * CFDS;
				}
			}
		}
	}
	if (sim->legacy_enable && t!=PT_SPRK) // SPRK has no legacy reactions
		updateLegacy(UPDATE_FUNC_SUBCALL_ARGS);
	return 0;
}

static int updateLegacy(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int t = parts[i].type;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (sim->bmap[(y+ry)/CELL][(x+rx)/CELL] && sim->bmap[(y+ry)/CELL][(x+rx)/CELL]!=WL_STREAM)
					continue;
				auto rt = TYP(r);

				auto lpv = (int)sim->pv[(y+ry)/CELL][(x+rx)/CELL];
				if (lpv < 1) lpv = 1;
				if (elements[rt].Meltable &&
				        ((rt!=PT_RBDM && rt!=PT_LRBD) || t!=PT_SPRK)
				        && ((t!=PT_FIRE&&t!=PT_PLSM) || (rt!=PT_METL && rt!=PT_IRON && rt!=PT_ETRD && rt!=PT_PSCN && rt!=PT_NSCN && rt!=PT_NTCT && rt!=PT_PTCT && rt!=PT_BMTL && rt!=PT_BRMT && rt!=PT_SALT && rt!=PT_INWR))
				        && sim->rng.chance(elements[rt].Meltable*lpv, 1000))
				{
					if (t!=PT_LAVA || parts[i].life>0)
					{
						if (rt==PT_BRMT)
							parts[ID(r)].ctype = PT_BMTL;
						else if (rt==PT_SAND)
							parts[ID(r)].ctype = PT_GLAS;
						else
							parts[ID(r)].ctype = rt;
						sim->part_change_type(ID(r),x+rx,y+ry,PT_LAVA);
						parts[ID(r)].life = sim->rng.between(240, 359);
					}
					else
					{
						parts[i].life = 0;
						parts[i].ctype = PT_NONE;//rt;
						sim->part_change_type(i,x,y,(parts[i].ctype)?parts[i].ctype:PT_STNE);
						return 1;
					}
				}
				if (rt==PT_ICEI || rt==PT_SNOW)
				{
					sim->part_change_type(ID(r), x+rx, y+ry, PT_WATR);
					if (t==PT_FIRE)
					{
						sim->kill_part(i);
						return 1;
					}
					if (t==PT_LAVA)
					{
						parts[i].life = 0;
						sim->part_change_type(i,x,y,PT_STNE);
					}
				}
				if (rt==PT_WATR || rt==PT_DSTW || rt==PT_SLTW)
				{
					sim->kill_part(ID(r));
					if (t==PT_FIRE)
					{
						sim->kill_part(i);
						return 1;
					}
					if (t==PT_LAVA)
					{
						parts[i].life = 0;
						parts[i].ctype = PT_NONE;
						sim->part_change_type(i,x,y,(parts[i].ctype)?parts[i].ctype:PT_STNE);
					}
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	RGB color = Renderer::flameTableAt(cpart->life);
	*colr = color.Red;
	*colg = color.Green;
	*colb = color.Blue;

	*firea = 255;
	*firer = *colr;
	*fireg = *colg;
	*fireb = *colb;

	*pixel_mode = PMODE_NONE; //Clear default, don't draw pixel
	*pixel_mode |= FIRE_ADD;
	//Returning 0 means dynamic, do not cache
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].life = sim->rng.between(120, 169);
}


=== src\simulation\elements\FIRE.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_FIRE_update(UPDATE_FUNC_ARGS);


=== src\simulation\elements\FIRW.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_FIRW()
{
	Identifier = "DEFAULT_PT_FIRW";
	Name = "FIRW";
	Colour = 0xFFA040_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.2f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 55;

	HeatConduct = 70;
	Description = "Fireworks! Colorful, set off by fire.";

	Properties = TYPE_PART|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].tmp<=0)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					auto rt = TYP(r);
					if (rt==PT_FIRE||rt==PT_PLSM||rt==PT_THDR)
					{
						float gx, gy, multiplier;
						sim->GetGravityField(x, y, elements[PT_FIRW].Gravity, 1.0f, gx, gy);
						if (gx*gx+gy*gy < 0.001f)
						{
							float angle = sim->rng.between(0, 6283) * 0.001f;//(in radians, between 0 and 2*pi)
							gx += sinf(angle)*elements[PT_FIRW].Gravity*0.5f;
							gy += cosf(angle)*elements[PT_FIRW].Gravity*0.5f;
						}
						parts[i].tmp = 1;
						parts[i].life = sim->rng.between(20, 29);
						multiplier = (parts[i].life+20)*0.2f/sqrtf(gx*gx+gy*gy);
						parts[i].vx -= gx*multiplier;
						parts[i].vy -= gy*multiplier;
						return 0;
					}
				}
			}
		}
	}
	else if (parts[i].tmp==1) {
		if (parts[i].life<=0) {
			parts[i].tmp=2;
		} else {
			parts[i].flags &= ~FLAG_STAGNANT;
		}
	}
	else //if (parts[i].tmp>=2)
	{
		unsigned col = Renderer::firwTableAt(sim->rng.between(0, 199)).Pack();
		for (int n=0; n<40; n++)
		{
			auto np = sim->create_part(-3, x, y, PT_EMBR);
			if (np>-1)
			{
				auto magnitude = sim->rng.between(40, 99) * 0.05f;
				auto angle = sim->rng.between(0, 6283) * 0.001f;//(in radians, between 0 and 2*pi)
				parts[np].vx = parts[i].vx*0.5f + cosf(angle)*magnitude;
				parts[np].vy = parts[i].vy*0.5f + sinf(angle)*magnitude;
				parts[np].ctype = col;
				parts[np].tmp = 1;
				parts[np].life = sim->rng.between(70, 109);
				parts[np].temp = float(sim->rng.between(5750, 6249));
				parts[np].dcolour = parts[i].dcolour;
			}
		}
		sim->pv[y/CELL][x/CELL] += 8.0f;
		sim->kill_part(i);
		return 1;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->tmp > 0)
	{
		*pixel_mode |= PMODE_GLOW;
	}
	return 0;
}


=== src\simulation\elements\FOG.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_FOG()
{
	Identifier = "DEFAULT_PT_FOG";
	Name = "FOG";
	Colour = 0xAAAAAA_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 0.8f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.4f;
	Loss = 0.70f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 0.99f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 1;

	DefaultProperties.temp = 243.15f;
	HeatConduct = 100;
	Description = "Fog, created when an electric current is passed through RIME.";

	Properties = TYPE_GAS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 373.15f;
	HighTemperatureTransition = PT_WTRV;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if ((elements[TYP(r)].Properties&TYPE_SOLID) && sim->rng.chance(1, 10) && parts[i].life==0 && !(TYP(r)==PT_CLNE || TYP(r)==PT_PCLN)) // TODO: should this also exclude BCLN?
				{
					sim->part_change_type(i,x,y,PT_RIME);
				}
				if (TYP(r)==PT_SPRK)
				{
					parts[i].life += sim->rng.between(0, 19);
				}
				if (TYP(r) == PT_GAS && parts[i].tmp < 10)
				{
					sim->kill_part(ID(r));
					parts[i].tmp++;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\FRAY.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_FRAY()
{
	Identifier = "DEFAULT_PT_FRAY";
	Name = "FRAY";
	Colour = 0x00BBFF_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f  * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = 20.0f + 273.15f;
	HeatConduct = 0;
	Description = "Force Emitter. Pushes or pulls objects based on its temperature. Use like ARAY.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int curlen;
	if (parts[i].tmp > 0)
		curlen = parts[i].tmp;
	else
		curlen = 10;
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_SPRK)
				{
					for (auto nxx = 0, nyy = 0, nxi = rx*-1, nyi = ry*-1, len = 0; ; nyy+=nyi, nxx+=nxi, len++)
					{
						if (!(x+nxi+nxx<XRES && y+nyi+nyy<YRES && x+nxi+nxx >= 0 && y+nyi+nyy >= 0) || len>curlen)
						{
							break;
						}
						r = pmap[y+nyi+nyy][x+nxi+nxx];
						if (!r)
							r = sim->photons[y+nyi+nyy][x+nxi+nxx];
						if (r && !(elements[TYP(r)].Properties & TYPE_SOLID)){
							parts[ID(r)].vx += nxi*((parts[i].temp-273.15f)/10.0f);
							parts[ID(r)].vy += nyi*((parts[i].temp-273.15f)/10.0f);
						}
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\FRME.cpp ===

#include "simulation/ElementCommon.h"

static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_FRME()
{
	Identifier = "DEFAULT_PT_FRME";
	Name = "FRME";
	Colour = 0x999988_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 0;
	Description = "Frame, can be used with pistons to push many particles.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Graphics = &graphics;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->tmp)
	{
		*colr += 30;
		*colg += 30;
		*colb += 30;
	}
	return 0;
}


=== src\simulation\elements\FRZW.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_FRZW()
{
	Identifier = "DEFAULT_PT_FRZW";
	Name = "FRZW";
	Colour = 0x1020C0_rgb;
	MenuVisible = 0;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	DefaultProperties.temp = 120.0f;
	HeatConduct = 29;
	Description = "Freeze water. Hybrid liquid formed when Freeze powder melts.";

	Properties = TYPE_LIQUID | PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 53.0f;
	LowTemperatureTransition = PT_ICEI;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 100;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_WATR && sim->rng.chance(1, 14))
				{
					sim->part_change_type(ID(r),x+rx,y+ry,PT_FRZW);
				}
			}
		}
	}
	if ((parts[i].life==0 && sim->rng.chance(1, 192)) || sim->rng.chance(100-parts[i].life, 50000))
	{
		sim->part_change_type(i,x,y,PT_ICEI);
		parts[i].ctype=PT_FRZW;
		parts[i].temp = restrict_flt(parts[i].temp-200.0f, MIN_TEMP, MAX_TEMP);
	}
	return 0;
}


=== src\simulation\elements\FRZZ.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_FRZZ()
{
	Identifier = "DEFAULT_PT_FRZZ";
	Name = "FRZZ";
	Colour = 0xC0E0FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.90f;
	Collision = -0.1f;
	Gravity = 0.05f;
	Diffusion = 0.01f;
	HotAir = -0.00005f* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 50;

	DefaultProperties.temp = 253.15f;
	HeatConduct = 46;
	Description = "Freeze powder. When melted, forms ice that always cools. Spreads with regular water.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 1.8f;
	HighPressureTransition = PT_SNOW;
	LowTemperature = 50.0f;
	LowTemperatureTransition = PT_ICEI;
	HighTemperature = 273.15f;
	HighTemperatureTransition = PT_FRZW;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_WATR && sim->rng.chance(1, 20))
				{
					sim->part_change_type(ID(r),x+rx,y+ry,PT_FRZW);
					parts[ID(r)].life = 100;
					sim->kill_part(i);
					return 1;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\FSEP.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_FSEP()
{
	Identifier = "DEFAULT_PT_FSEP";
	Name = "FSEP";
	Colour = 0x63AD5F_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 70;

	HeatConduct = 70;
	Description = "Fuse Powder. Burns slowly like FUSE.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 50;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life<=0) {
		auto r = sim->create_part(i, x, y, PT_PLSM);
		if (r!=-1)
			parts[r].life = 50;
		return 1;
	}
	else if (parts[i].life < 40) {
		parts[i].life--;
		if (sim->rng.chance(1, 10)) {
			auto r = sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), PT_PLSM);
			if (r>-1)
				parts[r].life = 50;
		}
	}
	else {
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if ((TYP(r)==PT_SPRK || (parts[i].temp>=(273.15+400.0f))) && parts[i].life>40 && sim->rng.chance(1, 15))
					{
						parts[i].life = 39;
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\FUSE.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_FUSE()
{
	Identifier = "DEFAULT_PT_FUSE";
	Name = "FUSE";
	Colour = 0x0A5706_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.0f;
	HotAir = 0.0f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 100;

	HeatConduct = 200;
	Description = "Burns slowly. Ignites at very high temperatures or when sparked.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 50;
	DefaultProperties.tmp = 50;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life<=0) {
		auto r = sim->create_part(i, x, y, PT_PLSM);
		if (r>-1)
			parts[r].life = 50;
		return 1;
	}
	else if (parts[i].life < 40) {
		parts[i].life--;
		if (sim->rng.chance(1, 100)) {
			auto r = sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), PT_PLSM);
			if (r>-1)
				parts[r].life = 50;
		}
	}
	if ((sim->pv[y/CELL][x/CELL] > 2.7f) && parts[i].tmp>40)
		parts[i].tmp=39;
	else if (parts[i].tmp<=0) {
		sim->create_part(i, x, y, PT_FSEP);
		return 1;
	}
	else if (parts[i].tmp<40)
		parts[i].tmp--;

	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_SPRK || (parts[i].temp>=(273.15+700.0f) && sim->rng.chance(1, 20)))
				{
					if (parts[i].life > 40)
						parts[i].life = 39;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\FWRK.cpp ===

#include "simulation/ElementCommon.h"
#include <algorithm>

static int update(UPDATE_FUNC_ARGS);

void Element::Element_FWRK()
{
	Identifier = "DEFAULT_PT_FWRK";
	Name = "FWRK";
	Colour = 0x666666_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.4f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 97;

	HeatConduct = 100;
	Description = "Original version of fireworks, activated by heat/neutrons.";

	Properties = TYPE_PART|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].life == 0 && ((surround_space && parts[i].temp>400 && sim->rng.chance(int(9+parts[i].temp/40), 100000)) || parts[i].ctype == PT_DUST))
	{
		float gx, gy, multiplier, gmax;
		int randTmp;
		sim->GetGravityField(x, y, elements[PT_FWRK].Gravity, 1.0f, gx, gy);
		if (gx*gx+gy*gy < 0.001f)
		{
			float angle = sim->rng.between(0, 6283) * 0.001f;//(in radians, between 0 and 2*pi)
			gx += sinf(angle)*elements[PT_FWRK].Gravity*0.5f;
			gy += cosf(angle)*elements[PT_FWRK].Gravity*0.5f;
		}
		gmax = std::max(fabsf(gx), fabsf(gy));
		if (sim->eval_move(PT_FWRK, (int)(x-(gx/gmax)+0.5f), (int)(y-(gy/gmax)+0.5f), nullptr))
		{
			multiplier = 15.0f/sqrtf(gx*gx+gy*gy);

			//Some variation in speed parallel to gravity direction
			randTmp = sim->rng.between(-100, 100);
			gx += gx*randTmp*0.002f;
			gy += gy*randTmp*0.002f;
			//and a bit more variation in speed perpendicular to gravity direction
			randTmp = sim->rng.between(-100, 100);
			gx += -gy*randTmp*0.005f;
			gy += gx*randTmp*0.005f;

			parts[i].life = sim->rng.between(18, 27);
			parts[i].ctype=0;
			parts[i].vx -= gx*multiplier;
			parts[i].vy -= gy*multiplier;
			return 0;
		}
	}
	if (parts[i].life<3&&parts[i].life>0)
	{
		int r = sim->rng.between(11, 255);
		int g = sim->rng.between(11, 255);
		int b = sim->rng.between(11, 255);
		int n;
		float angle, magnitude;
		unsigned col = (r<<16) | (g<<8) | b;
		for (n=0; n<40; n++)
		{
			int np = sim->create_part(-3, x, y, PT_EMBR);
			if (np>-1)
			{
				magnitude = sim->rng.between(40, 99) * 0.05f;
				angle = sim->rng.between(0, 6283) * 0.001f;//(in radians, between 0 and 2*pi)
				parts[np].vx = parts[i].vx*0.5f + cosf(angle)*magnitude;
				parts[np].vy = parts[i].vy*0.5f + sinf(angle)*magnitude;
				parts[np].ctype = col;
				parts[np].tmp = 1;
				parts[np].life = sim->rng.between(70, 109);
				parts[np].temp = float(sim->rng.between(5750, 6249));
				parts[np].dcolour = parts[i].dcolour;
			}
		}
		sim->pv[y/CELL][x/CELL] += 8.0f;
		sim->kill_part(i);
		return 1;
	}
	if (parts[i].life>=45)
		parts[i].life=0;
	return 0;
}


=== src\simulation\elements\GAS.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_GAS()
{
	Identifier = "DEFAULT_PT_GAS";
	Name = "GAS";
	Colour = 0xE0FF20_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 1.0f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 0.75f;
	HotAir = 0.001f	* CFDS;
	Falldown = 0;

	Flammable = 600;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 1;

	DefaultProperties.temp = R_TEMP + 2.0f + 273.15f;
	HeatConduct = 42;
	Description = "Diffuses quickly and is flammable. Liquefies into OIL under pressure.";

	Properties = TYPE_GAS | PROP_NEUTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 6.0f;
	HighPressureTransition = PT_OIL;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 573.0f;
	HighTemperatureTransition = PT_FIRE;
}


=== src\simulation\elements\GBMB.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_GBMB()
{
	Identifier = "DEFAULT_PT_GBMB";
	Name = "GBMB";
	Colour = 0x1144BB_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	Description = "Gravity bomb. Sticks to the first object it touches then produces a strong gravity push.";

	Properties = TYPE_PART|PROP_LIFE_DEC|PROP_LIFE_KILL_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life<=0)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				auto r = pmap[y+ry][x+rx];
				if(!r)
					continue;
				if(TYP(r)!=PT_BOMB && TYP(r)!=PT_GBMB &&
				   TYP(r)!=PT_CLNE && TYP(r)!=PT_PCLN &&
				   TYP(r)!=PT_DMND)
				{
					parts[i].life=60;
					break;
				}
			}
		}
	}
	if (parts[i].life > 20)
	{
		sim->gravIn.mass[Vec2{ x, y } / CELL] = 20;
	}
	else if (parts[i].life >= 1)
	{
		sim->gravIn.mass[Vec2{ x, y } / CELL] = -80;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if (cpart->life <= 0) {
		*pixel_mode |= PMODE_FLARE;
	}
	else
	{
		*pixel_mode |= PMODE_SPARK;
	}
	return 0;
}


=== src\simulation\elements\GEL.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_GEL()
{
	Identifier = "DEFAULT_PT_GEL";
	Name = "GEL";
	Colour = 0xFF9900_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f  * CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 35;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	Description = "A liquid with variable viscosity and heat conductivity. Absorbs water.";

	Properties = TYPE_LIQUID|PROP_LIFE_DEC|PROP_NEUTPENETRATE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].tmp > 100)
		parts[i].tmp = 100;
	if (parts[i].tmp < 0)
		parts[i].tmp = 0;
	int absorbChanceDenom = parts[i].tmp * 10 + 500;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto gel=false;
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				//Desaturation
				switch (rt)
				{
				case PT_WATR:
				case PT_DSTW:
				case PT_FRZW:
					if (parts[i].tmp<100 && sim->rng.chance(500, absorbChanceDenom))
					{
						parts[i].tmp++;
						sim->kill_part(ID(r));
					}
					break;
				case PT_PSTE:
					if (parts[i].tmp<100 && sim->rng.chance(20, absorbChanceDenom))
					{
						parts[i].tmp++;
						sim->create_part(ID(r), x+rx, y+ry, PT_CLST);
					}
					break;
				case PT_SLTW:
					if (parts[i].tmp<100 && sim->rng.chance(50, absorbChanceDenom))
					{
						parts[i].tmp++;
						if (sim->rng.chance(3, 4))
							sim->kill_part(ID(r));
						else
							sim->part_change_type(ID(r), x+rx, y+ry, PT_SALT);
					}
					break;
				case PT_CBNW:
					if (parts[i].tmp < 100 && sim->rng.chance(100, absorbChanceDenom))
					{
						parts[i].tmp++;
						sim->part_change_type(ID(r), x+rx, y+ry, PT_CO2);
					}
					break;
				case PT_SPNG:
					// Concentration diffusion
					if (parts[ID(r)].life>0 && parts[i].tmp<100 && ((parts[ID(r)].life+1)>parts[i].tmp))
					{
						// SPNG -> GEL
						parts[ID(r)].life--;
						parts[i].tmp++;
					}
					else if (parts[i].tmp>0 && (parts[ID(r)].life+1)<parts[i].tmp)
					{
						// SPNG <- GEL (saturation limit of SPNG is ignored here)
						parts[ID(r)].life++;
						parts[i].tmp--;
					}
					break;
				case PT_GEL:
					if ((parts[ID(r)].tmp+1)<parts[i].tmp)
					{
						parts[ID(r)].tmp++;
						parts[i].tmp--;
					}
					gel = true;
					break;
				default:
					break;
				}
				float dx, dy;
				dx = parts[i].x - parts[ID(r)].x;
				dy = parts[i].y - parts[ID(r)].y;

				//Stickiness
				if ((dx*dx + dy*dy)>1.5 && (gel || !elements[rt].Falldown || (fabs((float)rx)<2 && fabs((float)ry)<2)))
				{
					float per, nd;
					nd = dx*dx + dy*dy - 0.5;
					per = 5*(1 - parts[i].tmp/100)*(nd/(dx*dx + dy*dy + nd) - 0.5);
					if (elements[rt].Properties&TYPE_LIQUID)
						per *= 0.1f;
					dx *= per; dy *= per;
					parts[i].vx += dx;
					parts[i].vy += dy;
					if ((elements[rt].Properties&TYPE_PART) || rt==PT_GOO)
					{
						parts[ID(r)].vx -= dx;
						parts[ID(r)].vy -= dy;
					}
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int q = cpart->tmp;
	*colr = q*(32-255)/120+255;
	*colg = q*(48-186)/120+186;
	*colb = q*208/120;
	*pixel_mode |= PMODE_BLUR;
	return 0;
}


=== src\simulation\elements\GLAS.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_GLAS()
{
	Identifier = "DEFAULT_PT_GLAS";
	Name = "GLAS";
	Colour = 0x404040_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 150;
	Description = "Glass. Meltable. Shatters under pressure, and refracts photons.";

	Properties = TYPE_SOLID | PROP_NEUTPASS | PROP_PHOTPASS | PROP_HOT_GLOW | PROP_SPARKSETTLE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1973.0f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto press = int(sim->pv[y/CELL][x/CELL] * 64);
	auto diff = press - parts[i].tmp3;

	// Determine whether the GLAS is chemically strengthened via .life setting. (250 = Max., 16 = Min.)
	int strength = (parts[i].life / 120) + 16;
	if (strength < 16)
		strength = 16;
	if (diff > strength || diff < -1 * strength)
	{
		sim->part_change_type(i, x, y, PT_BGLA);
	}
	parts[i].tmp3 = press;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].tmp3 = int(sim->pv[y/CELL][x/CELL] * 64);
}


=== src\simulation\elements\GLOW.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_GLOW()
{
	Identifier = "DEFAULT_PT_GLOW";
	Name = "GLOW";
	Colour = 0x445464_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.3f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.15f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 2;

	Weight = 40;

	DefaultProperties.temp = R_TEMP + 20.0f + 273.15f;
	HeatConduct = 44;
	Description = "Glow, Glows under pressure.";

	Properties = TYPE_LIQUID | PROP_PHOTPASS | PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;

				if (TYP(r)==PT_WATR && sim->rng.chance(1, 400))
				{
					sim->kill_part(i);
					sim->part_change_type(ID(r),x+rx,y+ry,PT_DEUT);
					parts[ID(r)].life = 10;

					return 1;
				}
				else if (TYP(r) == PT_GEL) //GLOW + GEL = RSST
				{
					sim->kill_part(i);
					sim->part_change_type(ID(r),x+rx,y+ry,PT_RSST);
					parts[ID(r)].tmp = 0;

					return 1;
				}
			}
		}
	}
	int ctype = int(sim->pv[y/CELL][x/CELL]*16);
	if (ctype < 0)
		ctype = 0;
	parts[i].ctype = ctype;
	parts[i].tmp = abs((int)((sim->vx[y/CELL][x/CELL]+sim->vy[y/CELL][x/CELL])*16.0f)) + abs((int)((parts[i].vx+parts[i].vy)*64.0f));

	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{

	*firer = 16+int(restrict_flt(cpart->temp-(273.15f+34.0f), 0, 128)/2.0f);
	*fireg = 16+int(restrict_flt(float(cpart->ctype), 0, 128)/2.0f);
	*fireb = 16+int(restrict_flt(float(cpart->tmp), 0, 128)/2.0f);
	*firea = 64;

	*colr = int(restrict_flt(64.0f+cpart->temp-(273.15f+34.0f), 0, 255));
	*colg = int(restrict_flt(64.0f+cpart->ctype, 0, 255));
	*colb = int(restrict_flt(64.0f+cpart->tmp, 0, 255));

	int rng = gfctx.rng.between(1, 32); //
	if(((*colr) + (*colg) + (*colb)) > (256 + rng)) {
		*colr -= 54;
		*colg -= 54;
		*colb -= 54;
		*pixel_mode |= FIRE_ADD;
		*pixel_mode |= PMODE_GLOW | PMODE_ADD;
		*pixel_mode &= ~PMODE_FLAT;
	} else {
		*pixel_mode |= PMODE_BLUR;
	}
	return 0;
}


=== src\simulation\elements\GOLD.cpp ===

#include "simulation/ElementCommon.h"
#include "simulation/Air.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_GOLD()
{
	Identifier = "DEFAULT_PT_GOLD";
	Name = "GOLD";
	Colour = 0xDCAD2C_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 0;
	PhotonReflectWavelengths = 0x3C038100;

	Weight = 100;

	HeatConduct = 251;
	Description = "Corrosion resistant metal, will reverse corrosion of iron. Excellent conductor.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_HOT_GLOW|PROP_LIFE_DEC|PROP_NEUTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1337.0f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	static int checkCoordsX[] = { -4, 4, 0, 0 };
	static int checkCoordsY[] = { 0, 0, -4, 4 };
	//Find nearby rusted iron (BMTL with tmp 1+)
	for(int j = 0; j < 8; j++)
	{
		auto rndstore = sim->rng.gen();
		auto rx = (rndstore % 9)-4;
		rndstore >>= 4;
		auto ry = (rndstore % 9)-4;
		if ((!rx != !ry)) {
			auto r = pmap[y+ry][x+rx];
			if(!r) continue;
			if(TYP(r)==PT_BMTL && parts[ID(r)].tmp)
			{
				parts[ID(r)].tmp = 0;
				sim->part_change_type(ID(r), x+rx, y+ry, PT_IRON);
			}
		}
	}
	//Find sparks
	if(!parts[i].life)
	{
		for(int j = 0; j < 4; j++)
		{
			auto rx = checkCoordsX[j];
			auto ry = checkCoordsY[j];
			auto r = pmap[y+ry][x+rx];
			if(!r) continue;
			if(TYP(r)==PT_SPRK && parts[ID(r)].life && parts[ID(r)].life<4)
			{
				sim->part_change_type(i, x, y, PT_SPRK);
				parts[i].life = 4;
				parts[i].ctype = PT_GOLD;
			}
		}
	}
	if (TYP(sim->photons[y][x]) == PT_NEUT)
	{
		if (sim->rng.chance(1, 7))
		{
			sim->kill_part(ID(sim->photons[y][x]));
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int rndstore = gfctx.rng.gen();
	*colr += (rndstore % 10) - 5;
	rndstore >>= 4;
	*colg += (rndstore % 10)- 5;
	rndstore >>= 4;
	*colb += (rndstore % 10) - 5;
	return 0;
}


=== src\simulation\elements\GOO.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_GOO()
{
	Identifier = "DEFAULT_PT_GOO";
	Name = "GOO";
	Colour = 0x804000_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.97f;
	Loss = 0.50f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 12;
	PhotonReflectWavelengths = 0x3FFAAA00;

	Weight = 100;

	HeatConduct = 75;
	Description = "Deforms and disappears under pressure.";

	Properties = TYPE_SOLID | PROP_NEUTPENETRATE|PROP_LIFE_DEC|PROP_LIFE_KILL_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

constexpr float ADVECTION = 0.1f;

static int update(UPDATE_FUNC_ARGS)
{
	if (!parts[i].life && sim->pv[y/CELL][x/CELL]>1.0f)
		parts[i].life = sim->rng.between(300, 379);
	if (parts[i].life)
	{
		parts[i].vx += ADVECTION*sim->vx[y/CELL][x/CELL];
		parts[i].vy += ADVECTION*sim->vy[y/CELL][x/CELL];
	}
	return 0;
}


=== src\simulation\elements\GPMP.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_GPMP()
{
	Identifier = "DEFAULT_PT_GPMP";
	Name = "GPMP";
	Colour = 0x0A3B3B_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Gravity pump. Changes gravity to its temp when activated. (use HEAT/COOL)";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 10;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life!=10)
	{
		if (parts[i].life>0)
			parts[i].life--;
	}
	else
	{
		if (parts[i].temp>=256.0f+273.15f)
			parts[i].temp=256.0f+273.15f;
		if (parts[i].temp<= -256.0f+273.15f)
			parts[i].temp = -256.0f+273.15f;

		sim->gravIn.mass[Vec2{ x, y } / CELL] = 0.2f * (parts[i].temp - 273.15);
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r)==PT_GPMP)
					{
						if (parts[ID(r)].life<10&&parts[ID(r)].life>0)
							parts[i].life = 9;
						else if (parts[ID(r)].life==0)
							parts[ID(r)].life = 10;
					}
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int lifemod = ((cpart->life>10?10:cpart->life)*19);
	*colg += lifemod;
	*colb += lifemod;
	return 0;
}


=== src\simulation\elements\GRAV.cpp ===

#include "simulation/ElementCommon.h"
#include <algorithm>

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_GRAV()
{
	Identifier = "DEFAULT_PT_GRAV";
	Name = "GRAV";
	Colour = 0x202020_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 1.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 10;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 85;

	HeatConduct = 70;
	Description = "Very light dust. Changes colour based on velocity.";

	Properties = TYPE_PART | PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].vx*parts[i].vx + parts[i].vy*parts[i].vy >= 0.1f && sim->rng.chance(1, 512))
	{
		if (!parts[i].life)
			parts[i].life = 48;
	}

	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int GRAV_R, GRAV_B, GRAV_G, GRAV_R2, GRAV_B2, GRAV_G2;

	GRAV_R = std::abs((gfctx.sim->currentTick%120)-60);
	GRAV_G = std::abs(((gfctx.sim->currentTick+60)%120)-60);
	GRAV_B = std::abs(((gfctx.sim->currentTick+120)%120)-60);
	GRAV_R2 = std::abs((gfctx.sim->currentTick%60)-30);
	GRAV_G2 = std::abs(((gfctx.sim->currentTick+30)%60)-30);
	GRAV_B2 = std::abs(((gfctx.sim->currentTick+60)%60)-30);


	*colr = 20;
	*colg = 20;
	*colb = 20;
	if (cpart->vx>0)
	{
		*colr += int((cpart->vx)*GRAV_R);
		*colg += int((cpart->vx)*GRAV_G);
		*colb += int((cpart->vx)*GRAV_B);
	}
	if (cpart->vy>0)
	{
		*colr += int((cpart->vy)*GRAV_G);
		*colg += int((cpart->vy)*GRAV_B);
		*colb += int((cpart->vy)*GRAV_R);

	}
	if (cpart->vx<0)
	{
		*colr -= int((cpart->vx)*GRAV_B);
		*colg -= int((cpart->vx)*GRAV_R);
		*colb -= int((cpart->vx)*GRAV_G);

	}
	if (cpart->vy<0)
	{
		*colr -= int((cpart->vy)*GRAV_R2);
		*colg -= int((cpart->vy)*GRAV_G2);
		*colb -= int((cpart->vy)*GRAV_B2);
	}

	if (cpart->life)
	{
		*pixel_mode = FIRE_ADD | PMODE_ADD | PMODE_GLOW | PMODE_FLARE;
		*firer = std::min(*colr * 3, 255);
		*fireg = std::min(*colg * 3, 255);
		*fireb = std::min(*colb * 3, 255);
		*firea = (cpart->life+15)*4;
		*cola = (cpart->life+15)*4;
	}
	else
		*pixel_mode = PMODE_ADD;

	return 0;
}


=== src\simulation\elements\GRVT.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_GRVT()
{
	Identifier = "DEFAULT_PT_GRVT";
	Name = "GRVT";
	Colour = 0x00EE76_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 1.00f;
	Collision = -.99f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = -1;

	HeatConduct = 61;
	Description = "Gravitons. Create Newtonian Gravity.";

	Properties = TYPE_ENERGY|PROP_LIFE_DEC|PROP_LIFE_KILL_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.tmp = 7;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	//at higher tmps they just go completely insane
	if (parts[i].tmp >= 100)
		parts[i].tmp = 100;
	if (parts[i].tmp <= -100)
		parts[i].tmp = -100;

	int under = pmap[y][x];
	int utype = TYP(under);

	//Randomly kill GRVT inside RSSS
	if((utype == PT_RSSS) && sim->rng.chance(1, 5))
	{

		sim->kill_part(i);
		return 1;
	}
	sim->gravIn.mass[Vec2{ x, y } / CELL] = 0.2f * parts[i].tmp;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 5;
	*firer = 0;
	*fireg = 250;
	*fireb = 170;

	*pixel_mode |= FIRE_BLEND;
	return 1;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	float a = sim->rng.between(0, 359) * 3.14159f / 180.0f;
	sim->parts[i].life = 250 + sim->rng.between(0, 199);
	sim->parts[i].vx = 2.0f*cosf(a);
	sim->parts[i].vy = 2.0f*sinf(a);
}


=== src\simulation\elements\GUNP.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_GUNP()
{
	Identifier = "DEFAULT_PT_GUNP";
	Name = "GUN";
	Colour = 0xC0C0D0_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.80f;
	Collision = -0.1f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 600;
	Explosive = 1;
	Meltable = 0;
	Hardness = 10;

	Weight = 85;

	HeatConduct = 97;
	Description = "Gunpowder. Light dust, explodes on contact with fire or spark.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 673.0f;
	HighTemperatureTransition = PT_FIRE;
}


=== src\simulation\elements\H2.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_H2()
{
	Identifier = "DEFAULT_PT_H2";
	Name = "HYGN";
	Colour = 0x5070FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 2.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.10f;
	Gravity = 0.00f;
	Diffusion = 3.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 1;

	HeatConduct = 251;
	Description = "Hydrogen. Combusts with OXYG to make WATR. Undergoes fusion at high temperature and pressure.";

	Properties = TYPE_GAS | PROP_PHOTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &can_move = sd.can_move;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if (sim->pv[y/CELL][x/CELL] > 8.0f && rt == PT_DESL) // This will not work. DESL turns to fire above 5.0 pressure
				{
					sim->part_change_type(ID(r),x+rx,y+ry,PT_WATR);
					sim->part_change_type(i,x,y,PT_OIL);
					return 1;
				}
				if (sim->pv[y/CELL][x/CELL] > 45.0f)
				{
					if (parts[ID(r)].temp > 2273.15)
						continue;
				}
				else
				{
					if (rt==PT_FIRE)
					{
						if(parts[ID(r)].tmp&0x02)
							parts[ID(r)].temp=3473.0f;
						else
							parts[ID(r)].temp=2473.15f;
						parts[ID(r)].tmp |= 1;
						sim->create_part(i,x,y,PT_FIRE);
						parts[i].temp += sim->rng.between(0, 99);
						parts[i].tmp |= 1;
						return 1;
					}
					else if ((rt==PT_PLSM && !(parts[ID(r)].tmp&4)) || (rt==PT_LAVA && parts[ID(r)].ctype != PT_BMTL))
					{
						sim->create_part(i,x,y,PT_FIRE);
						parts[i].temp += sim->rng.between(0, 99);
						parts[i].tmp |= 1;
						return 1;
					}
				}
			}
		}
	}
	if (parts[i].temp > 2273.15 && sim->pv[y/CELL][x/CELL] > 50.0f)
	{
		if (sim->rng.chance(1, 5))
		{
			int j;
			float temp = parts[i].temp;
			sim->create_part(i,x,y,PT_NBLE);
			parts[i].tmp = 0x1;

			j = sim->create_part(-3,x,y,PT_NEUT);
			if (j>-1)
				parts[j].temp = temp;
			if (sim->rng.chance(1, 10))
			{
				j = sim->create_part(-3,x,y,PT_ELEC);
				if (j>-1)
					parts[j].temp = temp;
			}
			j = sim->create_part(-3,x,y,PT_PHOT);
			if (j>-1)
			{
				parts[j].ctype = 0x7C0000;
				parts[j].temp = temp;
				parts[j].tmp = 0x1;
			}
			auto rx = x + sim->rng.between(-1, 1), ry = y + sim->rng.between(-1, 1), rt = TYP(pmap[ry][rx]);
			if (can_move[PT_PLSM][rt] || rt == PT_H2)
			{
				j = sim->create_part(-3,rx,ry,PT_PLSM);
				if (j>-1)
				{
					parts[j].temp = temp;
					parts[j].tmp |= 4;
				}
			}
			parts[i].temp = temp + sim->rng.between(750, 1249);
			sim->pv[y/CELL][x/CELL] += 30;
			return 1;
		}
	}
	return 0;
}


=== src\simulation\elements\HEAC.cpp ===

#include "simulation/ElementCommon.h"
#include "simulation/Air.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_HEAC()
{
	Identifier = "DEFAULT_PT_HEAC";
	Name = "HEAC";
	Colour = 0xCB6351_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 251;
	Description = "Rapid heat conductor.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	// can't melt by normal heat conduction, this is used by other elements for special melting behavior
	HighTemperature = 1887.15f;
	HighTemperatureTransition = NT;

	Update = &update;
}

static const auto isInsulator = [](Simulation* sim, int p) -> bool {
	return p && sim->IsHeatInsulator(sim->parts[ID(p)]);
};

// If this is used elsewhere (GOLD), it should be moved into Simulation.h
template<class BinaryPredicate>
bool CheckLine(Simulation* sim, int x1, int y1, int x2, int y2, BinaryPredicate func)
{
	bool reverseXY = abs(y2-y1) > abs(x2-x1);
	int x, y, dx, dy, sy;
	float e, de;
	if (reverseXY)
	{
		y = x1;
		x1 = y1;
		y1 = y;
		y = x2;
		x2 = y2;
		y2 = y;
	}
	if (x1 > x2)
	{
		y = x1;
		x1 = x2;
		x2 = y;
		y = y1;
		y1 = y2;
		y2 = y;
	}
	dx = x2 - x1;
	dy = abs(y2 - y1);
	e = 0.0f;
	if (dx)
		de = dy/(float)dx;
	else
		de = 0.0f;
	y = y1;
	sy = (y1<y2) ? 1 : -1;
	for (x=x1; x<=x2; x++)
	{
		if (reverseXY)
		{
			if (func(sim, sim->pmap[x][y])) return true;
		}
		else
		{
			if (func(sim, sim->pmap[y][x])) return true;
		}
		e += de;
		if (e >= 0.5f)
		{
			y += sy;
			if ((y1<y2) ? (y<=y2) : (y>=y2))
			{
				if (reverseXY)
				{
					if (func(sim, sim->pmap[x][y])) return true;
				}
				else
				{
					if (func(sim, sim->pmap[y][x])) return true;
				}
			}
			e -= 1.0f;
		}
	}
	return false;
}

static int update(UPDATE_FUNC_ARGS)
{
	const int rad = 4;
	int rry, rrx, r, count = 0;
	float tempAgg = 0;
	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			rry = ry * rad;
			rrx = rx * rad;
			if (x+rrx >= 0 && x+rrx < XRES && y+rry >= 0 && y+rry < YRES && !CheckLine(sim, x, y, x+rrx, y+rry, isInsulator))
			{
				r = pmap[y+rry][x+rrx];
				if (r && !sim->IsHeatInsulator(parts[ID(r)]))
				{
					count++;
					tempAgg += parts[ID(r)].temp;
				}
				r = sim->photons[y+rry][x+rrx];
				if (r && !sim->IsHeatInsulator(parts[ID(r)]))
				{
					count++;
					tempAgg += parts[ID(r)].temp;
				}
			}
		}
	}

	if (count > 0)
	{
		parts[i].temp = tempAgg/count;

		for (int rx = -1; rx <= 1; rx++)
		{
			for (int ry = -1; ry <= 1; ry++)
			{
				rry = ry * rad;
				rrx = rx * rad;
				if (x+rrx >= 0 && x+rrx < XRES && y+rry >= 0 && y+rry < YRES && !CheckLine(sim, x, y, x+rrx, y+rry, isInsulator))
				{
					r = pmap[y+rry][x+rrx];
					if (r && !sim->IsHeatInsulator(parts[ID(r)]))
					{
						parts[ID(r)].temp = parts[i].temp;
					}
					r = sim->photons[y+rry][x+rrx];
					if (r && !sim->IsHeatInsulator(parts[ID(r)]))
					{
						parts[ID(r)].temp = parts[i].temp;
					}
				}
			}
		}
	}

	return 0;
}


=== src\simulation\elements\HSWC.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_HSWC()
{
	Identifier = "DEFAULT_PT_HSWC";
	Name = "HSWC";
	Colour = 0x3B0A0A_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Heat switch. Conducts heat only when activated.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life!=10)
	{
		if (parts[i].life>0)
			parts[i].life--;
	}
	else
	{
		bool deserializeTemp = parts[i].tmp == 1;
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						r = sim->photons[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r) == PT_HSWC)
					{
						if (parts[ID(r)].life<10&&parts[ID(r)].life>0)
							parts[i].life = 9;
						else if (parts[ID(r)].life==0)
							parts[ID(r)].life = 10;
					}
					if (deserializeTemp && TYP(r) == PT_FILT)
					{
						if (rx >= -1 && rx <= 1 && ry >= -1 && ry <= 1)
						{
							int newTemp = parts[ID(r)].ctype - 0x10000000;
							if (newTemp >= MIN_TEMP && newTemp <= MAX_TEMP)
								parts[i].temp = float(parts[ID(r)].ctype - 0x10000000);
						}
					}
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int lifemod = ((cpart->life>10?10:cpart->life)*19);
	*colr += lifemod;
	return 0;
}


=== src\simulation\elements\ICEI.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_ICEI()
{
	Identifier = "DEFAULT_PT_ICEI";
	Name = "ICE";
	Colour = 0xA0C0FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = -0.0003f* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 100;

	DefaultProperties.temp = R_TEMP - 50.0f + 273.15f;
	HeatConduct = 46;
	LatentHeat = 1095;
	Description = "Crushes under pressure. Cools down air.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC|PROP_NEUTPASS;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 0.8f;
	HighPressureTransition = PT_SNOW;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 252.05f;
	HighTemperatureTransition = ST;

	DefaultProperties.ctype = PT_WATR;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].ctype==PT_FRZW)//get colder if it is from FRZW
	{
		parts[i].temp = restrict_flt(parts[i].temp-1.0f, MIN_TEMP, MAX_TEMP);
	}
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_SALT || TYP(r)==PT_SLTW)
				{
					if (parts[i].temp > elements[PT_SLTW].LowTemperature && sim->rng.chance(1, 200))
					{
						sim->part_change_type(i,x,y,PT_SLTW);
						sim->part_change_type(ID(r),x+rx,y+ry,PT_SLTW);
						return 0;
					}
				}
				else if ((TYP(r)==PT_FRZZ) && sim->rng.chance(1, 200))
				{
					sim->part_change_type(ID(r),x+rx,y+ry,PT_ICEI);
					parts[ID(r)].ctype = PT_FRZW;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\IGNT.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_IGNT()
{
	Identifier = "DEFAULT_PT_IGNT";
	Name = "IGNC";
	Colour = 0xC0B050_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 88;
	Description = "Ignition cord. Burns slowly with fire and sparks.";

	Properties = TYPE_SOLID | PROP_NEUTPENETRATE | PROP_SPARKSETTLE | PROP_LIFE_KILL;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 673.0f;
	HighTemperatureTransition = PT_FIRE;

	DefaultProperties.life = 3;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if(parts[i].tmp==0)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					auto rt = TYP(r);
					if (rt==PT_FIRE || rt==PT_PLSM || rt==PT_SPRK || rt==PT_LIGH || (rt==PT_IGNT && parts[ID(r)].life==1))
					{
						parts[i].tmp = 1;
					}
				}
			}
		}
	}
	else if(parts[i].life > 0)
	{
		if (sim->rng.chance(2, 3))
		{
			int nb = sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), PT_EMBR);
			if (nb!=-1) {
				parts[nb].tmp = 0;
				parts[nb].life = 30;
				parts[nb].vx = float(sim->rng.between(-10, 10));
				parts[nb].vy = float(sim->rng.between(-10, 10));
				parts[nb].temp = restrict_flt(parts[i].temp-273.15f+400.0f, MIN_TEMP, MAX_TEMP);
			}
		}
		else
		{
			sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), PT_FIRE);
		}
		parts[i].life--;
	}
	return 0;
}


=== src\simulation\elements\INSL.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_INSL()
{
	Identifier = "DEFAULT_PT_INSL";
	Name = "INSL";
	Colour = 0x9EA3B6_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 7;
	Explosive = 0;
	Meltable = 0;
	Hardness = 10;

	Weight = 100;

	HeatConduct = 0;
	Description = "Insulator. Blocks heat, electricity, and radiation.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}


=== src\simulation\elements\INST.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_INST()
{
	Identifier = "DEFAULT_PT_INST";
	Name = "INST";
	Colour = 0x404039_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Instantly conducts, PSCN to charge, NSCN to take.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}


=== src\simulation\elements\INVIS.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_INVIS()
{
	Identifier = "DEFAULT_PT_INVIS";
	Name = "INVS";
	Colour = 0x00CCCC_rgb;
	MenuVisible = 1;
	MenuSection = SC_SENSOR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 15;

	Weight = 100;

	HeatConduct = 164;
	Description = "Invisible under pressure, allowing particles through.";

	Properties = TYPE_SOLID | PROP_NEUTPASS | PROP_PHOTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	float pressureResistance = 0.0f;
	if (parts[i].tmp > 0)
		pressureResistance = (float) parts[i].tmp;
	else
		pressureResistance = 4.0f;

	if (sim->pv[y/CELL][x/CELL] < -pressureResistance || sim->pv[y/CELL][x/CELL] > pressureResistance)
		parts[i].tmp2 = 1;
	else
		parts[i].tmp2 = 0;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	//pv[ny/CELL][nx/CELL]>4.0f || pv[ny/CELL][nx/CELL]<-4.0f
	if(cpart->tmp2)
	{
		*cola = 100;
		*colr = 15;
		*colg = 0;
		*colb = 150;
		*pixel_mode = PMODE_BLEND;
	}
	return 0;
}


=== src\simulation\elements\INWR.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_INWR()
{
	Identifier = "DEFAULT_PT_INWR";
	Name = "INWR";
	Colour = 0x544141_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Insulated wire. Only conducts to PSCN, NSCN, WIFI, and SWCH.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1687.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\IRON.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_IRON()
{
	Identifier = "DEFAULT_PT_IRON";
	Name = "IRON";
	Colour = 0x707070_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 50;

	Weight = 100;

	HeatConduct = 251;
	Description = "Rusts with salt, can be used for electrolysis of WATR.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC|PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1687.0f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life)
		return 0;
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				switch (TYP(r))
				{
				case PT_SALT:
					if (sim->rng.chance(1, 47))
						goto succ;
					break;
				case PT_SLTW:
					if (sim->rng.chance(1, 67))
						goto succ;
					break;
				case PT_WATR:
					if (sim->rng.chance(1, 1200))
						goto succ;
					break;
				case PT_O2:
					if (sim->rng.chance(1, 250))
						goto succ;
					break;
				case PT_LO2:
					goto succ;
				default:
					break;
				}
			}
		}
	}
	return 0;
succ:
	sim->part_change_type(i,x,y,PT_BMTL);
	parts[i].tmp = sim->rng.between(20, 29);
	return 0;
}


=== src\simulation\elements\ISOZ.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_ISOZ()
{
	Identifier = "DEFAULT_PT_ISOZ";
	Name = "ISOZ";
	Colour = 0xAA30D0_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 24;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	Description = "Isotope-Z. Radioactive liquid, decays into photons when touching PHOT or under negative pressure.";

	Properties = TYPE_LIQUID | PROP_NEUTPENETRATE | PROP_PHOTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 160.0f;
	LowTemperatureTransition = PT_ISZS;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	float rr, rrr;
	if (sim->rng.chance(1, 200) && sim->rng.chance(int(-4.0f * sim->pv[y/CELL][x/CELL]), 1000))
	{
		sim->create_part(i, x, y, PT_PHOT);
		rr = sim->rng.between(128, 355) / 127.0f;
		rrr = sim->rng.between(0, 359) * 3.14159f / 180.0f;
		parts[i].vx = rr*cosf(rrr);
		parts[i].vy = rr*sinf(rrr);
	}
	return 0;
}


=== src\simulation\elements\ISZS.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_ISZS()
{
	Identifier = "DEFAULT_PT_ISZS";
	Name = "ISZS";
	Colour = 0x662089_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = -0.0007f* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = 140.00f;
	HeatConduct = 251;
	Description = "Solid form of ISOZ, slowly decays into PHOT.";

	Properties = TYPE_SOLID | PROP_PHOTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 300.0f;
	HighTemperatureTransition = PT_ISOZ;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	float rr, rrr;
	if (sim->rng.chance(1, 200) && sim->rng.chance(int(-4.0f * sim->pv[y/CELL][x/CELL]), 1000))
	{
		sim->create_part(i, x, y, PT_PHOT);
		rr = sim->rng.between(128, 355) / 127.0f;
		rrr = sim->rng.between(0, 359) * 3.14159f / 180.0f;
		parts[i].vx = rr*cosf(rrr);
		parts[i].vy = rr*sinf(rrr);
	}
	return 0;
}


=== src\simulation\elements\LAVA.cpp ===

#include "simulation/ElementCommon.h"
#include "FIRE.h"

static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_LAVA()
{
	Identifier = "DEFAULT_PT_LAVA";
	Name = "LAVA";
	Colour = 0xE05010_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.3f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.15f;
	Diffusion = 0.00f;
	HotAir = 0.0003f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 2;
	PhotonReflectWavelengths = 0x3FF00000;

	Weight = 45;

	DefaultProperties.temp = R_TEMP + 1500.0f + 273.15f;
	HeatConduct = 60;
	Description = "Molten lava. Ignites flammable materials. Generated when metals and other materials melt, solidifies when cold.";

	Properties = TYPE_LIQUID|PROP_LIFE_DEC;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = MAX_TEMP;// check for lava solidification at all temperatures
	LowTemperatureTransition = ST;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &Element_FIRE_update;
	Graphics = &graphics;
	Create = &create;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*colr = cpart->life * 2 + 0xE0;
	*colg = cpart->life * 1 + 0x50;
	*colb = cpart->life / 2 + 0x10;
	if (*colr>255) *colr = 255;
	if (*colg>192) *colg = 192;
	if (*colb>128) *colb = 128;
	*firea = 40;
	*firer = *colr;
	*fireg = *colg;
	*fireb = *colb;
	*pixel_mode |= FIRE_ADD;
	*pixel_mode |= PMODE_BLUR;
	//Returning 0 means dynamic, do not cache
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].life = sim->rng.between(240, 359);
}


=== src\simulation\elements\LCRY.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_LCRY()
{
	Identifier = "DEFAULT_PT_LCRY";
	Name = "LCRY";
	Colour = 0x505050_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Liquid Crystal. Changes colour when charged. (PSCN Charges, NSCN Discharges)";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1273.0f;
	HighTemperatureTransition = PT_BGLA;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	int check, setto;
	switch (parts[i].tmp)
	{
	case 1:
		if(parts[i].life<=0)
			parts[i].tmp = 0;
		else
		{
			parts[i].life-=2;
			if(parts[i].life < 0)
				parts[i].life = 0;
			parts[i].tmp2 = parts[i].life;
		}
	case 0:
		check=3;
		setto=1;
		break;
	case 2:
		if(parts[i].life>=10)
			parts[i].tmp = 3;
		else
		{
			parts[i].life+=2;
			if(parts[i].life > 10)
				parts[i].life = 10;
			parts[i].tmp2 = parts[i].life;
		}
	case 3:
		check=0;
		setto=2;
		break;
	default:
		parts[i].tmp = 0;
		parts[i].life = 0;
		return 0;
	}
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_LCRY && parts[ID(r)].tmp == check)
				{
					parts[ID(r)].tmp = setto;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	bool deco = false;
	if (gfctx.ren->decorationLevel != RendererSettings::decorationDisabled && cpart->dcolour && (cpart->dcolour&0xFF000000))
	{
		if (gfctx.ren->decorationLevel == RendererSettings::decorationEnabled) // if blackDecorations is off, always show deco
			deco = true;
		else if(((cpart->dcolour>>24)&0xFF) >= 250 && ((cpart->dcolour>>16)&0xFF) <= 5 && ((cpart->dcolour>>8)&0xFF) <= 5 && ((cpart->dcolour)&0xFF) <= 5) // else only render black deco
			deco = true;
	}

	if(deco)
	{
		*colr = (cpart->dcolour>>16)&0xFF;
		*colg = (cpart->dcolour>>8)&0xFF;
		*colb = (cpart->dcolour)&0xFF;

		if(cpart->tmp2<10){
			*colr /= 10-cpart->tmp2;
			*colg /= 10-cpart->tmp2;
			*colb /= 10-cpart->tmp2;
		}

	}
	else
	{
		*colr = *colg = *colb = 0x50+((cpart->tmp2>10?10:cpart->tmp2)*10);
	}
	*pixel_mode |= NO_DECO;
	return 0;
}



=== src\simulation\elements\LDTC.cpp ===

#include "simulation/ElementCommon.h"
#include "FILT.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_LDTC()
{
	Identifier = "DEFAULT_PT_LDTC";
	Name = "LDTC";
	Colour = 0x66ff66_rgb;
	MenuVisible = 1;
	MenuSection = SC_SENSOR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 0;
	Description = "Linear detector. Scans in 8 directions for particles with its ctype and creates a spark on the opposite side.";

	Properties = TYPE_SOLID | PROP_NOCTYPEDRAW;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	CtypeDraw = &Element::ctypeDrawVInCtype;
}

constexpr int FLAG_INVERT_FILTER =  0x1;
constexpr int FLAG_IGNORE_ENERGY =  0x2;
constexpr int FLAG_NO_COPY_COLOR =  0x4;
constexpr int FLAG_KEEP_SEARCHING = 0x8;

//NOTES:
// ctype is used to store the target element, if any. (NONE is treated as a wildcard)
// life is used for the amount of pixels to skip before starting the scan. Starts just in front of the LDTC if 0.
// tmp is the number of particles that will be scanned before scanning stops. Unbounded if 0.
// tmp2 is used for settings (binary flags). The flags are as follows:
// 0x01: Inverts the CTYPE filter so that the element in ctype is the only thing that doesn't trigger LDTC, instead of the opposite.
// 0x02: Ignore energy particles
// 0x04: Ignore FILT (do not use color copying mode)
// 0x08: Keep searching even after finding a particle


/* Returns true for particles that activate the special FILT color copying mode */
static bool phot_data_type(int rt)
{
	return rt == PT_FILT || rt == PT_PHOT || rt == PT_BRAY || rt == PT_BIZR || rt == PT_BIZRG || rt == PT_BIZRS;
}

/* Returns true for particles that start a ray search ("dtec" mode)
 */
static bool accepted_conductor(Simulation* sim, int r)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int rt = TYP(r);
	return (elements[rt].Properties & PROP_CONDUCTS) &&
		!(rt == PT_WATR || rt == PT_SLTW || rt == PT_NTCT ||
		rt == PT_PTCT || rt == PT_INWR) &&
		sim->parts[ID(r)].life == 0;
}

static int update(UPDATE_FUNC_ARGS)
{
	int ctype = TYP(parts[i].ctype), ctypeExtra = ID(parts[i].ctype), detectLength = parts[i].tmp, detectSpaces = parts[i].tmp2;
	bool copyColor = !(parts[i].tmp2 & FLAG_NO_COPY_COLOR);
	bool ignoreEnergy = parts[i].tmp2 & FLAG_IGNORE_ENERGY;
	bool invertFilter = parts[i].tmp2 & FLAG_INVERT_FILTER;
	bool keepSearching = parts[i].tmp2 & FLAG_KEEP_SEARCHING;
	if (detectSpaces < 0)
		detectSpaces = parts[i].tmp2 = 0;
	if (detectLength < 0)
		detectLength = parts[i].tmp = 0;
	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				bool boolMode = accepted_conductor(sim, r);
				bool filtMode = copyColor && TYP(r) == PT_FILT;
				if (!boolMode && !filtMode)
					continue;

				int maxRange = parts[i].life + parts[i].tmp;
				int xStep = rx * -1, yStep = ry * -1;
				int xCurrent = x + (xStep * (parts[i].life + 1)), yCurrent = y + (yStep * (parts[i].life + 1));
				for (; !parts[i].tmp ||
					(xStep * (xCurrent - x) <= maxRange &&
					yStep * (yCurrent - y) <= maxRange);
					xCurrent += xStep, yCurrent += yStep)
				{
					if (!(xCurrent>=0 && yCurrent>=0 && xCurrent<XRES && yCurrent<YRES))
						break; // We're out of bounds! Oops!
					int rr = pmap[yCurrent][xCurrent];
					if (!rr && !ignoreEnergy)
						rr = sim->photons[yCurrent][xCurrent];
					if (!rr)
						continue;

					// If ctype isn't set (no type restriction), or ctype matches what we found
					// Can use .tmp2 flag to invert this
					bool matchesCtype = ctype == TYP(rr) && (ctype != PT_LIFE || parts[ID(rr)].ctype == ctypeExtra);
					bool matchesFilter = !ctype || (invertFilter ^ (int)matchesCtype);
					if (!matchesFilter)
					{
						if (keepSearching)
							continue;
						else
							break;
					}
					// room for more conditions here.

					if (boolMode)
					{
						parts[ID(r)].life = 4;
						parts[ID(r)].ctype = TYP(r);
						sim->part_change_type(ID(r), x + rx, y + ry, PT_SPRK);
						break;
					}

					if (filtMode)
					{
						if (!phot_data_type(TYP(rr)))
							continue;

						int nx = x + rx, ny = y + ry;
						int photonWl = TYP(rr) == PT_FILT ?
							Element_FILT_getWavelengths(&parts[ID(rr)]) :
							parts[ID(rr)].ctype;
						while (TYP(r) == PT_FILT)
						{
							parts[ID(r)].ctype = photonWl;
							nx += rx;
							ny += ry;
							if (nx < 0 || ny < 0 || nx >= XRES || ny >= YRES)
								break;
							r = pmap[ny][nx];
						}
						break;
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\LIFE.cpp ===

#include "simulation/ElementCommon.h"

static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_LIFE()
{
	Identifier = "DEFAULT_PT_LIFE";
	Name = "LIFE";
	Colour = 0x0CAC00_rgb;
	MenuVisible = 0;
	MenuSection = SC_LIFE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = 9000.0f;
	HeatConduct = 40;
	Description = "Game Of Life! B3/S23";

	Properties = TYPE_SOLID|PROP_LIFE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Graphics = &graphics;
	Create = &create;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	auto &builtinGol = SimulationData::builtinGol;
	auto colour1 = RGB::Unpack(cpart->dcolour);
	auto colour2 = RGB::Unpack(cpart->tmp);
	if (!cpart->dcolour)
	{
		colour1 = 0xFFFFFF_rgb;
	}
	auto ruleset = cpart->ctype;
	bool renderDeco = gfctx.ren->decorationLevel != RendererSettings::decorationAntiClickbait;
	if (ruleset >= 0 && ruleset < NGOL)
	{
		if (!renderDeco || gfctx.ren->decorationLevel == RendererSettings::decorationDisabled)
		{
			colour1 = builtinGol[ruleset].colour;
			colour2 = builtinGol[ruleset].colour2;
			renderDeco = true;
		}
		ruleset = builtinGol[ruleset].ruleset;
	}
	if (renderDeco)
	{
		auto states = ((ruleset >> 17) & 0xF) + 2;
		if (states == 2)
		{
			*colr = colour1.Red;
			*colg = colour1.Green;
			*colb = colour1.Blue;
		}
		else
		{
			auto mul = (cpart->tmp2 - 1) / float(states - 2);
			*colr = int(colour1.Red   * mul + colour2.Red   * (1.f - mul));
			*colg = int(colour1.Green * mul + colour2.Green * (1.f - mul));
			*colb = int(colour1.Blue  * mul + colour2.Blue  * (1.f - mul));
		}
	}
	*pixel_mode |= NO_DECO;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &builtinGol = sd.builtinGol;
	if (v == -1)
		v = 0;
	// * 0x200000: No need to look for colours, they'll be set later anyway.
	bool skipLookup = v & 0x200000;
	v &= 0x1FFFFF;
	sim->parts[i].ctype = v;
	if (v < NGOL)
	{
		sim->parts[i].dcolour = builtinGol[v].colour.Pack();
		sim->parts[i].tmp = builtinGol[v].colour2.Pack();
		v = builtinGol[v].ruleset;
	}
	else if (!skipLookup)
	{
		auto *cgol = sd.GetCustomGOLByRule(v);
		if (cgol)
		{
			sim->parts[i].dcolour = cgol->colour1.Pack();
			sim->parts[i].tmp = cgol->colour2.Pack();
		}
	}
	sim->parts[i].tmp2 = ((v >> 17) & 0xF) + 1;
}


=== src\simulation\elements\LIGH.cpp ===

#include "simulation/ElementCommon.h"

#include "graphics/Pixel.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);
static void create_line_par(Simulation * sim, int x1, int y1, int x2, int y2, int c, float temp, int life, int tmp, int tmp2, int i);

void Element::Element_LIGH()
{
	Identifier = "DEFAULT_PT_LIGH";
	Name = "LIGH";
	Colour = 0xFFFFC0_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Lightning. Change the brush size to set the size of the lightning.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

constexpr float LIGHTING_POWER = 0.65f;

static int update(UPDATE_FUNC_ARGS)
{
	/*
	 * tmp2:
	 * 0 - bending
	 * 1 - bending (particle order deferred)
	 * 2 - branching
	 * 3 - branching (particle order deferred)
	 * 4 - first pixel
	 * 5+  normal segment. Starts at 8, counts down and is removed at 5
	 *
	 * life - power of lightning, influences reaction strength and segment length
	 *
	 * tmp - angle of lighting, measured in degrees counterclockwise from the positive x direction
	 */
	auto powderful = int(parts[i].temp*(1+parts[i].life/40)*LIGHTING_POWER);
	//Element_FIRE::update(UPDATE_FUNC_SUBCALL_ARGS);
	if (sim->aheat_enable)
	{
		sim->hv[y/CELL][x/CELL] += powderful/50;
		if (sim->hv[y/CELL][x/CELL] > MAX_TEMP)
			sim->hv[y/CELL][x/CELL] = MAX_TEMP;
		// If the LIGH was so powerful that it overflowed hv, set to max temp
		else if (sim->hv[y/CELL][x/CELL] < 0)
			sim->hv[y/CELL][x/CELL] = MAX_TEMP;
	}

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if ((surround_space || elements[rt].Explosive) &&
				    (rt!=PT_SPNG || parts[ID(r)].life==0) &&
					elements[rt].Flammable && sim->rng.chance(elements[rt].Flammable + int(sim->pv[(y+ry)/CELL][(x+rx)/CELL] * 10.0f), 1000))
				{
					sim->part_change_type(ID(r),x+rx,y+ry,PT_FIRE);
					parts[ID(r)].temp = restrict_flt(elements[PT_FIRE].DefaultProperties.temp + (elements[rt].Flammable/2), MIN_TEMP, MAX_TEMP);
					parts[ID(r)].life = sim->rng.between(180, 259);
					parts[ID(r)].tmp = parts[ID(r)].ctype = 0;
					if (elements[rt].Explosive)
						sim->pv[y/CELL][x/CELL] += 0.25f * CFDS;
				}
				switch (rt)
				{
				case PT_LIGH:
				case PT_TESC:
					continue;
				case PT_CLNE:
				case PT_THDR:
				case PT_DMND:
				case PT_FIRE:
					parts[ID(r)].temp = restrict_flt(parts[ID(r)].temp+powderful/10, MIN_TEMP, MAX_TEMP);
					continue;
				case PT_DEUT:
				case PT_PLUT:
					parts[ID(r)].temp = restrict_flt(parts[ID(r)].temp+powderful, MIN_TEMP, MAX_TEMP);
					sim->pv[y/CELL][x/CELL] +=powderful/35;
					if (sim->rng.chance(1, 3))
					{
						sim->part_change_type(ID(r),x+rx,y+ry,PT_NEUT);
						parts[ID(r)].life = sim->rng.between(480, 959);
						parts[ID(r)].vx = float(sim->rng.between(-5, 5));
						parts[ID(r)].vy = float(sim->rng.between(-5, 5));
					}
					break;
				case PT_COAL:
				case PT_BCOL:
					if (parts[ID(r)].life>100)
						parts[ID(r)].life = 99;
					break;
				case PT_STKM:
					if (sim->player.elem!=PT_LIGH)
						parts[ID(r)].life-=powderful/100;
					break;
				case PT_STKM2:
					if (sim->player2.elem!=PT_LIGH)
						parts[ID(r)].life-=powderful/100;
					break;
				case PT_HEAC:
					parts[ID(r)].temp = restrict_flt(parts[ID(r)].temp+powderful/10, MIN_TEMP, MAX_TEMP);
					if (parts[ID(r)].temp > elements[PT_HEAC].HighTemperature)
					{
						sim->part_change_type(ID(r), x+rx, y+ry, PT_LAVA);
						parts[ID(r)].ctype = PT_HEAC;
					}
					break;
				default:
					break;
				}
				if ((elements[TYP(r)].Properties&PROP_CONDUCTS) && parts[ID(r)].life==0)
					sim->create_part(ID(r),x+rx,y+ry,PT_SPRK);
				sim->pv[y/CELL][x/CELL] += powderful/400;
				if (!sim->IsHeatInsulator(parts[ID(r)])) parts[ID(r)].temp = restrict_flt(parts[ID(r)].temp+powderful/1.3, MIN_TEMP, MAX_TEMP);
			}
		}
	}
	// Deferred branch or bend; or in removal countdown stage
	if (parts[i].tmp2 == 1 || parts[i].tmp2 == 3 || (parts[i].tmp2 >= 6 && parts[i].tmp2 <= 8))
	{
		// Probably set via console, make sure it doesn't stick around forever
		if (parts[i].tmp2 >= 9)
			parts[i].tmp2 = 7;
		else
			parts[i].tmp2--;
		return 0;
	}
	if (parts[i].tmp2 == 5 || parts[i].life <= 1)
	{
		sim->kill_part(i);
		return 1;
	}
	auto angle = float((parts[i].tmp + sim->rng.between(-30, 30)) % 360);
	auto multipler = int(parts[i].life * 1.5) + sim->rng.between(0, parts[i].life);
	auto rx=int(cos(angle*TPT_PI_FLT/180)*multipler);
	auto ry=int(-sin(angle*TPT_PI_FLT/180)*multipler);
	create_line_par(sim, x, y, x+rx, y+ry, PT_LIGH, parts[i].temp, parts[i].life, int(angle), parts[i].tmp2, i);
	if (parts[i].tmp2 == 2)// && pNear == -1)
	{
		auto angle2 = float(((int)angle + sim->rng.between(-100, 100)) % 360);
		rx=int(cos(angle2*TPT_PI_FLT/180)*multipler);
		ry=int(-sin(angle2*TPT_PI_FLT/180)*multipler);
		create_line_par(sim, x, y, x+rx, y+ry, PT_LIGH, parts[i].temp, parts[i].life, int(angle2), parts[i].tmp2, i);
	}

	parts[i].tmp2 = 7;
	return 0;
}

static bool create_LIGH(Simulation * sim, int x, int y, int c, float temp, int life, int tmp, int tmp2, bool last, int i)
{
	int p = sim->create_part(-1, x, y,c);
	if (p != -1)
	{
		sim->parts[p].temp = float(temp);
		sim->parts[p].tmp = tmp;
		sim->parts[p].dcolour = sim->parts[i].dcolour;
		if (last)
		{
			int nextSegmentLife = (int)(life/1.5 - sim->rng.between(0, 1));
			sim->parts[p].life = nextSegmentLife;
			if (nextSegmentLife > 1)
			{
				// Decide whether to branch or to bend
				bool doBranch = sim->rng.chance(7, 10);
				sim->parts[p].tmp2 = (doBranch ? 2 : 0) + (p > i && tmp2 != 4 ? 1 : 0);
			}
			// Not enough energy to continue
			else
			{
				sim->parts[p].tmp2 = 7 + (p > i ? 1 : 0);
			}
		}
		else
		{
			sim->parts[p].life = life;
			sim->parts[p].tmp2 = 7 + (p > i ? 1 : 0);
		}
	}
	else if (x >= 0 && x < XRES && y >= 0 && y < YRES)
	{
		int r = sim->pmap[y][x];
		if (((TYP(r)==PT_VOID || (TYP(r)==PT_PVOD && sim->parts[ID(r)].life >= 10)) && (!sim->parts[ID(r)].ctype || (sim->parts[ID(r)].ctype==c)!=(sim->parts[ID(r)].tmp&1))) || TYP(r)==PT_BHOL || TYP(r)==PT_NBHL) // VOID, PVOD, VACU, and BHOL eat LIGH here
			return true;
	}
	else return true;
	return false;
}

static void create_line_par(Simulation * sim, int x1, int y1, int x2, int y2, int c, float temp, int life, int tmp, int tmp2, int i)
{
	bool reverseXY = abs(y2-y1) > abs(x2-x1), back = false;
	int x, y, dx, dy, Ystep;
	float e = 0.0f, de;
	if (reverseXY)
	{
		y = x1;
		x1 = y1;
		y1 = y;
		y = x2;
		x2 = y2;
		y2 = y;
	}
	if (x1 > x2)
		back = 1;
	dx = x2 - x1;
	dy = abs(y2 - y1);
	if (dx)
		de = dy/(float)dx;
	else
		de = 0.0f;
	y = y1;
	Ystep = (y1<y2) ? 1 : -1;
	if (!back)
	{
		for (x = x1; x <= x2; x++)
		{
			bool ret;
			if (reverseXY)
				ret = create_LIGH(sim, y, x, c, temp, life, tmp, tmp2,x==x2, i);
			else
				ret = create_LIGH(sim, x, y, c, temp, life, tmp, tmp2,x==x2, i);
			if (ret)
				return;

			e += de;
			if (e >= 0.5f)
			{
				y += Ystep;
				e -= 1.0f;
			}
		}
	}
	else
	{
		for (x = x1; x >= x2; x--)
		{
			bool ret;
			if (reverseXY)
				ret = create_LIGH(sim, y, x, c, temp, life, tmp, tmp2,x==x2, i);
			else
				ret = create_LIGH(sim, x, y, c, temp, life, tmp, tmp2,x==x2, i);
			if (ret)
				return;

			e += de;
			if (e <= -0.5f)
			{
				y += Ystep;
				e += 1.0f;
			}
		}
	}
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 120;
	*firer = *colr = 235;
	*fireg = *colg = 245;
	*fireb = *colb = 255;
	*pixel_mode |= PMODE_GLOW | FIRE_ADD | DECO_FIRE;
	return 1;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	float gx, gy, gsize;
	if (v >= 0)
	{
		if (v > 55)
			v = 55;
		sim->parts[i].life = v;
	}
	else
		sim->parts[i].life = 30;
	sim->parts[i].temp = sim->parts[i].life * 150.0f; // temperature of the lightning shows the power of the lightning
	sim->GetGravityField(x, y, 1.0f, 1.0f, gx, gy);
	gsize = gx * gx + gy * gy;
	if (gsize < 0.0016f)
	{
		float angle = sim->rng.between(0, 6283) * 0.001f; //(in radians, between 0 and 2*pi)
		gsize = sqrtf(gsize);
		// randomness in weak gravity fields (more randomness with weaker fields)
		gx += cosf(angle) * (0.04f - gsize);
		gy += sinf(angle) * (0.04f - gsize);
	}
	sim->parts[i].tmp = (static_cast<int>(atan2f(-gy, gx) * (180.0f / TPT_PI_FLT)) + sim->rng.between(-20, 20) + 360) % 360;
	sim->parts[i].tmp2 = 4;
}


=== src\simulation\elements\LITH.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_LITH()
{
	Identifier = "DEFAULT_PT_LITH";
	Name = "LITH";
	Colour = 0xB6AABF_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.2f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.2f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 15;

	Weight = 17;

	HeatConduct = 70;
	Description = "Lithium. Reactive element that explodes on contact with water.";

	Properties = TYPE_PART | PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 453.65f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
	Graphics = &graphics;
}

/*

tmp2:  carbonation factor
life:  burn timer above 1000, spark cooldown timer otherwise
tmp:   hydrogenation factor
ctype: absorbed energy

For game reasons, baseline LITH has the reactions of both its pure form and
its hydroxide, and also has basic li-ion battery-like behavior.
It absorbs CO2 like its hydroxide form, but can only be converted into GLAS
after having absorbed CO2.

*/

static int update(UPDATE_FUNC_ARGS)
{
	Particle &self = parts[i];

	int &hydrogenationFactor = self.tmp;
	int &burnTimer = self.life;
	int &carbonationFactor = self.tmp2;
	int &storedEnergy = self.ctype;
	if (storedEnergy < 0)
	{
		storedEnergy = 0;
	}

	bool charged = false;
	bool discharged = false;
	for (int rx = -2; rx <= 2; ++rx)
	{
		for (int ry = -2; ry <= 2; ++ry)
		{
			if (rx || ry)
			{
				int neighborData = pmap[y + ry][x + rx];
				if (!neighborData)
				{
					if (burnTimer > 1012 && sim->rng.chance(1, 10))
					{
						sim->create_part(-1, x + rx, y + ry, PT_FIRE);
					}
					continue;
				}
				Particle &neighbor = parts[ID(neighborData)];

				auto pavg = sim->parts_avg(i, ID(neighborData), PT_INSL);

				switch (TYP(neighborData))
				{
				case PT_SLTW:
				case PT_WTRV:
				case PT_WATR:
				case PT_DSTW:
				case PT_CBNW:
					if (burnTimer > 1016)
					{
						sim->part_change_type(ID(neighborData), x + rx, y + ry, PT_WTRV);
						neighbor.temp = 440.f;
						continue;
					}
					if (hydrogenationFactor + carbonationFactor >= 10)
					{
						continue;
					}
					if (self.temp > 440.f)
					{
						burnTimer = 1024 + (storedEnergy > 24 ? 96 : storedEnergy * 4);
						sim->part_change_type(ID(neighborData), x + rx, y + ry, PT_H2);
						hydrogenationFactor = 10;
					}
					else
					{
						self.temp = restrict_flt(self.temp + 20.365f + storedEnergy * storedEnergy * 1.5f, MIN_TEMP, MAX_TEMP);
						sim->part_change_type(ID(neighborData), x + rx, y + ry, PT_H2);
						hydrogenationFactor += 1;
					}
					break;

				case PT_CO2:
					if (hydrogenationFactor + carbonationFactor >= 10)
					{
						continue;
					}
					sim->kill_part(ID(neighborData));
					carbonationFactor += 1;
					break;

				case PT_SPRK:
					if (pavg == PT_INSL || pavg == PT_RSSS)
					{
						break;
					}
					if (hydrogenationFactor + carbonationFactor >= 5)
					{
						continue; // too impure to do battery things.
					}
					if (neighbor.ctype == PT_PSCN && neighbor.life == 3 && !charged && !burnTimer)
					{
						charged = true;
					}
					break;

				case PT_NSCN:
					if (pavg == PT_INSL || pavg == PT_RSSS)
					{
						break;
					}
					if (neighbor.life == 0 && storedEnergy > 0 && !burnTimer)
					{
						sim->part_change_type(ID(neighborData), x + rx, y + ry, PT_SPRK);
						neighbor.life = 4;
						neighbor.ctype = PT_NSCN;
						discharged = true;
					}
					break;

				case PT_FIRE:
					if (self.temp > 440.f && sim->rng.chance(1, 40) && hydrogenationFactor < 6)
					{
						burnTimer = 1013;
						hydrogenationFactor += 1;
					}
					break;

				case PT_O2:
					if (burnTimer > 1000 && sim->rng.chance(1, 10))
					{
						sim->part_change_type(i, x, y, PT_PLSM);
						sim->part_change_type(ID(neighborData), x + rx, y + ry, PT_PLSM);
						sim->pv[y / CELL][x / CELL] += 4.0;
						return 0;
					}						
					break;
				}
			}
		}
	}
	if (charged)
	{
		storedEnergy += 1;
		burnTimer = 8;
	}
	if (discharged)
	{
		storedEnergy -= 1;
		burnTimer = 8;
	}

	for (int trade = 0; trade < 9; ++trade)
	{
		int rx = sim->rng.between(-3, 3);
		int ry = sim->rng.between(-3, 3);
		if (rx || ry)
		{
			int neighborData = pmap[y + ry][x + rx];
			if (TYP(neighborData) != PT_LITH)
			{
				continue;
			}
			Particle &neighbor = parts[ID(neighborData)];

			int &neighborStoredEnergy = neighbor.ctype;
			// Transfer overcharge explosion status to nearby LITH
			if (burnTimer < 1000 && storedEnergy > 90 && neighbor.life > 1000)
				burnTimer = 1024;
			if (storedEnergy > neighborStoredEnergy)
			{
				int transfer = storedEnergy - neighborStoredEnergy;
				transfer -= transfer / 2;
				neighborStoredEnergy += transfer;
				storedEnergy -= transfer;
				break;
			}
		}
	}

	// Overcharged - begin explosion
	if (burnTimer < 1000 && storedEnergy >= 100)
		burnTimer = 1024;
	if (burnTimer == 1000)
	{
		burnTimer = 0;
		sim->part_change_type(i, x, y, PT_LAVA);
		if (carbonationFactor < 3)
		{
			self.temp = restrict_flt(500.f + storedEnergy * 10, MIN_TEMP, MAX_TEMP);
			self.ctype = PT_LITH;
		}
		else
		{
			self.temp = restrict_flt(2000.f + storedEnergy * 10, MIN_TEMP, MAX_TEMP);
			self.ctype = PT_GLAS;
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	// Exploding lith
	if (cpart->life >= 1000)
	{
		auto colour = 0xFFA040_rgb;
		*colr = colour.Red;
		*colg = colour.Green;
		*colb = colour.Blue;
		*pixel_mode |= PMODE_FLARE | PMODE_GLOW;
	}
	// Charged lith
	else if (cpart->ctype > 0)
	{
		int mult = gfctx.rng.between(cpart->ctype / 3, cpart->ctype) / 15;
		mult = std::min(6, mult);
		*colr -= 30 * mult;
		*colb += 20 * mult;
		*pixel_mode |= PMODE_FLARE | PMODE_GLOW;
	}
	return 0;
}


=== src\simulation\elements\LNTG.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_LNTG()
{
	Identifier = "DEFAULT_PT_LNTG";
	Name = "LN2";
	Colour = 0x80A0DF_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 30;

	DefaultProperties.temp = 70.15f;
	HeatConduct = 70;
	Description = "Liquid Nitrogen. Very cold, disappears whenever it touches anything warmer.";

	Properties = TYPE_LIQUID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 63.0f;
	LowTemperatureTransition = PT_NICE;
	HighTemperature = 77.0f;
	HighTemperatureTransition = PT_NONE;
}


=== src\simulation\elements\LO2.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_LO2()
{
	Identifier = "DEFAULT_PT_LO2";
	Name = "LOXY";
	Colour = 0x80A0EF_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 5000;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 30;

	DefaultProperties.temp = 80.0f;
	HeatConduct = 70;
	Description = "Liquid Oxygen. Very cold. Reacts with fire.";

	Properties = TYPE_LIQUID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 90.1f;
	HighTemperatureTransition = PT_O2;
}


=== src\simulation\elements\LOLZ.cpp ===

#include "simulation/ElementCommon.h"
#include "LOLZ.h"

void Element::Element_LOLZ()
{
	Identifier = "DEFAULT_PT_LOLZ";
	Name = "LOLZ";
	Colour = 0x569212_rgb;
	MenuVisible = 0;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.0f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = 373.0f;
	HeatConduct = 40;
	Description = "Lolz";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}

int Element_LOLZ_RuleTable[9][9] =
{
	{0,0,0,0,0,0,0,0,0},
	{1,0,0,0,0,0,1,0,0},
	{1,0,0,0,0,0,1,0,0},
	{1,0,0,1,1,0,0,1,0},
	{1,0,1,0,0,1,0,1,0},
	{1,0,1,0,0,1,0,1,0},
	{0,1,0,1,1,0,0,1,0},
	{0,1,0,0,0,0,0,1,0},
	{0,1,0,0,0,0,0,1,0},
};

int Element_LOLZ_lolz[XRES/9][YRES/9];


=== src\simulation\elements\LOLZ.h ===

#pragma once
#include "simulation/ElementDefs.h"

extern int Element_LOLZ_RuleTable[9][9];
extern int Element_LOLZ_lolz[XRES/9][YRES/9];
extern int Element_LOVE_RuleTable[9][9];
extern int Element_LOVE_love[XRES/9][YRES/9];


=== src\simulation\elements\LOVE.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_LOVE()
{
	Identifier = "DEFAULT_PT_LOVE";
	Name = "LOVE";
	Colour = 0xFF30FF_rgb;
	MenuVisible = 0;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.0f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = 373.0f;
	HeatConduct = 40;
	Description = "Love...";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}

int Element_LOVE_RuleTable[9][9] =
{
	{0,0,1,1,0,0,0,0,0},
	{0,1,0,0,1,1,0,0,0},
	{1,0,0,0,0,0,1,0,0},
	{1,0,0,0,0,0,0,1,0},
	{0,1,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,1,0},
	{1,0,0,0,0,0,1,0,0},
	{0,1,0,0,1,1,0,0,0},
	{0,0,1,1,0,0,0,0,0},
};

int Element_LOVE_love[XRES/9][YRES/9];


=== src\simulation\elements\LRBD.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_LRBD()
{
	Identifier = "DEFAULT_PT_LRBD";
	Name = "LRBD";
	Colour = 0xAAAAAA_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.3f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.15f;
	Diffusion = 0.00f;
	HotAir = 0.000001f* CFDS;
	Falldown = 2;

	Flammable = 1000;
	Explosive = 1;
	Meltable = 0;
	Hardness = 2;

	Weight = 45;

	DefaultProperties.temp = R_TEMP + 45.0f + 273.15f;
	HeatConduct = 170;
	Description = "Liquid Rubidium.";

	Properties = TYPE_LIQUID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 311.0f;
	LowTemperatureTransition = PT_RBDM;
	HighTemperature = 961.0f;
	HighTemperatureTransition = PT_FIRE;
}


=== src\simulation\elements\LSNS.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_LSNS()
{
	Identifier = "DEFAULT_PT_LSNS";
	Name = "LSNS";
	Colour = 0x336699_rgb;
	MenuVisible = 1;
	MenuSection = SC_SENSOR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = 4.0f + 273.15f;
	HeatConduct = 0;
	Description = "Life sensor, creates a spark when there's a nearby particle with a life higher than its temperature.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.tmp2 = 2;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int rd = parts[i].tmp2;
	if (rd > 25) parts[i].tmp2 = rd = 25;
	if (parts[i].life)
	{
		parts[i].life = 0;
		for (int rx = -2; rx <= 2; rx++)
		{
			for (int ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					int r = pmap[y + ry][x + rx];
					if (!r)
						r = sim->photons[y + ry][x + rx];
					if (!r)
						continue;
					int rt = TYP(r);
					auto pavg = sim->parts_avg(i, ID(r), PT_INSL);
					if (pavg != PT_INSL && pavg != PT_RSSS)
					{
						if ((elements[rt].Properties&PROP_CONDUCTS) && !(rt == PT_WATR || rt == PT_SLTW || rt == PT_NTCT || rt == PT_PTCT || rt == PT_INWR) && parts[ID(r)].life == 0)
						{
							parts[ID(r)].life = 4;
							parts[ID(r)].ctype = rt;
							sim->part_change_type(ID(r), x + rx, y + ry, PT_SPRK);
						}
					}
				}
			}
		}
	}
	bool doSerialization = false;
	bool doDeserialization = false;
	int life = 0;
	for (int rx = -rd; rx < rd + 1; rx++)
	{
		for (int ry = -rd; ry < rd + 1; ry++)
		{
			if (x + rx >= 0 && y + ry >= 0 && x + rx < XRES && y + ry < YRES && (rx || ry))
			{
				int r = pmap[y + ry][x + rx];
				if (!r)
					r = sim->photons[y + ry][x + rx];
				if (!r)
					continue;

				switch (parts[i].tmp)
				{
				case 1:
					// .life serialization into FILT
					if (TYP(r) != PT_LSNS && TYP(r) != PT_FILT && parts[ID(r)].life >= 0)
					{
						doSerialization = true;
						life = parts[ID(r)].life;
					}
					break;
				case 3:
					// .life deserialization
					if (TYP(r) == PT_FILT)
					{
						doDeserialization = true;
						life = parts[ID(r)].ctype;
					}
					break;
				case 2:
					// Invert mode
					if (TYP(r) != PT_METL && parts[ID(r)].life <= parts[i].temp - 273.15)
						parts[i].life = 1;
					break;
				default:
					// Normal mode
					if (TYP(r) != PT_METL && parts[ID(r)].life > parts[i].temp - 273.15)
						parts[i].life = 1;
					break;
				}
			}
		}
	}

	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y + ry][x + rx];
				if (!r)
					r = sim->photons[y + ry][x + rx];
				if (!r)
					continue;
				int nx = x + rx;
				int ny = y + ry;
				// .life serialization.
				if (doSerialization)
				{
					while (TYP(r) == PT_FILT)
					{
						parts[ID(r)].ctype = 0x10000000 + life;
						nx += rx;
						ny += ry;
						if (nx < 0 || ny < 0 || nx >= XRES || ny >= YRES)
							break;
						r = pmap[ny][nx];
					}
				}
				// .life deserialization.
				else if (doDeserialization)
				{
					if (TYP(r) != PT_FILT)
						parts[ID(r)].life = life - 0x10000000;
				}
			}
		}
	}

	return 0;
}


=== src\simulation\elements\MERC.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_MERC()
{
	Identifier = "DEFAULT_PT_MERC";
	Name = "MERC";
	Colour = 0x736B6D_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 91;

	HeatConduct = 251;
	Description = "Mercury. Volume changes with temperature, Conductive.";

	Properties = TYPE_LIQUID|PROP_CONDUCTS|PROP_NEUTABSORB|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.tmp = 10;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	// Max number of particles that can be condensed into one
	const int absorbScale = 10000;
	// Obscure division by 0 fix
	if (parts[i].temp + 1 == 0)
		parts[i].temp = 0;
	int maxtmp = int(absorbScale/(parts[i].temp + 1))-1;
	if (sim->rng.chance(absorbScale%(int(parts[i].temp)+1), int(parts[i].temp)+1))
		maxtmp ++;

	if (parts[i].tmp < 0)
	{
		parts[i].tmp = 0;
	}
	if (parts[i].tmp > absorbScale)
	{
		parts[i].tmp = absorbScale;
	}

	if (parts[i].tmp < maxtmp)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r || (parts[i].tmp >=maxtmp))
						continue;
					if (TYP(r)==PT_MERC&& sim->rng.chance(1, 3))
					{
						if ((parts[i].tmp + parts[ID(r)].tmp + 1) <= maxtmp)
						{
							parts[i].tmp += parts[ID(r)].tmp + 1;
							sim->kill_part(ID(r));
						}
					}
				}
			}
		}
	}
	else
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (parts[i].tmp<=maxtmp)
						continue;
					if ((!r)&&parts[i].tmp>=1)//if nothing then create MERC
					{
						auto np = sim->create_part(-1,x+rx,y+ry,PT_MERC);
						if (np<0) continue;
						parts[i].tmp--;
						parts[np].temp = parts[i].temp;
						parts[np].tmp = 0;
						parts[np].dcolour = parts[i].dcolour;
					}
				}
			}
		}
	}
	for (auto trade = 0; trade<4; trade ++)
	{
		auto rx = sim->rng.between(-2, 2);
		auto ry = sim->rng.between(-2, 2);
		if (rx || ry)
		{
			auto r = pmap[y+ry][x+rx];
			if (!r)
				continue;
			if (TYP(r)==PT_MERC&&(parts[i].tmp>parts[ID(r)].tmp)&&parts[i].tmp>0)//diffusion
			{
				int temp = parts[i].tmp - parts[ID(r)].tmp;
				if (temp ==1)
				{
					parts[ID(r)].tmp ++;
					parts[i].tmp --;
				}
				else if (temp>0)
				{
					parts[ID(r)].tmp += temp/2;
					parts[i].tmp -= temp/2;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\meson.build ===

simulation_elem_names = [
	'NONE',
	'DUST',
	'WATR',
	'OIL',
	'FIRE',
	'STNE',
	'LAVA',
	'GUNP',
	'NITR',
	'CLNE',
	'GAS',
	'PLEX',
	'GOO',
	'ICEI',
	'METL',
	'SPRK',
	'SNOW',
	'WOOD',
	'NEUT',
	'PLUT',
	'PLNT',
	'ACID',
	'VOID',
	'WTRV',
	'CNCT',
	'DSTW',
	'SALT',
	'SLTW',
	'DMND',
	'BMTL',
	'BRMT',
	'PHOT',
	'URAN',
	'WAX',
	'MWAX',
	'PSCN',
	'NSCN',
	'LNTG',
	'INSL',
	'BHOL',
	'WHOL',
	'RBDM',
	'LRBD',
	'NTCT',
	'SAND',
	'GLAS',
	'PTCT',
	'BGLA',
	'THDR',
	'PLSM',
	'ETRD',
	'NICE',
	'NBLE',
	'BTRY',
	'LCRY',
	'STKM',
	'SWCH',
	'SMKE',
	'DESL',
	'COAL',
	'LO2',
	'O2',
	'INWR',
	'YEST',
	'DYST',
	'THRM',
	'GLOW',
	'BRCK',
	'CFLM',
	'FIRW',
	'FUSE',
	'FSEP',
	'AMTR',
	'BCOL',
	'PCLN',
	'HSWC',
	'IRON',
	'MORT',
	'LIFE',
	'DLAY',
	'CO2',
	'DRIC',
	'CBNW',
	'STOR',
	'PVOD',
	'CONV',
	'CAUS',
	'LIGH',
	'TESC',
	'DEST',
	'SPNG',
	'RIME',
	'FOG',
	'BCLN',
	'LOVE',
	'DEUT',
	'WARP',
	'PUMP',
	'FWRK',
	'PIPE',
	'FRZZ',
	'FRZW',
	'GRAV',
	'BIZR',
	'BIZRG',
	'BIZRS',
	'INST',
	'ISOZ',
	'ISZS',
	'PRTI',
	'PRTO',
	'PSTE',
	'PSTS',
	'ANAR',
	'VINE',
	'INVIS',
	'E116',
	'SPAWN2',
	'SPAWN',
	'SHLD1',
	'SHLD2',
	'SHLD3',
	'SHLD4',
	'LOLZ',
	'WIFI',
	'FILT',
	'ARAY',
	'BRAY',
	'STKM2',
	'BOMB',
	'C5',
	'SING',
	'QRTZ',
	'PQRT',
	'EMP',
	'BREC',
	'ELEC',
	'ACEL',
	'DCEL',
	'BANG',
	'IGNT',
	'BOYL',
	'GEL',
	'TRON',
	'TTAN',
	'EXOT',
	disabler(),
	'EMBR',
	'H2',
	'SOAP',
	'NBHL',
	'NWHL',
	'MERC',
	'PBCN',
	'GPMP',
	'CLST',
	'WIRE',
	'GBMB',
	'FIGH',
	'FRAY',
	'RPEL',
	'PPIP',
	'DTEC',
	'DMG',
	'TSNS',
	'VIBR',
	'BVBR',
	'CRAY',
	'PSTN',
	'FRME',
	'GOLD',
	'TUNG',
	'PSNS',
	'PROT',
	'VIRS',
	'VRSS',
	'VRSG',
	'GRVT',
	'DRAY',
	'CRMC',
	'HEAC',
	'SAWD',
	'POLO',
	'RFRG',
	'RFGL',
	'LSNS',
	'LDTC',
	'SLCN',
	'PTNM',
	'VSNS',
	'ROCK',
	'LITH',
	'RSST',
	'RSSS'
]

simulation_elem_src = []
simulation_elem_ids = []
elem_id = 0
foreach elem_name : simulation_elem_names
	if not is_disabler(elem_name)
		simulation_elem_src += elem_name + '.cpp'
		simulation_elem_ids += [ [ elem_name, elem_id ] ]
	endif
	elem_id = elem_id + 1
endforeach
simulation_files += files(simulation_elem_src)


=== src\simulation\elements\METL.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_METL()
{
	Identifier = "DEFAULT_PT_METL";
	Name = "METL";
	Colour = 0x404060_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	LatentHeat = 919;
	Description = "Metal, the basic conductor. Meltable.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC|PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1273.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\MORT.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_MORT()
{
	Identifier = "DEFAULT_PT_MORT";
	Name = "MORT";
	Colour = 0xE0E0E0_rgb;
	MenuVisible = 0;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 1.00f;
	Collision = -0.99f;
	Gravity = 0.0f;
	Diffusion = 0.01f;
	HotAir = 0.002f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = -1;

	DefaultProperties.temp = R_TEMP + 4.0f + 273.15f;
	HeatConduct = 60;
	Description = "Steam Train.";

	Properties = TYPE_GAS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	// CHOO CHOO
	DefaultProperties.vx = 2.0f;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	sim->create_part(-1, x, y-1, PT_SMKE);
	return 0;
}


=== src\simulation\elements\MWAX.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_MWAX()
{
	Identifier = "DEFAULT_PT_MWAX";
	Name = "MWAX";
	Colour = 0xE0E0AA_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.3f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.15f;
	Diffusion = 0.00f;
	HotAir = 0.000001f* CFDS;
	Falldown = 2;

	Flammable = 5;
	Explosive = 0;
	Meltable = 0;
	Hardness = 2;

	Weight = 25;

	DefaultProperties.temp = R_TEMP + 28.0f + 273.15f;
	HeatConduct = 44;
	Description = "Liquid Wax. Hardens into WAX at 45 degrees.";

	Properties = TYPE_LIQUID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 318.0f;
	LowTemperatureTransition = PT_WAX;
	HighTemperature = 673.0f;
	HighTemperatureTransition = PT_FIRE;
}


=== src\simulation\elements\NBHL.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_NBHL()
{
	Identifier = "DEFAULT_PT_NBHL";
	Name = "BHOL";
	Colour = 0x202020_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 186;
	Description = "Black hole, sucks in particles using gravity. (Requires Newtonian gravity)";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].tmp)
	{
		sim->gravIn.mass[Vec2{ x, y } / CELL] += restrict_flt(0.001f * parts[i].tmp, 0.1f, 51.2f);
	}
	else
	{
		sim->gravIn.mass[Vec2{ x, y } / CELL] += 0.1f;
	}
	return 0;
}


=== src\simulation\elements\NBLE.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_NBLE()
{
	Identifier = "DEFAULT_PT_NBLE";
	Name = "NBLE";
	Colour = 0xEB4917_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 1.0f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 0.75f;
	HotAir = 0.001f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;
	PhotonReflectWavelengths = 0x3FFF8000;

	Weight = 1;

	DefaultProperties.temp = R_TEMP + 2.0f + 273.15f;
	HeatConduct = 106;
	Description = "Noble Gas. Ionizes into plasma when sparked. Diffuses.";

	Properties = TYPE_GAS|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &can_move = sd.can_move;
	if (parts[i].temp > 5273.15 && sim->pv[y/CELL][x/CELL] > 100.0f)
	{
		parts[i].tmp |= 0x1;
		if (sim->rng.chance(1, 5))
		{
			int j;
			float temp = parts[i].temp;
			sim->create_part(i,x,y,PT_CO2);

			j = sim->create_part(-3,x,y,PT_NEUT);
			if (j != -1)
				parts[j].temp = temp;
			if (sim->rng.chance(1, 25))
			{
				j = sim->create_part(-3,x,y,PT_ELEC);
				if (j != -1)
					parts[j].temp = temp;
			}
			j = sim->create_part(-3,x,y,PT_PHOT);
			if (j != -1)
			{
				parts[j].ctype = 0xF800000;
				parts[j].temp = temp;
				parts[j].tmp = 0x1;
			}
			int rx = x + sim->rng.between(-1, 1), ry = y + sim->rng.between(-1, 1), rt = TYP(pmap[ry][rx]);
			if (can_move[PT_PLSM][rt] || rt == PT_NBLE)
			{
				j = sim->create_part(-3,rx,ry,PT_PLSM);
				if (j != -1)
				{
					parts[j].temp = temp;
					parts[j].tmp |= 4;
				}
			}
			parts[i].temp = temp + 1750 + sim->rng.between(0, 499);
			sim->pv[y/CELL][x/CELL] += 50;
		}
	}
	return 0;
}


=== src\simulation\elements\NEUT.cpp ===

#include "simulation/ElementCommon.h"
#include "FIRE.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);
static int DeutExplosion(Simulation * sim, int n, int x, int y, float temp, int t);

void Element::Element_NEUT()
{
	Identifier = "DEFAULT_PT_NEUT";
	Name = "NEUT";
	Colour = 0x20E0FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 1.00f;
	Collision = -0.99f;
	Gravity = 0.0f;
	Diffusion = 0.01f;
	HotAir = 0.002f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = -1;

	DefaultProperties.temp = R_TEMP + 4.0f + 273.15f;
	HeatConduct = 60;
	Description = "Neutrons. Interact with matter in odd ways.";

	Properties = TYPE_ENERGY|PROP_LIFE_DEC|PROP_LIFE_KILL_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	unsigned int pressureFactor = 3 + (int)sim->pv[y/CELL][x/CELL];
	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			auto r = pmap[y+ry][x+rx];
			switch (TYP(r))
			{
			case PT_WATR:
				if (sim->rng.chance(3, 20))
					sim->part_change_type(ID(r),x+rx,y+ry,PT_DSTW);
			case PT_ICEI:
			case PT_SNOW:
				parts[i].vx *= 0.995f;
				parts[i].vy *= 0.995f;
				break;
			case PT_PLUT:
				if (sim->rng.chance(pressureFactor, 1000))
				{
					if (sim->rng.chance(1, 3))
					{
						sim->create_part(ID(r), x+rx, y+ry, sim->rng.chance(2, 3) ? PT_LAVA : PT_URAN);
						parts[ID(r)].temp = MAX_TEMP;
						if (parts[ID(r)].type==PT_LAVA) {
							parts[ID(r)].tmp = 100;
							parts[ID(r)].ctype = PT_PLUT;
						}
					}
					else
					{
						sim->create_part(ID(r), x+rx, y+ry, PT_NEUT);
						parts[ID(r)].vx = 0.25f*parts[ID(r)].vx + parts[i].vx;
						parts[ID(r)].vy = 0.25f*parts[ID(r)].vy + parts[i].vy;
					}
					sim->pv[y/CELL][x/CELL] += 10.0f * CFDS; //Used to be 2, some people said nukes weren't powerful enough
					Element_FIRE_update(UPDATE_FUNC_SUBCALL_ARGS);
				}
				break;
			case PT_DEUT:
				if (sim->rng.chance(pressureFactor + 1 + (parts[ID(r)].life/100), 1000))
				{
					DeutExplosion(sim, parts[ID(r)].life, x+rx, y+ry, restrict_flt(parts[ID(r)].temp + parts[ID(r)].life*500.0f, MIN_TEMP, MAX_TEMP), PT_NEUT);
					sim->kill_part(ID(r));
				}
				break;
			case PT_GUNP:
				if (sim->rng.chance(3, 200))
					sim->part_change_type(ID(r),x+rx,y+ry,PT_DUST);
				break;
			case PT_DYST:
				if (sim->rng.chance(3, 200))
					sim->part_change_type(ID(r),x+rx,y+ry,PT_YEST);
				break;
			case PT_YEST:
				sim->part_change_type(ID(r),x+rx,y+ry,PT_DYST);
				break;
			case PT_PLEX:
				if (sim->rng.chance(3, 200))
					sim->part_change_type(ID(r),x+rx,y+ry,PT_GOO);
				break;
			case PT_NITR:
				if (sim->rng.chance(3, 200))
					sim->part_change_type(ID(r),x+rx,y+ry,PT_DESL);
				break;
			case PT_PLNT:
				if (sim->rng.chance(1, 20))
					sim->create_part(ID(r), x+rx, y+ry, PT_WOOD);
				break;
			case PT_DESL:
			case PT_OIL:
				if (sim->rng.chance(3, 200))
					sim->part_change_type(ID(r),x+rx,y+ry,PT_GAS);
				break;
			case PT_COAL:
				if (sim->rng.chance(1, 20))
					sim->create_part(ID(r), x+rx, y+ry, PT_WOOD);
				break;
			case PT_BCOL:
				if (sim->rng.chance(1, 20))
					sim->create_part(ID(r), x+rx, y+ry, PT_SAWD);
				break;
			case PT_DUST:
				if (sim->rng.chance(1, 20))
					sim->part_change_type(ID(r), x+rx, y+ry, PT_FWRK);
				break;
			case PT_FWRK:
				if (sim->rng.chance(1, 20))
					parts[ID(r)].ctype = PT_DUST;
				break;
			case PT_ACID:
				if (sim->rng.chance(1, 20))
					sim->create_part(ID(r), x+rx, y+ry, PT_ISOZ);
				break;
			case PT_TTAN:
				if (sim->rng.chance(1, 20))
				{
					sim->kill_part(i);
					return 1;
				}
				break;
			case PT_EXOT:
				if (sim->rng.chance(1, 20))
					parts[ID(r)].life = 1500;
				break;
			case PT_RFRG:
				if (sim->rng.chance(1, 2))
					sim->create_part(ID(r), x+rx, y+ry, PT_GAS);
				else
					sim->create_part(ID(r), x+rx, y+ry, PT_CAUS);
				break;
			case PT_RSSS:
				if(!rx && !ry)
				{
					int ct_under, tmp_under;

					ct_under = parts[ID(r)].ctype;
					tmp_under = parts[ID(r)].tmp;

					//If there's a correct ctype set, liquefy into it
					if(ct_under > 0 && ct_under < PT_NUM)
					{
						sim->create_part(ID(r), x, y, ct_under);

						//If there's a correct tmp set, use it for ctype
						if((tmp_under > 0) && (tmp_under < PT_NUM) && (elements[ct_under].CarriesTypeIn & (1U << FIELD_CTYPE)))
							parts[ID(r)].ctype = tmp_under;
					}
					else
						sim->part_change_type(ID(r), x, y, PT_RSST); //Default to RSST if no ctype

					sim->kill_part(i);

					return 1;
				}
				break;
			default:
				break;
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 120;
	*firer = 10;
	*fireg = 80;
	*fireb = 120;

	*pixel_mode |= FIRE_ADD;
	return 1;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	float r = sim->rng.between(128, 255) / 127.0f;
	float a = sim->rng.between(0, 359) * 3.14159f / 180.0f;
	sim->parts[i].life = sim->rng.between(480, 959);
	sim->parts[i].vx = r * cosf(a);
	sim->parts[i].vy = r * sinf(a);
}

static int DeutExplosion(Simulation * sim, int n, int x, int y, float temp, int t)//testing a new deut create part
{
	int i;
	n = (n/50);
	if (n < 1)
		n = 1;
	else if (n > 340)
		n = 340;

	for (int c = 0; c < n; c++)
	{
		i = sim->create_part(-3, x, y, t);
		if (i >= 0)
			sim->parts[i].temp = temp;
		else if (sim->MaxPartsReached())
			break;
	}
	sim->pv[y/CELL][x/CELL] += (6.0f * CFDS)*n;
	return 0;
}


=== src\simulation\elements\NICE.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_NICE()
{
	Identifier = "DEFAULT_PT_NICE";
	Name = "NICE";
	Colour = 0xC0E0FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = -0.0005f* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 100;

	DefaultProperties.temp = 35.0f;
	HeatConduct = 46;
	Description = "Nitrogen Ice. Very cold, will melt into LN2 when heated only slightly.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 63.1f;
	HighTemperatureTransition = PT_LNTG;
}


=== src\simulation\elements\NITR.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_NITR()
{
	Identifier = "DEFAULT_PT_NITR";
	Name = "NITR";
	Colour = 0x20E010_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.5f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.92f;
	Loss = 0.97f;
	Collision = 0.0f;
	Gravity = 0.2f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 1000;
	Explosive = 2;
	Meltable = 0;
	Hardness = 3;
	PhotonReflectWavelengths = 0x0007C000;

	Weight = 23;

	HeatConduct = 50;
	Description = "Nitroglycerin. Pressure sensitive explosive. Mix with CLST to make TNT.";

	Properties = TYPE_LIQUID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 673.0f;
	HighTemperatureTransition = PT_FIRE;
}


=== src\simulation\elements\NONE.cpp ===

#include "simulation/ElementCommon.h"
#include "graphics/VideoBuffer.h"

static std::unique_ptr<VideoBuffer> iconGen(int wallID, Vec2<int> size);

void Element::Element_NONE()
{
	Identifier = "DEFAULT_PT_NONE";
	Name = "NONE";
	Colour = 0x000000_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Erases particles.";

	Properties = 0;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	IconGenerator = &iconGen;
}

static std::unique_ptr<VideoBuffer> iconGen(int wallID, Vec2<int> size)
{
	auto texture = std::make_unique<VideoBuffer>(size);
	texture->BlendChar(size / 2 - Vec2(4, 2), 0xE06C, 0xFF0000_rgb .WithAlpha(0xFF));
	return texture;
}


=== src\simulation\elements\NSCN.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_NSCN()
{
	Identifier = "DEFAULT_PT_NSCN";
	Name = "NSCN";
	Colour = 0x505080_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;
	PhotonReflectWavelengths = 0x00000000;

	Weight = 100;

	HeatConduct = 251;
	Description = "N-Type Silicon, Will not transfer current to P-Type Silicon. Disables powered materials.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1687.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\NTCT.cpp ===

#include "simulation/ElementCommon.h"
#include "NTCT.h"

void Element::Element_NTCT()
{
	Identifier = "DEFAULT_PT_NTCT";
	Name = "NTCT";
	Colour = 0x505040_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "NTC Thermistor. Conducts with PSCN and NSCN, but only when heated above 100C.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1687.0f;
	HighTemperatureTransition = PT_LAVA;

	Update = &Element_NTCT_update;
}

int Element_NTCT_update(UPDATE_FUNC_ARGS)
{
	if (parts[i].temp>295.0f)
		parts[i].temp -= 2.5f;
	return 0;
}


=== src\simulation\elements\NTCT.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_NTCT_update(UPDATE_FUNC_ARGS);


=== src\simulation\elements\NWHL.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_NWHL()
{
	Identifier = "DEFAULT_PT_NWHL";
	Name = "WHOL";
	Colour = 0xFFFFFF_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 186;
	Description = "White hole, pushes away other particles with gravity. (Requires Newtonian gravity)";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].tmp)
	{
		sim->gravIn.mass[Vec2{ x, y } / CELL] -= restrict_flt(0.001f * parts[i].tmp, 0.1f, 51.2f);
	}
	else
	{
		sim->gravIn.mass[Vec2{ x, y } / CELL] -= 0.1f;
	}
	return 0;
}


=== src\simulation\elements\O2.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_O2()
{
	Identifier = "DEFAULT_PT_O2";
	Name = "OXYG";
	Colour = 0x80A0FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 2.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 3.0f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 1;

	HeatConduct = 70;
	Description = "Oxygen gas. Ignites easily.";

	Properties = TYPE_GAS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 90.0f;
	LowTemperatureTransition = PT_LO2;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &can_move = sd.can_move;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;

				if (TYP(r)==PT_FIRE)
				{
					parts[ID(r)].temp += sim->rng.between(0, 99);
					if (parts[ID(r)].tmp & 0x01)
						parts[ID(r)].temp = 3473;
					parts[ID(r)].tmp |= 2;

					sim->create_part(i,x,y,PT_FIRE);
					parts[i].temp += sim->rng.between(0, 99);
					parts[i].tmp |= 2;
				}
				else if (TYP(r)==PT_PLSM && !(parts[ID(r)].tmp&4))
				{
					sim->create_part(i,x,y,PT_FIRE);
					parts[i].temp += sim->rng.between(0, 99);
					parts[i].tmp |= 2;
				}
			}
		}
	}
	if (parts[i].temp > 9973.15 && sim->pv[y/CELL][x/CELL] > 250.0f)
	{
		auto gravx = sim->gravOut.forceX[Vec2{ x, y } / CELL];
		auto gravy = sim->gravOut.forceY[Vec2{ x, y } / CELL];
		if (gravx*gravx + gravy*gravy > 400)
		{
			if (sim->rng.chance(1, 5))
			{
				int j;
				sim->create_part(i,x,y,PT_BRMT);

				j = sim->create_part(-3,x,y,PT_NEUT);
				if (j != -1)
					parts[j].temp = MAX_TEMP;
				j = sim->create_part(-3,x,y,PT_PHOT);
				if (j != -1)
				{
					parts[j].temp = MAX_TEMP;
					parts[j].tmp = 0x1;
				}
				auto rx = x + sim->rng.between(-1, 1), ry = y + sim->rng.between(-1, 1), r = TYP(pmap[ry][rx]);
				if (can_move[PT_PLSM][r] || r == PT_O2)
				{
					j = sim->create_part(-3,rx,ry,PT_PLSM);
					if (j > -1)
					{
						parts[j].temp = MAX_TEMP;
						parts[j].tmp |= 4;
					}
				}
				j = sim->create_part(-3,x,y,PT_GRVT);
				if (j != -1)
					parts[j].temp = MAX_TEMP;
				parts[i].temp = MAX_TEMP;
				sim->pv[y/CELL][x/CELL] = MAX_PRESSURE;
			}
		}
	}
	return 0;
}


=== src\simulation\elements\OIL.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_OIL()
{
	Identifier = "DEFAULT_PT_OIL";
	Name = "OIL";
	Colour = 0x404010_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 20;
	Explosive = 0;
	Meltable = 0;
	Hardness = 5;

	Weight = 20;

	HeatConduct = 42;
	Description = "Flammable, turns into GAS at low pressure or high temperature.";

	Properties = TYPE_LIQUID | PROP_NEUTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 333.0f;
	HighTemperatureTransition = PT_GAS;
}


=== src\simulation\elements\PBCN.cpp ===

#include "simulation/ElementCommon.h"
#include "PCLN.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_PBCN()
{
	Identifier = "DEFAULT_PT_PBCN";
	Name = "PBCN";
	Colour = 0x3B1D0A_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.97f;
	Loss = 0.50f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 12;

	Weight = 100;

	HeatConduct = 251;
	Description = "Powered breakable clone.";

	Properties = TYPE_SOLID | PROP_PHOTPASS | PROP_NOCTYPEDRAW;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	CtypeDraw = &Element_PCLN_ctypeDraw;
}

constexpr float ADVECTION = 0.1f;

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (!parts[i].tmp2 && sim->pv[y/CELL][x/CELL]>4.0f)
		parts[i].tmp2 = sim->rng.between(80, 119);
	if (parts[i].tmp2)
	{
		parts[i].vx += ADVECTION*sim->vx[y/CELL][x/CELL];
		parts[i].vy += ADVECTION*sim->vy[y/CELL][x/CELL];
		parts[i].tmp2--;
		if(!parts[i].tmp2){
			sim->kill_part(i);
			return 1;
		}
	}
	if (parts[i].ctype<=0 || parts[i].ctype>=PT_NUM || !elements[parts[i].ctype].Enabled)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				auto r = sim->photons[y+ry][x+rx];
				if (!r)
					r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if (rt!=PT_CLNE && rt!=PT_PCLN &&
				    rt!=PT_BCLN &&  rt!=PT_SPRK &&
				    rt!=PT_NSCN && rt!=PT_PSCN &&
				    rt!=PT_STKM && rt!=PT_STKM2 &&
				    rt!=PT_PBCN && rt<PT_NUM)
				{
					parts[i].ctype = rt;
					if (rt==PT_LIFE || rt==PT_LAVA)
						parts[i].tmp = parts[ID(r)].ctype;
				}
			}
		}
	}
	if (parts[i].life!=10)
	{
		if (parts[i].life>0)
			parts[i].life--;
	}
	else
	{
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r)==PT_PBCN)
					{
						if (parts[ID(r)].life<10&&parts[ID(r)].life>0)
							parts[i].life = 9;
						else if (parts[ID(r)].life==0)
							parts[ID(r)].life = 10;
					}
				}
			}
		}
		if (parts[i].ctype>0 && parts[i].ctype<PT_NUM && elements[parts[i].ctype].Enabled)
		{
			if (parts[i].ctype==PT_PHOT) {//create photons a different way
				for (auto rx = -1; rx <= 1; rx++)
				{
					for (auto ry = -1; ry <= 1; ry++)
					{
						if (rx || ry)
						{
							int r = sim->create_part(-1, x + rx, y + ry, PT_PHOT);
							if (r != -1)
							{
								parts[r].vx = float(rx * 3);
								parts[r].vy = float(ry * 3);
								if (r>i)
								{
									// Make sure movement doesn't happen until next frame, to avoid gaps in the beams of photons produced
									parts[r].flags |= FLAG_SKIPMOVE;
								}
							}
						}
					}
				}
			}
			else if (parts[i].ctype==PT_LIFE)//create life a different way
			{
				for (auto rx = -1; rx <= 1; rx++)
				{
					for (auto ry = -1; ry <= 1; ry++)
					{
						sim->create_part(-1, x+rx, y+ry, PT_LIFE, parts[i].tmp);
					}
				}
			}
			else if (parts[i].ctype!=PT_LIGH || sim->rng.chance(1, 30))
			{
				int np = sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), TYP(parts[i].ctype));
				if (np>-1)
				{
					if (parts[i].ctype==PT_LAVA && parts[i].tmp>0 && parts[i].tmp<PT_NUM && elements[parts[i].tmp].HighTemperatureTransition==PT_LAVA)
						parts[np].ctype = parts[i].tmp;
				}
			}
		}
	}

	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int lifemod = ((cpart->life>10?10:cpart->life)*10);
	*colr += lifemod;
	*colg += lifemod/2;
	return 0;
}


=== src\simulation\elements\PCLN.cpp ===

#include "simulation/ElementCommon.h"
#include "PCLN.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_PCLN()
{
	Identifier = "DEFAULT_PT_PCLN";
	Name = "PCLN";
	Colour = 0x3B3B0A_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Powered clone. When activated, duplicates any particles it touches.";

	Properties = TYPE_SOLID | PROP_PHOTPASS | PROP_NOCTYPEDRAW;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	CtypeDraw = &Element_PCLN_ctypeDraw;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].life>0 && parts[i].life!=10)
		parts[i].life--;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_SPRK)
				{
					if (parts[ID(r)].life>0 && parts[ID(r)].life<4)
					{
						if (parts[ID(r)].ctype==PT_PSCN)
							parts[i].life = 10;
						else if (parts[ID(r)].ctype==PT_NSCN)
							parts[i].life = 9;
					}
				}
				else if (TYP(r)==PT_PCLN)
				{
					if (parts[i].life==10&&parts[ID(r)].life<10&&parts[ID(r)].life>0)
						parts[i].life = 9;
					else if (parts[i].life==0&&parts[ID(r)].life==10)
						parts[i].life = 10;
				}
			}
		}
	}
	if (parts[i].ctype<=0 || parts[i].ctype>=PT_NUM || !elements[parts[i].ctype].Enabled)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				auto r = sim->photons[y+ry][x+rx];
				if (!r)
					r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if (rt!=PT_CLNE && rt!=PT_PCLN &&
				    rt!=PT_BCLN &&  rt!=PT_SPRK &&
				    rt!=PT_NSCN && rt!=PT_PSCN &&
				    rt!=PT_STKM && rt!=PT_STKM2 &&
				    rt!=PT_PBCN && rt<PT_NUM)
				{
					parts[i].ctype = rt;
					if (rt==PT_LIFE || rt==PT_LAVA)
						parts[i].tmp = parts[ID(r)].ctype;
				}
			}
		}
	}
	if (parts[i].ctype>0 && parts[i].ctype<PT_NUM && elements[parts[i].ctype].Enabled && parts[i].life==10)
	{
		if (parts[i].ctype==PT_PHOT) {//create photons a different way
			for (auto rx = -1; rx <= 1; rx++)
			{
				for (auto ry = -1; ry <= 1; ry++)
				{
					if (rx || ry)
					{
						int r = sim->create_part(-1, x + rx, y + ry, PT_PHOT);
						if (r != -1)
						{
							parts[r].vx = float(rx * 3);
							parts[r].vy = float(ry * 3);
							if (r>i)
							{
								// Make sure movement doesn't happen until next frame, to avoid gaps in the beams of photons produced
								parts[r].flags |= FLAG_SKIPMOVE;
							}
						}
					}
				}
			}
		}
		else if (parts[i].ctype==PT_LIFE)//create life a different way
		{
			for (auto rx = -1; rx <= 1; rx++)
			{
				for (auto ry = -1; ry <= 1; ry++)
				{
					sim->create_part(-1, x+rx, y+ry, PT_LIFE, parts[i].tmp);
				}
			}
		}
		else if (parts[i].ctype != PT_LIGH || sim->rng.chance(1, 30))
		{
			int np = sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), TYP(parts[i].ctype));
			if (np>=0)
			{
				if (parts[i].ctype==PT_LAVA && parts[i].tmp>0 && parts[i].tmp<PT_NUM && elements[parts[i].tmp].HighTemperatureTransition==PT_LAVA)
					parts[np].ctype = parts[i].tmp;
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int lifemod = ((cpart->life>10?10:cpart->life)*10);
	*colr += lifemod;
	*colg += lifemod;
	return 0;
}

bool Element_PCLN_ctypeDraw(CTYPEDRAW_FUNC_ARGS)
{
	if (t == PT_PSCN || t == PT_NSCN || t == PT_SPRK)
	{
		return false;
	}
	return Element::ctypeDrawVInTmp(CTYPEDRAW_FUNC_SUBCALL_ARGS);
}


=== src\simulation\elements\PCLN.h ===

#pragma once
#include "simulation/ElementDefs.h"

bool Element_PCLN_ctypeDraw(CTYPEDRAW_FUNC_ARGS);


=== src\simulation\elements\PHOT.cpp ===

#include "simulation/ElementCommon.h"
#include "FIRE.h"
#include "FILT.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_PHOT()
{
	Identifier = "DEFAULT_PT_PHOT";
	Name = "PHOT";
	Colour = 0xFFFFFF_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 1.00f;
	Collision = -0.99f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = -1;

	DefaultProperties.temp = R_TEMP + 900.0f + 273.15f;
	HeatConduct = 251;
	Description = "Photons. Refract through glass, and different elements change its color. Can ignite flammable materials.";

	Properties = TYPE_ENERGY | PROP_PHOTPASS | PROP_LIFE_DEC | PROP_LIFE_KILL_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 680;
	DefaultProperties.ctype = 0x3FFFFFFF;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;

	if (!(parts[i].ctype&0x3FFFFFFF)) {
		sim->kill_part(i);
		return 1;
	}
	if (parts[i].temp > 506)
		if (sim->rng.chance(1, 10))
			Element_FIRE_update(UPDATE_FUNC_SUBCALL_ARGS);
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			auto r = pmap[y+ry][x+rx];
			if (!r)
				continue;
			if (TYP(r)==PT_ISOZ || TYP(r)==PT_ISZS)
			{
				if (sim->rng.chance(1, 400))
				{
					parts[i].vx *= 0.90f;
					parts[i].vy *= 0.90f;
					sim->create_part(ID(r), x+rx, y+ry, PT_PHOT);
					auto rrr = sim->rng.between(0, 359) * 3.14159f / 180.0f;
					int rr;
					if (TYP(r) == PT_ISOZ)
						rr = int(sim->rng.between(128, 255) / 127.0f);
					else
						rr = int(sim->rng.between(128, 355) / 127.0f);
					parts[ID(r)].vx = rr*cosf(rrr);
					parts[ID(r)].vy = rr*sinf(rrr);
					sim->pv[y/CELL][x/CELL] -= 15.0f * CFDS;
				}
			}
			else if((TYP(r) == PT_QRTZ || TYP(r) == PT_PQRT) && !ry && !rx)//if on QRTZ
			{
				float a = sim->rng.between(0, 359) * 3.14159f / 180.0f;
				parts[i].vx = 3.0f*cosf(a);
				parts[i].vy = 3.0f*sinf(a);
				if(parts[i].ctype == 0x3FFFFFFF)
					parts[i].ctype = 0x1F << sim->rng.between(0, 25);
				if (parts[i].life)
					parts[i].life++; //Delay death
			}
			else if(TYP(r) == PT_BGLA && !ry && !rx)//if on BGLA
			{
				float a = sim->rng.between(-50, 50) * 0.001f;
				float rx = cosf(a), ry = sinf(a), vx, vy;
				vx = rx * parts[i].vx + ry * parts[i].vy;
				vy = rx * parts[i].vy - ry * parts[i].vx;
				parts[i].vx = vx;
				parts[i].vy = vy;
			}
			else if(TYP(r) == PT_RSST && !ry && !rx)//if on RSST, make it solid
			{
				int ct_under, tmp_under;

				ct_under = parts[ID(r)].ctype;
				tmp_under = parts[ID(r)].tmp;

				//If there's a correct ctype set, solidify RSST into it
				if(ct_under > 0 && ct_under < PT_NUM)
				{
					sim->create_part(ID(r), x, y, ct_under);

					//If there's a correct tmp set, use it for ctype
					if((tmp_under > 0) && (tmp_under < PT_NUM) && (elements[ct_under].CarriesTypeIn & (1U << FIELD_CTYPE)))
						parts[ID(r)].ctype = tmp_under;
				}
				else
					sim->part_change_type(ID(r), x, y, PT_RSSS); //Default to RSSS if no ctype

				sim->kill_part(i);

				return 1;
			}
			else if (TYP(r) == PT_FILT && parts[ID(r)].tmp==9)
			{
				parts[i].vx += ((float)sim->rng.between(-500, 500))/1000.0f;
				parts[i].vy += ((float)sim->rng.between(-500, 500))/1000.0f;
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int x = 0;
	*colr = *colg = *colb = 0;
	for (x=0; x<12; x++) {
		*colr += (cpart->ctype >> (x+18)) & 1;
		*colb += (cpart->ctype >>  x)     & 1;
	}
	for (x=0; x<12; x++)
		*colg += (cpart->ctype >> (x+9))  & 1;
	x = 624/(*colr+*colg+*colb+1);
	*colr *= x;
	*colg *= x;
	*colb *= x;

	*firea = 100;
	*firer = *colr;
	*fireg = *colg;
	*fireb = *colb;

	*pixel_mode &= ~PMODE_FLAT;
	*pixel_mode |= FIRE_ADD | PMODE_ADD | NO_DECO;
	if (cpart->flags & FLAG_PHOTDECO)
	{
		*pixel_mode &= ~NO_DECO;
	}
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	float a = sim->rng.between(0, 7) * 0.78540f;
	sim->parts[i].vx = 3.0f * cosf(a);
	sim->parts[i].vy = 3.0f * sinf(a);
	if (TYP(sim->pmap[y][x]) == PT_FILT)
		sim->parts[i].ctype = Element_FILT_interactWavelengths(sim, &sim->parts[ID(sim->pmap[y][x])], sim->parts[i].ctype);
}


=== src\simulation\elements\PIPE.cpp ===

#include "simulation/ElementCommon.h"
#include "PIPE.h"
#include "SOAP.h"

static void props_pipe_to_part(const Particle *pipe, Particle *part, bool STOR);
static void transfer_pipe_to_pipe(Particle *src, Particle *dest, bool STOR);
static void pushParticle(Simulation * sim, int i, int count, int original);

void Element::Element_PIPE()
{
	Identifier = "DEFAULT_PT_PIPE";
	Name = "PIPE";
	Colour = 0x444444_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = 295.15f;
	HeatConduct = 251;
	Description = "PIPE, moves particles around. Once the BRCK generates, erase some for the exit. Then the PIPE generates and is usable.";

	Properties = TYPE_SOLID | PROP_LIFE_DEC;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 10.0f;
	HighPressureTransition = PT_BRMT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 60;

	Update = &Element_PIPE_update;
	Graphics = &Element_PIPE_graphics;
}

constexpr int PPIP_TMPFLAG_REVERSED        = 0x01000000;
constexpr int PPIP_TMPFLAG_PAUSED          = 0x02000000;
constexpr int PPIP_TMPFLAG_TRIGGER_REVERSE = 0x04000000;
constexpr int PPIP_TMPFLAG_TRIGGER_OFF     = 0x08000000;
constexpr int PPIP_TMPFLAG_TRIGGER_ON      = 0x10000000;
constexpr int PPIP_TMPFLAG_TRIGGERS        = 0x1C000000;

const std::array<Vec2<int>, 8> Element_PIPE_offsets = {{
	{ -1, -1 },
	{ -1,  0 },
	{ -1,  1 },
	{  0, -1 },
	{  0,  1 },
	{  1, -1 },
	{  1,  0 },
	{  1,  1 },
}};

void Element_PIPE_transformPatchOffsets(Particle &part, const std::array<int, 8> &offsetMap)
{
	if (part.tmp & 0x00000200) part.tmp = (part.tmp & 0xFFFFE3FF) | (offsetMap[(part.tmp & 0x00001C00) >> 10] << 10);
	if (part.tmp & 0x00002000) part.tmp = (part.tmp & 0xFFFE3FFF) | (offsetMap[(part.tmp & 0x0001C000) >> 14] << 14);
}

static unsigned int prevColor(unsigned int flags)
{
	unsigned int color = flags & PFLAG_COLORS;
	if (color == PFLAG_COLOR_RED)
		return PFLAG_COLOR_GREEN;
	else if (color == PFLAG_COLOR_GREEN)
		return PFLAG_COLOR_BLUE;
	else if (color == PFLAG_COLOR_BLUE)
		return PFLAG_COLOR_RED;
	return PFLAG_COLOR_RED;
}

static unsigned int nextColor(unsigned int flags)
{
	unsigned int color = flags & PFLAG_COLORS;
	if (color == PFLAG_COLOR_RED)
		return PFLAG_COLOR_BLUE;
	else if (color == PFLAG_COLOR_BLUE)
		color = PFLAG_COLOR_GREEN;
	else if (color == PFLAG_COLOR_GREEN)
		return PFLAG_COLOR_RED;
	return PFLAG_COLOR_GREEN;
}

int Element_PIPE_update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].ctype && !elements[TYP(parts[i].ctype)].Enabled)
		parts[i].ctype = 0;
	if (parts[i].tmp & PPIP_TMPFLAG_TRIGGERS)
	{
		int pause_changed = 0;
		if (parts[i].tmp & PPIP_TMPFLAG_TRIGGER_ON) // TRIGGER_ON overrides TRIGGER_OFF
		{
			if (parts[i].tmp & PPIP_TMPFLAG_PAUSED)
				pause_changed = 1;
			parts[i].tmp &= ~PPIP_TMPFLAG_PAUSED;
		}
		else if (parts[i].tmp & PPIP_TMPFLAG_TRIGGER_OFF)
		{
			if (!(parts[i].tmp & PPIP_TMPFLAG_PAUSED))
				pause_changed = 1;
			parts[i].tmp |= PPIP_TMPFLAG_PAUSED;
		}
		if (pause_changed)
		{
			for (auto rx = -2; rx <= 2; rx++)
			{
				for (auto ry = -2; ry <= 2; ry++)
				{
					if (rx || ry)
					{
						auto r = pmap[y+ry][x+rx];
						if (TYP(r) == PT_BRCK)
						{
							if (parts[i].tmp & PPIP_TMPFLAG_PAUSED)
								parts[ID(r)].tmp = 0;
							else
								parts[ID(r)].tmp = 1; //make surrounding BRCK glow
						}
					}
				}
			}
		}

		if (parts[i].tmp & PPIP_TMPFLAG_TRIGGER_REVERSE)
		{
			parts[i].tmp ^= PPIP_TMPFLAG_REVERSED;
			// Switch colors so it goes in reverse
			if ((parts[i].tmp&PFLAG_COLORS) != PFLAG_COLOR_GREEN)
				parts[i].tmp ^= PFLAG_COLOR_GREEN;
			if (parts[i].tmp & 0x100) //Switch one pixel pipe direction
			{
				int coords = (parts[i].tmp>>13)&0xF;
				int coords2 = (parts[i].tmp>>9)&0xF;
				parts[i].tmp &= ~0x1FE00;
				parts[i].tmp |= coords<<9;
				parts[i].tmp |= coords2<<13;
			}
		}

		parts[i].tmp &= ~PPIP_TMPFLAG_TRIGGERS;
	}
	if ((parts[i].tmp&PFLAG_COLORS) && !(parts[i].tmp & PPIP_TMPFLAG_PAUSED))
	{
		if (parts[i].life==3)
		{
			int lastneighbor = -1;
			int neighborcount = 0;
			int count = 0;
			bool heatPipe = false;
			// make automatic pipe pattern
			for (auto rx = -1; rx <= 1; rx++)
			{
				for (auto ry = -1; ry <= 1; ry++)
				{
					if (rx || ry)
					{
						count++;
						auto r = pmap[y+ry][x+rx];
						if (!r)
							continue;
						if (TYP(r) == PT_HEAC)
						{
							heatPipe = true;
							continue;
						}
						if (TYP(r) != PT_PIPE && TYP(r) != PT_PPIP)
							continue;
						unsigned int next = nextColor(parts[i].tmp);
						unsigned int prev = prevColor(parts[i].tmp);
						if (parts[ID(r)].tmp&PFLAG_INITIALIZING)
						{
							parts[ID(r)].tmp |= next;
							parts[ID(r)].tmp &= ~PFLAG_INITIALIZING;
							parts[ID(r)].life = 6;
							// Is a single pixel pipe
							if (parts[i].tmp&0x100)
							{
								// Will transfer to a single pixel pipe
								parts[ID(r)].tmp |= 0x200;
								// Coords of where it came from
								parts[ID(r)].tmp |= (count - 1) << 10;
								parts[i].tmp |= (8 - count) << 14;
								parts[i].tmp |= 0x2000;
							}
							neighborcount ++;
							lastneighbor = ID(r);
						}
						else if ((parts[ID(r)].tmp&PFLAG_COLORS) != prev)
						{
							neighborcount ++;
							lastneighbor = ID(r);
						}
					}
				}
			}
			if (neighborcount == 1)
				parts[lastneighbor].tmp |= 0x100;
			if (heatPipe)
				Element_PPIP_flood_trigger(sim, x, y, PT_HEAC);
		}
		else
		{
			if (parts[i].flags&PFLAG_NORMALSPEED)//skip particle push to prevent particle number being higher causing speed up
			{
				parts[i].flags &= ~PFLAG_NORMALSPEED;
			}
			else
			{
				pushParticle(sim, i,0,i);
			}

			if (nt)//there is something besides PIPE around current particle
			{
				auto rndstore = sim->rng.gen();
				auto rnd = rndstore&7;
				auto rx = Element_PIPE_offsets[rnd].X;
				auto ry = Element_PIPE_offsets[rnd].Y;
				auto r = pmap[y+ry][x+rx];
				if(!r)
					r = sim->photons[y+ry][x+rx];
				if (surround_space && !r && TYP(parts[i].ctype))  //creating at end
				{
					auto np = sim->create_part(-1, x+rx, y+ry, TYP(parts[i].ctype));
					if (np!=-1)
					{
						Element_PIPE_transfer_pipe_to_part(sim, parts+i, parts+np, false);
					}
				}
				//try eating particle at entrance
				else if (!TYP(parts[i].ctype) && (elements[TYP(r)].Properties & (TYPE_PART | TYPE_LIQUID | TYPE_GAS | TYPE_ENERGY)))
				{
					if (TYP(r)==PT_SOAP)
						Element_SOAP_detach(sim, ID(r));
					Element_PIPE_transfer_part_to_pipe(parts+(ID(r)), parts+i);
					sim->kill_part(ID(r));
				}
				else if (!TYP(parts[i].ctype) && TYP(r)==PT_STOR && sd.IsElement(parts[ID(r)].tmp) && (elements[parts[ID(r)].tmp].Properties & (TYPE_PART | TYPE_LIQUID | TYPE_GAS | TYPE_ENERGY)))
				{
					// STOR stores properties in the same places as PIPE does
					transfer_pipe_to_pipe(parts+(ID(r)), parts+i, true);
				}
			}
		}
	}
	else if (!(parts[i].tmp&(PFLAG_COLORS|PFLAG_INITIALIZING)) && parts[i].life<=10)
	{
		// make a border
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
					{
						// BRCK border
						int index = sim->create_part(-1,x+rx,y+ry,PT_BRCK);
						if (parts[i].type == PT_PPIP && index != -1)
							parts[index].tmp = 1;
					}
				}
			}
		}
		if (parts[i].life <= 1)
			parts[i].tmp |= PFLAG_INITIALIZING;
	}
	// Wait for empty space before starting to generate automatic pipe pattern
	else if (parts[i].tmp & PFLAG_INITIALIZING)
	{
		if (!parts[i].life)
		{
			for (auto rx = -1; rx <= 1; rx++)
			{
				for (auto ry = -1; ry <= 1; ry++)
				{
					if (rx || ry)
					{
						if (!pmap[y+ry][x+rx] && sim->bmap[(y+ry)/CELL][(x+rx)/CELL]!=WL_ALLOWAIR && sim->bmap[(y+ry)/CELL][(x+rx)/CELL]!=WL_WALL && sim->bmap[(y+ry)/CELL][(x+rx)/CELL]!=WL_WALLELEC && (sim->bmap[(y+ry)/CELL][(x+rx)/CELL]!=WL_EWALL || sim->emap[(y+ry)/CELL][(x+rx)/CELL]))
							parts[i].life=50;
					}
				}
			}
		}
		else if (parts[i].life==5)//check for beginning of pipe single pixel
		{
			int issingle = 1;
			for (auto rx = -1; rx <= 1; rx++)
			{
				for (auto ry = -1; ry <= 1; ry++)
				{
					if (rx || ry)
					{
						auto r = pmap[y+ry][x+rx];
						if ((TYP(r)==PT_PIPE || TYP(r) == PT_PPIP) && parts[i].life)
							issingle = 0;
					}
				}
			}
			if (issingle)
				parts[i].tmp |= 0x100;
		}
		else if (parts[i].life == 2)
		{
			parts[i].tmp |= PFLAG_COLOR_RED;
			parts[i].tmp &= ~PFLAG_INITIALIZING;
			parts[i].life = 6;
		}
	}
	return 0;
}

int Element_PIPE_graphics(GRAPHICS_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	auto &graphicscache = sd.graphicscache;
	int t = TYP(cpart->ctype);
	if (t>0 && t<PT_NUM && elements[t].Enabled)
	{
		if (t == PT_STKM || t == PT_STKM2 || t == PT_FIGH)
			return 0;
		if (graphicscache[t].isready)
		{
			*pixel_mode = graphicscache[t].pixel_mode;
			*cola = graphicscache[t].cola;
			*colr = graphicscache[t].colr;
			*colg = graphicscache[t].colg;
			*colb = graphicscache[t].colb;
			*firea = graphicscache[t].firea;
			*firer = graphicscache[t].firer;
			*fireg = graphicscache[t].fireg;
			*fireb = graphicscache[t].fireb;
		}
		else
		{
			// We emulate the graphics of the stored particle. We need a const Particle *cpart to pass to the graphics function,
			// but we don't have a Particle that is populated the way the graphics function expects, so we construct a temporary
			// one and present that to it.
			//
			// Native graphics functions are well-behaved and use the cpart we give them, no questions asked, so we can just have
			// the Particle on stack. Swapping the pointers in cpart with tpart takes care of passing the particle on stack to the
			// native graphics function. Lua graphics functions are more complicated to appease: they access particle data through the
			// particle ID, so not only do we have to give them a correctly populated Particle, it also has to be somewhere in Simulation.
			// luaGraphicsWrapper takes care of this.
			RGB colour = elements[t].Colour;
			*colr = colour.Red;
			*colg = colour.Green;
			*colb = colour.Blue;
			auto *graphics = elements[t].Graphics;
			if (graphics)
			{
				Particle tpart{};
				props_pipe_to_part(cpart, &tpart, false);
				auto *prevPipeSubcallCpart = gfctx.pipeSubcallCpart;
				auto *prevPipeSubcallTpart = gfctx.pipeSubcallTpart;
				gfctx.pipeSubcallCpart = cpart;
				gfctx.pipeSubcallTpart = &tpart;
				cpart = gfctx.pipeSubcallTpart;
				graphics(GRAPHICS_FUNC_SUBCALL_ARGS);
				cpart = gfctx.pipeSubcallCpart;
				gfctx.pipeSubcallCpart = prevPipeSubcallCpart;
				gfctx.pipeSubcallTpart = prevPipeSubcallTpart;
			}
			else
			{
				Element::defaultGraphics(GRAPHICS_FUNC_SUBCALL_ARGS);
			}
		}
	}
	else
	{
		switch (cpart->tmp & PFLAG_COLORS)
		{
		case PFLAG_COLOR_RED:
			*colr = 50;
			*colg = 1;
			*colb = 1;
			break;
		case PFLAG_COLOR_GREEN:
			*colr = 1;
			*colg = 50;
			*colb = 1;
			break;
		case PFLAG_COLOR_BLUE:
			*colr = 1;
			*colg = 1;
			*colb = 50;
			break;
		default:
			break;
		}
	}
	return 0;
}

static void props_pipe_to_part(const Particle *pipe, Particle *part, bool STOR)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	// STOR also calls this function to move particles from STOR to PRTI
	// PIPE was changed, so now PIPE and STOR don't use the same particle storage format
	if (STOR)
	{
		part->type = TYP(pipe->tmp);
	}
	else
	{
		part->type = TYP(pipe->ctype);
	}
	part->temp = pipe->temp;
	part->life = pipe->tmp2;
	part->tmp = pipe->tmp3;
	part->ctype = pipe->tmp4;

	if (!(elements[part->type].Properties & TYPE_ENERGY))
	{
		part->vx = 0.0f;
		part->vy = 0.0f;
	}
	part->tmp2 = 0;
	part->flags = 0;
	part->dcolour = 0;
}

void Element_PIPE_transfer_pipe_to_part(Simulation * sim, Particle *pipe, Particle *part, bool STOR)
{
	props_pipe_to_part(pipe, part, STOR);
	if (STOR)
	{
		pipe->tmp = 0;
	}
	else
	{
		pipe->ctype = 0;

		// If deco originated from particle, and not PIPE, then copy it
		if (pipe->tmp & PFLAG_PARTICLE_DECO)
		{
			part->dcolour = pipe->dcolour;
			pipe->dcolour = 0;
		}
	}
}

void Element_PIPE_transfer_part_to_pipe(Particle *part, Particle *pipe)
{
	pipe->ctype = part->type;

	if ((pipe->tmp & PFLAG_CAN_CONDUCT) == 0)
		pipe->temp = part->temp;
	else
		pipe->temp = (part->temp + pipe->temp) / 2.0f;

	pipe->tmp2 = part->life;
	pipe->tmp3 = part->tmp;
	pipe->tmp4 = part->ctype;

	if (part->dcolour && !pipe->dcolour)
	{
		pipe->dcolour = part->dcolour;
		pipe->tmp |= PFLAG_PARTICLE_DECO;
	}
}

static void transfer_pipe_to_pipe(Particle *src, Particle *dest, bool STOR)
{
	// STOR to PIPE
	if (STOR)
	{
		dest->ctype = src->tmp;
		src->tmp = 0;
	}
	else
	{
		dest->ctype = src->ctype;
		src->ctype = 0;

		if (src->tmp & PFLAG_PARTICLE_DECO)
		{
			// Even if source pipe has particle deco, don't override existing pipe deco. Just delete source deco only.
			if (!dest->dcolour)
			{
				dest->dcolour = src->dcolour;
				dest->tmp |= PFLAG_PARTICLE_DECO;
			}
			src->dcolour = 0;
			src->tmp &= ~PFLAG_PARTICLE_DECO;
		}
	}

	if ((dest->tmp & PFLAG_CAN_CONDUCT) == 0)
		dest->temp = src->temp;
	else
		dest->temp = (src->temp + dest->temp) / 2.0f;

	dest->tmp2 = src->tmp2;
	dest->tmp3 = src->tmp3;
	dest->tmp4 = src->tmp4;
}

static void pushParticle(Simulation * sim, int i, int count, int original)
{
	unsigned int notctype = nextColor(sim->parts[i].tmp);
	if (!TYP(sim->parts[i].ctype) || count >= 2)//don't push if there is nothing there, max speed of 2 per frame
		return;
	auto x = (int)(sim->parts[i].x+0.5f);
	auto y = (int)(sim->parts[i].y+0.5f);
	if( !(sim->parts[i].tmp&0x200) )
	{
		//normal random push
		auto rndstore = sim->rng.gen();
		// RAND_MAX is at least 32767 on all platforms i.e. pow(8,5)-1
		// so can go 5 cycles without regenerating rndstore
		// (although now we use our own randomizer so maybe should reevaluate all the rndstore usages in every element)
		for (auto q=0; q<3; q++)//try to push 3 times
		{
			auto rnd = rndstore&7;
			rndstore = rndstore>>3;
			auto rx = Element_PIPE_offsets[rnd].X;
			auto ry = Element_PIPE_offsets[rnd].Y;
			auto r = sim->pmap[y+ry][x+rx];
			if (!r)
				continue;
			else if ((TYP(r) == PT_PIPE || TYP(r) == PT_PPIP) && (sim->parts[ID(r)].tmp&PFLAG_COLORS) != notctype && !TYP(sim->parts[ID(r)].ctype))
			{
				transfer_pipe_to_pipe(sim->parts+i, sim->parts+(ID(r)), false);
				if (ID(r) > original)
					sim->parts[ID(r)].flags |= PFLAG_NORMALSPEED;//skip particle push, normalizes speed
				count++;
				pushParticle(sim, ID(r),count,original);
			}
			else if (TYP(r) == PT_PRTI) //Pass particles into PRTI for a pipe speed increase
			{
				int portaltmp = sim->parts[ID(r)].tmp;
				if (portaltmp >= CHANNELS)
					portaltmp = CHANNELS-1;
				else if (portaltmp < 0)
					portaltmp = 0;
				for (int nnx = 0; nnx < 80; nnx++)
					if (!sim->portalp[portaltmp][count][nnx].type)
					{
						Element_PIPE_transfer_pipe_to_part(sim, sim->parts+i, &(sim->portalp[portaltmp][count][nnx]), false);
						count++;
						break;
					}
			}
		}
	}
	else //predefined 1 pixel thick pipe movement
	{
		int coords = 7 - ((sim->parts[i].tmp>>10)&7);
		auto r = sim->pmap[y+ Element_PIPE_offsets[coords].Y][x+ Element_PIPE_offsets[coords].X];
		if ((TYP(r) == PT_PIPE || TYP(r) == PT_PPIP) && (sim->parts[ID(r)].tmp&PFLAG_COLORS) != notctype && !TYP(sim->parts[ID(r)].ctype))
		{
			transfer_pipe_to_pipe(sim->parts+i, sim->parts+(ID(r)), false);
			if (ID(r) > original)
				sim->parts[ID(r)].flags |= PFLAG_NORMALSPEED;//skip particle push, normalizes speed
			count++;
			pushParticle(sim, ID(r),count,original);
		}
		else if (TYP(r) == PT_PRTI) //Pass particles into PRTI for a pipe speed increase
		{
			int portaltmp = sim->parts[ID(r)].tmp;
			if (portaltmp >= CHANNELS)
				portaltmp = CHANNELS-1;
			else if (portaltmp < 0)
				portaltmp = 0;
			for (int nnx = 0; nnx < 80; nnx++)
				if (!sim->portalp[portaltmp][count][nnx].type)
				{
					Element_PIPE_transfer_pipe_to_part(sim, sim->parts+i, &(sim->portalp[portaltmp][count][nnx]), false);
					count++;
					break;
				}
		}
		else if (!r) //Move particles out of pipe automatically, much faster at ends
		{
			auto rx = Element_PIPE_offsets[coords].X;
			auto ry = Element_PIPE_offsets[coords].Y;
			auto np = sim->create_part(-1,x+rx,y+ry,TYP(sim->parts[i].ctype));
			if (np!=-1)
			{
				Element_PIPE_transfer_pipe_to_part(sim, sim->parts+i, sim->parts+np, false);
			}
		}

	}
	return;
}


=== src\simulation\elements\PIPE.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_PIPE_graphics(GRAPHICS_FUNC_ARGS);
void Element_PIPE_transfer_pipe_to_part(Simulation * sim, Particle *pipe, Particle *part, bool STOR);
void Element_PIPE_transfer_part_to_pipe(Particle *part, Particle *pipe);
void Element_PIPE_transformPatchOffsets(Particle &part, const std::array<int, 8> &offsetMap);
int Element_PIPE_update(UPDATE_FUNC_ARGS);
void Element_PPIP_flood_trigger(Simulation * sim, int x, int y, int sparkedBy);

// 0x00000100 is single pixel pipe
// 0x00000200 will transfer like a single pixel pipe when in forward mode
// 0x00001C00 forward single pixel pipe direction
// 0x00002000 will transfer like a single pixel pipe when in reverse mode
// 0x0001C000 reverse single pixel pipe direction
// 0x000E0000 PIPE color data stored here

constexpr int PFLAG_CAN_CONDUCT            = 0x00000001;
constexpr int PFLAG_PARTICLE_DECO          = 0x00000002; // differentiate particle deco from pipe deco
constexpr int PFLAG_NORMALSPEED            = 0x00010000;
constexpr int PFLAG_INITIALIZING           = 0x00020000; // colors haven't been set yet
constexpr int PFLAG_COLOR_RED              = 0x00040000;
constexpr int PFLAG_COLOR_GREEN            = 0x00080000;
constexpr int PFLAG_COLOR_BLUE             = 0x000C0000;
constexpr int PFLAG_COLORS                 = 0x000C0000;

extern int Element_PPIP_ppip_changed;
extern const std::array<Vec2<int>, 8> Element_PIPE_offsets;


=== src\simulation\elements\PLEX.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_PLEX()
{
	Identifier = "DEFAULT_PT_PLEX";
	Name = "C-4";
	Colour = 0xD080E0_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 1000;
	Explosive = 2;
	Meltable = 50;
	Hardness = 1;
	PhotonReflectWavelengths = 0x1F00003E;

	Weight = 100;

	HeatConduct = 88;
	Description = "Solid pressure sensitive explosive.";

	Properties = TYPE_SOLID | PROP_NEUTPENETRATE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 673.0f;
	HighTemperatureTransition = PT_FIRE;
}


=== src\simulation\elements\PLNT.cpp ===

#include "simulation/ElementCommon.h"
#include <algorithm>

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_PLNT()
{
	Identifier = "DEFAULT_PT_PLNT";
	Name = "PLNT";
	Colour = 0x0CAC00_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 20;
	Explosive = 0;
	Meltable = 0;
	Hardness = 10;
	PhotonReflectWavelengths = 0x0007C000;

	Weight = 100;

	HeatConduct = 65;
	Description = "Plant, drinks water and grows.";

	Properties = TYPE_SOLID|PROP_NEUTPENETRATE|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 573.0f;
	HighTemperatureTransition = PT_FIRE;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				switch (TYP(r))
				{
				case PT_WATR:
					if (sim->rng.chance(1, 50))
					{
						auto np = sim->create_part(ID(r),x+rx,y+ry,PT_PLNT);
						if (np<0) continue;
						parts[np].life = 0;
					}
					break;
				case PT_LAVA:
					if (sim->rng.chance(1, 50))
					{
						sim->part_change_type(i,x,y,PT_FIRE);
						parts[i].life = 4;
					}
					break;
				case PT_SMKE:
				case PT_CO2:
					if (sim->rng.chance(1, 50))
					{
						sim->kill_part(ID(r));
						parts[i].life = sim->rng.between(60, 119);
					}
					break;
				case PT_WOOD:
					{
						auto rndstore = sim->rng.gen();
						if (surround_space && !(rndstore%4) && parts[i].tmp==1)
						{
							rndstore >>= 3;
							int nnx = (rndstore%3) -1;
							rndstore >>= 2;
							int nny = (rndstore%3) -1;
							if (nnx || nny)
							{
								if (pmap[y+ry+nny][x+rx+nnx])
									continue;
								auto np = sim->create_part(-1,x+rx+nnx,y+ry+nny,PT_VINE);
								if (np<0) continue;
								parts[np].temp = parts[i].temp;
							}
						}
					}
					break;
				default:
					continue;
				}
			}
		}
	}
	if (parts[i].life==2)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						sim->create_part(-1,x+rx,y+ry,PT_O2);
				}
			}
		}
		parts[i].life = 0;
	}
	if (parts[i].temp > 350 && parts[i].temp > parts[i].tmp2)
		parts[i].tmp2 = (int)parts[i].temp;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	float maxtemp = std::max((float)cpart->tmp2, cpart->temp);
	if (maxtemp > 300)
	{
		*colr += (int)restrict_flt((maxtemp-300)/5,0,58);
		*colg -= (int)restrict_flt((maxtemp-300)/2,0,102);
		*colb += (int)restrict_flt((maxtemp-300)/5,0,70);
	}
	if (maxtemp < 273)
	{
		*colg += (int)restrict_flt((273-maxtemp)/4,0,255);
		*colb += (int)restrict_flt((273-maxtemp)/1.5,0,255);
	}
	return 0;
}


=== src\simulation\elements\PLSM.cpp ===

#include "simulation/ElementCommon.h"
#include "FIRE.h"

static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_PLSM()
{
	Identifier = "DEFAULT_PT_PLSM";
	Name = "PLSM";
	Colour = 0xBB99FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 0.9f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.97f;
	Loss = 0.20f;
	Collision = 0.0f;
	Gravity = -0.1f;
	Diffusion = 0.30f;
	HotAir = 0.001f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 1;

	DefaultProperties.temp = MAX_TEMP;
	HeatConduct = 5;
	Description = "Plasma, extremely hot.";

	Properties = TYPE_GAS|PROP_LIFE_DEC|PROP_LIFE_KILL;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &Element_FIRE_update;
	Graphics = &graphics;
	Create = &create;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	RGB color = Renderer::plasmaTableAt(cpart->life);
	*colr = color.Red;
	*colg = color.Green;
	*colb = color.Blue;

	*firea = 255;
	*firer = *colr;
	*fireg = *colg;
	*fireb = *colb;

	*pixel_mode = PMODE_GLOW | PMODE_ADD; //Clear default, don't draw pixel
	*pixel_mode |= FIRE_ADD;
	//Returning 0 means dynamic, do not cache
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].life = sim->rng.between(50, 199);
}


=== src\simulation\elements\PLUT.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_PLUT()
{
	Identifier = "DEFAULT_PT_PLUT";
	Name = "PLUT";
	Colour = 0x407020_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.4f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;
	PhotonReflectWavelengths = 0x001FCE00;

	Weight = 90;

	DefaultProperties.temp = R_TEMP + 4.0f + 273.15f;
	HeatConduct = 251;
	Description = "Plutonium. Heavy, fissile particles. Generates neutrons under pressure.";

	Properties = TYPE_PART|PROP_NEUTPASS|PROP_RADIOACTIVE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (sim->rng.chance(1, 100) && sim->rng.chance(int(5.0f*sim->pv[y/CELL][x/CELL]), 1000))
	{
		sim->create_part(i, x, y, PT_NEUT);
	}
	return 0;
}


=== src\simulation\elements\POLO.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_POLO()
{
	Identifier = "DEFAULT_PT_POLO";
	Name = "POLO";
	Colour = 0x506030_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.4f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 0;
	PhotonReflectWavelengths = 0x000FF200;

	Weight = 90;

	DefaultProperties.temp = 388.15f;
	HeatConduct = 251;
	Description = "Polonium, highly radioactive. Decays into NEUT and heats up.";

	Properties = TYPE_PART|PROP_NEUTPASS|PROP_RADIOACTIVE|PROP_LIFE_DEC|PROP_DEADLY;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 526.95f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
	Graphics = &graphics;
}

constexpr int COOLDOWN = 15;
constexpr int LIMIT = 5;

static int update(UPDATE_FUNC_ARGS)
{
	int r = sim->photons[y][x];
	if (parts[i].tmp < LIMIT && !parts[i].life)
	{
		if (sim->rng.chance(1, 10000) && !parts[i].tmp)
		{
			int s = sim->create_part(-3, x, y, PT_NEUT);
			if (s >= 0)
			{
				parts[i].life = COOLDOWN;
				parts[i].tmp++;

				parts[i].temp = ((parts[i].temp + parts[s].temp) + 600.0f) / 2.0f;
				parts[s].temp = parts[i].temp;
			}
		}

		if (r && sim->rng.chance(1, 100))
		{
			int s = sim->create_part(-3, x, y, PT_NEUT);
			if (s >= 0)
			{
				parts[i].temp = ((parts[i].temp + parts[ID(r)].temp + parts[ID(r)].temp) + 600.0f) / 3.0f;
				parts[i].life = COOLDOWN;
				parts[i].tmp++;

				parts[ID(r)].temp = parts[i].temp;

				parts[s].temp = parts[i].temp;
				parts[s].vx = parts[ID(r)].vx;
				parts[s].vy = parts[ID(r)].vy;
			}
		}
	}
	if (parts[i].tmp2 >= 10)
	{
		sim->part_change_type(i,x,y,PT_PLUT);
		parts[i].temp = (parts[i].temp+600.0f)/2.0f;
		return 1;
	}
	if (TYP(r) == PT_PROT)
	{
		parts[i].tmp2++;
		sim->kill_part(ID(r));
	}
	if (parts[i].temp < 388.15f)
	{
		parts[i].temp += 0.2f;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if (cpart->tmp >= LIMIT)
	{
		*colr = 0x70;
		*colg = 0x70;
		*colb = 0x70;
	}
	else
		*pixel_mode |= PMODE_GLOW;

	return 0;
}


=== src\simulation\elements\PPIP.cpp ===

#include "simulation/ElementCommon.h"
#include "PIPE.h"

void Element::Element_PPIP()
{
	Identifier = "DEFAULT_PT_PPIP";
	Name = "PPIP";
	Colour = 0x444466_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = 295.15f;
	HeatConduct = 251;
	Description = "Powered version of PIPE, use PSCN/NSCN to Activate/Deactivate.";

	Properties = TYPE_SOLID | PROP_LIFE_DEC;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 60;

	Update = &Element_PIPE_update;
	Graphics = &Element_PIPE_graphics;
}

// parts[].tmp flags
// trigger flags to be processed this frame (trigger flags for next frame are shifted 3 bits to the left):
constexpr int PPIP_TMPFLAG_TRIGGER_ON      = 0x10000000;
constexpr int PPIP_TMPFLAG_TRIGGER_OFF     = 0x08000000;
constexpr int PPIP_TMPFLAG_TRIGGER_REVERSE = 0x04000000;
// 0x000000FF element
// 0x00000100 is single pixel pipe
// 0x00000200 will transfer like a single pixel pipe when in forward mode
// 0x00001C00 forward single pixel pipe direction
// 0x00002000 will transfer like a single pixel pipe when in reverse mode
// 0x0001C000 reverse single pixel pipe direction

int Element_PPIP_ppip_changed = 0;

void Element_PPIP_flood_trigger(Simulation * sim, int x, int y, int sparkedBy)
{
	int coord_stack_limit = XRES*YRES;
	unsigned short (*coord_stack)[2];
	int coord_stack_size = 0;
	int x1, x2;

	Particle * parts = sim->parts;
	int (*pmap)[XRES] = sim->pmap;
	int t = TYP(pmap[y][x]);
	if (t != PT_PIPE && t != PT_PPIP)
		return;

	// Separate flags for on and off in case PPIP is sparked by PSCN and NSCN on the same frame
	// - then PSCN can override NSCN and behaviour is not dependent on particle order
	int prop = 0;
	if (sparkedBy==PT_PSCN) prop = PPIP_TMPFLAG_TRIGGER_ON << 3;
	else if (sparkedBy==PT_NSCN) prop = PPIP_TMPFLAG_TRIGGER_OFF << 3;
	else if (sparkedBy==PT_INST) prop = PPIP_TMPFLAG_TRIGGER_REVERSE << 3;
	else if (sparkedBy == PT_HEAC) prop = PFLAG_CAN_CONDUCT; // Special case for HEAC near pipe

	if (prop == 0 || (t != PT_PPIP && sparkedBy != PT_HEAC) || (parts[ID(pmap[y][x])].tmp & prop))
		return;

	coord_stack = new unsigned short[coord_stack_limit][2];
	coord_stack[coord_stack_size][0] = x;
	coord_stack[coord_stack_size][1] = y;
	coord_stack_size++;

	do
	{
		coord_stack_size--;
		x = coord_stack[coord_stack_size][0];
		y = coord_stack[coord_stack_size][1];
		x1 = x2 = x;
		// go left as far as possible
		while (x1>=CELL)
		{
			if (TYP(pmap[y][x1-1]) != t)
			{
				break;
			}
			x1--;
		}
		// go right as far as possible
		while (x2<XRES-CELL)
		{
			if (TYP(pmap[y][x2+1]) != t)
			{
				break;
			}
			x2++;
		}
		// fill span
		for (x=x1; x<=x2; x++)
		{
			if (!(parts[ID(pmap[y][x])].tmp & prop) && sparkedBy != PT_HEAC)
				Element_PPIP_ppip_changed = 1;
			parts[ID(pmap[y][x])].tmp |= prop;
		}

		// add adjacent pixels to stack
		// +-1 to x limits to include diagonally adjacent pixels
		// Don't need to check x bounds here, because already limited to [CELL, XRES-CELL]
		if (y>=CELL+1)
			for (x=x1-1; x<=x2+1; x++)
			if (TYP(pmap[y-1][x]) == t && !(parts[ID(pmap[y-1][x])].tmp & prop))
			{
				coord_stack[coord_stack_size][0] = x;
				coord_stack[coord_stack_size][1] = y-1;
				coord_stack_size++;
				if (coord_stack_size>=coord_stack_limit)
				{
					delete[] coord_stack;
					return;
				}
			}
		if (y<YRES-CELL-1)
			for (x=x1-1; x<=x2+1; x++)
				if (TYP(pmap[y+1][x]) == t && !(parts[ID(pmap[y+1][x])].tmp & prop))
				{
					coord_stack[coord_stack_size][0] = x;
					coord_stack[coord_stack_size][1] = y+1;
					coord_stack_size++;
					if (coord_stack_size>=coord_stack_limit)
					{
						delete[] coord_stack;
						return;
					}
				}
	} while (coord_stack_size>0);
	delete[] coord_stack;
}


=== src\simulation\elements\PQRT.cpp ===

#include "simulation/ElementCommon.h"
#include "QRTZ.h"

static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_PQRT()
{
	Identifier = "DEFAULT_PT_PQRT";
	Name = "PQRT";
	Colour = 0x88BBBB_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.27f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 90;

	HeatConduct = 3;
	Description = "Powdered quartz, broken form of QRTZ.";

	Properties = TYPE_PART | PROP_PHOTPASS | PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 2573.15f;
	HighTemperatureTransition = PT_LAVA;

	Update = &Element_QRTZ_update;
	Graphics = &Element_QRTZ_graphics;
	Create = &create;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].tmp2 = sim->rng.between(0, 10);
}


=== src\simulation\elements\PROT.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);
static int DeutImplosion(Simulation * sim, int n, int x, int y, float temp, int t);

void Element::Element_PROT()
{
	Identifier = "DEFAULT_PT_PROT";
	Name = "PROT";
	Colour = 0x990000_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 1.00f;
	Collision = -.99f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = -1;

	HeatConduct = 61;
	Description = "Protons. Transfer heat to materials, and remove sparks.";

	Properties = TYPE_ENERGY;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 75;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	sim->pv[y/CELL][x/CELL] -= .003f;
	int under = pmap[y][x];
	int utype = TYP(under);
	int uID = ID(under);
	switch (utype)
	{
	case PT_SPRK:
	{
		//remove active sparks
		int sparked = parts[uID].ctype;
		if (!sim->part_change_type(uID, x, y, sparked))
		{
			parts[uID].life = 44 + parts[uID].life;
			parts[uID].ctype = 0;
		}
		else
			utype = 0;
		break;
	}
	case PT_DEUT:
		if (sim->rng.chance(-((int)sim->pv[y / CELL][x / CELL] - 4) + (parts[uID].life / 100), 200))
		{
			DeutImplosion(sim, parts[uID].life, x, y, restrict_flt(parts[uID].temp + parts[uID].life * 500, MIN_TEMP, MAX_TEMP), PT_PROT);
			sim->kill_part(uID);
		}
		break;
	case PT_LCRY:
		//Powered LCRY reaction: PROT->PHOT
		if (parts[uID].life > 5 && sim->rng.chance(1, 10))
		{
			sim->part_change_type(i, x, y, PT_PHOT);
			parts[i].life *= 2;
			parts[i].ctype = 0x3FFFFFFF;
		}
		break;
	case PT_EXOT:
		parts[uID].ctype = PT_PROT;
		break;
	case PT_WIFI:
		float change;
		if (parts[i].temp < 173.15f) change = -1000.0f;
		else if (parts[i].temp < 273.15f) change = -100.0f;
		else if (parts[i].temp > 473.15f) change = 1000.0f;
		else if (parts[i].temp > 373.15f) change = 100.0f;
		else change = 0.0f;
		parts[uID].temp = restrict_flt(parts[uID].temp + change, MIN_TEMP, MAX_TEMP);
		break;
	case PT_RSSS: //Destroy RSSS
		{
			sim->kill_part(uID);
			sim->kill_part(i);
			return 1;
		}
		break;
	case PT_NONE:
		//slowly kill if it's not inside an element
		if (parts[i].life)
		{
			if (!--parts[i].life)
			{
				sim->kill_part(i);
				return 1;
			}
		}
		break;
	default:
		//set off explosives (only when hot because it wasn't as fun when it made an entire save explode)
		if (parts[i].temp > 273.15f + 500.0f && (elements[utype].Flammable || elements[utype].Explosive || utype == PT_BANG))
		{
			sim->create_part(uID, x, y, PT_FIRE);
			parts[uID].temp += restrict_flt(float(elements[utype].Flammable * 5), MIN_TEMP, MAX_TEMP);
			sim->pv[y / CELL][x / CELL] += 1.00f;
		}
		//prevent inactive sparkable elements from being sparked
		else if ((elements[utype].Properties&PROP_CONDUCTS) && parts[uID].life <= 4)
		{
			parts[uID].life = 40 + parts[uID].life;
		}
		break;
	}
	//make temp of other things closer to it's own temperature. This will change temp of things that don't conduct, and won't change the PROT's temperature
	if (utype && utype != PT_WIFI)
		parts[uID].temp = restrict_flt(parts[uID].temp-(parts[uID].temp-parts[i].temp)/4.0f, MIN_TEMP, MAX_TEMP);


	//if this proton has collided with another last frame, change it into a heavier element
	if (parts[i].tmp)
	{
		int newID, element;
		if (parts[i].tmp > 500000)
			element = PT_SING; //particle accelerators are known to create earth-destroying black holes
		else if (parts[i].tmp > 700)
			element = PT_PLUT;
		else if (parts[i].tmp > 420)
			element = PT_URAN;
		else if (parts[i].tmp > 310)
			element = PT_POLO;
		else if (parts[i].tmp > 250)
			element = PT_PLSM;
		else if (parts[i].tmp > 100)
			element = PT_O2;
		else if (parts[i].tmp > 50)
			element = PT_CO2;
		else
			element = PT_NBLE;
		newID = sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), element);
		if (newID >= 0)
			parts[newID].temp = restrict_flt(100.0f*parts[i].tmp, MIN_TEMP, MAX_TEMP);
		sim->kill_part(i);
		return 1;
	}
	//collide with other protons to make heavier materials
	int ahead = sim->photons[y][x];
	if (ID(ahead) != i && TYP(ahead) == PT_PROT)
	{
		float velocity1 = powf(parts[i].vx, 2.0f)+powf(parts[i].vy, 2.0f);
		float velocity2 = powf(parts[ID(ahead)].vx, 2.0f)+powf(parts[ID(ahead)].vy, 2.0f);
		float direction1 = atan2f(-parts[i].vy, parts[i].vx);
		float direction2 = atan2f(-parts[ID(ahead)].vy, parts[ID(ahead)].vx);
		float difference = direction1 - direction2; if (difference < 0) difference += 6.28319f;

		if (difference > 3.12659f && difference < 3.15659f && velocity1 + velocity2 > 10.0f)
		{
			parts[ID(ahead)].tmp += (int)(velocity1 + velocity2);
			sim->kill_part(i);
			return 1;
		}
	}
	return 0;
}

static int DeutImplosion(Simulation * sim, int n, int x, int y, float temp, int t)
{
	int i;
	n = (n/50);
	if (n < 1)
		n = 1;
	else if (n > 340)
		n = 340;

	for (int c = 0; c < n; c++)
	{
		i = sim->create_part(-3, x, y, t);
		if (i >= 0)
			sim->parts[i].temp = temp;
		else if (sim->MaxPartsReached())
			break;
	}
	sim->pv[y/CELL][x/CELL] -= (6.0f * CFDS)*n;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 7;
	*firer = 250;
	*fireg = 170;
	*fireb = 170;

	*pixel_mode |= FIRE_BLEND;
	return 1;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	float a = sim->rng.between(0, 35) * 0.17453f;
	sim->parts[i].life = 680;
	sim->parts[i].vx = 2.0f * cosf(a);
	sim->parts[i].vy = 2.0f * sinf(a);
}


=== src\simulation\elements\PRTI.cpp ===

#include "simulation/ElementCommon.h"
#include "simulation/orbitalparts.h"
#include "PIPE.h"
#include "SOAP.h"
#include "PRTI.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_PRTI()
{
	Identifier = "DEFAULT_PT_PRTI";
	Name = "PRTI";
	Colour = 0xEB5917_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = -0.005f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 0;
	Description = "Portal IN. Particles go in here. Also has temperature dependent channels. (same as WIFI)";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

/*these are the count values of where the particle gets stored, depending on where it came from
   0 1 2
   7 . 3
   6 5 4
   PRTO does (count+4)%8, so that it will come out at the opposite place to where it came in
   PRTO does +/-1 to the count, so it doesn't jam as easily
*/

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int fe = 0;

	parts[i].tmp = (int)((parts[i].temp-73.15f)/100+1);
	if (parts[i].tmp >= CHANNELS)
		parts[i].tmp = CHANNELS-1;
	else if (parts[i].tmp < 0)
		parts[i].tmp = 0;

	for (int count = 0; count < 8; count++)
	{
		int rx = portal_rx[count];
		int ry = portal_ry[count];
		if (rx || ry)
		{
			int r = pmap[y+ry][x+rx];
			if (!r || TYP(r) == PT_STOR)
				fe = 1;
			if (!r || (!(elements[TYP(r)].Properties & (TYPE_PART | TYPE_LIQUID | TYPE_GAS | TYPE_ENERGY)) && TYP(r)!=PT_SPRK && TYP(r)!=PT_STOR))
			{
				r = sim->photons[y+ry][x+rx];
				if (!r)
					continue;
			}

			if (TYP(r)==PT_STKM || TYP(r)==PT_STKM2 || TYP(r)==PT_FIGH)
				continue;// Handling these is a bit more complicated, and is done in STKM_interact()

			if (TYP(r) == PT_SOAP)
				Element_SOAP_detach(sim, ID(r));

			for (int nnx=0; nnx<80; nnx++)
				if (!sim->portalp[parts[i].tmp][count][nnx].type)
				{
					if (TYP(r) == PT_STOR)
					{
						if (sd.IsElement(parts[ID(r)].tmp) && (elements[parts[ID(r)].tmp].Properties & (TYPE_PART | TYPE_LIQUID | TYPE_GAS | TYPE_ENERGY)))
						{
							// STOR uses same format as PIPE, so we can use this function to do the transfer
							Element_PIPE_transfer_pipe_to_part(sim, parts+(ID(r)), &sim->portalp[parts[i].tmp][count][nnx], true);
							break;
						}
					}
					else
					{
						sim->portalp[parts[i].tmp][count][nnx] = parts[ID(r)];
						if (TYP(r) == PT_SPRK)
							sim->part_change_type(ID(r),x+rx,y+ry,parts[ID(r)].ctype);
						else
							sim->kill_part(ID(r));
						fe = 1;
						break;
					}
				}
		}
	}


	if (fe) {
		int orbd[4] = {0, 0, 0, 0};	//Orbital distances
		int orbl[4] = {0, 0, 0, 0};	//Orbital locations
		if (!sim->parts[i].life) parts[i].life = sim->rng.gen();
		if (!sim->parts[i].ctype) parts[i].ctype = sim->rng.gen();
		orbitalparts_get(parts[i].life, parts[i].ctype, orbd, orbl);
		for (int r = 0; r < 4; r++) {
			if (orbd[r]>1) {
				orbd[r] -= 12;
				if (orbd[r]<1) {
					orbd[r] = sim->rng.between(128, 255);
					orbl[r] = sim->rng.between(0, 254);
				} else {
					orbl[r] += 2;
					orbl[r] = orbl[r]%255;
				}
			} else {
				orbd[r] = sim->rng.between(128, 255);
				orbl[r] = sim->rng.between(0, 254);
			}
		}
		orbitalparts_set(&parts[i].life, &parts[i].ctype, orbd, orbl);
	} else {
		parts[i].life = 0;
		parts[i].ctype = 0;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 8;
	*firer = 255;
	*fireg = 0;
	*fireb = 0;
	*pixel_mode |= EFFECT_DBGLINES;
	*pixel_mode |= EFFECT_GRAVIN;
	*pixel_mode &= ~PMODE;
	*pixel_mode |= PMODE_ADD;
	return 1;
}


=== src\simulation\elements\PRTI.h ===

#pragma once

constexpr int portal_rx[8] = { -1,  0,  1,  1,  1,  0, -1, -1 };
constexpr int portal_ry[8] = { -1, -1, -1,  0,  1,  1,  1,  0 };


=== src\simulation\elements\PRTO.cpp ===

#include "simulation/ElementCommon.h"
#include "simulation/orbitalparts.h"
#include "PRTI.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_PRTO()
{
	Identifier = "DEFAULT_PT_PRTO";
	Name = "PRTO";
	Colour = 0x0020EB_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.005f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 0;
	Description = "Portal OUT. Particles come out here. Also has temperature dependent channels. (same as WIFI)";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

/*these are the count values of where the particle gets stored, depending on where it came from
	0 1 2
	7 . 3
	6 5 4
	PRTO does (count+4)%8, so that it will come out at the opposite place to where it came in
	PRTO does +/-1 to the count, so it doesn't jam as easily
*/

static int update(UPDATE_FUNC_ARGS)
{
	int fe = 0;
	parts[i].tmp = (int)((parts[i].temp-73.15f)/100+1);
	if (parts[i].tmp>=CHANNELS) parts[i].tmp = CHANNELS-1;
	else if (parts[i].tmp<0) parts[i].tmp = 0;
	for (auto count=0; count<8; count++)
	{
		auto rx = portal_rx[count];
		auto ry = portal_ry[count];
		if (rx || ry)
		{
			auto r = pmap[y+ry][x+rx];
			if (!r)
			{
				fe = 1;
				for (auto nnx =0 ; nnx<80; nnx++)
				{
					int randomness = (count + sim->rng.between(-1, 1) + 4) % 8;//add -1,0,or 1 to count
					if (sim->portalp[parts[i].tmp][randomness][nnx].type==PT_SPRK)// TODO: make it look better, spark creation
					{
						sim->create_part(-1,x+1,y,PT_SPRK);
						sim->create_part(-1,x+1,y+1,PT_SPRK);
						sim->create_part(-1,x+1,y-1,PT_SPRK);
						sim->create_part(-1,x,y-1,PT_SPRK);
						sim->create_part(-1,x,y+1,PT_SPRK);
						sim->create_part(-1,x-1,y+1,PT_SPRK);
						sim->create_part(-1,x-1,y,PT_SPRK);
						sim->create_part(-1,x-1,y-1,PT_SPRK);
						memset(&sim->portalp[parts[i].tmp][randomness][nnx], 0, sizeof(Particle));
						break;
					}
					else if (sim->portalp[parts[i].tmp][randomness][nnx].type)
					{
						if (sim->portalp[parts[i].tmp][randomness][nnx].type==PT_STKM)
							sim->player.spwn = 0;
						if (sim->portalp[parts[i].tmp][randomness][nnx].type==PT_STKM2)
							sim->player2.spwn = 0;
						if (sim->portalp[parts[i].tmp][randomness][nnx].type==PT_FIGH)
						{
							sim->fighcount--;
							sim->fighters[(unsigned char)sim->portalp[parts[i].tmp][randomness][nnx].tmp].spwn = 0;
						}
						auto np = sim->create_part(-1, x+rx, y+ry, sim->portalp[parts[i].tmp][randomness][nnx].type);
						if (np<0)
						{
							if (sim->portalp[parts[i].tmp][randomness][nnx].type==PT_STKM)
								sim->player.spwn = 1;
							if (sim->portalp[parts[i].tmp][randomness][nnx].type==PT_STKM2)
								sim->player2.spwn = 1;
							if (sim->portalp[parts[i].tmp][randomness][nnx].type==PT_FIGH)
							{
								sim->fighcount++;
								sim->fighters[(unsigned char)sim->portalp[parts[i].tmp][randomness][nnx].tmp].spwn = 1;
							}
							continue;
						}
						if (parts[np].type==PT_FIGH)
						{
							// Release the fighters[] element allocated by create_part, the one reserved when the fighter went into the portal will be used
							sim->fighters[(unsigned char)parts[np].tmp].spwn = 0;
							sim->fighters[(unsigned char)sim->portalp[parts[i].tmp][randomness][nnx].tmp].spwn = 1;
						}
						if (sim->portalp[parts[i].tmp][randomness][nnx].vx == 0.0f && sim->portalp[parts[i].tmp][randomness][nnx].vy == 0.0f)
						{
							// particles that have passed from PIPE into PRTI have lost their velocity, so use the velocity of the newly created particle if the particle in the portal has no velocity
							float tmp_vx = parts[np].vx;
							float tmp_vy = parts[np].vy;
							parts[np] = sim->portalp[parts[i].tmp][randomness][nnx];
							parts[np].vx = tmp_vx;
							parts[np].vy = tmp_vy;
						}
						else
							parts[np] = sim->portalp[parts[i].tmp][randomness][nnx];
						parts[np].x = float(x+rx);
						parts[np].y = float(y+ry);
						memset(&sim->portalp[parts[i].tmp][randomness][nnx], 0, sizeof(Particle));
						break;
					}
				}
			}
		}
	}
	if (fe)
	{
		int orbd[4] = {0, 0, 0, 0};	//Orbital distances
		int orbl[4] = {0, 0, 0, 0};	//Orbital locations
		if (!sim->parts[i].life) parts[i].life = sim->rng.gen();
		if (!sim->parts[i].ctype) parts[i].ctype = sim->rng.gen();
		orbitalparts_get(parts[i].life, parts[i].ctype, orbd, orbl);
		for (auto r = 0; r < 4; r++)
		{
			if (orbd[r]<254)
			{
				orbd[r] += 16;
				if (orbd[r]>254) {
					orbd[r] = 0;
					orbl[r] = sim->rng.between(0, 254);
				}
				else
				{
					orbl[r] += 1;
					orbl[r] = orbl[r]%255;
				}
			}
			else
			{
				orbd[r] = 0;
				orbl[r] = sim->rng.between(0, 254);
			}
		}
		orbitalparts_set(&parts[i].life, &parts[i].ctype, orbd, orbl);
	}
	else
	{
		parts[i].life = 0;
		parts[i].ctype = 0;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 8;
	*firer = 0;
	*fireg = 0;
	*fireb = 255;
	*pixel_mode |= EFFECT_DBGLINES;
	*pixel_mode |= EFFECT_GRAVOUT;
	*pixel_mode &= ~PMODE;
	*pixel_mode |= PMODE_ADD;
	return 1;
}


=== src\simulation\elements\PSCN.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_PSCN()
{
	Identifier = "DEFAULT_PT_PSCN";
	Name = "PSCN";
	Colour = 0x805050_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;
	PhotonReflectWavelengths = 0x00000000;

	Weight = 100;

	HeatConduct = 251;
	Description = "P-Type Silicon, Will transfer current to any conductor. Enables powered materials.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1687.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\PSNS.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_PSNS()
{
	Identifier = "DEFAULT_PT_PSNS";
	Name = "PSNS";
	Colour = 0xDB2020_rgb;
	MenuVisible = 1;
	MenuSection = SC_SENSOR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = 4.0f + 273.15f;
	HeatConduct = 0;
	Description = "Pressure sensor, creates a spark when the pressure is greater than its temperature.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if ((parts[i].tmp == 0 && sim->pv[y/CELL][x/CELL] > parts[i].temp-273.15f) || (parts[i].tmp == 2 && sim->pv[y/CELL][x/CELL] < parts[i].temp-273.15f))
	{
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					auto pavg = sim->parts_avg(i,ID(r),PT_INSL);
					if (pavg != PT_INSL && pavg != PT_RSSS)
					{
						auto rt = TYP(r);
						if ((elements[rt].Properties&PROP_CONDUCTS) && !(rt==PT_WATR||rt==PT_SLTW||rt==PT_NTCT||rt==PT_PTCT||rt==PT_INWR) && parts[ID(r)].life==0)
						{
							parts[ID(r)].life = 4;
							parts[ID(r)].ctype = rt;
							sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
						}
					}
				}
			}
		}
	}
	if (parts[i].tmp == 1)
	{
		bool setFilt = true;
		float photonWl = sim->pv[y / CELL][x / CELL];
		if (setFilt)
		{
			for (auto rx = -1; rx <= 1; rx++)
			{
				for (auto ry = -1; ry <= 1; ry++)
				{
					if (rx || ry)
					{
						auto r = pmap[y + ry][x + rx];
						if (!r)
							continue;
						auto nx = x + rx;
						auto ny = y + ry;
						while (TYP(r) == PT_FILT)
						{
							parts[ID(r)].ctype = 0x10000000 + int(round(photonWl) - MIN_PRESSURE);
							nx += rx;
							ny += ry;
							if (nx < 0 || ny < 0 || nx >= XRES || ny >= YRES)
								break;
							r = pmap[ny][nx];
						}
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\PSTE.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_PSTE()
{
	Identifier = "DEFAULT_PT_PSTE";
	Name = "PSTE";
	Colour = 0xAA99AA_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 31;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	Description = "Colloid, Hardens under pressure.";

	Properties = TYPE_LIQUID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 0.5f;
	HighPressureTransition = PT_PSTS;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 747.0f;
	HighTemperatureTransition = PT_BRCK;
}


=== src\simulation\elements\PSTN.cpp ===

#include "simulation/ElementCommon.h"
#include <algorithm>

struct StackData;
static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static bool ctypeDraw(CTYPEDRAW_FUNC_ARGS);
static StackData CanMoveStack(Simulation * sim, int stackX, int stackY, int directionX, int directionY, int maxSize, int amount, bool retract, int block);
static int MoveStack(Simulation * sim, int stackX, int stackY, int directionX, int directionY, int maxSize, int amount, bool retract, int block, bool sticky, int callDepth = 0);

void Element::Element_PSTN()
{
	Identifier = "DEFAULT_PT_PSTN";
	Name = "PSTN";
	Colour = 0xAA9999_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = 10.0f + 273.15f;
	HeatConduct = 0;
	Description = "Piston, pushes particles. PSCN extends, NSCN retracts";

	Properties = TYPE_SOLID;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	CtypeDraw = &ctypeDraw;
}

struct StackData
{
	int pushed;
	int spaces;

	StackData(int pushed, int spaces):
		pushed(pushed),
		spaces(spaces)
	{
	}
};

int tempParts[XRES];

constexpr int PISTON_INACTIVE   = 0x00;
constexpr int PISTON_RETRACT    = 0x01;
constexpr int PISTON_EXTEND     = 0x02;
constexpr int MAX_FRAME         = 0x0F;
constexpr int DEFAULT_LIMIT     = 0x1F;
constexpr int DEFAULT_ARM_LIMIT = 0xFF;

static int update(UPDATE_FUNC_ARGS)
{
 	if(parts[i].life)
 		return 0;
 	int maxSize = parts[i].tmp ? parts[i].tmp : DEFAULT_LIMIT;
 	int armLimit = parts[i].tmp2 ? parts[i].tmp2 : DEFAULT_ARM_LIMIT;
 	int state = 0;
	int directionX = 0, directionY = 0;
	if (state == PISTON_INACTIVE)
	{
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if ((rx || ry) && (!rx || !ry))
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r)==PT_SPRK && parts[ID(r)].life==3) {
						if(parts[ID(r)].ctype == PT_PSCN)
							state = PISTON_EXTEND;
						else
							state = PISTON_RETRACT;
					}
				}
			}
		}
	}
	if (state == PISTON_EXTEND || state == PISTON_RETRACT)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if ((rx || ry) && (!rx || !ry))
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r) == PT_PSTN && !parts[ID(r)].life)
					{
						bool movedPiston = false;
						bool foundEnd = false;
						int pistonEndX, pistonEndY;
						int pistonCount = -1;// number of PSTN particles minus 1
						int newSpace = 0;
						int armCount = 0;
						directionX = rx;
						directionY = ry;
						auto nxi = directionX, nyi = directionY;
						for (auto nxx = 0, nyy = 0; ; nyy += nyi, nxx += nxi)
						{
							if (!(x+nxx<XRES && y+nyy<YRES && x+nxx >= 0 && y+nyy >= 0)) {
								break;
							}
							r = pmap[y+nyy][x+nxx];
							if(TYP(r)==PT_PSTN)
							{
								if(parts[ID(r)].life)
									armCount++;
								else if (armCount)
								{
									pistonEndX = x+nxx;
									pistonEndY = y+nyy;
									foundEnd = true;
									break;
								}
								else
								{
									pistonCount += int(floor((parts[ID(r)].temp-268.15f)/10));// How many tens of degrees above 0 C, rounded to nearest ten degrees. Can be negative.
								}
							}
							else if (nxx==0 && nyy==0)
							{
								// compatibility with BAD THINGS: starting PSTN layered underneath other particles
								// (in v90, it started scanning from the neighbouring particle, so could not break out of loop at offset=(0,0))
								pistonCount += int(floor((parts[i].temp-268.15f)/10));
								continue;
							}
							else
							{
								pistonEndX = x+nxx;
								pistonEndY = y+nyy;
								foundEnd = true;
								break;
							}
						}
						if(foundEnd) {
							if(state == PISTON_EXTEND) {
								if(armCount+pistonCount > armLimit)
									pistonCount = armLimit-armCount;
								if(pistonCount > 0) {
									newSpace = MoveStack(sim, pistonEndX, pistonEndY, directionX, directionY, maxSize, pistonCount, false, parts[i].ctype, true);
									if(newSpace) {
										//Create new piston section
										for(int j = 0; j < newSpace; j++) {
											int nr = sim->create_part(-3, pistonEndX+(nxi*j), pistonEndY+(nyi*j), PT_PSTN);
											if (nr > -1) {
												parts[nr].life = 1;
												if (parts[i].dcolour)
												{
													int colour=parts[i].dcolour;
													parts[nr].dcolour=(colour&0xFF000000)|std::max((colour&0xFF0000)-0x3C0000,0)|std::max((colour&0xFF00)-0x3C00,0)|std::max((colour&0xFF)-0x3C,0);
												}
											}
										}
										movedPiston =  true;
									}
								}
							} else if(state == PISTON_RETRACT) {
								if(pistonCount > armCount)
									pistonCount = armCount;
								if(armCount && pistonCount > 0) {
									MoveStack(sim, pistonEndX, pistonEndY, directionX, directionY, maxSize, pistonCount, true, parts[i].ctype, true);
									movedPiston = true;
								}
							}
						}
						if (movedPiston)
							return 0;
					}
				}
			}
		}
	}
	return 0;
}

static StackData CanMoveStack(Simulation * sim, int stackX, int stackY, int directionX, int directionY, int maxSize, int amount, bool retract, int block)
{
	int posX, posY, r, spaces = 0, currentPos = 0;
	if (amount <= 0)
		return StackData(0, 0);
	for (posX = stackX, posY = stackY; currentPos < maxSize + amount && currentPos < XRES-1; posX += directionX, posY += directionY)
	{
		if (!(posX < XRES && posY < YRES && posX >= 0 && posY >= 0))
			break;

		r = sim->pmap[posY][posX];
		if (sim->IsWallBlocking(posX, posY, 0) || (block && TYP(r) == block))
			return StackData(currentPos - spaces, spaces);
		if (!r)
		{
			spaces++;
			tempParts[currentPos++] = -1;
			if (spaces >= amount)
				break;
		}
		else
		{
			if (currentPos - spaces < maxSize && (!retract || (TYP(r) == PT_FRME && posX == stackX && posY == stackY)))
				tempParts[currentPos++] = ID(r);
			else
				return StackData(currentPos - spaces, spaces);
		}
	}
	return StackData(currentPos - spaces, spaces);
}

static int MoveStack(Simulation * sim, int stackX, int stackY, int directionX, int directionY, int maxSize, int amount, bool retract, int block, bool sticky, int callDepth)
{
	int posX, posY, r;
	r = sim->pmap[stackY][stackX];
	if(!callDepth && TYP(r) == PT_FRME) {
		int newY = !!directionX, newX = !!directionY;
		int realDirectionX = retract?-directionX:directionX;
		int realDirectionY = retract?-directionY:directionY;
		int maxRight = MAX_FRAME, maxLeft = MAX_FRAME;

		//check if we can push all the FRME
		for(int c = retract; c < MAX_FRAME; c++) {
			posY = stackY + (c*newY);
			posX = stackX + (c*newX);
			if (posX < XRES && posY < YRES && posX >= 0 && posY >= 0 && TYP(sim->pmap[posY][posX]) == PT_FRME) {
				int spaces = CanMoveStack(sim, posX, posY, realDirectionX, realDirectionY, maxSize, amount, retract, block).spaces;
				if(spaces < amount)
					amount = spaces;
			} else {
				maxRight = c;
				break;
			}
		}
		for(int c = 1; c < MAX_FRAME; c++) {
			posY = stackY - (c*newY);
			posX = stackX - (c*newX);
			if (posX < XRES && posY < YRES && posX >= 0 && posY >= 0 && TYP(sim->pmap[posY][posX]) == PT_FRME) {
				int spaces = CanMoveStack(sim, posX, posY, realDirectionX, realDirectionY, maxSize, amount, retract, block).spaces;
				if(spaces < amount)
					amount = spaces;
			} else {
				maxLeft = c;
				break;
			}
		}

		//If the piston is pushing frame, iterate out from the centre to the edge and push everything resting on frame
		for(int c = 1; c < maxRight; c++) {
			posY = stackY + (c*newY);
			posX = stackX + (c*newX);
			MoveStack(sim, posX, posY, directionX, directionY, maxSize, amount, retract, block, !sim->parts[ID(sim->pmap[posY][posX])].tmp, 1);
		}
		for(int c = 1; c < maxLeft; c++) {
			posY = stackY - (c*newY);
			posX = stackX - (c*newX);
			MoveStack(sim, posX, posY, directionX, directionY, maxSize, amount, retract, block, !sim->parts[ID(sim->pmap[posY][posX])].tmp, 1);
		}

		//Remove arm section if retracting with FRME
		if (retract)
			for(int j = 1; j <= amount; j++)
				sim->kill_part(ID(sim->pmap[stackY+(directionY*-j)][stackX+(directionX*-j)]));
		return MoveStack(sim, stackX, stackY, directionX, directionY, maxSize, amount, retract, block, !sim->parts[ID(sim->pmap[stackY][stackX])].tmp, 1);
	}
	if(retract){
		bool foundParts = false;
		//Remove arm section if retracting without FRME
		if (!callDepth)
			for(int j = 1; j <= amount; j++)
				sim->kill_part(ID(sim->pmap[stackY+(directionY*-j)][stackX+(directionX*-j)]));
		int currentPos = 0;
		for(posX = stackX, posY = stackY; currentPos < maxSize && currentPos < XRES-1; posX += directionX, posY += directionY) {
			if (!(posX < XRES && posY < YRES && posX >= 0 && posY >= 0)) {
				break;
			}
			r = sim->pmap[posY][posX];
			if(!r || TYP(r) == block || (!sticky && TYP(r) != PT_FRME)) {
				break;
			} else {
				foundParts = true;
				tempParts[currentPos++] = ID(r);
			}
		}
		if(foundParts) {
			//Move particles
			for(int j = 0; j < currentPos; j++) {
				int jP = tempParts[j];
				int srcX = (int)(sim->parts[jP].x + 0.5f), srcY = (int)(sim->parts[jP].y + 0.5f);
				int destX = srcX-directionX*amount, destY = srcY-directionY*amount;
				sim->pmap[srcY][srcX] = 0;
				sim->parts[jP].x = float(destX);
				sim->parts[jP].y = float(destY);
				sim->pmap[destY][destX] = PMAP(jP, sim->parts[jP].type);
			}
			return amount;
		}
	} else {
		StackData stackData = CanMoveStack(sim, stackX, stackY, directionX, directionY, maxSize, amount, retract, block);
		int currentPos = stackData.pushed + stackData.spaces;
		if(currentPos){
			//Move particles
			int possibleMovement = 0;
			for(int j = currentPos-1; j >= 0; j--) {
				int jP = tempParts[j];
				if(jP < 0) {
					possibleMovement++;
					continue;
				}
				if(!possibleMovement)
					continue;
				int srcX = (int)(sim->parts[jP].x + 0.5f), srcY = (int)(sim->parts[jP].y + 0.5f);
				int destX = srcX+directionX*possibleMovement, destY = srcY+directionY*possibleMovement;
				sim->pmap[srcY][srcX] = 0;
				sim->parts[jP].x = float(destX);
				sim->parts[jP].y = float(destY);
				sim->pmap[destY][destX] = PMAP(jP, sim->parts[jP].type);
			}
			return possibleMovement;
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->life)
	{
		*colr -= 60;
		*colg -= 60;
	}
	return 0;
}

static bool ctypeDraw(CTYPEDRAW_FUNC_ARGS)
{
	if (t == PT_FRME)
	{
		return false;
	}
	return Element::basicCtypeDraw(CTYPEDRAW_FUNC_SUBCALL_ARGS);
}


=== src\simulation\elements\PSTS.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_PSTS()
{
	Identifier = "DEFAULT_PT_PSTS";
	Name = "PSTS";
	Colour = 0x776677_rgb;
	MenuVisible = 0;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 100;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	Description = "Solid form of PSTE.";

	Properties = TYPE_SOLID;

	LowPressure = 0.5f;
	LowPressureTransition = PT_PSTE;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}


=== src\simulation\elements\PTCT.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_PTCT()
{
	Identifier = "DEFAULT_PT_PTCT";
	Name = "PTCT";
	Colour = 0x405050_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "PTC Thermistor. Conducts with PSCN and NSCN, but only when cooled below 100C.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1687.0f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].temp>295.0f)
		parts[i].temp -= 2.5f;
	return 0;
}


=== src\simulation\elements\PTNM.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_PTNM()
{
	Identifier = "DEFAULT_PT_PTNM";
	Name = "PTNM";
	Colour = 0xD5E0EB_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 0;
	Weight = 100;

	HeatConduct = 251;
	Description = "Platinum. Catalyzes certain reactions.";

	Properties = TYPE_SOLID | PROP_CONDUCTS | PROP_LIFE_DEC | PROP_HOT_GLOW | PROP_SPARKSETTLE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1768.0f + 273.15f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static void wtrv_reactions(int wtrv1_id, UPDATE_FUNC_ARGS)
{
	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y + ry][x + rx];
				if (!r || ID(r) == wtrv1_id)
					continue;
				int rt = TYP(r);

				// WTRV + BCOL -> OIL
				if (rt == PT_BCOL && parts[ID(r)].temp > 200.0f + 273.15f && parts[wtrv1_id].temp > 200.0f + 273.15f && sim->pv[(y + ry) / CELL][(x + rx) / CELL] > 7.f)
				{
					sim->part_change_type(ID(r), x + rx, y + ry, PT_OIL);
					sim->kill_part(wtrv1_id);
					return;
				}
			}
		}
	}
}

static void hygn_reactions(int hygn1_id, UPDATE_FUNC_ARGS)
{
	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y + ry][x + rx];
				if (!r || ID(r) == hygn1_id)
					continue;
				int rt = TYP(r);

				// HYGN + DESL -> OIL + WATR
				if (rt == PT_DESL)
				{
					sim->part_change_type(ID(r), x + rx, y + ry, PT_WATR);
					sim->part_change_type(hygn1_id, (int)(parts[hygn1_id].x + 0.5f), (int)(parts[hygn1_id].y + 0.5f), PT_OIL);
					return;
				}

				// HYGN + OXYG -> DSTW + SPRK + Heat
				if (rt == PT_O2 && !parts[i].life)
				{
					sim->part_change_type(ID(r), x + rx, y + ry, PT_DSTW);
					sim->part_change_type(hygn1_id, (int)(parts[hygn1_id].x + 0.5f), (int)(parts[hygn1_id].y + 0.5f), PT_DSTW);
					parts[ID(r)].temp += 5.0f;
					parts[hygn1_id].temp += 5.0f;

					parts[i].ctype = PT_PTNM;
					parts[i].life = 4;
					sim->part_change_type(i, x, y, PT_SPRK);
					return;
				}

				// Cold fusion: 2 hydrogen > 500 C has a chance to fuse
				if (rt == PT_H2 && sim->rng.chance(1, 1000) && parts[ID(r)].temp > 500.0f + 273.15f && parts[hygn1_id].temp > 500.0f + 273.15f)
				{
					sim->part_change_type(ID(r), x + rx, y + ry, PT_NBLE);
					sim->part_change_type(hygn1_id, (int)(parts[hygn1_id].x + 0.5f), (int)(parts[hygn1_id].y + 0.5f), PT_NEUT);

					parts[ID(r)].temp += 1000.0f;
					parts[hygn1_id].temp += 1000.0f;
					sim->pv[(y + ry) / CELL][(x + rx) / CELL] += 10.0f;

					int j = sim->create_part(-3, x + rx, y + ry, PT_PHOT);
					if (j > -1)
					{
						parts[j].ctype = 0x7C0000;
						parts[j].temp = parts[ID(r)].temp;
						parts[j].tmp = 0x1;
					}
					if (sim->rng.chance(1, 10))
					{
						int j = sim->create_part(-3, x + rx, y + ry, PT_ELEC);
						if (j > -1)
							parts[j].temp = parts[ID(r)].temp;
					}
					return;
				}
			}
		}
	}
}

static int update(UPDATE_FUNC_ARGS)
{
	int hygn1_id = -1; // Id of a hydrogen particle for hydrogen multi-particle reactions
	int wtrv1_id = -1; // same but wtrv

	// Fast conduction (like GOLD)
	if (!parts[i].life)
	{
		for (int j = 0; j < 4; j++)
		{
			static const int checkCoordsX[] = { -4, 4, 0, 0 };
			static const int checkCoordsY[] = { 0, 0, -4, 4 };
			int rx = checkCoordsX[j];
			int ry = checkCoordsY[j];
			int r = pmap[y + ry][x + rx];
			if (r && TYP(r) == PT_SPRK && parts[ID(r)].life && parts[ID(r)].life < 4)
			{
				sim->part_change_type(i, x, y, PT_SPRK);
				parts[i].life = 4;
				parts[i].ctype = PT_PTNM;
			}
		}
	}

	// Single element reactions
	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y + ry][x + rx];
				if (!r)
					continue;
				int rt = TYP(r);

				if (rt == PT_H2 && hygn1_id < 0)
					hygn1_id = ID(r);

				if (rt == PT_WTRV && wtrv1_id < 0)
					wtrv1_id = ID(r);

				// These reactions will occur instantly in contact with PTNM
				// --------------------------------------------------------

				// Shield instantly grows (even without SPRK)
				if (!parts[ID(r)].life && (rt == PT_SHLD1 || rt == PT_SHLD2 || rt == PT_SHLD3))
				{
					int next = PT_SHLD1;
					switch (rt)
					{
					case PT_SHLD1: next = PT_SHLD2; break;
					case PT_SHLD2: next = PT_SHLD3; break;
					case PT_SHLD3: next = PT_SHLD4; break;
					}
					sim->part_change_type(ID(r), x + rx, y + ry, next);
					parts[ID(r)].life = 7;
					continue;
				}

				// ISZS / ISOZ -> PHOT + PLUT
				if (rt == PT_ISZS || rt == PT_ISOZ)
				{
					sim->part_change_type(ID(r), x + rx, y + ry, PT_PLUT);
					sim->create_part(-3, x + rx, y + ry, PT_PHOT);
					continue;
				}

				// These reactions are dependent on temperature
				// Probability goes quadratically from 0% / frame to 100% / frame from 0 C to 1500 C
				// --------------------------------------------------------
				float prob = std::min(1.0f, parts[i].temp / (273.15f + 1500.0f));
				prob *= prob;

				if (sim->rng.uniform01() <= prob)
				{
					switch (rt)
					{
					case PT_GAS: // GAS + > 2 pressure + >= 200 C -> INSL
						if (parts[ID(r)].temp >= 200.0f + 273.15f && sim->pv[(y + ry) / CELL][(x + rx) / CELL] > 2.0f)
						{
							sim->part_change_type(ID(r), x + rx, y + ry, PT_INSL);
							parts[i].temp += 60.0f; // Other part is INSL, adding temp is useless
						}
						break;

					case PT_BREC: // BREL + > 1000 C + > 50 pressure -> EXOT
						if (parts[ID(r)].temp > 1000.0f + 273.15f && sim->pv[(y + ry) / CELL][(x + rx) / CELL] > 50.0f)
						{
							sim->part_change_type(ID(r), x + rx, y + ry, PT_EXOT);
							parts[ID(r)].temp -= 30.0f;
							parts[i].temp -= 30.0f;
						}
						break;

					case PT_SMKE: // SMKE -> CO2
						sim->part_change_type(ID(r), x + rx, y + ry, PT_CO2);
						break;

					case PT_RSST: // RSST -> BIZR
						sim->create_part(ID(r), x + rx, y + ry, PT_BIZR);
						break;
					}
				}
			}
		}
	}

	// Hydrogen reactions
	if (hygn1_id >= 0)
	{
		hygn_reactions(hygn1_id, UPDATE_FUNC_SUBCALL_ARGS);
	}

	// WTRV reactions
	if (wtrv1_id >= 0)
	{
		wtrv_reactions(wtrv1_id, UPDATE_FUNC_SUBCALL_ARGS);
	}

	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if (cpart->tmp)
		*pixel_mode |= PMODE_FLARE;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	if (sim->rng.chance(1, 15))
		sim->parts[i].tmp = 1;
}


=== src\simulation\elements\PUMP.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_PUMP()
{
	Identifier = "DEFAULT_PT_PUMP";
	Name = "PUMP";
	Colour = 0x0A0A3B_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 10;

	Weight = 100;

	DefaultProperties.temp = 273.15f;
	HeatConduct = 0;
	Description = "Pressure pump. Changes pressure to its temp when activated. (use HEAT/COOL).";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.life = 10;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life != 10)
	{
		if (parts[i].life>0)
			parts[i].life--;
	}
	else
	{
		if (parts[i].temp >= MAX_PRESSURE+273.15f)
			parts[i].temp = MAX_PRESSURE+273.15f;
		if (parts[i].temp <= MIN_PRESSURE+273.15f)
			parts[i].temp = MIN_PRESSURE+273.15f;

		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (parts[i].tmp != 1)
				{
					if (!(rx && ry))
						sim->pv[(y/CELL)+ry][(x/CELL)+rx] += 0.1f*((parts[i].temp-273.15)-sim->pv[(y/CELL)+ry][(x/CELL)+rx]);
				}
				else
				{
					int r = pmap[y+ry][x+rx];
					if (TYP(r) == PT_FILT)
					{
						int newPressure = parts[ID(r)].ctype - 0x10000000;
						if (newPressure >= 0 && newPressure <= MAX_PRESSURE - MIN_PRESSURE)
						{
							sim->pv[(y + ry) / CELL][(x + rx) / CELL] = float(newPressure) + MIN_PRESSURE;
						}
					}
				}
			}
		}
		for (auto rx = -2; rx <= 2; rx++)
		{
			for (auto ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r) == PT_PUMP)
					{
						if (parts[ID(r)].life < 10 && parts[ID(r)].life > 0)
							parts[i].life = 9;
						else if (parts[ID(r)].life == 0)
							parts[ID(r)].life = 10;
					}
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int lifemod = ((cpart->life>10?10:cpart->life)*19);
	*colb += lifemod;
	return 0;
}


=== src\simulation\elements\PVOD.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_PVOD()
{
	Identifier = "DEFAULT_PT_PVOD";
	Name = "PVOD";
	Colour = 0x792020_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Powered VOID. When activated, destroys entering particles.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
	CtypeDraw = &Element::basicCtypeDraw;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life>0 && parts[i].life!=10)
		parts[i].life--;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_SPRK)
				{
					if (parts[ID(r)].life>0 && parts[ID(r)].life<4)
					{
						if (parts[ID(r)].ctype==PT_PSCN)
							parts[i].life = 10;
						else if (parts[ID(r)].ctype==PT_NSCN)
							parts[i].life = 9;
					}
				}
				else if (TYP(r)==PT_PVOD)
				{
					if (parts[i].life==10&&parts[ID(r)].life<10&&parts[ID(r)].life>0)
						parts[i].life = 9;
					else if (parts[i].life==0&&parts[ID(r)].life==10)
						parts[i].life = 10;
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int lifemod = ((cpart->life>10?10:cpart->life)*16);
	*colr += lifemod;
	return 0;
}


=== src\simulation\elements\QRTZ.cpp ===

#include "simulation/ElementCommon.h"
#include "QRTZ.h"

static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_QRTZ()
{
	Identifier = "DEFAULT_PT_QRTZ";
	Name = "QRTZ";
	Colour = 0xAADDDD_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 3;
	Description = "Quartz, breakable mineral. Conducts but becomes brittle when cold. Scatters photons.";

	Properties = TYPE_SOLID | PROP_PHOTPASS | PROP_HOT_GLOW | PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 2573.15f;
	HighTemperatureTransition = PT_LAVA;

	Update = &Element_QRTZ_update;
	Graphics = &Element_QRTZ_graphics;
	Create = &create;
}

int Element_QRTZ_update(UPDATE_FUNC_ARGS)
{
	int t = parts[i].type;
	if (t == PT_QRTZ)
	{
		auto press = int(sim->pv[y/CELL][x/CELL] * 64);
		auto diffTolerance = parts[i].temp * 1.0666f;
		if (press - parts[i].tmp3 > diffTolerance || press - parts[i].tmp3 < -diffTolerance)
		{
			sim->part_change_type(i,x,y,PT_PQRT);
			parts[i].life = 5; //timer before it can grow or diffuse again
		}
		parts[i].tmp3 = press;
	}
	if (parts[i].life>5)
		parts[i].life = 5;
	// absorb SLTW
	if (parts[i].tmp != -1)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					else if (TYP(r)==PT_SLTW && sim->rng.chance(1, 500))
					{
						sim->kill_part(ID(r));
						parts[i].tmp++;
					}
				}
			}
		}
	}
	// grow and diffuse
	if (parts[i].tmp > 0 && (parts[i].vx*parts[i].vx + parts[i].vy*parts[i].vy)<0.2f && parts[i].life<=0)
	{
		bool stopgrow = false;
		for (auto trade = 0; trade < 9; trade++)
		{
			auto rnd = sim->rng.gen() % 0x3FF;
			auto rx = (rnd%5)-2;
			auto srx = (rnd%3)-1;
			rnd >>= 3;
			auto ry = (rnd%5)-2;
			auto sry = (rnd%3)-1;
			if (rx || ry)
			{
				if (!stopgrow)//try to grow
				{
					if (!pmap[y+sry][x+srx] && parts[i].tmp!=0)
					{
						auto np = sim->create_part(-1,x+srx,y+sry,PT_QRTZ);
						if (np>-1)
						{
							parts[np].temp = parts[i].temp;
							parts[np].tmp2 = parts[i].tmp2;
							if (sim->rng.chance(1, 2))
							{
								parts[np].tmp2 = std::clamp(parts[np].tmp2 + sim->rng.between(-1, 1), 0, 10);
							}
							parts[i].tmp--;
							if (t == PT_PQRT)
							{
								// If PQRT is stationary and has started growing particles of QRTZ, the PQRT is basically part of a new QRTZ crystal. So turn it back into QRTZ so that it behaves more like part of the crystal.
								sim->part_change_type(i,x,y,PT_QRTZ);
							}
							if (sim->rng.chance(1, 2))
							{
								parts[np].tmp=-1;//dead qrtz
							}
							else if (!parts[i].tmp && sim->rng.chance(1, 15))
							{
								parts[i].tmp=-1;
							}
							stopgrow=true;
						}
					}
				}
				//diffusion
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				else if (TYP(r)==PT_QRTZ && (parts[i].tmp>parts[ID(r)].tmp) && parts[ID(r)].tmp>=0)
				{
					auto tmp = parts[i].tmp - parts[ID(r)].tmp;
					if (tmp ==1)
					{
						parts[ID(r)].tmp++;
						parts[i].tmp--;
						break;
					}
					if (tmp>0)
					{
						parts[ID(r)].tmp += tmp/2;
						parts[i].tmp -= tmp/2;
						break;
					}
				}
			}
		}
	}
	return 0;
}

int Element_QRTZ_graphics(GRAPHICS_FUNC_ARGS)
 //QRTZ and PQRT
{
	int z = (cpart->tmp2 - 5) * 16;//speckles!
	*colr += z;
	*colg += z;
	*colb += z;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].tmp2 = sim->rng.between(0, 10);
	sim->parts[i].tmp3 = int(sim->pv[y/CELL][x/CELL] * 64);
}


=== src\simulation\elements\QRTZ.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_QRTZ_graphics(GRAPHICS_FUNC_ARGS);
int Element_QRTZ_update(UPDATE_FUNC_ARGS);


=== src\simulation\elements\RBDM.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_RBDM()
{
	Identifier = "DEFAULT_PT_RBDM";
	Name = "RBDM";
	Colour = 0xCCCCCC_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 1000;
	Explosive = 1;
	Meltable = 50;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 240;
	Description = "Rubidium. Explosive, especially on contact with water. Low melting point.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 312.0f;
	HighTemperatureTransition = PT_LRBD;
}


=== src\simulation\elements\RFGL.cpp ===

#include "simulation/ElementCommon.h"
#include "RFRG.h"

void Element::Element_RFGL()
{
	Identifier = "DEFAULT_PT_RFGL";
	Name = "RFGL";
	Colour = 0x84C2CF_rgb;
	MenuVisible = 0;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 10;

	HeatConduct = 3;
	Description = "Liquid refrigerant.";

	Properties = TYPE_LIQUID|PROP_DEADLY;

	LowPressure = 2;
	LowPressureTransition = PT_RFRG;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &Element_RFRG_update;
}


=== src\simulation\elements\RFRG.cpp ===

#include "simulation/ElementCommon.h"
#include "RFRG.h"

void Element::Element_RFRG()
{
	Identifier = "DEFAULT_PT_RFRG";
	Name = "RFRG";
	Colour = 0x72D2D4_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 1.2f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 1.3f;
	HotAir = 0.0001f * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 1;

	HeatConduct = 3;
	Description = "Refrigerant. Heats up and liquefies under pressure.";

	Properties = TYPE_GAS|PROP_DEADLY;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 2;
	HighPressureTransition = PT_RFGL;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &Element_RFRG_update;
}

int Element_RFRG_update(UPDATE_FUNC_ARGS)
{
	float new_pressure = sim->pv[y/CELL][x/CELL];
	float *old_pressure = (float *)&parts[i].tmp;
	if (std::isnan(*old_pressure))
	{
		*old_pressure = new_pressure;
		return 0;
	}

	// * 0 bar seems to be pressure value -256 in TPT, see Air.cpp. Also, 1 bar seems to be pressure value 0.
	//   With those two values we can set up our pressure scale which states that ... the highest pressure
	//   we can achieve in TPT is 2 bar. That's not particularly realistic, but good enough for TPT.

	parts[i].temp = restrict_flt(parts[i].temp * ((new_pressure + 257.f) / (*old_pressure + 257.f)), 0, MAX_TEMP);
	*old_pressure = new_pressure;
	return 0;
}


=== src\simulation\elements\RFRG.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_RFRG_update(UPDATE_FUNC_ARGS);


=== src\simulation\elements\RIME.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_RIME()
{
	Identifier = "DEFAULT_PT_RIME";
	Name = "RIME";
	Colour = 0xCCCCCC_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.00f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.00f;
	Loss = 0.00f;
	Collision = 0.00f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f  * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 100;

	DefaultProperties.temp = -30.0f + 273.15f;
	HeatConduct = 100;
	Description = "Solid, created when steam cools rapidly and goes through deposition, skipping the liquid phase.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 273.15f;
	HighTemperatureTransition = ST;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_SPRK)
				{
					sim->part_change_type(i,x,y,PT_FOG);
					parts[i].life = sim->rng.between(60, 119);
				}
				else if (TYP(r) == PT_GAS && parts[i].tmp < 10)
				{
					sim->kill_part(ID(r));
					parts[i].tmp++;
				}
				else if (TYP(r)==PT_FOG&&parts[ID(r)].life>0)
				{
					sim->part_change_type(i,x,y,PT_FOG);
					parts[i].life = parts[ID(r)].life;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\ROCK.cpp ===

#include "simulation/ElementCommon.h"

static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_ROCK()
{
	Identifier = "DEFAULT_PT_ROCK";
	Name = "ROCK";
	Colour = 0x727272_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 5;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 200;
	Description = "Solid, melts into various elements.";

	Properties = TYPE_SOLID | PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 120;
	HighPressureTransition = PT_STNE;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1943.15f;
	HighTemperatureTransition = PT_LAVA;

	Graphics = &graphics;
	Create = &create;
}


static int graphics(GRAPHICS_FUNC_ARGS)
{
	int z = (cpart->tmp2 - 7) * 6; // Randomized color noise based on tmp2
	*colr += z;
	*colg += z;
	*colb += z;

	if (cpart->temp >= 810.15) // Glows when hot, right before melting becomes bright
	{
		*pixel_mode |= FIRE_ADD;

		*firea = int(((cpart->temp)-810.15)/45);
		*firer = *colr;
		*fireg = *colg;
		*fireb = *colb;
	}
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].tmp2 = sim->rng.between(0, 10);
}


=== src\simulation\elements\RPEL.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_RPEL()
{
	Identifier = "DEFAULT_PT_RPEL";
	Name = "RPEL";
	Colour = 0x99CC00_rgb;
	MenuVisible = 1;
	MenuSection = SC_FORCE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f  * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = 20.0f + 273.15f;
	HeatConduct = 0;
	Description = "Repels or attracts particles based on its temperature.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	CtypeDraw = &Element::basicCtypeDraw;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int r, rx, ry, ri;
	for(ri = 0; ri <= 10; ri++)
	{
		rx = sim->rng.between(-10, 10);
		ry = sim->rng.between(-10, 10);
		if (x+rx >= 0 && x+rx < XRES && y+ry >= 0 && y+ry < YRES && (rx || ry))
		{
			r = pmap[y+ry][x+rx];
			if (!r)
				r = sim->photons[y+ry][x+rx];

			if (r && !(elements[TYP(r)].Properties & TYPE_SOLID)) {
				if (!parts[i].ctype || parts[i].ctype == parts[ID(r)].type) {
					parts[ID(r)].vx += isign(rx)*((parts[i].temp-273.15)/10.0f);
					parts[ID(r)].vy += isign(ry)*((parts[i].temp-273.15)/10.0f);
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\RSSS.cpp ===

#include "simulation/ElementCommon.h"
#include "simulation/Air.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_RSSS()
{
	Identifier = "DEFAULT_PT_RSSS";
	Name = "RSSS";
	Colour = 0xC43626_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 130;
	Description = "Solidified resist. Blocks pressure and insulates electricity. Liquefies on contact with neutrons.";

	Properties = TYPE_SOLID|PROP_NEUTPASS;
	CarriesTypeIn = (1U << FIELD_CTYPE) | (1U << FIELD_TMP);

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for(int rx = -1; rx < 2; rx++)
	{
		for(int ry = -1; ry < 2; ry++)
		{
			auto r = pmap[y+ry][x+rx];

			if (!r)
				continue;

			// Set RSSS ctype from nearby clone
			if((TYP(r) == PT_CLNE) || (TYP(r) == PT_PCLN))
			{
				if(parts[ID(r)].ctype != PT_RSSS)
					parts[i].ctype = parts[ID(r)].ctype;
			}

			// Set RSSS tmp from nearby breakable clone
			if((TYP(r) == PT_BCLN) || (TYP(r) == PT_PBCN))
			{
				if(parts[ID(r)].ctype != PT_RSSS)
					parts[i].tmp = parts[ID(r)].ctype;
			}
		}
	}

	//Block air like TTAN
	sim->air->bmap_blockair[y/CELL][x/CELL] = 1;
	sim->air->bmap_blockairh[y/CELL][x/CELL] = 0x8;

	return 0;
}


=== src\simulation\elements\RSST.cpp ===

#include "simulation/ElementCommon.h"

int update(UPDATE_FUNC_ARGS);

void Element::Element_RSST()
{
	Identifier = "DEFAULT_PT_RSST";
	Name = "RSST";
	Colour = 0xF95B49_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.3f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.15f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 50;

	Weight = 33;

	DefaultProperties.temp = R_TEMP + 20.0f + 273.15f;
	HeatConduct = 55;
	Description = "Resist. Solidifies on contact with photons, is destroyed by electrons and spark.";

	Properties = TYPE_LIQUID | PROP_CONDUCTS | PROP_LIFE_DEC | PROP_NEUTPASS | PROP_PHOTPASS;
	CarriesTypeIn = (1U << FIELD_CTYPE) | (1U << FIELD_TMP);

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

int update(UPDATE_FUNC_ARGS)
{
	for(int rx = -1; rx < 2; rx++)
	{
		for(int ry = -1; ry < 2; ry++)
		{
			auto r = pmap[y+ry][x+rx];

			if (!r)
				continue;

			// RSST + GUNP = FIRW
			if(TYP(r) == PT_GUNP)
			{
				sim->create_part(i, x, y, PT_FIRW);
				sim->kill_part(ID(r));
				return 1;
			}

			// RSST + BCOL = FSEP
			if(TYP(r) == PT_BCOL)
			{
				sim->create_part(i, x, y, PT_FSEP);
				parts[i].life = 50;
				sim->kill_part(ID(r));
				return 1;
			}

			// Set RSST ctype from nearby clone
			if((TYP(r) == PT_CLNE) || (TYP(r) == PT_PCLN))
			{
				if(parts[ID(r)].ctype != PT_RSST)
					parts[i].ctype = parts[ID(r)].ctype;
			}

			// Set RSST tmp from nearby breakable clone
			if((TYP(r) == PT_BCLN) || (TYP(r) == PT_PBCN))
			{
				if(parts[ID(r)].ctype != PT_RSST)
					parts[i].tmp = parts[ID(r)].ctype;
			}
		}
	}

	return 0;
}


=== src\simulation\elements\SALT.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_SALT()
{
	Identifier = "DEFAULT_PT_SALT";
	Name = "SALT";
	Colour = 0xFFFFFF_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 5;
	Hardness = 1;

	Weight = 75;

	HeatConduct = 110;
	Description = "Salt, dissolves in water.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1173.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\SAND.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_SAND()
{
	Identifier = "DEFAULT_PT_SAND";
	Name = "SAND";
	Colour = 0xFFD090_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 5;
	Hardness = 1;

	Weight = 90;

	HeatConduct = 150;
	Description = "Sand, Heavy particles. Melts into glass.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1973.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\SAWD.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_SAWD()
{
	Identifier = "DEFAULT_PT_SAWD";
	Name = "SAWD";
	Colour = 0xF0F0A0_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 10;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 18;

	HeatConduct = 70;
	Description = "Sawdust. Floats on water.";

	Properties = TYPE_PART | PROP_NEUTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Graphics = nullptr; // is this needed?
}


=== src\simulation\elements\SHLD1.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_SHLD1()
{
	Identifier = "DEFAULT_PT_SHLD1";
	Name = "SHLD";
	Colour = 0xAAAAAA_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Shield. Grows around spark, broken by pressure.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 7.0f;
	HighPressureTransition = PT_NONE;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				else if (TYP(r)==PT_SPRK&&parts[i].life==0)
				{
					if (sim->rng.chance(11, 40))
					{
						sim->part_change_type(i,x,y,PT_SHLD2);
						parts[i].life = 7;
					}
					for (auto nnx = -1; nnx <= 1; nnx++)
					{
						for (auto nny = -1; nny <= 1; nny++)
						{
							if (!pmap[y+ry+nny][x+rx+nnx])
							{
								sim->create_part(-1,x+rx+nnx,y+ry+nny,PT_SHLD1);
								//parts[ID(pmap[y+ny+nny][x+nx+nnx])].life=7;
							}
						}
					}
				}
				else if (TYP(r) == PT_SHLD3 && sim->rng.chance(2, 5))
				{
					sim->part_change_type(i,x,y,PT_SHLD2);
					parts[i].life = 7;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\SHLD2.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_SHLD2()
{
	Identifier = "DEFAULT_PT_SHLD2";
	Name = "SHD2";
	Colour = 0x777777_rgb;
	MenuVisible = 0;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Shield lvl 2.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 15.0f;
	HighPressureTransition = PT_NONE;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
				{
					if (parts[i].life>0)
						sim->create_part(-1,x+rx,y+ry,PT_SHLD1);
					continue;
				}
				else if (TYP(r)==PT_SPRK&&parts[i].life==0)
				{
					if (sim->rng.chance(1, 8))
					{
						sim->part_change_type(i,x,y,PT_SHLD3);
						parts[i].life = 7;
					}
					for (auto nnx = -1; nnx <= 1; nnx++)
					{
						for (auto nny = -1; nny <= 1; nny++)
						{
							if (!pmap[y+ry+nny][x+rx+nnx])
							{
								auto np = sim->create_part(-1,x+rx+nnx,y+ry+nny,PT_SHLD1);
								if (np<0) continue;
								parts[np].life=7;
							}
						}
					}
				}
				else if (TYP(r) == PT_SHLD4 && sim->rng.chance(2, 5))
				{
					sim->part_change_type(i,x,y,PT_SHLD3);
					parts[i].life = 7;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\SHLD3.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_SHLD3()
{
	Identifier = "DEFAULT_PT_SHLD3";
	Name = "SHD3";
	Colour = 0x444444_rgb;
	MenuVisible = 0;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Shield lvl 3.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 25.0f;
	HighPressureTransition = PT_NONE;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
				{
					if (sim->rng.chance(1, 2500))
					{
						auto np = sim->create_part(-1,x+rx,y+ry,PT_SHLD1);
						if (np<0) continue;
						parts[np].life=7;
						sim->part_change_type(i,x,y,PT_SHLD2);
					}
					continue;
				}
				if (TYP(r)==PT_SHLD1 && parts[i].life>3)
				{
					sim->part_change_type(ID(r),x+rx,y+ry,PT_SHLD2);
					parts[ID(r)].life=7;
				}
				else if (TYP(r)==PT_SPRK&&parts[i].life==0)
				{
					if (sim->rng.chance(3, 500))
					{
						sim->part_change_type(i,x,y,PT_SHLD4);
						parts[i].life = 7;
					}
					for (auto nnx = -1; nnx <= 1; nnx++)
					{
						for (auto nny = -1; nny <= 1; nny++)
						{

							if (!pmap[y+ry+nny][x+rx+nnx])
							{
								auto np = sim->create_part(-1,x+rx+nnx,y+ry+nny,PT_SHLD1);
								if (np<0) continue;
								parts[np].life=7;
							}
						}
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\SHLD4.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_SHLD4()
{
	Identifier = "DEFAULT_PT_SHLD4";
	Name = "SHD4";
	Colour = 0x212121_rgb;
	MenuVisible = 0;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Shield lvl 4.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 40.0f;
	HighPressureTransition = PT_NONE;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
				{
					if (sim->rng.chance(1, 5500))
					{
						auto np = sim->create_part(-1,x+rx,y+ry,PT_SHLD1);
						if (np<0) continue;
						parts[np].life=7;
						sim->part_change_type(i,x,y,PT_SHLD2);
					}
					continue;

				}
				if (TYP(r)==PT_SHLD2 && parts[i].life>3)
				{
					sim->part_change_type(ID(r),x+rx,y+ry,PT_SHLD3);
					parts[ID(r)].life = 7;
				}
				else if (TYP(r)==PT_SPRK&&parts[i].life==0)
				{
					for (auto nnx = -1; nnx <= 1; nnx++)
					{
						for (auto nny = -1; nny <= 1; nny++)
						{
							if (!pmap[y+ry+nny][x+rx+nnx])
							{
								auto np = sim->create_part(-1,x+rx+nnx,y+ry+nny,PT_SHLD1);
								if (np<0) continue;
								parts[np].life=7;
							}
						}
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\SING.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_SING()
{
	Identifier = "DEFAULT_PT_SING";
	Name = "SING";
	Colour = 0x242424_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.36f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.1f;
	Gravity = 0.12f;
	Diffusion = 0.00f;
	HotAir = -0.001f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 86;

	HeatConduct = 70;
	Description = "Singularity. Creates huge amounts of negative pressure and destroys everything.";

	Properties = TYPE_PART|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	int singularity = -parts[i].life;

	if (sim->pv[y/CELL][x/CELL]<singularity)
		sim->pv[y/CELL][x/CELL] += 0.1f*(singularity-sim->pv[y/CELL][x/CELL]);
	if (sim->pv[y/CELL+1][x/CELL]<singularity)
		sim->pv[y/CELL+1][x/CELL] += 0.1f*(singularity-sim->pv[y/CELL+1][x/CELL]);
	if (sim->pv[y/CELL-1][x/CELL]<singularity)
		sim->pv[y/CELL-1][x/CELL] += 0.1f*(singularity-sim->pv[y/CELL-1][x/CELL]);

	sim->pv[y/CELL][x/CELL+1] += 0.1f*(singularity-sim->pv[y/CELL][x/CELL+1]);
	sim->pv[y/CELL+1][x/CELL+1] += 0.1f*(singularity-sim->pv[y/CELL+1][x/CELL+1]);
	sim->pv[y/CELL][x/CELL-1] += 0.1f*(singularity-sim->pv[y/CELL][x/CELL-1]);
	sim->pv[y/CELL-1][x/CELL-1] += 0.1f*(singularity-sim->pv[y/CELL-1][x/CELL-1]);

	if (parts[i].life<1) {
		//Pop!
		for (auto rx = -1; rx <= 1; rx++)
		{
			auto crx = (x/CELL)+rx;
			for (auto ry = -1; ry <= 1; ry++)
			{
				auto cry = (y/CELL)+ry;
				if (cry >= 0 && crx >= 0 && crx < XCELLS && cry < YCELLS) {
					sim->pv[cry][crx] += (float)parts[i].tmp;
				}
			}
		}
		auto spawncount = std::abs(parts[i].tmp);
		spawncount = (spawncount>255) ? 3019 : int(std::pow((double)(spawncount/8), 2)*TPT_PI_FLT);
		for (int j = 0;j < spawncount; j++)
		{
			auto nb = -1;
			switch (sim->rng.gen() % 3)
			{
				case 0:
					nb = sim->create_part(-3, x, y, PT_PHOT);
					break;
				case 1:
					nb = sim->create_part(-3, x, y, PT_NEUT);
					break;
				case 2:
					nb = sim->create_part(-3, x, y, PT_ELEC);
					break;
			}
			if (nb!=-1) {
				parts[nb].life = sim->rng.between(0, 299);
				parts[nb].temp = MAX_TEMP/2;
				auto angle = sim->rng.uniform01()*2.0f*TPT_PI_FLT;
				auto v = sim->rng.uniform01()*5.0f;
				parts[nb].vx = v*cosf(angle);
				parts[nb].vy = v*sinf(angle);
			}
			else if (sim->MaxPartsReached())
				break;//if we've run out of particles, stop trying to create them - saves a lot of lag on "sing bomb" saves
		}
		sim->kill_part(i);
		return 1;
	}
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)!=PT_DMND&& sim->rng.chance(1, 3))
				{
					if (TYP(r)==PT_SING && parts[ID(r)].life >10)
					{
						if (parts[i].life+parts[ID(r)].life > 255)
							continue;
						parts[i].life += parts[ID(r)].life;
					}
					else
					{
						if (parts[i].life+3 > 255)
						{
							if (parts[ID(r)].type!=PT_SING && sim->rng.chance(1, 1000))
							{
								int np;
								np = sim->create_part(ID(r),x+rx,y+ry,PT_SING);
								parts[np].life = sim->rng.between(60, 109);
							}
							continue;
						}
						parts[i].life += 3;
						parts[i].tmp++;
					}
					parts[i].temp = restrict_flt(parts[ID(r)].temp+parts[i].temp, MIN_TEMP, MAX_TEMP);
					sim->kill_part(ID(r));
				}
			}
		}
	}
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].life = sim->rng.between(60, 109);
}


=== src\simulation\elements\SLCN.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_SLCN()
{
	Identifier = "DEFAULT_PT_SLCN";
	Name = "SLCN";
	Colour = 0xBCCDDF_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.27f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 90;

	HeatConduct = 100;
	Description = "Powdered Silicon. A key ingredient in producing multiple materials.";

	Properties = TYPE_PART | PROP_CONDUCTS | PROP_HOT_GLOW | PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 3538.15f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static const RGB SLCN_COLOUR[16] = {
	0x5A6679_rgb, 0x6878A1_rgb, 0xABBFDD_rgb, 0x838490_rgb,
	0xBCCDDF_rgb, 0x82A0D2_rgb, 0x5B6680_rgb, 0x232C3B_rgb,
	0x485067_rgb, 0x8B9AB6_rgb, 0xADB1C1_rgb, 0xC3C6D1_rgb,
	0x8594AD_rgb, 0x262F47_rgb, 0xA9AEBC_rgb, 0xC2E1F7_rgb,
};

static void initSparkles(Simulation *sim, Particle &part)
{
	// bits 31-20: phase increment (randomised to a value between 1 and 9)
	// bits 19-16: next colour index
	// bits 15-12: current colour index
	// bits 11-00: phase
	part.tmp = sim->rng.between(0x100000, 0x9FFFFF);
}

static int update(UPDATE_FUNC_ARGS)
{
	if (!parts[i].tmp)
	{
		initSparkles(sim, parts[i]);
	}
	int phase = (parts[i].tmp & 0xFFF) + ((parts[i].tmp >> 20) & 0xFFF);
	if (phase & 0x1000)
	{
		// discard current, current <- next, next <- random, wrap phase
		parts[i].tmp = (parts[i].tmp & 0xFFF00000) | (phase & 0xFFF) | (sim->rng.between(0, 15) << 16) | ((parts[i].tmp >> 4) & 0xF000);
	}
	else
	{
		// update phase
		parts[i].tmp = (parts[i].tmp & 0xFFFFF000) | phase;
	}

	if (parts[i].life == 0 && parts[i].temp < 373.15f)
	{
		for (int j = 0; j < 4; j++)
		{
			static const int check_coords_x[] = { -4, 4, 0, 0 };
			static const int check_coords_y[] = { 0, 0, -4, 4 };
			int n = pmap[y + check_coords_y[j]][x + check_coords_x[j]];
			if (n && TYP(n) == PT_SPRK)
			{
				Particle &neighbour = parts[ID(n)];
				if (neighbour.life != 0 && neighbour.life < 4)
				{
					sim->part_change_type(i, x, y, PT_SPRK);
					parts[i].life = 4;
					parts[i].ctype = PT_SLCN;
				}
			}
		}
	}

	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	RGB curr_colour = SLCN_COLOUR[(cpart->tmp >> 12) & 15];
	if (cpart->tmp & 0x800) // mix with next colour if phase is at least halfway there
	{
		RGB next_colour = SLCN_COLOUR[(cpart->tmp >> 16) & 15];
		curr_colour = RGB(
			(curr_colour.Red   + next_colour.Red) / 2,
			(curr_colour.Green + next_colour.Green) / 2,
			(curr_colour.Blue  + next_colour.Blue) / 2
		);
	}
	*colr = curr_colour.Red;
	*colg = curr_colour.Green;
	*colb = curr_colour.Blue;

	int rnd = (cpart->tmp & 0xFFFF) * ((cpart->tmp >> 16) & 0xFFFF);
	if (!(rnd % 887))
	{
		*pixel_mode |= PMODE_FLARE | PMODE_GLOW;
	}
	if (!(rnd % 593))
	{
		*pixel_mode |= PMODE_SPARK;
	}

	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	initSparkles(sim, sim->parts[i]);
}


=== src\simulation\elements\SLTW.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_SLTW()
{
	Identifier = "DEFAULT_PT_SLTW";
	Name = "SLTW";
	Colour = 0x4050F0_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 35;

	HeatConduct = 75;
	LatentHeat = 7500;
	Description = "Saltwater, conducts electricity, difficult to freeze.";

	Properties = TYPE_LIQUID | PROP_CONDUCTS | PROP_LIFE_DEC | PROP_NEUTPENETRATE | PROP_PHOTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 252.05f;
	LowTemperatureTransition = PT_ICEI;
	HighTemperature = 383.0f;
	HighTemperatureTransition = ST;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				switch (TYP(r))
				{
				case PT_SALT:
					if (sim->rng.chance(1, 2000))
						sim->part_change_type(ID(r),x+rx,y+ry,PT_SLTW);
					break;
				case PT_PLNT:
					if (sim->rng.chance(1, 40))
						sim->kill_part(ID(r));
					break;
				case PT_RBDM:
				case PT_LRBD:
					if ((sim->legacy_enable||parts[i].temp>(273.15f+12.0f)) && sim->rng.chance(1, 100))
					{
						sim->part_change_type(i,x,y,PT_FIRE);
						parts[i].life = 4;
						parts[i].ctype = PT_WATR;
					}
					break;
				case PT_FIRE:
					if (parts[ID(r)].ctype!=PT_WATR)
					{
						sim->kill_part(ID(r));
						if (sim->rng.chance(1, 30))
						{
							sim->kill_part(i);
							return 1;
						}
					}
					break;
				case PT_NONE:
					break;
				default:
					continue;
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\SMKE.cpp ===

#include "simulation/ElementCommon.h"

static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_SMKE()
{
	Identifier = "DEFAULT_PT_SMKE";
	Name = "SMKE";
	Colour = 0x222222_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 0.9f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.97f;
	Loss = 0.20f;
	Collision = 0.0f;
	Gravity = -0.1f;
	Diffusion = 0.00f;
	HotAir = 0.001f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 1;

	DefaultProperties.temp = R_TEMP + 320.0f + 273.15f;
	HeatConduct = 88;
	Description = "Smoke, created by fire.";

	Properties = TYPE_GAS|PROP_LIFE_DEC|PROP_LIFE_KILL_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 625.0f;
	HighTemperatureTransition = PT_FIRE;

	Graphics = &graphics;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*colr = 55;
	*colg = 55;
	*colb = 55;

	*firea = 75;
	*firer = 55;
	*fireg = 55;
	*fireb = 55;

	*pixel_mode = PMODE_NONE; //Clear default, don't draw pixel
	*pixel_mode |= FIRE_BLEND;
	//Returning 1 means static, cache as we please
	return 1;
}


=== src\simulation\elements\SNOW.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_SNOW()
{
	Identifier = "DEFAULT_PT_SNOW";
	Name = "SNOW";
	Colour = 0xC0E0FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.90f;
	Collision = -0.1f;
	Gravity = 0.05f;
	Diffusion = 0.01f;
	HotAir = -0.00005f* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;
	PhotonReflectWavelengths = 0x03FFFFFF;

	Weight = 50;

	DefaultProperties.temp = R_TEMP - 30.0f + 273.15f;
	HeatConduct = 46;
	LatentHeat = 1095;
	Description = "Light particles. Created when ICE breaks under pressure.";

	Properties = TYPE_PART|PROP_NEUTPASS;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 252.05f;
	HighTemperatureTransition = ST;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].ctype==PT_FRZW)//get colder if it is from FRZW
	{
		parts[i].temp = restrict_flt(parts[i].temp-1.0f, MIN_TEMP, MAX_TEMP);
	}
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if ((TYP(r)==PT_SALT || TYP(r)==PT_SLTW) && sim->rng.chance(1, 333))
				{
					sim->part_change_type(i,x,y,PT_SLTW);
					sim->part_change_type(ID(r),x+rx,y+ry,PT_SLTW);
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\SOAP.cpp ===

#include "simulation/ElementCommon.h"
#include "SOAP.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS);

void Element::Element_SOAP()
{
	Identifier = "DEFAULT_PT_SOAP";
	Name = "SOAP";
	Colour = 0xF5F5DC_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 35;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	Description = "Soap. Creates bubbles, washes off deco color, and cures virus.";

	Properties = TYPE_LIQUID|PROP_NEUTPENETRATE|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.tmp = -1;
	DefaultProperties.tmp2 = -1;

	Update = &update;
	Graphics = &graphics;
	ChangeType = &changeType;
}

static bool validIndex(int i)
{
	return i >= 0 && i < NPART;
}

void Element_SOAP_detach(Simulation * sim, int i)
{
	if ((sim->parts[i].ctype&2) == 2 && validIndex(sim->parts[i].tmp) && sim->parts[sim->parts[i].tmp].type == PT_SOAP)
	{
		if ((sim->parts[sim->parts[i].tmp].ctype&4) == 4)
			sim->parts[sim->parts[i].tmp].ctype ^= 4;
	}

	if ((sim->parts[i].ctype&4) == 4 && validIndex(sim->parts[i].tmp2) && sim->parts[sim->parts[i].tmp2].type == PT_SOAP)
	{
		if ((sim->parts[sim->parts[i].tmp2].ctype&2) == 2)
			sim->parts[sim->parts[i].tmp2].ctype ^= 2;
	}

	sim->parts[i].ctype = 0;
}

static void attach(Particle * parts, int i1, int i2)
{
	if (!(parts[i2].ctype&4))
	{
		parts[i1].ctype |= 2;
		parts[i1].tmp = i2;

		parts[i2].ctype |= 4;
		parts[i2].tmp2 = i1;
	}
	else if (!(parts[i2].ctype&2))
	{
		parts[i1].ctype |= 4;
		parts[i1].tmp2= i2;

		parts[i2].ctype |= 2;
		parts[i2].tmp = i1;
	}
}

constexpr float FREEZING = 248.15f;
constexpr float BLEND = 0.85f;

static int update(UPDATE_FUNC_ARGS)
{
	//0x01 - bubble on/off
	//0x02 - first mate yes/no
	//0x04 - "back" mate yes/no

	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (parts[i].ctype&1)
	{
		// reset invalid SOAP links
		if (!validIndex(parts[i].tmp) || !validIndex(parts[i].tmp2))
		{
			parts[i].tmp = parts[i].tmp2 = parts[i].ctype = 0;
			return 0;
		}
		if (parts[i].temp>FREEZING)
		{
			if (parts[i].life<=0)
			{
				//if only connected on one side
				if ((parts[i].ctype&6) != 6 && (parts[i].ctype&6))
				{
					int target = i;
					//break entire bubble in a loop
					while((parts[target].ctype&6) != 6 && (parts[target].ctype&6) && parts[target].type == PT_SOAP)
					{
						if (parts[target].ctype&2)
						{
							target = parts[target].tmp;
							if (!validIndex(target))
							{
								break;
							}
							Element_SOAP_detach(sim, target);
						}
						if (parts[target].ctype&4)
						{
							target = parts[target].tmp2;
							if (!validIndex(target))
							{
								break;
							}
							Element_SOAP_detach(sim, target);
						}
					}
				}
				if ((parts[i].ctype&6) != 6)
					parts[i].ctype = 0;
				if (validIndex(parts[i].tmp) && (parts[i].ctype&6) == 6 && (parts[parts[i].tmp].ctype&6) == 6 && parts[parts[i].tmp].tmp == i)
					Element_SOAP_detach(sim, i);
			}
			parts[i].vy = (parts[i].vy-0.1f)*0.5f;
			parts[i].vx *= 0.5f;
		}
		if(!(parts[i].ctype&2))
		{
			for (auto rx = -2; rx <= 2; rx++)
			{
				for (auto ry = -2; ry <= 2; ry++)
				{
					if (rx || ry)
					{
						auto r = pmap[y+ry][x+rx];
						if (!r)
							continue;
						if ((parts[ID(r)].type == PT_SOAP) && (parts[ID(r)].ctype&1) && !(parts[ID(r)].ctype&4))
							attach(parts, i, ID(r));
					}
				}
			}
		}
		else
		{
			if (parts[i].life<=0)
			{
				for (auto rx = -2; rx <= 2; rx++)
				{
					for (auto ry = -2; ry <= 2; ry++)
					{
						if (rx || ry)
						{
							auto r = pmap[y+ry][x+rx];
							if (!r && !sim->bmap[(y+ry)/CELL][(x+rx)/CELL])
								continue;
							if (parts[i].temp>FREEZING)
							{
								if (sim->bmap[(y+ry)/CELL][(x+rx)/CELL]
									|| (r && !(elements[TYP(r)].Properties&TYPE_GAS)
								    && TYP(r) != PT_SOAP && TYP(r) != PT_GLAS))
								{
									Element_SOAP_detach(sim, i);
									continue;
								}
							}
							if (TYP(r) == PT_SOAP)
							{
								if (parts[ID(r)].ctype == 1)
								{
									int buf = parts[i].tmp;

									parts[i].tmp = ID(r);
									if (validIndex(buf) && parts[buf].type == PT_SOAP)
										parts[buf].tmp2 = ID(r);
									parts[ID(r)].tmp2 = i;
									parts[ID(r)].tmp = buf;
									parts[ID(r)].ctype = 7;
								}
								else if (parts[ID(r)].ctype == 7 && parts[i].tmp != ID(r) && parts[i].tmp2 != ID(r))
								{
									if (validIndex(parts[i].tmp) && parts[parts[i].tmp].type == PT_SOAP)
										parts[parts[i].tmp].tmp2 = parts[ID(r)].tmp2;
									if (validIndex(parts[ID(r)].tmp2) && parts[parts[ID(r)].tmp2].type == PT_SOAP)
										parts[parts[ID(r)].tmp2].tmp = parts[i].tmp;
									parts[ID(r)].tmp2 = i;
									parts[i].tmp = ID(r);
								}
							}
						}
					}
				}
			}
		}
		if(parts[i].ctype&2 && validIndex(parts[i].tmp))
		{
			float d, dx, dy;
			dx = parts[i].x - parts[parts[i].tmp].x;
			dy = parts[i].y - parts[parts[i].tmp].y;
			d = 9/(pow(dx, 2)+pow(dy, 2)+9)-0.5;
			parts[parts[i].tmp].vx -= dx*d;
			parts[parts[i].tmp].vy -= dy*d;
			parts[i].vx += dx*d;
			parts[i].vy += dy*d;
			if ((parts[parts[i].tmp].ctype&2) && (parts[parts[i].tmp].ctype&1)
					&& validIndex(parts[parts[i].tmp].tmp)
					&& (parts[parts[parts[i].tmp].tmp].ctype&2) && (parts[parts[parts[i].tmp].tmp].ctype&1))
			{
				int ii = parts[parts[parts[i].tmp].tmp].tmp;
				if (validIndex(ii))
				{
					dx = parts[ii].x - parts[parts[i].tmp].x;
					dy = parts[ii].y - parts[parts[i].tmp].y;
					d = 81/(pow(dx, 2)+pow(dy, 2)+81)-0.5;
					parts[parts[i].tmp].vx -= dx*d*0.5f;
					parts[parts[i].tmp].vy -= dy*d*0.5f;
					parts[ii].vx += dx*d*0.5f;
					parts[ii].vy += dy*d*0.5f;
				}
			}
		}
	}
	else
	{
		if (sim->pv[y/CELL][x/CELL]>0.5f || sim->pv[y/CELL][x/CELL]<(-0.5f))
		{
			parts[i].ctype = 1;
			parts[i].life = 10;
		}

		//SOAP+OIL foam effect
		for (auto rx=-2; rx<3; rx++)
			for (auto ry=-2; ry<3; ry++)
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r) == PT_OIL)
					{
						float ax, ay, gx, gy;

						sim->GetGravityField(x, y, elements[PT_SOAP].Gravity, 1.0f, gx, gy);

						ax = ((parts[i].vx-gx)*0.5f + parts[ID(r)].vx)/2;
						ay = ((parts[i].vy-gy)*0.5f + parts[ID(r)].vy)/2;
						parts[i].vx = parts[ID(r)].vx = ax;
						parts[i].vy = parts[ID(r)].vy = ay;
					}
				}
	}
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)!=PT_SOAP)
				{
					auto tr = float((parts[ID(r)].dcolour>>16)&0xFF);
					auto tg = float((parts[ID(r)].dcolour>>8)&0xFF);
					auto tb = float((parts[ID(r)].dcolour)&0xFF);
					auto ta = float((parts[ID(r)].dcolour>>24)&0xFF);
					auto nr = int(tr*BLEND);
					auto ng = int(tg*BLEND);
					auto nb = int(tb*BLEND);
					auto na = int(ta*BLEND);
					parts[ID(r)].dcolour = nr<<16 | ng<<8 | nb | na<<24;
				}
			}
		}
	}

	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*pixel_mode |= EFFECT_LINES|PMODE_BLUR;
	return 1;
}

static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS)
{
	if (from == PT_SOAP && to != PT_SOAP)
	{
		Element_SOAP_detach(sim, i);
	}
}


=== src\simulation\elements\SOAP.h ===

#pragma once
#include "simulation/ElementDefs.h"

void Element_SOAP_detach(Simulation * sim, int i);


=== src\simulation\elements\SPAWN.cpp ===

#include "simulation/ElementCommon.h"

static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS);
static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS);

void Element::Element_SPAWN()
{
	Identifier = "DEFAULT_PT_SPAWN";
	Name = "SPWN";
	Colour = 0xAAAAAA_rgb;
	MenuVisible = 0;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "STKM spawn point.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	CreateAllowed = &createAllowed;
	ChangeType = &changeType;
}

static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS)
{
	return sim->player.spawnID == -1;
}

static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS)
{
	if (to == PT_SPAWN)
	{
		if (sim->player.spawnID == -1)
			sim->player.spawnID = i;
	}
	else
	{
		if (sim->player.spawnID == i)
			sim->player.spawnID = -1;
	}
}


=== src\simulation\elements\SPAWN2.cpp ===

#include "simulation/ElementCommon.h"

static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS);
static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS);

void Element::Element_SPAWN2()
{
	Identifier = "DEFAULT_PT_SPAWN2";
	Name = "SPWN2";
	Colour = 0xAAAAAA_rgb;
	MenuVisible = 0;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "STK2 spawn point.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	CreateAllowed = &createAllowed;
	ChangeType = &changeType;
}

static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS)
{
	return sim->player2.spawnID == -1;
}

static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS)
{
	if (to == PT_SPAWN2)
	{
		if (sim->player2.spawnID == -1)
			sim->player2.spawnID = i;
	}
	else
	{
		if (sim->player2.spawnID == i)
			sim->player2.spawnID = -1;
	}
}


=== src\simulation\elements\SPNG.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_SPNG()
{
	Identifier = "DEFAULT_PT_SPNG";
	Name = "SPNG";
	Colour = 0xFFBE30_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.00f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.00f;
	Loss = 0.00f;
	Collision = 0.00f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f  * CFDS;
	Falldown = 0;

	Flammable = 20;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 100;

	HeatConduct = 251;
	Description = "Sponge, absorbs water. Is not a moving solid.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 2730.0f;
	HighTemperatureTransition = PT_FIRE;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	int limit = 50;
	if (parts[i].life<limit && sim->pv[y/CELL][x/CELL]<=3&&sim->pv[y/CELL][x/CELL]>=-3&&parts[i].temp<=374.0f)
	{
		int absorbChanceDenom = parts[i].life*10000/limit + 500;
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					switch (TYP(r))
					{
					case PT_WATR:
					case PT_DSTW:
					case PT_FRZW:
						if (parts[i].life<limit && sim->rng.chance(500, absorbChanceDenom))
						{
							parts[i].life++;
							sim->kill_part(ID(r));
						}
						break;
					case PT_SLTW:
						if (parts[i].life<limit && sim->rng.chance(50, absorbChanceDenom))
						{
							parts[i].life++;
							if (sim->rng.chance(3, 4))
								sim->kill_part(ID(r));
							else
								sim->part_change_type(ID(r), x+rx, y+ry, PT_SALT);
						}
						break;
					case PT_CBNW:
						if (parts[i].life<limit && sim->rng.chance(100, absorbChanceDenom))
						{
							parts[i].life++;
							sim->part_change_type(ID(r), x+rx, y+ry, PT_CO2);
						}
						break;
					case PT_PSTE:
						if (parts[i].life<limit && sim->rng.chance(20, absorbChanceDenom))
						{
							parts[i].life++;
							sim->create_part(ID(r), x+rx, y+ry, PT_CLST);
						}
						break;
					default:
						continue;
					}
				}
			}
		}
	}
	else
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if ((!r)&&parts[i].life>=1)//if nothing then create water
					{
						auto np = sim->create_part(-1,x+rx,y+ry,PT_WATR);
						if (np>-1) parts[i].life--;
					}
				}
			}
		}
	}
	for (auto trade = 0; trade<9; trade ++)
	{
		auto rx = sim->rng.between(-2, 2);
		auto ry = sim->rng.between(-2, 2);
		if (rx || ry)
		{
			auto r = pmap[y+ry][x+rx];
			if (!r)
				continue;
			if (TYP(r)==PT_SPNG&&(parts[i].life>parts[ID(r)].life)&&parts[i].life>0)//diffusion
			{
				auto tmp = parts[i].life - parts[ID(r)].life;
				if (tmp ==1)
				{
					parts[ID(r)].life ++;
					parts[i].life --;
					trade = 9;
				}
				else if (tmp>0)
				{
					parts[ID(r)].life += tmp/2;
					parts[i].life -= tmp/2;
					trade = 9;
				}
			}
		}
	}
	auto tmp = 0;
	if (parts[i].life>0)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r)==PT_FIRE)
					{
						tmp++;
						if (parts[ID(r)].life>60)
							parts[ID(r)].life -= parts[ID(r)].life/60;
						else if (parts[ID(r)].life>2)
							parts[ID(r)].life--;
					}
				}
			}
		}
	}
	if (tmp && parts[i].life>3)
		parts[i].life -= parts[i].life/3;
	if (tmp>1)
		tmp = tmp/2;
	if (tmp || parts[i].temp>=374)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if ((!r)&&parts[i].life>=1)//if nothing then create steam
					{
						auto np = sim->create_part(-1,x+rx,y+ry,PT_WTRV);
						if (np>-1)
						{
							parts[np].temp = parts[i].temp;
							tmp--;
							parts[i].life--;
							parts[i].temp -= 20.0f;
						}
					}
				}
			}
		}
	}
	if (tmp>0)
	{
		if (parts[i].life>tmp)
			parts[i].life -= tmp;
		else
			parts[i].life = 0;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*colr -= cpart->life*15;
	*colg -= cpart->life*15;
	*colb -= cpart->life*15;
	if (*colr<=50)
		*colr = 50;
	if (*colg<=50)
		*colg = 50;
	if (*colb<=20)
		*colb = 20;
	return 0;
}


=== src\simulation\elements\SPRK.cpp ===

#include "simulation/ElementCommon.h"
#include "NTCT.h"
#include "PIPE.h"
#include "FIRE.h"
#include "ETRD.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_SPRK()
{
	Identifier = "DEFAULT_PT_SPRK";
	Name = "SPRK";
	Colour = 0xFFFF80_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.001f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;
	PhotonReflectWavelengths = 0x00000000;

	Weight = 100;

	HeatConduct = 251;
	Description = "Electricity. The basis of all electronics in TPT, travels along conductive elements.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int ct = parts[i].ctype;
	Element_FIRE_update(UPDATE_FUNC_SUBCALL_ARGS);

	if (parts[i].life<=0)
	{
		if (ct==PT_WATR||ct==PT_SLTW||ct==PT_PSCN||ct==PT_NSCN||ct==PT_ETRD||ct==PT_INWR)
			parts[i].temp = R_TEMP + 273.15f;
		if (ct<=0 || ct>=PT_NUM || !elements[parts[i].ctype].Enabled)
			ct = PT_METL;
		parts[i].ctype = PT_NONE;
		parts[i].life = 4;
		if (ct == PT_WATR)
			parts[i].life = 64;
		else if (ct == PT_SLTW)
			parts[i].life = 54;
		else if (ct == PT_SWCH)
			parts[i].life = 14;
		else if (ct == PT_RSST) //RSST disappears at the end of its spark cycle
		{
			sim->kill_part(i);
			return 1;
		}

		if (sim->part_change_type(i,x,y,ct))
			return 1;
		return 0;
	}
	//Some functions of SPRK based on ctype (what it is on)
	switch(ct)
	{
	case PT_SPRK:
		sim->kill_part(i);
		return 1;
	case PT_NTCT:
	case PT_PTCT:
		Element_NTCT_update(UPDATE_FUNC_SUBCALL_ARGS);
		break;
	case PT_ETRD:
		if (parts[i].life==1)
		{
			auto nearp = Element_ETRD_nearestSparkablePart(sim, i);
			if (nearp == -1)
				break;
			auto pavg = sim->parts_avg(i, nearp, PT_INSL);
			if (pavg != PT_INSL && pavg != PT_RSSS)
			{
				sim->CreateLine(x, y, (int)(parts[nearp].x+0.5f), (int)(parts[nearp].y+0.5f), PT_PLSM);
				parts[i].life = 20;
				sim->part_change_type(i,x,y,ct);
				ct = parts[i].ctype = PT_NONE;
				sim->part_change_type(nearp,(int)(parts[nearp].x+0.5f),(int)(parts[nearp].y+0.5f),PT_SPRK);
				parts[nearp].life = 9;
				parts[nearp].ctype = PT_ETRD;
			}
		}
		break;
	case PT_NBLE:
		if (parts[i].life<=1 && !(parts[i].tmp&0x1))
		{
			parts[i].life = sim->rng.between(50, 199);
			sim->part_change_type(i,x,y,PT_PLSM);
			parts[i].ctype = PT_NBLE;
			if (parts[i].temp > 5273.15)
				parts[i].tmp |= 0x4;
			parts[i].temp = 3500;
			sim->pv[y/CELL][x/CELL] += 1;
		}
		break;
	case PT_TESC:
		if (parts[i].tmp>300)
			parts[i].tmp=300;
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (r)
						continue;
					if (parts[i].tmp>4 && sim->rng.chance(1, parts[i].tmp*parts[i].tmp/20+6))
					{
						int p = sim->create_part(-1, x+rx*2, y+ry*2, PT_LIGH);
						if (p!=-1)
						{
							parts[p].life = sim->rng.between(0, 2+parts[i].tmp/15) + parts[i].tmp/7;
							if (parts[i].life>60)
								parts[i].life=60;
							parts[p].temp=parts[p].life*parts[i].tmp/2.5;
							parts[p].tmp2=1;
							parts[p].tmp=int(atan2(-ry, (float)rx)/TPT_PI_FLT*360);
							parts[p].dcolour = parts[i].dcolour;
							parts[i].temp-=parts[i].tmp*2+parts[i].temp/5; // slight self-cooling
							if (fabs(sim->pv[y/CELL][x/CELL])!=0.0f)
							{
								if (fabs(sim->pv[y/CELL][x/CELL])<=0.5f)
									sim->pv[y/CELL][x/CELL]=0;
								else
									sim->pv[y/CELL][x/CELL]-=(sim->pv[y/CELL][x/CELL]>0)?0.5:-0.5;
							}
						}
					}
				}
			}
		}
		break;
	case PT_IRON:
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					if (TYP(r)==PT_DSTW || TYP(r)==PT_SLTW || TYP(r)==PT_WATR)
					{
						int rndstore = sim->rng.gen()%100;
						if (!rndstore)
							sim->part_change_type(ID(r),x+rx,y+ry,PT_O2);
						else if (3 > rndstore)
							sim->part_change_type(ID(r),x+rx,y+ry,PT_H2);
					}
				}
			}
		}
		break;
	case PT_TUNG:
		if(parts[i].temp < 3595.0){
			parts[i].temp += sim->rng.between(-4, 15);
		}
	default:
		break;
	}
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto receiver = TYP(r);
				auto sender = ct;
				auto pavg = sim->parts_avg(ID(r), i,PT_INSL);
				//receiver is the element SPRK is trying to conduct to
				//sender is the element the SPRK is on
				//First, some checks usually for (de)activation of elements
				switch (receiver)
				{
				case PT_SWCH:
					if (pavg!=PT_INSL && pavg!=PT_RSSS && parts[i].life<4)
					{
						if(sender==PT_PSCN && parts[ID(r)].life<10) {
							parts[ID(r)].life = 10;
						}
						else if (sender==PT_NSCN)
						{
							parts[ID(r)].ctype = PT_NONE;
							parts[ID(r)].life = 9;
						}
					}
					break;
				case PT_SPRK:
					if (pavg!=PT_INSL && pavg!=PT_RSSS && parts[i].life<4)
					{
						if (parts[ID(r)].ctype==PT_SWCH)
						{
							if (sender==PT_NSCN)
							{
								sim->part_change_type(ID(r),x+rx,y+ry,PT_SWCH);
								parts[ID(r)].ctype = PT_NONE;
								parts[ID(r)].life = 9;
							}
						}
						else if(parts[ID(r)].ctype==PT_NTCT||parts[ID(r)].ctype==PT_PTCT)
							if (sender==PT_METL)
							{
								parts[ID(r)].temp = 473.0f;
							}
					}
					continue;
				case PT_PUMP: case PT_GPMP: case PT_HSWC: case PT_PBCN:
					if (parts[i].life<4)// PROP_PTOGGLE, Maybe? We seem to use 2 different methods for handling actived elements, this one seems better. Yes, use this one for new elements, PCLN is different for compatibility with existing saves
					{
						if (sender==PT_PSCN) parts[ID(r)].life = 10;
						else if (sender==PT_NSCN && parts[ID(r)].life>=10) parts[ID(r)].life = 9;
					}
					continue;
				case PT_LCRY:
					if (abs(rx)<2&&abs(ry)<2 && parts[i].life<4)
					{
						if (sender==PT_PSCN && parts[ID(r)].tmp == 0) parts[ID(r)].tmp = 2;
						else if (sender==PT_NSCN && parts[ID(r)].tmp == 3) parts[ID(r)].tmp = 1;
					}
					continue;
				case PT_PPIP:
					if (parts[i].life == 3 && pavg!=PT_INSL && pavg!=PT_RSSS)
					{
						if (sender == PT_NSCN || sender == PT_PSCN || sender == PT_INST)
							Element_PPIP_flood_trigger(sim, x+rx, y+ry, sender);
					}
					continue;
				case PT_NTCT: case PT_PTCT: case PT_INWR:
					if (sender==PT_METL && pavg!=PT_INSL && pavg!=PT_RSSS && parts[i].life<4)
					{
						parts[ID(r)].temp = 473.0f;
						if (receiver==PT_NTCT||receiver==PT_PTCT)
							continue;
					}
					break;
				case PT_EMP:
					if (!parts[ID(r)].life && parts[i].life > 0 && parts[i].life < 4)
					{
						sim->emp_trigger_count++;
						sim->emp_decor += 3;
						if (sim->emp_decor > 40)
							sim->emp_decor = 40;
						parts[ID(r)].life = 220;
					}
					continue;
				}

				if ((pavg == PT_INSL) || (pavg == PT_RSSS)) continue; //Insulation blocks everything past here
				if (!((elements[receiver].Properties&PROP_CONDUCTS)||receiver==PT_INST||receiver==PT_QRTZ)) continue; //Stop non-conducting receivers, allow INST and QRTZ as special cases
				if (abs(rx)+abs(ry)>=4 &&sender!=PT_SWCH&&receiver!=PT_SWCH) continue; //Only switch conducts really far
				if (receiver==sender && receiver!=PT_INST && receiver!=PT_QRTZ) goto conduct; //Everything conducts to itself, except INST.

				//Sender cases, where elements can have specific outputs
				switch (sender)
				{
				case PT_INST:
					if (receiver==PT_NSCN)
						goto conduct;
					continue;
				case PT_SWCH:
					if (receiver==PT_PSCN||receiver==PT_NSCN||receiver==PT_WATR||receiver==PT_SLTW||receiver==PT_NTCT||receiver==PT_PTCT||receiver==PT_INWR)
						continue;
					break;
				case PT_ETRD:
					if (receiver==PT_METL||receiver==PT_BMTL||receiver==PT_BRMT||receiver==PT_LRBD||receiver==PT_RBDM||receiver==PT_PSCN||receiver==PT_NSCN)
						goto conduct;
					continue;
				case PT_NTCT:
					if (receiver==PT_PSCN || (receiver==PT_NSCN && parts[i].temp>373.0f))
						goto conduct;
					continue;
				case PT_PTCT:
					if (receiver==PT_PSCN || (receiver==PT_NSCN && parts[i].temp<373.0f))
						goto conduct;
					continue;
				case PT_INWR:
					if (receiver==PT_NSCN || receiver==PT_PSCN)
						goto conduct;
					continue;
				default:
					break;
				}
				//Receiving cases, where elements can have specific inputs
				switch (receiver)
				{
				case PT_QRTZ:
					if ((sender==PT_NSCN||sender==PT_METL||sender==PT_PSCN||sender==PT_QRTZ) && (parts[ID(r)].temp<173.15||sim->pv[(y+ry)/CELL][(x+rx)/CELL]>8))
						goto conduct;
					continue;
				case PT_NTCT:
					if (sender==PT_NSCN || (sender==PT_PSCN&&parts[ID(r)].temp>373.0f))
						goto conduct;
					continue;
				case PT_PTCT:
					if (sender==PT_NSCN || (sender==PT_PSCN&&parts[ID(r)].temp<373.0f))
						goto conduct;
					continue;
				case PT_INWR:
					if (sender==PT_NSCN || sender==PT_PSCN)
						goto conduct;
					continue;
				case PT_INST:
					if (sender==PT_PSCN)
						goto conduct;
					continue;
				case PT_NBLE:
					if (!(parts[i].tmp&0x1))
						goto conduct;
					continue;
				case PT_PSCN:
					if (sender!=PT_NSCN)
						goto conduct;
					continue;
				default:
					break;
				}
			conduct:
				//Yay, passed normal conduction rules, check a few last things and change receiver to spark
				if (receiver==PT_WATR||receiver==PT_SLTW) {
					if (parts[ID(r)].life==0 && parts[i].life<3)
					{
						sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
						if (receiver==PT_WATR) parts[ID(r)].life = 6;
						else parts[ID(r)].life = 5;
						parts[ID(r)].ctype = receiver;
					}
				}
				else if (receiver==PT_INST) {
					if (parts[ID(r)].life==0 && parts[i].life<4)
					{
						sim->FloodINST(x+rx,y+ry);//spark the wire
					}
				}
				else if (receiver==PT_RSST) {
					if (parts[ID(r)].life==0 && parts[i].life<4)
					{
						sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
						parts[ID(r)].life = 5;
						parts[ID(r)].ctype = receiver;
					}
				}
				else if (parts[ID(r)].life==0 && parts[i].life<4) {
					parts[ID(r)].life = 4;
					parts[ID(r)].ctype = receiver;
					sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
					if (parts[ID(r)].temp+10.0f<673.0f&&!sim->legacy_enable&&(receiver==PT_METL||receiver==PT_BMTL||receiver==PT_BRMT||receiver==PT_PSCN||receiver==PT_NSCN||receiver==PT_ETRD||receiver==PT_NBLE||receiver==PT_IRON))
						parts[ID(r)].temp = parts[ID(r)].temp+10.0f;
				}
				else if (!parts[ID(r)].life && sender==PT_ETRD && parts[i].life==5) //ETRD is odd and conducts to others only at life 5, this could probably be somewhere else
				{
					sim->part_change_type(i,x,y,sender);
					parts[i].ctype = PT_NONE;
					parts[i].life = 20;
					parts[ID(r)].life = 4;
					parts[ID(r)].ctype = receiver;
					sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 60;
	*firer = *colr/2;
	*fireg = *colg/2;
	*fireb = *colb/2;
	*pixel_mode |= FIRE_SPARK;
	return 1;
}


=== src\simulation\elements\STKM.cpp ===

#include "simulation/ElementCommon.h"
#include "STKM.h"

static int update(UPDATE_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);
static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS);
static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS);

void Element::Element_STKM()
{
	Identifier = "DEFAULT_PT_STKM";
	Name = "STKM";
	Colour = 0xFFE0A0_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.5f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.2f;
	Loss = 1.0f;
	Collision = 0.0f;
	Gravity = 0.0f;
	NewtonianGravity = 0.0f;
	Diffusion = 0.0f;
	HotAir = 0.00f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 50;

	DefaultProperties.temp = R_TEMP + 14.6f + 273.15f;
	HeatConduct = 0;
	Description = "Stickman. Don't kill him! Control with the arrow keys.";

	Properties = PROP_NOCTYPEDRAW;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 620.0f;
	HighTemperatureTransition = PT_FIRE;

	DefaultProperties.life = 100;

	Update = &update;
	Graphics = &Element_STKM_graphics;
	Create = &create;
	CreateAllowed = &createAllowed;
	ChangeType = &changeType;
}

static int update(UPDATE_FUNC_ARGS)
{
	Element_STKM_run_stickman(&sim->player, UPDATE_FUNC_SUBCALL_ARGS);
	return 0;
}

int Element_STKM_graphics(GRAPHICS_FUNC_ARGS)
{
	*colr = *colg = *colb = *cola = 0;
	*pixel_mode = PSPEC_STICKMAN;
	return 1;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	int spawnID = sim->create_part(-3, x, y, PT_SPAWN);
	if (spawnID >= 0)
		sim->player.spawnID = spawnID;
}

static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS)
{
	return sim->elementCount[PT_STKM] <= 0 && !sim->player.spwn;
}

static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS)
{
	if (to == PT_STKM)
	{
		Element_STKM_init_legs(sim, &sim->player, i);
		sim->player.spwn = 1;
	}
	else
		sim->player.spwn = 0;
}

void die(Simulation *sim, playerst *playerp, int i)
{
	int x = (int)(sim->parts[i].x + 0.5f);
	int y = (int)(sim->parts[i].y + 0.5f);
	for (int r = -2; r <= 1; r++)
	{
		sim->create_part(-1, x + r, y - 2, playerp->elem);
		sim->create_part(-1, x + r + 1, y + 2, playerp->elem);
		sim->create_part(-1, x - 2, y + r + 1, playerp->elem);
		sim->create_part(-1, x + 2, y + r, playerp->elem);
	}
	sim->kill_part(i);  //Kill him
}

int Element_STKM_run_stickman(playerst *playerp, UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int r, rx, ry;
	int t = parts[i].type;
	float pp, d;
	float dt = 0.9f;///(FPSB*FPSB);  //Delta time in square
	float gvx, gvy;
	float gx, gy, dl, dr;
	float rocketBootsHeadEffect = 0.35f;
	float rocketBootsFeetEffect = 0.15f;
	float rocketBootsHeadEffectV = 0.3f;// stronger acceleration vertically, to counteract gravity
	float rocketBootsFeetEffectV = 0.45f;

	if (!playerp->fan && parts[i].ctype && sd.IsElementOrNone(parts[i].ctype))
		Element_STKM_set_element(sim, playerp, parts[i].ctype);
	playerp->frames++;

	//Temperature handling
	if (parts[i].temp<243)
		parts[i].life -= 1;
	if ((parts[i].temp<309.6f) && (parts[i].temp>=243))
		parts[i].temp += 1;

	//Death
	if (parts[i].life<1 || (sim->pv[y/CELL][x/CELL]>=4.5f && !playerp->fan) ) //If his HP is less than 0 or there is very big wind...
	{
		die(sim, playerp, i);
		return 1;
	}

	//Follow gravity
	gvx = gvy = 0.0f;
	switch (sim->gravityMode)
	{
		default:
		case GRAV_VERTICAL:
			gvy = 1;
			break;
		case GRAV_OFF:
			gvy = gvx = 0.0f;
			break;
		case GRAV_RADIAL:
			{
				float gravd;
				gravd = 0.01f - hypotf((parts[i].x - XCNTR), (parts[i].y - YCNTR));
				gvx = ((float)(parts[i].x - XCNTR) / gravd);
				gvy = ((float)(parts[i].y - YCNTR) / gravd);
			}
			break;
		case GRAV_CUSTOM:
			gvx = sim->customGravityX;
			gvy = sim->customGravityY;
			break;
	}

	gvx += sim->gravOut.forceX[Vec2{ int(parts[i].x), int(parts[i].y) } / CELL];
	gvy += sim->gravOut.forceY[Vec2{ int(parts[i].x), int(parts[i].y) } / CELL];

	float mvx = gvx;
	float mvy = gvy;
	bool rbLowGrav = false;
	float tmp = fabsf(mvx) > fabsf(mvy)?fabsf(mvx):fabsf(mvy);
	if (tmp < 0.001f)
	{
		rbLowGrav = true;
		mvx = -parts[i].vx;
		mvy = -parts[i].vy;
		tmp = fabsf(mvx) > fabsf(mvy)?fabsf(mvx):fabsf(mvy);
	}
	if (tmp < 0.001f)
	{
		mvx = 0;
		mvy = 1.0f;
		tmp = 1.0f;
	}
	else
		tmp = 1.0f/sqrtf(mvx*mvx+mvy*mvy);
	mvx *= tmp;// scale to a unit vector
	mvy *= tmp;
	if (rbLowGrav)
	{
		rocketBootsHeadEffectV = rocketBootsHeadEffect;
		rocketBootsFeetEffectV = rocketBootsFeetEffect;
	}

	parts[i].vx -= gvx*dt;  //Head up!
	parts[i].vy -= gvy*dt;

	//Verlet integration
	pp = 2*playerp->legs[0]-playerp->legs[2]+playerp->accs[0]*dt*dt;
	playerp->legs[2] = playerp->legs[0];
	playerp->legs[0] = pp;
	pp = 2*playerp->legs[1]-playerp->legs[3]+playerp->accs[1]*dt*dt;
	playerp->legs[3] = playerp->legs[1];
	playerp->legs[1] = pp;

	pp = 2*playerp->legs[4]-playerp->legs[6]+(playerp->accs[2]+gvx)*dt*dt;
	playerp->legs[6] = playerp->legs[4];
	playerp->legs[4] = pp;
	pp = 2*playerp->legs[5]-playerp->legs[7]+(playerp->accs[3]+gvy)*dt*dt;
	playerp->legs[7] = playerp->legs[5];
	playerp->legs[5] = pp;

	pp = 2*playerp->legs[8]-playerp->legs[10]+playerp->accs[4]*dt*dt;
	playerp->legs[10] = playerp->legs[8];
	playerp->legs[8] = pp;
	pp = 2*playerp->legs[9]-playerp->legs[11]+playerp->accs[5]*dt*dt;
	playerp->legs[11] = playerp->legs[9];
	playerp->legs[9] = pp;

	pp = 2*playerp->legs[12]-playerp->legs[14]+(playerp->accs[6]+gvx)*dt*dt;
	playerp->legs[14] = playerp->legs[12];
	playerp->legs[12] = pp;
	pp = 2*playerp->legs[13]-playerp->legs[15]+(playerp->accs[7]+gvy)*dt*dt;
	playerp->legs[15] = playerp->legs[13];
	playerp->legs[13] = pp;

	//Setting acceleration to 0
	playerp->accs[0] = 0;
	playerp->accs[1] = 0;

	playerp->accs[2] = 0;
	playerp->accs[3] = 0;

	playerp->accs[4] = 0;
	playerp->accs[5] = 0;

	playerp->accs[6] = 0;
	playerp->accs[7] = 0;

	gx = (playerp->legs[4] + playerp->legs[12])/2 - gvy;
	gy = (playerp->legs[5] + playerp->legs[13])/2 + gvx;
	dl = pow(gx - playerp->legs[4], 2) + pow(gy - playerp->legs[5], 2);
	dr = pow(gx - playerp->legs[12], 2) + pow(gy - playerp->legs[13], 2);

	//Go left
	if (((int)(playerp->comm)&0x01) == 0x01)
	{
		bool moved = false;
		if (dl>dr)
		{
			if (InBounds(int(playerp->legs[4]), int(playerp->legs[5])) && !sim->eval_move(t, int(playerp->legs[4]), int(playerp->legs[5]), nullptr))
			{
				playerp->accs[2] = -3*mvy-3*mvx;
				playerp->accs[3] = 3*mvx-3*mvy;
				playerp->accs[0] = -mvy;
				playerp->accs[1] = mvx;
				moved = true;
			}
		}
		else
		{
			if (InBounds(int(playerp->legs[12]), int(playerp->legs[13])) && !sim->eval_move(t, int(playerp->legs[12]), int(playerp->legs[13]), nullptr))
			{
				playerp->accs[6] = -3*mvy-3*mvx;
				playerp->accs[7] = 3*mvx-3*mvy;
				playerp->accs[0] = -mvy;
				playerp->accs[1] = mvx;
				moved = true;
			}
		}
		if (!moved && playerp->rocketBoots)
		{
			parts[i].vx -= rocketBootsHeadEffect*mvy;
			parts[i].vy += rocketBootsHeadEffect*mvx;
			playerp->accs[2] -= rocketBootsFeetEffect*mvy;
			playerp->accs[6] -= rocketBootsFeetEffect*mvy;
			playerp->accs[3] += rocketBootsFeetEffect*mvx;
			playerp->accs[7] += rocketBootsFeetEffect*mvx;
			for (int leg=0; leg<2; leg++)
			{
				if (leg==1 && (((int)(playerp->comm)&0x02) == 0x02))
					continue;
				int footX = int(playerp->legs[leg*8+4]), footY = int(playerp->legs[leg*8+5]);
				int np = sim->create_part(-1, footX, footY, PT_PLSM);
				if (np>=0)
				{
					parts[np].vx = parts[i].vx+mvy*25;
					parts[np].vy = parts[i].vy-mvx*25;
					parts[np].life += 30;
				}
			}
		}
	}

	//Go right
	if (((int)(playerp->comm)&0x02) == 0x02)
	{
		bool moved = false;
		if (dl<dr)
		{
			if (InBounds(int(playerp->legs[4]), int(playerp->legs[5])) && !sim->eval_move(t, int(playerp->legs[4]), int(playerp->legs[5]), nullptr))
			{
				playerp->accs[2] = 3*mvy-3*mvx;
				playerp->accs[3] = -3*mvx-3*mvy;
				playerp->accs[0] = mvy;
				playerp->accs[1] = -mvx;
				moved = true;
			}
		}
		else
		{
			if (InBounds(int(playerp->legs[12]), int(playerp->legs[13])) && !sim->eval_move(t, int(playerp->legs[12]), int(playerp->legs[13]), nullptr))
			{
				playerp->accs[6] = 3*mvy-3*mvx;
				playerp->accs[7] = -3*mvx-3*mvy;
				playerp->accs[0] = mvy;
				playerp->accs[1] = -mvx;
				moved = true;
			}
		}
		if (!moved && playerp->rocketBoots)
		{
			parts[i].vx += rocketBootsHeadEffect*mvy;
			parts[i].vy -= rocketBootsHeadEffect*mvx;
			playerp->accs[2] += rocketBootsFeetEffect*mvy;
			playerp->accs[6] += rocketBootsFeetEffect*mvy;
			playerp->accs[3] -= rocketBootsFeetEffect*mvx;
			playerp->accs[7] -= rocketBootsFeetEffect*mvx;
			for (int leg=0; leg<2; leg++)
			{
				if (leg==0 && (((int)(playerp->comm)&0x01) == 0x01))
					continue;
				int footX = int(playerp->legs[leg*8+4]), footY = int(playerp->legs[leg*8+5]);
				int np = sim->create_part(-1, footX, footY, PT_PLSM);
				if (np>=0)
				{
					parts[np].vx = parts[i].vx-mvy*25;
					parts[np].vy = parts[i].vy+mvx*25;
					parts[np].life += 30;
				}
			}
		}
	}

	if (playerp->rocketBoots && ((int)(playerp->comm)&0x03) == 0x03)
	{
		// Pressing left and right simultaneously with rocket boots on slows the stickman down
		// Particularly useful in zero gravity
		parts[i].vx *= 0.5f;
		parts[i].vy *= 0.5f;
		playerp->accs[2] = playerp->accs[6] = 0;
		playerp->accs[3] = playerp->accs[7] = 0;
	}

	//Jump
	if (((int)(playerp->comm)&0x04) == 0x04)
	{
		if (playerp->rocketBoots)
		{
			parts[i].vx -= rocketBootsHeadEffectV*mvx;
			parts[i].vy -= rocketBootsHeadEffectV*mvy;
			playerp->accs[2] -= rocketBootsFeetEffectV*mvx;
			playerp->accs[6] -= rocketBootsFeetEffectV*mvx;
			playerp->accs[3] -= rocketBootsFeetEffectV*mvy;
			playerp->accs[7] -= rocketBootsFeetEffectV*mvy;
			for (int leg=0; leg<2; leg++)
			{
				int footX = int(playerp->legs[leg*8+4]), footY = int(playerp->legs[leg*8+5]);
				int np = sim->create_part(-1, footX, footY+1, PT_PLSM);
				if (np>=0)
				{
					parts[np].vx = parts[i].vx+mvx*30;
					parts[np].vy = parts[i].vy+mvy*30;
					parts[np].life += 10;
				}
			}
		}
		else if ((InBounds(int(playerp->legs[4]), int(playerp->legs[5])) && !sim->eval_move(t, int(playerp->legs[4]), int(playerp->legs[5]), nullptr)) ||
				 (InBounds(int(playerp->legs[12]), int(playerp->legs[13])) && !sim->eval_move(t, int(playerp->legs[12]), int(playerp->legs[13]), nullptr)))
		{
			parts[i].vx -= 4*mvx;
			parts[i].vy -= 4*mvy;
			playerp->accs[2] -= mvx;
			playerp->accs[6] -= mvx;
			playerp->accs[3] -= mvy;
			playerp->accs[7] -= mvy;
		}
	}

	//Charge detector wall if foot inside
	if (InBounds(int(playerp->legs[4]+0.5)/CELL, int(playerp->legs[5]+0.5)/CELL) &&
	       sim->bmap[(int)(playerp->legs[5]+0.5)/CELL][(int)(playerp->legs[4]+0.5)/CELL]==WL_DETECT)
		sim->set_emap((int)playerp->legs[4]/CELL, (int)playerp->legs[5]/CELL);
	if (InBounds(int(playerp->legs[12]+0.5)/CELL, int(playerp->legs[13]+0.5)/CELL) &&
	        sim->bmap[(int)(playerp->legs[13]+0.5)/CELL][(int)(playerp->legs[12]+0.5)/CELL]==WL_DETECT)
		sim->set_emap((int)(playerp->legs[12]+0.5)/CELL, (int)(playerp->legs[13]+0.5)/CELL);

	//Searching for particles near head
	for (rx=-2; rx<3; rx++)
		for (ry=-2; ry<3; ry++)
			if (x+rx>=0 && y+ry>0 && x+rx<XRES && y+ry<YRES && (rx || ry))
			{
				r = pmap[y+ry][x+rx];
				if (!r)
					r = sim->photons[y+ry][x+rx];

				if (!r && !sim->bmap[(y+ry)/CELL][(x+rx)/CELL])
					continue;

				Element_STKM_set_element(sim, playerp, TYP(r));
				if (TYP(r) == PT_PLNT && parts[i].life<100) //Plant gives him 5 HP
				{
					if (parts[i].life<=95)
						parts[i].life += 5;
					else
						parts[i].life = 100;
					sim->kill_part(ID(r));
				}

				if (TYP(r) == PT_NEUT)
				{
					if (parts[i].life<=100) parts[i].life -= (102-parts[i].life)/2;
					else parts[i].life = int(parts[i].life * 0.9f);
					sim->kill_part(ID(r));
				}
				if (sim->bmap[(ry+y)/CELL][(rx+x)/CELL]==WL_FAN)
					playerp->fan = true;
				else if (sim->bmap[(ry+y)/CELL][(rx+x)/CELL]==WL_EHOLE)
					playerp->rocketBoots = false;
				else if (sim->bmap[(ry+y)/CELL][(rx+x)/CELL]==WL_GRAV /* && parts[i].type!=PT_FIGH */)
					playerp->rocketBoots = true;
				if (TYP(r)==PT_PRTI)
					Element_STKM_interact(sim, playerp, i, rx, ry);
				if (!parts[i].type)//STKM_interact may kill STKM
					return 1;
			}

	//Head position
	rx = x + 3*((((int)playerp->pcomm)&0x02) == 0x02) - 3*((((int)playerp->pcomm)&0x01) == 0x01);
	ry = y - 3*(playerp->pcomm == 0);

	//Spawn
	if (((int)(playerp->comm)&0x08) == 0x08)
	{
		ry -= 2 * sim->rng.between(0, 1) + 1;
		r = pmap[ry][rx];
		if (elements[TYP(r)].Properties&TYPE_SOLID)
		{
			sim->create_part(-1, rx, ry, PT_SPRK);
			playerp->frames = 0;
		}
		else
		{
			int np = -1;
			if (playerp->fan)
			{
				for(int j = -4; j < 5; j++)
					for (int k = -4; k < 5; k++)
					{
						int airx = rx + 3*((((int)playerp->pcomm)&0x02) == 0x02) - 3*((((int)playerp->pcomm)&0x01) == 0x01)+j;
						int airy = ry+k;
						sim->pv[airy/CELL][airx/CELL] += 0.03f;
						if (airy + CELL < YRES)
							sim->pv[airy/CELL+1][airx/CELL] += 0.03f;
						if (airx + CELL < XRES)
						{
							sim->pv[airy/CELL][airx/CELL+1] += 0.03f;
							if (airy + CELL < YRES)
								sim->pv[airy/CELL+1][airx/CELL+1] += 0.03f;
						}
					}
			}
			else if (playerp->elem==PT_LIGH && playerp->frames<30)//limit lightning creation rate
				np = -1;
			else
				np = sim->create_part(-1, rx, ry, playerp->elem);
			if ( (np < NPART) && np>=0)
			{
				if (playerp->elem == PT_PHOT)
				{
					int random = abs((sim->rng.between(-1, 1)))*3;
					if (random==0)
					{
						sim->kill_part(np);
					}
					else
					{
						parts[np].vy = 0;
						if (((int)playerp->pcomm)&(0x01|0x02))
							parts[np].vx = float((((((int)playerp->pcomm)&0x02) == 0x02) - (((int)(playerp->pcomm)&0x01) == 0x01))*random);
						else
							parts[np].vx = float(random);
					}
				}
				else if (playerp->elem == PT_LIGH)
				{
					int angle;
					int power = 100;
					if (gvx!=0 || gvy!=0)
						angle = int(atan2(mvx, mvy)*180.0f/TPT_PI_FLT);
					else
						angle = sim->rng.between(0, 359);
					if (((int)playerp->pcomm)&0x01)
						angle += 180;
					if (angle>360)
						angle-=360;
					if (angle<0)
						angle+=360;
					parts[np].tmp = angle;
					parts[np].life = sim->rng.between(0, 1+power/15) + power/7;
					parts[np].temp = parts[np].life*power/2.5;
					parts[np].tmp2 = 1;
				}
				else if (!playerp->fan)
				{
					parts[np].vx -= -mvy*(5*((((int)playerp->pcomm)&0x02) == 0x02) - 5*(((int)(playerp->pcomm)&0x01) == 0x01));
					parts[np].vy -= mvx*(5*((((int)playerp->pcomm)&0x02) == 0x02) - 5*(((int)(playerp->pcomm)&0x01) == 0x01));
					parts[i].vx -= (elements[(int)playerp->elem].Weight*parts[np].vx)/1000;
				}
				playerp->frames = 0;
			}

		}
	}

	//Simulation of joints
	d = 25/(pow((playerp->legs[0]-playerp->legs[4]), 2) + pow((playerp->legs[1]-playerp->legs[5]), 2)+25) - 0.5;  //Fast distance
	playerp->legs[4] -= (playerp->legs[0]-playerp->legs[4])*d;
	playerp->legs[5] -= (playerp->legs[1]-playerp->legs[5])*d;
	playerp->legs[0] += (playerp->legs[0]-playerp->legs[4])*d;
	playerp->legs[1] += (playerp->legs[1]-playerp->legs[5])*d;

	d = 25/(pow((playerp->legs[8]-playerp->legs[12]), 2) + pow((playerp->legs[9]-playerp->legs[13]), 2)+25) - 0.5;
	playerp->legs[12] -= (playerp->legs[8]-playerp->legs[12])*d;
	playerp->legs[13] -= (playerp->legs[9]-playerp->legs[13])*d;
	playerp->legs[8] += (playerp->legs[8]-playerp->legs[12])*d;
	playerp->legs[9] += (playerp->legs[9]-playerp->legs[13])*d;

	d = 36/(pow((playerp->legs[0]-parts[i].x), 2) + pow((playerp->legs[1]-parts[i].y), 2)+36) - 0.5;
	parts[i].vx -= (playerp->legs[0]-parts[i].x)*d;
	parts[i].vy -= (playerp->legs[1]-parts[i].y)*d;
	playerp->legs[0] += (playerp->legs[0]-parts[i].x)*d;
	playerp->legs[1] += (playerp->legs[1]-parts[i].y)*d;

	d = 36/(pow((playerp->legs[8]-parts[i].x), 2) + pow((playerp->legs[9]-parts[i].y), 2)+36) - 0.5;
	parts[i].vx -= (playerp->legs[8]-parts[i].x)*d;
	parts[i].vy -= (playerp->legs[9]-parts[i].y)*d;
	playerp->legs[8] += (playerp->legs[8]-parts[i].x)*d;
	playerp->legs[9] += (playerp->legs[9]-parts[i].y)*d;

	if (InBounds(int(playerp->legs[4]), int(playerp->legs[5])) && !sim->eval_move(t, int(playerp->legs[4]), int(playerp->legs[5]), nullptr))
	{
		playerp->legs[4] = playerp->legs[6];
		playerp->legs[5] = playerp->legs[7];
	}

	if (InBounds(int(playerp->legs[12]), int(playerp->legs[13])) && !sim->eval_move(t, int(playerp->legs[12]), int(playerp->legs[13]), nullptr))
	{
		playerp->legs[12] = playerp->legs[14];
		playerp->legs[13] = playerp->legs[15];
	}

	//This makes stick man "pop" from obstacles
	if (InBounds(int(playerp->legs[4]), int(playerp->legs[5])) && !sim->eval_move(t, int(playerp->legs[4]), int(playerp->legs[5]), nullptr))
	{
		float t;
		t = playerp->legs[4]; playerp->legs[4] = playerp->legs[6]; playerp->legs[6] = t;
		t = playerp->legs[5]; playerp->legs[5] = playerp->legs[7]; playerp->legs[7] = t;
	}

	if (InBounds(int(playerp->legs[12]), int(playerp->legs[13])) && !sim->eval_move(t, int(playerp->legs[12]), int(playerp->legs[13]), nullptr))
	{
		float t;
		t = playerp->legs[12]; playerp->legs[12] = playerp->legs[14]; playerp->legs[14] = t;
		t = playerp->legs[13]; playerp->legs[13] = playerp->legs[15]; playerp->legs[15] = t;
	}

	//Keeping legs distance
	if ((pow((playerp->legs[4] - playerp->legs[12]), 2) + pow((playerp->legs[5]-playerp->legs[13]), 2))<16)
	{
		float tvx, tvy;
		tvx = -gvy;
		tvy = gvx;

		if (tvx || tvy)
		{
			playerp->accs[2] -= 0.2*tvx/hypot(tvx, tvy);
			playerp->accs[3] -= 0.2*tvy/hypot(tvx, tvy);

			playerp->accs[6] += 0.2*tvx/hypot(tvx, tvy);
			playerp->accs[7] += 0.2*tvy/hypot(tvx, tvy);
		}
	}

	if ((pow((playerp->legs[0] - playerp->legs[8]), 2) + pow((playerp->legs[1]-playerp->legs[9]), 2))<16)
	{
		float tvx, tvy;
		tvx = -gvy;
		tvy = gvx;

		if (tvx || tvy)
		{
			playerp->accs[0] -= 0.2*tvx/hypot(tvx, tvy);
			playerp->accs[1] -= 0.2*tvy/hypot(tvx, tvy);

			playerp->accs[4] += 0.2*tvx/hypot(tvx, tvy);
			playerp->accs[5] += 0.2*tvy/hypot(tvx, tvy);
		}
	}

	//If legs touch something
	Element_STKM_interact(sim, playerp, i, (int)(playerp->legs[4]+0.5), (int)(playerp->legs[5]+0.5));
	Element_STKM_interact(sim, playerp, i, (int)(playerp->legs[12]+0.5), (int)(playerp->legs[13]+0.5));
	Element_STKM_interact(sim, playerp, i, (int)(playerp->legs[4]+0.5), (int)playerp->legs[5]);
	Element_STKM_interact(sim, playerp, i, (int)(playerp->legs[12]+0.5), (int)playerp->legs[13]);
	if (!parts[i].type)
		return 1;

	parts[i].ctype = playerp->elem;
	return 0;
}

void Element_STKM_interact(Simulation *sim, playerst *playerp, int i, int x, int y)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int r;
	if (x<0 || y<0 || x>=XRES || y>=YRES || !sim->parts[i].type)
		return;
	r = sim->pmap[y][x];
	if (r)
	{
		int damage = 0;
		if (TYP(r)==PT_SPRK && playerp->elem!=PT_LIGH) //If on charge
		{
			damage += sim->rng.between(32, 51);
		}

		if (!sim->IsHeatInsulator(sim->parts[ID(r)]) && ((playerp->elem!=PT_LIGH && sim->parts[ID(r)].temp>=323) || sim->parts[ID(r)].temp<=243) && (!playerp->rocketBoots || TYP(r)!=PT_PLSM))
		{
			damage += 2;
			playerp->accs[3] -= 1;
		}

		if (elements[TYP(r)].Properties&PROP_DEADLY)
			switch (TYP(r))
			{
				case PT_ACID:
					damage += 5;
					break;
				default:
					damage++;
					break;
			}

		if (elements[TYP(r)].Properties&PROP_RADIOACTIVE)
			damage++;

		if (damage)
		{
			if (damage > sim->parts[i].life)
			{
				die(sim, playerp, i);
				return;
			}
			sim->parts[i].life -= damage;
		}

		if (TYP(r)==PT_PRTI && sim->parts[i].type)
		{
			int nnx, count=1;//gives rx=0, ry=1 in update_PRTO
			sim->parts[ID(r)].tmp = (int)((sim->parts[ID(r)].temp-73.15f)/100+1);
			if (sim->parts[ID(r)].tmp>=CHANNELS) sim->parts[ID(r)].tmp = CHANNELS-1;
			else if (sim->parts[ID(r)].tmp<0) sim->parts[ID(r)].tmp = 0;
			for (nnx=0; nnx<80; nnx++)
				if (!sim->portalp[sim->parts[ID(r)].tmp][count][nnx].type)
				{
					sim->portalp[sim->parts[ID(r)].tmp][count][nnx] = sim->parts[i];
					sim->kill_part(i);
					//stop new STKM/fighters being created to replace the ones in the portal:
					playerp->spwn = 1;
					if (sim->portalp[sim->parts[ID(r)].tmp][count][nnx].type==PT_FIGH)
						sim->fighcount++;
					break;
				}
		}
		if ((TYP(r)==PT_BHOL || TYP(r)==PT_NBHL) && sim->parts[i].type)
		{
			if (!sim->legacy_enable)
			{
				sim->parts[ID(r)].temp = restrict_flt(sim->parts[ID(r)].temp+sim->parts[i].temp/2, MIN_TEMP, MAX_TEMP);
			}
			sim->kill_part(i);
		}
		if ((TYP(r)==PT_VOID || (TYP(r)==PT_PVOD && sim->parts[ID(r)].life==10)) && (!sim->parts[ID(r)].ctype || (sim->parts[ID(r)].ctype==sim->parts[i].type)!=(sim->parts[ID(r)].tmp&1)) && sim->parts[i].type)
		{
			sim->kill_part(i);
		}
	}
}

void Element_STKM_init_legs(Simulation * sim, playerst *playerp, int i)
{
	int x, y;

	x = (int)(sim->parts[i].x+0.5f);
	y = (int)(sim->parts[i].y+0.5f);

	playerp->legs[0] = float(x-1);
	playerp->legs[1] = float(y+6);
	playerp->legs[2] = float(x-1);
	playerp->legs[3] = float(y+6);

	playerp->legs[4] = float(x-3);
	playerp->legs[5] = float(y+12);
	playerp->legs[6] = float(x-3);
	playerp->legs[7] = float(y+12);

	playerp->legs[8] = float(x+1);
	playerp->legs[9] = float(y+6);
	playerp->legs[10] = float(x+1);
	playerp->legs[11] = float(y+6);

	playerp->legs[12] = float(x+3);
	playerp->legs[13] = float(y+12);
	playerp->legs[14] = float(x+3);
	playerp->legs[15] = float(y+12);

	for (int i = 0; i < 8; i++)
		playerp->accs[i] = 0;
	playerp->comm = 0;
	playerp->pcomm = 0;
	playerp->frames = 0;
	playerp->spwn = 0;
	playerp->fan = false;
	playerp->rocketBoots = false;
}

void Element_STKM_set_element(Simulation *sim, playerst *playerp, int element)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (elements[element].Falldown != 0
	    || elements[element].Properties&TYPE_GAS
	    || elements[element].Properties&TYPE_LIQUID
	    || elements[element].Properties&TYPE_ENERGY
	    || element == PT_LOLZ || element == PT_LOVE)
	{
		if (!playerp->rocketBoots || element != PT_PLSM)
		{
			playerp->elem = element;
			playerp->fan = false;
		}
	}
	if (element == PT_TESC || element == PT_LIGH)
	{
		playerp->elem = PT_LIGH;
		playerp->fan = false;
	}
}


=== src\simulation\elements\STKM.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_FIGH_Alloc(Simulation *sim);
bool Element_FIGH_CanAlloc(Simulation *sim);
void Element_FIGH_NewFighter(Simulation *sim, int fighterID, int i, int elem);
int Element_STKM_graphics(GRAPHICS_FUNC_ARGS);
void Element_STKM_init_legs(Simulation * sim, playerst *playerp, int i);
void Element_STKM_interact(Simulation *sim, playerst *playerp, int i, int x, int y);
int Element_STKM_run_stickman(playerst *playerp, UPDATE_FUNC_ARGS);
void Element_STKM_set_element(Simulation *sim, playerst *playerp, int element);


=== src\simulation\elements\STKM2.cpp ===

#include "simulation/ElementCommon.h"
#include "STKM.h"

static int update(UPDATE_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);
static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS);
static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS);

void Element::Element_STKM2()
{
	Identifier = "DEFAULT_PT_STKM2";
	Name = "STK2";
	Colour = 0x6464FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.5f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.2f;
	Loss = 1.0f;
	Collision = 0.0f;
	Gravity = 0.0f;
	NewtonianGravity = 0.0f;
	Diffusion = 0.0f;
	HotAir = 0.00f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 50;

	DefaultProperties.temp = R_TEMP + 14.6f + 273.15f;
	HeatConduct = 0;
	Description = "Second stickman. Don't kill him! Control with wasd.";

	Properties = PROP_NOCTYPEDRAW;
	CarriesTypeIn = 1U << FIELD_CTYPE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 620.0f;
	HighTemperatureTransition = PT_FIRE;

	DefaultProperties.life = 100;

	Update = &update;
	Graphics = &Element_STKM_graphics;
	Create = &create;
	CreateAllowed = &createAllowed;
	ChangeType = &changeType;
}

static int update(UPDATE_FUNC_ARGS)
{
	Element_STKM_run_stickman(&sim->player2, UPDATE_FUNC_SUBCALL_ARGS);
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	int spawnID = sim->create_part(-3, x, y, PT_SPAWN2);
	if (spawnID >= 0)
		sim->player2.spawnID = spawnID;
}

static bool createAllowed(ELEMENT_CREATE_ALLOWED_FUNC_ARGS)
{
	return sim->elementCount[PT_STKM2] <= 0 && !sim->player2.spwn;
}

static void changeType(ELEMENT_CHANGETYPE_FUNC_ARGS)
{
	if (to == PT_STKM2)
	{
		Element_STKM_init_legs(sim, &sim->player2, i);
		sim->player2.spwn = 1;
	}
	else
		sim->player2.spwn = 0;
}


=== src\simulation\elements\STNE.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_STNE()
{
	Identifier = "DEFAULT_PT_STNE";
	Name = "STNE";
	Colour = 0xA0A0A0_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 5;
	Hardness = 1;

	Weight = 90;

	HeatConduct = 150;
	Description = "Stone. Heavy particles, meltable.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 983.0f;
	HighTemperatureTransition = PT_LAVA;
}


=== src\simulation\elements\STOR.cpp ===

#include "simulation/ElementCommon.h"
#include "SOAP.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static bool ctypeDraw(CTYPEDRAW_FUNC_ARGS);

void Element::Element_STOR()
{
	Identifier = "DEFAULT_PT_STOR";
	Name = "STOR";
	Colour = 0x50DFDF_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWERED;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Storage. Captures and stores a single particle. Releases when charged with PSCN, also passes to PIPE.";

	Properties = TYPE_SOLID | PROP_NOCTYPEDRAW;
	CarriesTypeIn = (1U << FIELD_CTYPE) | (1U << FIELD_TMP);

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	CtypeDraw = &ctypeDraw;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (!sd.IsElementOrNone(parts[i].tmp))
		parts[i].tmp = 0;
	if(parts[i].life && !parts[i].tmp)
		parts[i].life--;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					r= sim->photons[y+ry][x+rx];
				if (!r)
					continue;
				if (!parts[i].tmp && !parts[i].life && TYP(r)!=PT_STOR && !(elements[TYP(r)].Properties&TYPE_SOLID) && (!parts[i].ctype || TYP(r)==parts[i].ctype))
				{
					if (TYP(r) == PT_SOAP)
						Element_SOAP_detach(sim, ID(r));
					parts[i].tmp = parts[ID(r)].type;
					parts[i].temp = parts[ID(r)].temp;
					parts[i].tmp2 = parts[ID(r)].life;
					parts[i].tmp3 = parts[ID(r)].tmp;
					parts[i].tmp4 = parts[ID(r)].ctype;
					sim->kill_part(ID(r));
				}
				if(parts[i].tmp && TYP(r)==PT_SPRK && parts[ID(r)].ctype==PT_PSCN && parts[ID(r)].life>0 && parts[ID(r)].life<4)
				{
					for(auto ry1 = 1; ry1 >= -1; ry1--)
					{
						for(auto rx1 = 0; rx1 >= -1 && rx1 <= 1; rx1 = -rx1-rx1+1) // Oscillate the X starting at 0, 1, -1, 3, -5, etc (Though stop at -1)
						{
							auto np = sim->create_part(-1,x+rx1,y+ry1,TYP(parts[i].tmp));
							if (np!=-1)
							{
								parts[np].temp = parts[i].temp;
								parts[np].life = parts[i].tmp2;
								parts[np].tmp = parts[i].tmp3;
								parts[np].ctype = parts[i].tmp4;
								parts[i].tmp = 0;
								parts[i].life = 10;
								break;
							}
						}
					}
				}
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->tmp){
		*pixel_mode |= PMODE_GLOW;
		*colr = 0x50;
		*colg = 0xDF;
		*colb = 0xDF;
	} else {
		*colr = 0x20;
		*colg = 0xAF;
		*colb = 0xAF;
	}
	return 0;
}

static bool ctypeDraw(CTYPEDRAW_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (elements[t].Properties & TYPE_SOLID)
	{
		return false;
	}
	return Element::basicCtypeDraw(CTYPEDRAW_FUNC_SUBCALL_ARGS);
}


=== src\simulation\elements\SWCH.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_SWCH()
{
	Identifier = "DEFAULT_PT_SWCH";
	Name = "SWCH";
	Colour = 0x103B11_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f  * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Switch. Only conducts when switched on. (PSCN switches on, NSCN switches off)";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static bool isRedBRAY(UPDATE_FUNC_ARGS, int xc, int yc)
{
	return TYP(pmap[yc][xc]) == PT_BRAY && parts[ID(pmap[yc][xc])].tmp == 2;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].life>0 && parts[i].life!=10)
		parts[i].life--;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto pavg = sim->parts_avg(i,ID(r),PT_INSL);
				if (pavg!=PT_INSL && pavg!=PT_RSSS)
				{
					auto rt = TYP(r);
					if (rt==PT_SWCH)
					{
						if (parts[i].life>=10&&parts[ID(r)].life<10&&parts[ID(r)].life>0)
							parts[i].life = 9;
						else if (parts[i].life==0&&parts[ID(r)].life>=10)
						{
							//Set to other particle's life instead of 10, otherwise spark loops form when SWCH is sparked while turning on
							parts[i].life = parts[ID(r)].life;
						}
					}
					else if (rt==PT_SPRK && parts[i].life==10 && parts[ID(r)].life>0 && parts[ID(r)].ctype!=PT_PSCN && parts[ID(r)].ctype!=PT_NSCN) {
						sim->part_change_type(i,x,y,PT_SPRK);
						parts[i].ctype = PT_SWCH;
						parts[i].life = 4;
					}
				}
			}
		}
	}
	//turn SWCH on/off from two red BRAYS. There must be one either above or below, and one either left or right to work, and it can't come from the side, it must be a diagonal beam
	if (!TYP(pmap[y-1][x-1]) && !TYP(pmap[y-1][x+1]) && (isRedBRAY(UPDATE_FUNC_SUBCALL_ARGS, x, y-1) || isRedBRAY(UPDATE_FUNC_SUBCALL_ARGS, x, y+1)) && (isRedBRAY(UPDATE_FUNC_SUBCALL_ARGS, x+1, y) || isRedBRAY(UPDATE_FUNC_SUBCALL_ARGS, x-1, y)))
	{
		if (parts[i].life == 10)
			parts[i].life = 9;
		else if (parts[i].life <= 5)
			parts[i].life = 14;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if(cpart->life >= 10)
	{
		*colr = 17;
		*colg = 217;
		*colb = 24;
		*pixel_mode |= PMODE_GLOW;
	}
	return 0;
}


=== src\simulation\elements\TESC.cpp ===

#include "simulation/ElementCommon.h"

static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_TESC()
{
	Identifier = "DEFAULT_PT_TESC";
	Name = "TESC";
	Colour = 0x707040_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Tesla coil! Creates lightning when sparked.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC|PROP_HOT_GLOW;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Create = &create;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	if (v >= 0)
	{
		sim->parts[i].tmp = v;
		if (sim->parts[i].tmp > 300)
			sim->parts[i].tmp = 300;
	}
}


=== src\simulation\elements\THDR.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_THDR()
{
	Identifier = "DEFAULT_PT_THDR";
	Name = "THDR";
	Colour = 0xFFFFA0_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.0f;
	Loss = 0.30f;
	Collision = -0.99f;
	Gravity = 0.6f;
	Diffusion = 0.62f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 1;

	DefaultProperties.temp = 9000.0f + 273.15f;
	HeatConduct = 1;
	Description = "Lightning! Very hot, inflicts damage upon most materials, and transfers current to metals.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	bool kill=false;
	for (auto rx = -2; rx <= 2; rx++)
	{
		for (auto ry = -2; ry <= 2; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				auto rt = TYP(r);
				if ((elements[TYP(r)].Properties&PROP_CONDUCTS) && parts[ID(r)].life==0 && !(rt==PT_WATR||rt==PT_SLTW) && parts[ID(r)].ctype!=PT_SPRK)
				{
					parts[ID(r)].ctype = parts[ID(r)].type;
					sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
					parts[ID(r)].life = 4;
					kill=true;
				}
				else if (rt!=PT_CLNE&&rt!=PT_THDR&&rt!=PT_SPRK&&rt!=PT_DMND&&rt!=PT_FIRE)
				{
					sim->pv[y/CELL][x/CELL] += 100.0f;
					if (sim->legacy_enable && sim->rng.chance(1, 200))
					{
						parts[i].life = sim->rng.between(120, 169);
						sim->part_change_type(i,x,y,PT_FIRE);
					}
					else
						kill=true;
				}
			}
		}
	}
	if (kill) {
		sim->kill_part(i);
		return 1;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*firea = 160;
	*fireg = 192;
	*fireb = 255;
	*firer = 144;
	*pixel_mode |= FIRE_ADD;
	return 1;
}


=== src\simulation\elements\THRM.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_THRM()
{
	Identifier = "DEFAULT_PT_THRM";
	Name = "THRM";
	Colour = 0xA08090_rgb;
	MenuVisible = 1;
	MenuSection = SC_EXPLOSIVE;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.04f * CFDS;
	AirLoss = 0.94f;
	Loss = 0.95f;
	Collision = -0.1f;
	Gravity = 0.3f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 2;
	Hardness = 2;

	Weight = 90;

	HeatConduct = 211;
	Description = "Thermite. Burns into extremely hot molten metal.";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}


=== src\simulation\elements\TRON.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);
static void init_graphics();
static int trymovetron(Simulation * sim, int x, int y, int dir, int i, int len);
static bool canmovetron(Simulation * sim, int r, int len);
static int new_tronhead(Simulation * sim, int x, int y, int i, int direction);

void Element::Element_TRON()
{
	Identifier = "DEFAULT_PT_TRON";
	Name = "TRON";
	Colour = 0xA9FF00_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f  * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = 0.0f;
	HeatConduct = 40;
	Description = "Smart particles, Travels in straight lines and avoids obstacles. Grows with time.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC|PROP_LIFE_KILL;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	Create = &create;

	init_graphics();
}

/* TRON element is meant to resemble a tron bike (or worm) moving around and trying to avoid obstacles itself.
 * It has four direction each turn to choose from, 0 (left) 1 (up) 2 (right) 3 (down).
 * Each turn has a small random chance to randomly turn one way (so it doesn't do the exact same thing in a large room)
 * If the place it wants to move isn't a barrier, it will try and 'see' in front of itself to determine its safety.
 * For now the tron can only see its own body length in pixels ahead of itself (and around corners)
 *  - - - - - - - - - -
 *  - - - - + - - - - -
 *  - - - + + + - - - -
 *  - - +<--+-->+ - - -
 *  - +<----+---->+ - -
 *  - - - - H - - - - -
 * Where H is the head with tail length 4, it checks the + area to see if it can hit any of the edges, then it is called safe, or picks the biggest area if none safe.
 * .tmp bit values: 1st head, 2nd no tail growth, 3rd wait flag, 4th Nodie, 5th Dying, 6th & 7th is direction, 8th - 16th hue, 17th Norandom
 * .tmp2 is tail length (gets longer every few hundred frames)
 * .life is the timer that kills the end of the tail (the head uses life for how often it grows longer)
 * .ctype Contains the colour, lost on save, regenerated using hue tmp (bits 7 - 16)
 */

constexpr auto TRON_HEAD     = UINT32_C(0x00000001);
constexpr auto TRON_NOGROW   = UINT32_C(0x00000002);
constexpr auto TRON_WAIT     = UINT32_C(0x00000004); //it was just created, so WAIT a frame
constexpr auto TRON_NODIE    = UINT32_C(0x00000008);
constexpr auto TRON_DEATH    = UINT32_C(0x00000010); //Crashed, now dying
constexpr auto TRON_NORANDOM = UINT32_C(0x00010000);
int tron_rx[4] = {-1, 0, 1, 0};
int tron_ry[4] = { 0,-1, 0, 1};
unsigned int tron_colours[32];

static void init_graphics()
{
	int i;
	int r, g, b;
	for (i=0; i<32; i++)
	{
		HSV_to_RGB(i<<4,255,255,&r,&g,&b);
		tron_colours[i] = r<<16 | g<<8 | b;
	}
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].tmp&TRON_WAIT)
	{
		parts[i].tmp &= ~TRON_WAIT;
		return 0;
	}
	if (parts[i].tmp&TRON_HEAD)
	{
		int firstdircheck = 0, seconddir = 0, seconddircheck = 0, lastdir = 0, lastdircheck = 0;
		int direction = (parts[i].tmp>>5 & 0x3);
		int originaldir = direction;

		//random turn
		int random = sim->rng.between(0, 339);
		if ((random==1 || random==3) && !(parts[i].tmp & TRON_NORANDOM))
		{
			//randomly turn left(3) or right(1)
			direction = (direction + random)%4;
		}

		//check in front
		//do sight check
		firstdircheck = trymovetron(sim,x,y,direction,i,parts[i].tmp2);
		if (firstdircheck < parts[i].tmp2)
		{
			if (parts[i].tmp & TRON_NORANDOM)
			{
				seconddir = (direction + 1)%4;
				lastdir = (direction + 3)%4;
			}
			else if (originaldir != direction) //if we just tried a random turn, don't pick random again
			{
				seconddir = originaldir;
				lastdir = (direction + 2)%4;
			}
			else
			{
				seconddir = (direction + (sim->rng.between(0, 1)*2)+1)% 4;
				lastdir = (seconddir + 2)%4;
			}
			seconddircheck = trymovetron(sim,x,y,seconddir,i,parts[i].tmp2);
			lastdircheck = trymovetron(sim,x,y,lastdir,i,parts[i].tmp2);
		}
		//find the best move
		if (seconddircheck > firstdircheck)
			direction = seconddir;
		if (lastdircheck > seconddircheck && lastdircheck > firstdircheck)
			direction = lastdir;
		//now try making new head, even if it fails
		if (new_tronhead(sim,x + tron_rx[direction],y + tron_ry[direction],i,direction) == -1)
		{
			//ohgod crash
			parts[i].tmp |= TRON_DEATH;
			//trigger tail death for TRON_NODIE, or is that mode even needed? just set a high tail length(but it still won't start dying when it crashes)
		}

		//set own life and clear .tmp (it dies if it can't move anyway)
		parts[i].life = parts[i].tmp2;
		parts[i].tmp &= parts[i].tmp&0xF818;
	}
	else // fade tail deco, or prevent tail from dying
	{
		if (parts[i].tmp&TRON_NODIE)
			parts[i].life++;
		//parts[i].dcolour =  clamp_flt((float)parts[i].life/(float)parts[i].tmp2,0,1.0f) << 24 |  parts[i].dcolour&0x00FFFFFF;
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	unsigned int col = tron_colours[(cpart->tmp&0xF800)>>11];
	if(cpart->tmp & TRON_HEAD)
		*pixel_mode |= PMODE_GLOW;
	*colr = (col & 0xFF0000)>>16;
	*colg = (col & 0x00FF00)>>8;
	*colb = (col & 0x0000FF);
	if(cpart->tmp & TRON_DEATH)
	{
		*pixel_mode |= FIRE_ADD | PMODE_FLARE;
		*firer = *colr;
		*fireg = *colg;
		*fireb = *colb;
		*firea = 255;
	}
	if(cpart->life < cpart->tmp2 && !(cpart->tmp & TRON_HEAD))
	{
		*pixel_mode |= PMODE_BLEND;
		*pixel_mode &= ~PMODE_FLAT;
		*cola = (int)((((float)cpart->life)/((float)cpart->tmp2))*255.0f);
	}
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	int randhue = sim->rng.between(0, 359);
	int randomdir = sim->rng.between(0, 3);
	// Set as a head and a direction
	sim->parts[i].tmp = 1 | (randomdir << 5) | (randhue << 7);
	// Tail
	sim->parts[i].tmp2 = 4;
	sim->parts[i].life = 5;
}

static int new_tronhead(Simulation * sim, int x, int y, int i, int direction)
{
	int np = sim->create_part(-1, x , y ,PT_TRON);
	if (np==-1)
		return -1;
	if (sim->parts[i].life >= 100) // increase tail length
	{
		if (!(sim->parts[i].tmp&TRON_NOGROW))
			sim->parts[i].tmp2++;
		sim->parts[i].life = 5;
	}
	//give new head our properties
	sim->parts[np].tmp = 1 | direction<<5 | (sim->parts[i].tmp&(TRON_NOGROW|TRON_NODIE|TRON_NORANDOM)) | (sim->parts[i].tmp&0xF800);
	if (np > i)
		sim->parts[np].tmp |= TRON_WAIT;

	sim->parts[np].ctype = sim->parts[i].ctype;
	sim->parts[np].tmp2 = sim->parts[i].tmp2;
	sim->parts[np].life = sim->parts[i].life + 2;
	return 1;
}

static int trymovetron(Simulation * sim, int x, int y, int dir, int i, int len)
{
	int k,j,r,rx,ry,tx,ty,count;
	count = 0;
	rx = x;
	ry = y;
	for (k = 1; k <= len; k ++)
	{
		rx += tron_rx[dir];
		ry += tron_ry[dir];
		r = sim->pmap[ry][rx];
		if (canmovetron(sim, r, k-1) && !sim->bmap[(ry)/CELL][(rx)/CELL] && ry >= CELL && rx >= CELL && ry < YRES-CELL && rx < XRES-CELL)
		{
			count++;
			for (tx = rx - tron_ry[dir] , ty = ry - tron_rx[dir], j=1; abs(tx-rx) < (len-k) && abs(ty-ry) < (len-k); tx-=tron_ry[dir],ty-=tron_rx[dir],j++)
			{
				r = sim->pmap[ty][tx];
				if (canmovetron(sim, r, j+k-1) && !sim->bmap[(ty)/CELL][(tx)/CELL] && ty >= CELL && tx >= CELL && ty < YRES-CELL && tx < XRES-CELL)
				{
					if (j == (len-k))//there is a safe path, so we can break out
						return len+1;
					count++;
				}
				else //we hit a block so no need to check farther here
					break;
			}
			for (tx = rx + tron_ry[dir] , ty = ry + tron_rx[dir], j=1; abs(tx-rx) < (len-k) && abs(ty-ry) < (len-k); tx+=tron_ry[dir],ty+=tron_rx[dir],j++)
			{
				r = sim->pmap[ty][tx];
				if (canmovetron(sim, r, j+k-1) && !sim->bmap[(ty)/CELL][(tx)/CELL] && ty >= CELL && tx >= CELL && ty < YRES-CELL && tx < XRES-CELL)
				{
					if (j == (len-k))
						return len+1;
					count++;
				}
				else
					break;
			}
		}
		else //a block infront, no need to continue
			break;
	}
	return count;
}

static bool canmovetron(Simulation * sim, int r, int len)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	if (!r || (TYP(r) == PT_SWCH && sim->parts[ID(r)].life >= 10) || (TYP(r) == PT_INVIS && sim->parts[ID(r)].tmp2 == 1))
		return true;
	if ((((elements[TYP(r)].Properties & PROP_LIFE_KILL_DEC) && sim->parts[ID(r)].life > 0)|| ((elements[TYP(r)].Properties & PROP_LIFE_KILL) && (elements[TYP(r)].Properties & PROP_LIFE_DEC))) && sim->parts[ID(r)].life < len)
		return true;
	return false;
}


=== src\simulation\elements\TSNS.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_TSNS()
{
	Identifier = "DEFAULT_PT_TSNS";
	Name = "TSNS";
	Colour = 0xFD00D5_rgb;
	MenuVisible = 1;
	MenuSection = SC_SENSOR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 0;
	Description = "Temperature sensor, creates a spark when there's a nearby particle with a greater temperature.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.tmp2 = 2;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int rd = parts[i].tmp2;
	if (rd > 25)
		parts[i].tmp2 = rd = 25;
	if (parts[i].life)
	{
		parts[i].life = 0;
		for (int rx = -2; rx <= 2; rx++)
		{
			for (int ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					int r = pmap[y+ry][x+rx];
					if (!r)
						r = sim->photons[y+ry][x+rx];
					if (!r)
						continue;
					int rt = TYP(r);
					auto pavg = sim->parts_avg(i, ID(r), PT_INSL);
					if (pavg != PT_INSL && pavg != PT_RSSS)
					{
						if ((elements[rt].Properties&PROP_CONDUCTS) && !(rt == PT_WATR || rt == PT_SLTW || rt == PT_NTCT || rt == PT_PTCT || rt == PT_INWR) && parts[ID(r)].life == 0)
						{
							parts[ID(r)].life = 4;
							parts[ID(r)].ctype = rt;
							sim->part_change_type(ID(r), x+rx, y+ry, PT_SPRK);
						}
					}
				}
			}
		}
	}
	bool setFilt = false;
	int photonWl = 0;
	for (int rx = -rd; rx <= rd; rx++)
		for (int ry = -rd; ry <= rd; ry++)
			if (x + rx >= 0 && y + ry >= 0 && x + rx < XRES && y + ry < YRES && (rx || ry))
			{
				int r = pmap[y+ry][x+rx];
				if (!r)
					r = sim->photons[y+ry][x+rx];
				if (!r)
					continue;
				if (parts[i].tmp == 0 && TYP(r) != PT_TSNS && TYP(r) != PT_METL && parts[ID(r)].temp > parts[i].temp)
					parts[i].life = 1;
				if (parts[i].tmp == 2 && TYP(r) != PT_TSNS && TYP(r) != PT_METL && parts[ID(r)].temp < parts[i].temp)
					parts[i].life = 1;
				if (parts[i].tmp == 1 && TYP(r) != PT_TSNS && TYP(r) != PT_FILT)
				{
					setFilt = true;
					photonWl = int(parts[ID(r)].temp);
				}
			}
	if (setFilt)
	{
		for (int rx = -1; rx <= 1; rx++)
		{
			for (int ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					int r = pmap[y+ry][x+rx];
					if (!r)
						continue;
					auto nx = x + rx;
					auto ny = y + ry;
					while (TYP(r) == PT_FILT)
					{
						parts[ID(r)].ctype = 0x10000000 + photonWl;
						nx += rx;
						ny += ry;
						if (nx < 0 || ny < 0 || nx >= XRES || ny >= YRES)
							break;
						r = pmap[ny][nx];
					}
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\TTAN.cpp ===

#include "simulation/ElementCommon.h"
#include "simulation/Air.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_TTAN()
{
	Identifier = "DEFAULT_PT_TTAN";
	Name = "TTAN";
	Colour = 0x909090_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 50;

	Weight = 100;

	HeatConduct = 251;
	Description = "Titanium. Higher melting temperature than most other metals, blocks all air pressure.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_HOT_GLOW|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 1941.0f;
	HighTemperatureTransition = PT_LAVA;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	int ttan = 0;
	if (nt <= 2)
		ttan = 2;
	else if (parts[i].tmp)
		ttan = 2;
	else if (nt <= 6)
	{
		for (int rx = -1; rx <= 1; rx++)
		{
			for (int ry = -1; ry <= 1; ry++)
			{
				if (!rx != !ry)
				{
					if (TYP(pmap[y+ry][x+rx]) == PT_TTAN)
						ttan++;
				}
			}
		}
	}

	if (ttan >= 2)
	{
		sim->air->bmap_blockair[y/CELL][x/CELL] = 1;
		sim->air->bmap_blockairh[y/CELL][x/CELL] = 0x8;
	}
	return 0;
}


=== src\simulation\elements\TUNG.cpp ===

#include "simulation/ElementCommon.h"
#include "simulation/Air.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_TUNG()
{
	Identifier = "DEFAULT_PT_TUNG";
	Name = "TUNG";
	Colour = 0x505050_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 1;
	Hardness = 1;

	Weight = 100;

	HeatConduct = 251;
	Description = "Tungsten. Brittle metal with a very high melting point.";

	Properties = TYPE_SOLID|PROP_CONDUCTS|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 3695.0f;// TUNG melts in its update function instead of in the normal way, but store the threshold here so that it can be changed from Lua
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	bool splode = false;
	const float MELTING_POINT = elements[PT_TUNG].HighTemperature;

	if(parts[i].temp > 2400.0)
	{
		for (auto rx = -1; rx <= 1; rx++)
		{
			for (auto ry = -1; ry <= 1; ry++)
			{
				if (rx || ry)
				{
					auto r = pmap[y+ry][x+rx];
					if(TYP(r) == PT_O2)
					{
						splode = true;
					}
				}
			}
		}
	}
	if((parts[i].temp > MELTING_POINT && sim->rng.chance(1, 20)) || splode)
	{
		if (sim->rng.chance(1, 50))
		{
			sim->pv[y/CELL][x/CELL] += 50.0f;
		}
		else if (sim->rng.chance(1, 100))
		{
			sim->part_change_type(i, x, y, PT_FIRE);
			parts[i].life = sim->rng.between(0, 499);
			return 1;
		}
		else
		{
			sim->part_change_type(i, x, y, PT_LAVA);
			parts[i].ctype = PT_TUNG;
			return 1;
		}
		if(splode)
		{
			parts[i].temp = restrict_flt(MELTING_POINT + sim->rng.between(200, 799), MIN_TEMP, MAX_TEMP);
		}
		parts[i].vx += sim->rng.between(-50, 50);
		parts[i].vy += sim->rng.between(-50, 50);
		return 1;
	}
	auto press = int(sim->pv[y/CELL][x/CELL] * 64);
	auto diff = press - parts[i].tmp3;
	if (diff > 32 || diff < -32)
	{
		sim->part_change_type(i,x,y,PT_BRMT);
		parts[i].ctype = PT_TUNG;
		return 1;
	}
	parts[i].tmp3 = press;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	const float MELTING_POINT = elements[PT_TUNG].HighTemperature;
	double startTemp = (MELTING_POINT - 1500.0);
	double tempOver = (((cpart->temp - startTemp)/1500.0)*TPT_PI_FLT) - (TPT_PI_FLT/2.0);
	if(tempOver > -(TPT_PI_FLT/2.0))
	{
		if(tempOver > (TPT_PI_FLT/2.0))
			tempOver = (TPT_PI_FLT/2.0);
		double gradv = sin(tempOver) + 1.0;
		*firer = (int)(gradv * 258.0);
		*fireg = (int)(gradv * 156.0);
		*fireb = (int)(gradv * 112.0);
		*firea = 30;

		*colr += *firer;
		*colg += *fireg;
		*colb += *fireb;
		*pixel_mode |= FIRE_ADD;
	}
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].tmp3 = int(sim->pv[y/CELL][x/CELL] * 64);
}


=== src\simulation\elements\URAN.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_URAN()
{
	Identifier = "DEFAULT_PT_URAN";
	Name = "URAN";
	Colour = 0x707020_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.4f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.4f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;
	PhotonReflectWavelengths = 0x003FC000;

	Weight = 90;

	DefaultProperties.temp = R_TEMP + 30.0f + 273.15f;
	HeatConduct = 251;
	Description = "Uranium. Heavy particles. Generates heat under pressure.";

	Properties = TYPE_PART | PROP_RADIOACTIVE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (!sim->legacy_enable && sim->pv[y/CELL][x/CELL]>0.0f)
	{
		if (parts[i].temp == MIN_TEMP)
		{
			parts[i].temp += .01f;
		}
		else
		{
			parts[i].temp = restrict_flt((parts[i].temp*(1 + (sim->pv[y / CELL][x / CELL] / 2000))) + MIN_TEMP, MIN_TEMP, MAX_TEMP);
		}
	}
	return 0;
}


=== src\simulation\elements\VIBR.cpp ===

#include "simulation/ElementCommon.h"
#include "VIBR.h"

void Element::Element_VIBR()
{
	Identifier = "DEFAULT_PT_VIBR";
	Name = "VIBR";
	Colour = 0x005000_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.85f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = 273.15f;
	HeatConduct = 251;
	Description = "Vibranium. Stores energy and releases it in violent explosions.";

	Properties = TYPE_SOLID|PROP_LIFE_DEC;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &Element_VIBR_update;
	Graphics = &Element_VIBR_graphics;
}

constexpr int orbit_rx[8] = { -1,  0,  1,  1,  1,  0, -1, -1 };
constexpr int orbit_ry[8] = { -1, -1, -1,  0,  1,  1,  1,  0 };

int Element_VIBR_update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int rndstore = 0;
	if (!parts[i].life) //if not exploding
	{
		//Heat absorption code
		if (parts[i].temp > 274.65f)
		{
			parts[i].tmp++;
			parts[i].temp -= 3;
		}
		else if (parts[i].temp < 271.65f)
		{
			parts[i].tmp--;
			parts[i].temp += 3;
		}
		//Pressure absorption code
		if (sim->pv[y/CELL][x/CELL] > 2.5)
		{
			parts[i].tmp += 7;
			sim->pv[y/CELL][x/CELL]--;
		}
		else if (sim->pv[y/CELL][x/CELL] < -2.5)
		{
			parts[i].tmp -= 2;
			sim->pv[y/CELL][x/CELL]++;
		}
		//initiate explosion counter
		if (parts[i].tmp > 1000)
			parts[i].life = 750;
	}
	else //if it is exploding
	{
		//Release sparks before explode
		rndstore = sim->rng.gen();
		if (parts[i].life < 300)
		{
			auto rx = orbit_rx[rndstore & 7];
			auto ry = orbit_ry[rndstore & 7];
			rndstore = rndstore >> 3;
			auto r = pmap[y+ry][x+rx];
			if (TYP(r) && TYP(r) != PT_BREC && (elements[TYP(r)].Properties&PROP_CONDUCTS) && !parts[ID(r)].life)
			{
				parts[ID(r)].life = 4;
				parts[ID(r)].ctype = TYP(r);
				sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
			}
		}
		//Release all heat
		if (parts[i].life < 500)
		{
			auto rx = rndstore%7-3;
			auto ry = (rndstore>>3)%7-3;
			auto r = pmap[y+ry][x+rx];
			if (TYP(r) && TYP(r) != PT_VIBR && TYP(r) != PT_BVBR && (!sim->IsHeatInsulator(parts[ID(r)])))
			{
				parts[ID(r)].temp = restrict_flt(parts[ID(r)].temp + parts[i].tmp * 3, MIN_TEMP, MAX_TEMP);
				parts[i].tmp = 0;
			}
		}
		//Explosion code
		if (parts[i].life == 1)
		{
			if (!parts[i].tmp2)
			{
				rndstore = sim->rng.gen();
				int index = sim->create_part(-3, x + (orbit_rx[rndstore & 7]), y + (orbit_ry[rndstore & 7]), PT_ELEC);
				if (index != -1)
					parts[index].temp = 7000;
				index = sim->create_part(-3, x + (orbit_rx[(rndstore >> 3) & 7]), y + (orbit_ry[(rndstore >> 3) & 7]), PT_PHOT);
				if (index != -1)
					parts[index].temp = 7000;
				index = sim->create_part(-1, x + (orbit_rx[(rndstore >> 6) & 7]), y + (orbit_ry[(rndstore >> 6) & 7]), PT_BREC);
				if (index != -1)
					parts[index].temp = 7000;
				sim->create_part(i, x, y, PT_EXOT);
				parts[i].tmp2 = (rndstore >> 9) % 1000;
				parts[i].temp=9000;
				sim->pv[y/CELL][x/CELL] += 50;

				return 1;
			}
			else
			{
				parts[i].tmp2 = 0;
				parts[i].temp = 273.15f;
				parts[i].tmp = 0;
			}
		}
	}
	//Neighbor check loop
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (parts[i].life)
				{
					//Makes EXOT around it get tmp to start exploding too
					if ((TYP(r)==PT_VIBR  || TYP(r)==PT_BVBR))
					{
						if (!parts[ID(r)].life)
							parts[ID(r)].tmp += 45;
						else if (parts[i].tmp2 && parts[i].life > 75 && sim->rng.chance(1, 2))
						{
							parts[ID(r)].tmp2 = 1;
							parts[i].tmp = 0;
						}
					}
					else if (TYP(r)==PT_CFLM)
					{
						parts[i].tmp2 = 1;
						parts[i].tmp = 0;
					}
				}
				else
				{
					//Melts into EXOT
					if (TYP(r) == PT_EXOT && sim->rng.chance(1, 25))
					{
						sim->part_change_type(i, x, y, PT_EXOT);
						return 1;
					}
				}
				//VIBR+ANAR=BVBR
				if (parts[i].type != PT_BVBR && TYP(r) == PT_ANAR)
				{
					sim->part_change_type(i,x,y,PT_BVBR);
					sim->pv[y/CELL][x/CELL] -= 1;
				}
			}
		}
	}
	for (auto trade = 0; trade < 9; trade++)
	{
		if (!(trade%2))
			rndstore = sim->rng.gen();
		auto rx = rndstore%7-3;
		rndstore >>= 3;
		auto ry = rndstore%7-3;
		rndstore >>= 3;
		if (rx || ry)
		{
			auto r = pmap[y+ry][x+rx];
			if (TYP(r) != PT_VIBR && TYP(r) != PT_BVBR)
				continue;
			if (parts[i].tmp > parts[ID(r)].tmp)
			{
				auto transfer = parts[i].tmp - parts[ID(r)].tmp;
				parts[ID(r)].tmp += transfer/2;
				parts[i].tmp -= transfer/2;
				break;
			}
		}
	}
	parts[i].tmp = std::clamp(parts[i].tmp, 0, 1 << 15);
	return 0;
}

int Element_VIBR_graphics(GRAPHICS_FUNC_ARGS)
{
	int gradient = cpart->tmp/10;
	if (gradient >= 100 || cpart->life)
	{
		*colr = (int)(fabs(sin(exp((750.0f-cpart->life)/170)))*200.0f);
		if (cpart->tmp2)
		{
			*colg = *colr;
			*colb = 255;
		}
		else
		{
			*colg = 255;
			*colb = *colr;
		}

		*firea = 90;
		*firer = *colr;
		*fireg = *colg;
		*fireb = *colb;
		*pixel_mode = PMODE_NONE;
		*pixel_mode |= FIRE_BLEND;
	}
	else if (gradient < 100)
	{
		*colr += (int)restrict_flt(gradient*2.0f,0,255);
		*colg += (int)restrict_flt(gradient*2.0f,0,175);
		*colb += (int)restrict_flt(gradient*2.0f,0,255);
		*firea = (int)restrict_flt(gradient*.6f,0,60);
		*firer = *colr/2;
		*fireg = *colg/2;
		*fireb = *colb/2;
		*pixel_mode |= FIRE_BLEND;
	}
	return 0;
}


=== src\simulation\elements\VIBR.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_VIBR_graphics(GRAPHICS_FUNC_ARGS);
int Element_VIBR_update(UPDATE_FUNC_ARGS);


=== src\simulation\elements\VINE.cpp ===

#include "simulation/ElementCommon.h"
#include <algorithm>

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_VINE()
{
	Identifier = "DEFAULT_PT_VINE";
	Name = "VINE";
	Colour = 0x079A00_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 20;
	Explosive = 0;
	Meltable = 0;
	Hardness = 10;

	Weight = 100;

	HeatConduct = 65;
	Description = "Vine, can grow along WOOD.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 573.0f;
	HighTemperatureTransition = PT_FIRE;

	DefaultProperties.tmp = 1;

	Update = &update;
	Graphics = &graphics; // this used to be missing, maybe for a reason?
}

static int update(UPDATE_FUNC_ARGS)
{
	int rndstore = sim->rng.gen();
	auto rx = (rndstore % 3) - 1;
	rndstore >>= 2;
	auto ry = (rndstore % 3) - 1;
	rndstore >>= 2;
	if (rx || ry)
	{
		auto r = pmap[y+ry][x+rx];
		if (!(rndstore % 15))
			sim->part_change_type(i, x, y, PT_PLNT);
		else if (!r)
		{
			auto np = sim->create_part(-1,x+rx,y+ry,PT_VINE);
			if (np<0) return 0;
			parts[np].temp = parts[i].temp;
			sim->part_change_type(i,x,y,PT_PLNT);
		}
	}
	if (parts[i].temp > 350 && parts[i].temp > parts[i].tmp2)
		parts[i].tmp2 = (int)parts[i].temp;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	float maxtemp = std::max((float)cpart->tmp2, cpart->temp);
	if (maxtemp > 300)
	{
		*colr += (int)restrict_flt((maxtemp-300)/5,0,58);
		*colg -= (int)restrict_flt((maxtemp-300)/2,0,102);
		*colb += (int)restrict_flt((maxtemp-300)/5,0,70);
	}
	if (maxtemp < 273)
	{
		*colg += (int)restrict_flt((273-maxtemp)/4,0,255);
		*colb += (int)restrict_flt((273-maxtemp)/1.5,0,255);
	}
	return 0;
}


=== src\simulation\elements\VIRS.cpp ===

#include "simulation/ElementCommon.h"
#include "VIRS.h"

static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_VIRS()
{
	Identifier = "DEFAULT_PT_VIRS";
	Name = "VIRS";
	Colour = 0xFE11F6_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 31;

	DefaultProperties.temp = 72.0f + 273.15f;
	HeatConduct = 251;
	Description = "Virus. Turns everything it touches into virus.";

	Properties = TYPE_LIQUID|PROP_DEADLY;
	CarriesTypeIn = 1U << FIELD_TMP2;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 305.0f;
	LowTemperatureTransition = PT_VRSS;
	HighTemperature = 673.0f;
	HighTemperatureTransition = PT_VRSG;

	DefaultProperties.tmp4 = 250;

	Update = &Element_VIRS_update;
	Graphics = &graphics;
}

int Element_VIRS_update(UPDATE_FUNC_ARGS)
{
	//tmp3 measures how many frames until it is cured (0 if still actively spreading and not being cured)
	//tmp4 measures how many frames until it dies
	int rndstore = sim->rng.gen();
	if (parts[i].tmp3)
	{
		parts[i].tmp3 -= (rndstore & 0x1) ? 0:1;
		//has been cured, so change back into the original element
		if (!parts[i].tmp3)
		{
			sim->part_change_type(i,x,y,parts[i].tmp2);
			parts[i].tmp2 = 0;
			parts[i].tmp3 = 0;
			parts[i].tmp4 = 0;
		}
		return 0;
		//cured virus is never in below code
	}
	//decrease tmp4 so it slowly dies
	if (parts[i].tmp4)
	{
		if (!(rndstore & 0x7) && --parts[i].tmp4 <= 0)
		{
			sim->kill_part(i);
			return 1;
		}
		rndstore >>= 3;
	}

	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;

				//spread "being cured" state
				if (parts[ID(r)].tmp3 && (TYP(r) == PT_VIRS || TYP(r) == PT_VRSS || TYP(r) == PT_VRSG))
				{
					parts[i].tmp3 = parts[ID(r)].tmp3 + ((rndstore & 0x3) ? 2:1);
					return 0;
				}
				//soap cures virus
				else if (TYP(r) == PT_SOAP)
				{
					parts[i].tmp3 += 10;
					if (!(rndstore & 0x3))
						sim->kill_part(ID(r));
					return 0;
				}
				else if (TYP(r) == PT_PLSM)
				{
					if (surround_space && sim->rng.chance(10 + int(sim->pv[(y+ry)/CELL][(x+rx)/CELL]), 100))
					{
						sim->create_part(i, x, y, PT_PLSM);
						return 1;
					}
				}
				//transforms things into virus here
				else if (TYP(r) != PT_VIRS && TYP(r) != PT_VRSS && TYP(r) != PT_VRSG && TYP(r) != PT_DMND)
				{
					if (!(rndstore & 0x7))
					{
						parts[ID(r)].tmp2 = TYP(r);
						parts[ID(r)].tmp3 = 0;
						if (parts[i].tmp4)
							parts[ID(r)].tmp4 = parts[i].tmp4 + 1;
						else
							parts[ID(r)].tmp4 = 0;
						if (parts[ID(r)].temp < 305.0f)
							sim->part_change_type(ID(r), x+rx, y+ry, PT_VRSS);
						else if (parts[ID(r)].temp > 673.0f)
							sim->part_change_type(ID(r), x+rx, y+ry, PT_VRSG);
						else
							sim->part_change_type(ID(r), x+rx, y+ry, PT_VIRS);
					}
					rndstore >>= 3;
				}
				//protons make VIRS last forever
				else if (TYP(sim->photons[y+ry][x+rx]) == PT_PROT)
				{
					parts[i].tmp4 = 0;
				}
			}
			//reset rndstore only once, halfway through
			else if (!rx && !ry)
				rndstore = sim->rng.gen();
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*pixel_mode |= PMODE_BLUR;
	*pixel_mode |= NO_DECO;
	return 1;
}


=== src\simulation\elements\VIRS.h ===

#pragma once
#include "simulation/ElementDefs.h"

int Element_VIRS_update(UPDATE_FUNC_ARGS);


=== src\simulation\elements\VOID.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_VOID()
{
	Identifier = "DEFAULT_PT_VOID";
	Name = "VOID";
	Colour = 0x790B0B_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 1.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = -0.0003f* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 251;
	Description = "Hole, will drain away any particles.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
	CtypeDraw = &Element::basicCtypeDraw;
}


=== src\simulation\elements\VRSG.cpp ===

#include "simulation/ElementCommon.h"
#include "VIRS.h"

static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_VRSG()
{
	Identifier = "DEFAULT_PT_VRSG";
	Name = "VRSG";
	Colour = 0xFE68FE_rgb;
	MenuVisible = 0;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 1.0f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 0.75f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 500;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 1;

	DefaultProperties.temp = 522.0f + 273.15f;
	HeatConduct = 251;
	Description = "Gas Virus. Turns everything it touches into virus.";

	Properties = TYPE_GAS|PROP_DEADLY;
	CarriesTypeIn = 1U << FIELD_TMP2;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 673.0f;
	LowTemperatureTransition = PT_VIRS;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.tmp4 = 250;

	Update = &Element_VIRS_update;
	Graphics = &graphics;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*pixel_mode &= ~PMODE;
	*pixel_mode |= FIRE_BLEND;
	*firer = *colr/2;
	*fireg = *colg/2;
	*fireb = *colb/2;
	*firea = 125;
	*pixel_mode |= NO_DECO;
	return 1;
}


=== src\simulation\elements\VRSS.cpp ===

#include "simulation/ElementCommon.h"
#include "VIRS.h"

static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_VRSS()
{
	Identifier = "DEFAULT_PT_VRSS";
	Name = "VRSS";
	Colour = 0xD408CD_rgb;
	MenuVisible = 0;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = R_TEMP + 273.15f;
	HeatConduct = 251;
	Description = "Solid Virus. Turns everything it touches into virus.";

	Properties = TYPE_SOLID|PROP_DEADLY;
	CarriesTypeIn = 1U << FIELD_TMP2;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 305.0f;
	HighTemperatureTransition = PT_VIRS;

	DefaultProperties.tmp4 = 250;

	Update = &Element_VIRS_update;
	Graphics = &graphics;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*pixel_mode |= NO_DECO;
	return 1;
}


=== src\simulation\elements\VSNS.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_VSNS()
{
	Identifier = "DEFAULT_PT_VSNS";
	Name = "VSNS";
	Colour = 0x7C9C00_rgb;
	MenuVisible = 1;
	MenuSection = SC_SENSOR;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 1;

	Weight = 100;

	DefaultProperties.temp = 4.0f + 273.15f;
	HeatConduct = 0;
	Description = "Velocity sensor, creates a spark when there's a nearby particle with velocity higher than its temperature.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	DefaultProperties.tmp2 = 2;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int rd = parts[i].tmp2;
	if (rd > 25) parts[i].tmp2 = rd = 25;
	if (parts[i].life)
	{
		parts[i].life = 0;
		for (int rx = -2; rx <= 2; rx++)
		{
			for (int ry = -2; ry <= 2; ry++)
			{
				if (rx || ry)
				{
					int r = pmap[y + ry][x + rx];
					if (!r)
						continue;
					int rt = TYP(r);
					auto pavg = sim->parts_avg(i, ID(r), PT_INSL);
					if (pavg != PT_INSL && pavg != PT_RSSS)
					{
						if ((elements[rt].Properties &PROP_CONDUCTS) && !(rt == PT_WATR || rt == PT_SLTW || rt == PT_NTCT || rt == PT_PTCT || rt == PT_INWR) && parts[ID(r)].life == 0)
						{
							parts[ID(r)].life = 4;
							parts[ID(r)].ctype = rt;
							sim->part_change_type(ID(r), x + rx, y + ry, PT_SPRK);
						}
					}
				}
			}
		}
	}
	bool doSerialization = false;
	bool doDeserialization = false;
	float Vs = 0;
	for (int rx = -rd; rx < rd + 1; rx++)
		for (int ry = -rd; ry < rd + 1; ry++)
			if (x + rx >= 0 && y + ry >= 0 && x + rx < XRES && y + ry < YRES && (rx || ry))
			{
				int r = pmap[y + ry][x + rx];
				if (!r)
					r = sim->photons[y + ry][x + rx];
				if (!r)
					continue;
				float Vx = parts[ID(r)].vx;
				float Vy = parts[ID(r)].vy;
				float Vm = sqrt(Vx*Vx + Vy*Vy);

				switch (parts[i].tmp)
				{
				case 1:
					// serialization
					if (TYP(r) != PT_VSNS && TYP(r) != PT_FILT && !(elements[TYP(r)].Properties & TYPE_SOLID))
					{
						doSerialization = true;
						Vs = Vm;
					}
					break;
				case 3:
					// deserialization
					if (TYP(r) == PT_FILT)
					{
						int vel = parts[ID(r)].ctype - 0x10000000;
						if (vel >= 0 && vel < MAX_VELOCITY)
						{
							doDeserialization = true;
							Vs = float(vel);
						}
					}
					break;
				case 2:
					// Invert mode
					if (!(elements[TYP(r)].Properties & TYPE_SOLID) && Vm <= parts[i].temp - 273.15)
						parts[i].life = 1;
					break;
				default:
					// Normal mode
					if (!(elements[TYP(r)].Properties & TYPE_SOLID) && Vm > parts[i].temp - 273.15)
						parts[i].life = 1;
					break;
				}
			}

	for (int rx = -1; rx <= 1; rx++)
	{
		for (int ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				int r = pmap[y + ry][x + rx];
				if (!r)
					r = sim->photons[y + ry][x + rx];
				if (!r)
					continue;
				int nx = x + rx;
				int ny = y + ry;
				//Serialization.
				if (doSerialization)
				{
					while (TYP(r) == PT_FILT)
					{
						parts[ID(r)].ctype = 0x10000000 + (int)(Vs + 0.5f);
						nx += rx;
						ny += ry;
						if (nx < 0 || ny < 0 || nx >= XRES || ny >= YRES)
							break;
						r = pmap[ny][nx];
					}
				}
				//Deserialization.
				if (doDeserialization)
				{
					if (TYP(r) != PT_FILT && !(elements[TYP(r)].Properties & TYPE_SOLID))
					{
						float Vx = parts[ID(r)].vx;
						float Vy = parts[ID(r)].vy;
						float Vm = sqrt(Vx*Vx + Vy*Vy);
						if (Vm > 0)
						{
							parts[ID(r)].vx *= Vs / Vm;
							parts[ID(r)].vy *= Vs / Vm;
						}
						break;
					}
				}
			}
		}
	}

	return 0;
}


=== src\simulation\elements\WARP.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);
static void create(ELEMENT_CREATE_FUNC_ARGS);

void Element::Element_WARP()
{
	Identifier = "DEFAULT_PT_WARP";
	Name = "WARP";
	Colour = 0x101010_rgb;
	MenuVisible = 1;
	MenuSection = SC_NUCLEAR;
	Enabled = 1;

	Advection = 0.8f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.9f;
	Loss = 0.70f;
	Collision = -0.1f;
	Gravity = 0.0f;
	Diffusion = 3.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 1;

	HeatConduct = 100;
	Description = "Displaces other elements.";

	Properties = TYPE_GAS|PROP_LIFE_DEC|PROP_LIFE_KILL;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
	Create = &create;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].tmp2 > 2000)
	{
		parts[i].temp = 10000;
		sim->pv[y/CELL][x/CELL] += (parts[i].tmp2 / 5000) * CFDS;
		if (sim->rng.chance(1, 50))
			sim->create_part(-3, x, y, PT_ELEC);
	}
	for (int trade = 0; trade < 5; trade ++)
	{
		int rx = sim->rng.between(-1, 1);
		int ry = sim->rng.between(-1, 1);
		if (rx || ry)
		{
			int r = pmap[y + ry][x + rx];
			if (!r)
				continue;
			if (TYP(r) != PT_WARP && TYP(r) != PT_STKM && TYP(r) != PT_STKM2 && TYP(r) != PT_DMND && TYP(r) != PT_CLNE && TYP(r) != PT_BCLN && TYP(r) != PT_PCLN)
			{
				parts[i].x = parts[ID(r)].x;
				parts[i].y = parts[ID(r)].y;
				parts[ID(r)].x = float(x);
				parts[ID(r)].y = float(y);
				parts[ID(r)].vx = sim->rng.between(-2, 1) + 0.5f;
				parts[ID(r)].vy = float(sim->rng.between(-2, 1));
				parts[i].life += 4;
				pmap[y][x] = r;
				pmap[y + ry][x + rx] = PMAP(i, parts[i].type);
				trade = 5;
			}
		}
	}
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	*colr = *colg = *colb = *cola = 0;
	*pixel_mode |= NO_DECO;
	return 0;
}

static void create(ELEMENT_CREATE_FUNC_ARGS)
{
	sim->parts[i].life = sim->rng.between(70, 164);
}


=== src\simulation\elements\WATR.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_WATR()
{
	Identifier = "DEFAULT_PT_WATR";
	Name = "WATR";
	Colour = 0x2030D0_rgb;
	MenuVisible = 1;
	MenuSection = SC_LIQUID;
	Enabled = 1;

	Advection = 0.6f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.98f;
	Loss = 0.95f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 2;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 20;

	Weight = 30;

	DefaultProperties.temp = R_TEMP - 2.0f + 273.15f;
	HeatConduct = 29;
	LatentHeat = 7500;
	Description = "Water. Conducts electricity, freezes, and extinguishes fires.";

	Properties = TYPE_LIQUID | PROP_CONDUCTS | PROP_LIFE_DEC | PROP_NEUTPASS | PROP_PHOTPASS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 273.15f;
	LowTemperatureTransition = PT_ICEI;
	HighTemperature = 373.0f;
	HighTemperatureTransition = PT_WTRV;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_SALT && sim->rng.chance(1, 50))
				{
					sim->part_change_type(i,x,y,PT_SLTW);
					// on average, convert 3 WATR to SLTW before SALT turns into SLTW
					if (sim->rng.chance(1, 3))
						sim->part_change_type(ID(r),x+rx,y+ry,PT_SLTW);
				}
				else if ((TYP(r)==PT_RBDM||TYP(r)==PT_LRBD) && (sim->legacy_enable||parts[i].temp>(273.15f+12.0f)) && sim->rng.chance(1, 100))
				{
					sim->part_change_type(i,x,y,PT_FIRE);
					parts[i].life = 4;
					parts[i].ctype = PT_WATR;
				}
				else if (TYP(r)==PT_FIRE && parts[ID(r)].ctype!=PT_WATR)
				{
					sim->kill_part(ID(r));
					if (sim->rng.chance(1, 30))
					{
						sim->kill_part(i);
						return 1;
					}
				}
				else if (TYP(r)==PT_SLTW && sim->rng.chance(1, 2000))
				{
					sim->part_change_type(i,x,y,PT_SLTW);
				}
				else if (TYP(r)==PT_ROCK && fabs(parts[i].vx)+fabs(parts[i].vy) >= 0.5 && sim->rng.chance(1, 1000)) // ROCK erosion
				{
					if (sim->rng.chance(1,3))
						sim->part_change_type(ID(r),x+rx,y+ry,PT_SAND);
					else
						sim->part_change_type(ID(r),x+rx,y+ry,PT_STNE);
				}
			}
		}
	}
	return 0;
}


=== src\simulation\elements\WAX.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_WAX()
{
	Identifier = "DEFAULT_PT_WAX";
	Name = "WAX";
	Colour = 0xF0F0BB_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 10;

	Weight = 100;

	HeatConduct = 44;
	Description = "Flammable, melts at moderately high temperatures.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 319.0f;
	HighTemperatureTransition = PT_MWAX;
}


=== src\simulation\elements\WHOL.cpp ===

#include "simulation/ElementCommon.h"

void Element::Element_WHOL()
{
	Identifier = "DEFAULT_PT_WHOL";
	Name = "VENT";
	Colour = 0xEFEFEF_rgb;
	MenuVisible = 1;
	MenuSection = SC_SPECIAL;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.95f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.010f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	DefaultProperties.temp = R_TEMP - 16.0f + 273.15f;
	HeatConduct = 255;
	Description = "Air vent, creates pressure and pushes other particles away.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;
}


=== src\simulation\elements\WIFI.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_WIFI()
{
	Identifier = "DEFAULT_PT_WIFI";
	Name = "WIFI";
	Colour = 0x40A060_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 2;

	Weight = 100;

	HeatConduct = 0;
	Description = "Wireless transmitter, transfers spark to any other wifi on the same temperature channel.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = 15.0f;
	HighPressureTransition = PT_BRMT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	parts[i].tmp = (int)((parts[i].temp-73.15f)/100+1);
	if (parts[i].tmp>=CHANNELS) parts[i].tmp = CHANNELS-1;
	else if (parts[i].tmp<0) parts[i].tmp = 0;
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				// wireless[][0] - whether channel is active on this frame
				// wireless[][1] - whether channel should be active on next frame
				if (sim->wireless[parts[i].tmp][0])
				{
					if ((TYP(r)==PT_NSCN||TYP(r)==PT_PSCN||TYP(r)==PT_INWR)&&parts[ID(r)].life==0 && sim->wireless[parts[i].tmp][0])
					{
						parts[ID(r)].ctype = TYP(r);
						sim->part_change_type(ID(r),x+rx,y+ry,PT_SPRK);
						parts[ID(r)].life = 4;
					}
				}
				if (TYP(r)==PT_SPRK && parts[ID(r)].ctype!=PT_NSCN && parts[ID(r)].life>=3)
				{
					sim->wireless[parts[i].tmp][1] = 1;
					sim->ISWIRE = 2;
				}
			}
		}
	}
	return 0;
}

constexpr float FREQUENCY = 0.0628f;

static int graphics(GRAPHICS_FUNC_ARGS)
{
	int q = (int)((cpart->temp-73.15f)/100+1);
	*colr = int(sin(FREQUENCY*q + 0) * 127 + 128);
	*colg = int(sin(FREQUENCY*q + 2) * 127 + 128);
	*colb = int(sin(FREQUENCY*q + 4) * 127 + 128);
	*pixel_mode |= EFFECT_DBGLINES;
	return 0;
}


=== src\simulation\elements\WIRE.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_WIRE()
{
	Identifier = "DEFAULT_PT_WIRE";
	Name = "WWLD";
	Colour = 0xFFCC00_rgb;
	MenuVisible = 1;
	MenuSection = SC_ELEC;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.00f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f  * CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 0;

	Weight = 100;

	HeatConduct = 250;
	Description = "WireWorld wires, conducts based on a set of GOL-like rules.";

	Properties = TYPE_SOLID;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	int count=0;
	/*
	  0:  wire
	  1:  spark head
	  2:  spark tail

	  tmp is previous state, ctype is current state
	*/
	//parts[i].tmp=parts[i].ctype;
	parts[i].ctype=0;
	if (parts[i].tmp==1)
	{
		parts[i].ctype=2;
	}
	else if (parts[i].tmp==2)
	{
		parts[i].ctype=0;
	}
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_SPRK && parts[ID(r)].life==3 && parts[ID(r)].ctype==PT_PSCN)
				{
					parts[i].ctype=1;
					return 0;
				}
				else if (TYP(r)==PT_NSCN && parts[i].tmp==1)
					sim->create_part(-1, x+rx, y+ry, PT_SPRK);
				else if (TYP(r)==PT_WIRE && parts[ID(r)].tmp==1 && !parts[i].tmp)
					count++;
			}
		}
	}
	if (count==1 || count==2)
		parts[i].ctype=1;
	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	if (cpart->ctype==0)
	{
		*colr = 255;
		*colg = 204;
		*colb = 0;
		return 0;
	}
	if (cpart->ctype==1)
	{
		*colr = 50;
		*colg = 100;
		*colb = 255;
		//*pixel_mode |= PMODE_GLOW;
		return 0;
	}
	if (cpart->ctype==2)
	{
		*colr = 255;
		*colg = 100;
		*colb = 50;
		//*pixel_mode |= PMODE_GLOW;
		return 0;
	}
	return 0;
}


=== src\simulation\elements\WOOD.cpp ===

#include "simulation/ElementCommon.h"
#include <algorithm>

static int update(UPDATE_FUNC_ARGS);
static int graphics(GRAPHICS_FUNC_ARGS);

void Element::Element_WOOD()
{
	Identifier = "DEFAULT_PT_WOOD";
	Name = "WOOD";
	Colour = 0xC0A040_rgb;
	MenuVisible = 1;
	MenuSection = SC_SOLIDS;
	Enabled = 1;

	Advection = 0.0f;
	AirDrag = 0.00f * CFDS;
	AirLoss = 0.90f;
	Loss = 0.00f;
	Collision = 0.0f;
	Gravity = 0.0f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 0;

	Flammable = 20;
	Explosive = 0;
	Meltable = 0;
	Hardness = 15;

	Weight = 100;

	HeatConduct = 164;
	Description = "Wood, flammable.";

	Properties = TYPE_SOLID | PROP_NEUTPENETRATE;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 873.0f;
	HighTemperatureTransition = PT_FIRE;

	Update = &update;
	Graphics = &graphics;
}

static int update(UPDATE_FUNC_ARGS)
{
	if (parts[i].temp > 450 && parts[i].temp > parts[i].tmp)
		parts[i].tmp = (int)parts[i].temp;

	if (parts[i].temp > 773.0f && sim->pv[y/CELL][x/CELL] <= -10.0f)
	{
		float temp = parts[i].temp;
		sim->create_part(i, x, y, PT_BCOL);
		parts[i].temp = temp;
	}

	return 0;
}

static int graphics(GRAPHICS_FUNC_ARGS)
{
	float maxtemp = std::max((float)cpart->tmp, cpart->temp);
	if (maxtemp > 400)
	{
		*colr -= (int)restrict_flt((maxtemp-400)/3,0,172);
		*colg -= (int)restrict_flt((maxtemp-400)/4,0,140);
		*colb -= (int)restrict_flt((maxtemp-400)/20,0,44);
	}
	if (maxtemp < 273)
	{
		*colr -= (int)restrict_flt((273-maxtemp)/5,0,40);
		*colg += (int)restrict_flt((273-maxtemp)/4,0,40);
		*colb += (int)restrict_flt((273-maxtemp)/1.5,0,150);
	}
	return 0;
}


=== src\simulation\elements\WTRV.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_WTRV()
{
	Identifier = "DEFAULT_PT_WTRV";
	Name = "WTRV";
	Colour = 0xA0A0FF_rgb;
	MenuVisible = 1;
	MenuSection = SC_GAS;
	Enabled = 1;

	Advection = 1.0f;
	AirDrag = 0.01f * CFDS;
	AirLoss = 0.99f;
	Loss = 0.30f;
	Collision = -0.1f;
	Gravity = -0.1f;
	Diffusion = 0.75f;
	HotAir = 0.0003f	* CFDS;
	Falldown = 0;

	Flammable = 0;
	Explosive = 0;
	Meltable = 0;
	Hardness = 4;

	Weight = 1;

	DefaultProperties.temp = R_TEMP + 100.0f + 273.15f;
	HeatConduct = 48;
	Description = "Steam. Produced from hot water.";

	Properties = TYPE_GAS;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = 371.0f;
	LowTemperatureTransition = ST;
	HighTemperature = ITH;
	HighTemperatureTransition = NT;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if ((TYP(r)==PT_RBDM||TYP(r)==PT_LRBD) && !sim->legacy_enable && parts[i].temp>(273.15f+12.0f) && sim->rng.chance(1, 100))
				{
					sim->part_change_type(i,x,y,PT_FIRE);
					parts[i].life = 4;
					parts[i].ctype = PT_WATR;
				}
			}
		}
	}
	if(parts[i].temp>1273&&parts[i].ctype==PT_FIRE)
		parts[i].temp-=parts[i].temp/1000;
	return 0;
}


=== src\simulation\elements\YEST.cpp ===

#include "simulation/ElementCommon.h"

static int update(UPDATE_FUNC_ARGS);

void Element::Element_YEST()
{
	Identifier = "DEFAULT_PT_YEST";
	Name = "YEST";
	Colour = 0xEEE0C0_rgb;
	MenuVisible = 1;
	MenuSection = SC_POWDERS;
	Enabled = 1;

	Advection = 0.7f;
	AirDrag = 0.02f * CFDS;
	AirLoss = 0.96f;
	Loss = 0.80f;
	Collision = 0.0f;
	Gravity = 0.1f;
	Diffusion = 0.00f;
	HotAir = 0.000f	* CFDS;
	Falldown = 1;

	Flammable = 15;
	Explosive = 0;
	Meltable = 0;
	Hardness = 30;

	Weight = 80;

	HeatConduct = 70;
	Description = "Yeast, grows when warm (~37C).";

	Properties = TYPE_PART;

	LowPressure = IPL;
	LowPressureTransition = NT;
	HighPressure = IPH;
	HighPressureTransition = NT;
	LowTemperature = ITL;
	LowTemperatureTransition = NT;
	HighTemperature = 373.0f;
	HighTemperatureTransition = PT_DYST;

	Update = &update;
}

static int update(UPDATE_FUNC_ARGS)
{
	for (auto rx = -1; rx <= 1; rx++)
	{
		for (auto ry = -1; ry <= 1; ry++)
		{
			if (rx || ry)
			{
				auto r = pmap[y+ry][x+rx];
				if (!r)
					continue;
				if (TYP(r)==PT_DYST && sim->rng.chance(1, 6) && !sim->legacy_enable)
				{
					sim->part_change_type(i,x,y,PT_DYST);
				}
			}
		}
	}
	if (parts[i].temp > 303 && parts[i].temp < 317) {
		sim->create_part(-1, x + sim->rng.between(-1, 1), y + sim->rng.between(-1, 1), PT_YEST);
	}
	return 0;
}


=== src\simulation\gravity\Fft.cpp ===

#include "Gravity.h"
#include "Config.h"
#include "SimulationConfig.h"
#include <cstring>
#include <cmath>
#include <complex>
#include <memory>
#include <fftw3.h>
#include <thread>
#include <mutex>
#include <condition_variable>

// DFT is cyclic in nature; gravity would wrap around sort of like in loop mode without the 2x here;
// in fact it still does, it's just not as visible. the arrays are 2x as big along all dimensions as normal cell maps
constexpr auto blocks = CELLS * 2;

// https://www.fftw.org/fftw3_doc/Multi_002dDimensional-DFTs-of-Real-Data.html#Multi_002dDimensional-DFTs-of-Real-Data
constexpr auto transSize = (blocks.X / 2 + 1) * blocks.Y;

// NCELL * 4 is size of data array, scaling needed because FFTW calculates an unnormalized DFT
constexpr auto scaleFactor = -float(M_GRAV) / (NCELL * 4);

static_assert(sizeof(std::complex<float>) == sizeof(fftwf_complex));
struct FftwArrayDeleter        { void operator ()(float               ptr[]) const { fftwf_free(ptr);         } };
struct FftwComplexArrayDeleter { void operator ()(std::complex<float> ptr[]) const { fftwf_free(ptr);         } };
struct FftwPlanDeleter         { void operator ()(fftwf_plan          ptr  ) const { fftwf_destroy_plan(ptr); } };
using  FftwArrayPtr        = std::unique_ptr<float                              [], FftwArrayDeleter       >;
using  FftwComplexArrayPtr = std::unique_ptr<std::complex<float>                [], FftwComplexArrayDeleter>;
using  FftwPlanPtr         = std::unique_ptr<std::remove_pointer<fftwf_plan>::type, FftwPlanDeleter        >;
FftwArrayPtr FftwArray(size_t size)
{
	return FftwArrayPtr(reinterpret_cast<float *>(fftwf_malloc(size * sizeof(float))));
}
FftwComplexArrayPtr FftwComplexArray(size_t size)
{
	return FftwComplexArrayPtr(reinterpret_cast<std::complex<float> *>(fftwf_malloc(size * sizeof(std::complex<float>))));
}

struct GravityImpl : public Gravity
{
	FftwArrayPtr                            massBig , forceXBig , forceYBig ;
	FftwComplexArrayPtr kernelXT, kernelYT, massBigT, forceXBigT, forceYBigT;
	FftwPlanPtr massForward, forceXInverse, forceYInverse;
	bool initDone = false;

	std::thread thr;
	bool working = false;
	bool shouldStop = false;
	std::mutex stateMx;
	std::condition_variable stateCv;

	GravityInput gravIn;
	GravityOutput gravOut;
	bool copyGravOut = false;

	~GravityImpl();

	void Init();
	void Work();
	void Wait();
	void Stop();
	void Dispatch();
};

GravityImpl::~GravityImpl()
{
	if (initDone)
	{
		Wait();
		Stop();
	}
}

void GravityImpl::Dispatch()
{
	{
		std::unique_lock lk(stateMx);
		working = true;
	}
	stateCv.notify_one();
}

void GravityImpl::Stop()
{
	{
		std::unique_lock lk(stateMx);
		shouldStop = true;
	}
	stateCv.notify_one();
	thr.join();
}

void GravityImpl::Wait()
{
	std::unique_lock lk(stateMx);
	stateCv.wait(lk, [this]() {
		return !working;
	});
}

void GravityImpl::Work()
{
	{
		PlaneAdapter<PlaneBase<float>, blocks.X, blocks.Y> massBigP(blocks, std::in_place, massBig.get());
		for (auto p : CELLS.OriginRect())
		{
			// used to be a membwand but we'd need a new buffer for this,
			// not worth it just to make this unalinged copy faster
			massBigP[p + CELLS] = gravIn.mask[p] ? gravIn.mass[p] : 0.f;
		}
	}
	fftwf_execute(massForward.get());
	{
		// https://en.wikipedia.org/wiki/Convolution_theorem
		for (int i = 0; i < transSize; ++i)
		{
			forceXBigT[i] = massBigT[i] * kernelXT[i];
			forceYBigT[i] = massBigT[i] * kernelYT[i];
		}
	}
	fftwf_execute(forceXInverse.get());
	fftwf_execute(forceYInverse.get());
	{
		PlaneAdapter<PlaneBase<float>, blocks.X, blocks.Y> forceXBigP(blocks, std::in_place, forceXBig.get());
		PlaneAdapter<PlaneBase<float>, blocks.X, blocks.Y> forceYBigP(blocks, std::in_place, forceYBig.get());
		for (auto p : CELLS.OriginRect())
		{
			// similarly
			gravOut.forceX[p] = gravIn.mask[p] ? forceXBigP[p] : 0;
			gravOut.forceY[p] = gravIn.mask[p] ? forceYBigP[p] : 0;
		}
	}
}

void GravityImpl::Init()
{
	//select best algorithm, could use FFTW_PATIENT or FFTW_EXHAUSTIVE but that increases the time taken to plan, and I don't see much increase in execution speed
	auto fftwPlanFlags = FFTW_PLAN_MEASURE ? FFTW_MEASURE : FFTW_ESTIMATE;

	//use fftw malloc function to ensure arrays are aligned, to get better performance
	kernelXT = FftwComplexArray(transSize);
	kernelYT = FftwComplexArray(transSize);
	massBig = FftwArray(blocks.X * blocks.Y);
	massBigT = FftwComplexArray(transSize);
	forceXBig = FftwArray(blocks.X * blocks.Y);
	forceYBig = FftwArray(blocks.X * blocks.Y);
	forceXBigT = FftwComplexArray(transSize);
	forceYBigT = FftwComplexArray(transSize);

	massForward = FftwPlanPtr(fftwf_plan_dft_r2c_2d(blocks.Y, blocks.X, massBig.get(), reinterpret_cast<fftwf_complex *>(massBigT.get()), fftwPlanFlags));
	forceXInverse = FftwPlanPtr(fftwf_plan_dft_c2r_2d(blocks.Y, blocks.X, reinterpret_cast<fftwf_complex *>(forceXBigT.get()), forceXBig.get(), fftwPlanFlags));
	forceYInverse = FftwPlanPtr(fftwf_plan_dft_c2r_2d(blocks.Y, blocks.X, reinterpret_cast<fftwf_complex *>(forceYBigT.get()), forceYBig.get(), fftwPlanFlags));

	auto kernelXRaw = FftwArray(blocks.X * blocks.Y);
	auto kernelYRaw = FftwArray(blocks.X * blocks.Y);
	auto kernelXForward = FftwPlanPtr(fftwf_plan_dft_r2c_2d(blocks.Y, blocks.X, kernelXRaw.get(), reinterpret_cast<fftwf_complex *>(kernelXT.get()), fftwPlanFlags));
	auto kernelYForward = FftwPlanPtr(fftwf_plan_dft_r2c_2d(blocks.Y, blocks.X, kernelYRaw.get(), reinterpret_cast<fftwf_complex *>(kernelYT.get()), fftwPlanFlags));
	PlaneAdapter<PlaneBase<float>, blocks.X, blocks.Y> kernelX(blocks, std::in_place, kernelXRaw.get());
	PlaneAdapter<PlaneBase<float>, blocks.X, blocks.Y> kernelY(blocks, std::in_place, kernelYRaw.get());
	//calculate velocity map caused by a point mass
	for (auto p : blocks.OriginRect())
	{
		auto d = p - CELLS;
		if (d == Vec2{ 0, 0 })
		{
			kernelX[p] = 0.f;
			kernelY[p] = 0.f;
		}
		else
		{
			auto distance = std::hypot(float(d.X), float(d.Y));
			kernelX[p] = scaleFactor * d.X / std::pow(distance, 3.f);
			kernelY[p] = scaleFactor * d.Y / std::pow(distance, 3.f);
		}
	}

	//transform point mass velocity maps
	fftwf_execute(kernelXForward.get());
	fftwf_execute(kernelYForward.get());

	//clear padded gravmap
	std::fill(massBig.get(), massBig.get() + blocks.X * blocks.Y, 0.f);

	thr = std::thread([this]() {
		while (true)
		{
			{
				std::unique_lock lk(stateMx);
				stateCv.wait(lk, [this]() {
					return working || shouldStop;
				});
				if (shouldStop)
				{
					break;
				}
			}
			Work();
			{
				std::unique_lock lk(stateMx);
				working = false;
			}
			stateCv.notify_one();
		}
	});
}

void Gravity::Exchange(GravityOutput &gravOut, GravityInput &gravIn, bool forceRecalc)
{
	auto *fftGravity = static_cast<GravityImpl *>(this);

	// lazy init
	if (!fftGravity->initDone)
	{
		// this takes a noticeable amount of time
		// TODO: hide the wait somehow
		fftGravity->Init();
		fftGravity->initDone = true;
	}

	fftGravity->Wait();

	// take output
	if (fftGravity->copyGravOut)
	{
		fftGravity->copyGravOut = false;
		std::swap(gravOut, fftGravity->gravOut);
	}

	// pass input (but same input => same output)
	if (forceRecalc ||
	    std::memcmp(&fftGravity->gravIn.mass[{ 0, 0 }], &gravIn.mass[{ 0, 0 }], NCELL * sizeof(float)) ||
	    std::memcmp(&fftGravity->gravIn.mask[{ 0, 0 }], &gravIn.mask[{ 0, 0 }], NCELL * sizeof(float)))
	{
		fftGravity->copyGravOut = true;
		std::swap(gravIn.mass, fftGravity->gravIn.mass);
		fftGravity->gravIn.mask = gravIn.mask;
		fftGravity->Dispatch();
	}
}

GravityPtr Gravity::Create()
{
	return GravityPtr(new GravityImpl());
}

void GravityDeleter::operator ()(Gravity *ptr) const
{
	delete static_cast<GravityImpl *>(ptr);
}


=== src\simulation\gravity\Gravity.h ===

#pragma once
#include "GravityData.h"
#include "GravityPtr.h"

class Gravity
{
protected:
	Gravity() = default;

public:
	// potentially clobbers gravIn
	void Exchange(GravityOutput &gravOut, GravityInput &gravIn, bool forceRecalc);

	static GravityPtr Create();
};


=== src\simulation\gravity\GravityData.h ===

#pragma once
#include "common/Plane.h"
#include "SimulationConfig.h"
#include <cstdint>
#include <vector>

template<class Item>
using GravityPlane = PlaneAdapter<std::vector<Item>, CELLS.X, CELLS.Y>;

struct GravityInput
{
	GravityPlane<float> mass;
	GravityPlane<uint32_t> mask;
	static_assert(sizeof(float) == sizeof(uint32_t));

	GravityInput() : mass(CELLS, 0.f), mask(CELLS, UINT32_C(0xFFFFFFFF))
	{
	}
};

struct GravityOutput
{
	GravityPlane<float> forceX;
	GravityPlane<float> forceY;

	GravityOutput() : forceX(CELLS, 0.f), forceY(CELLS, 0.f)
	{
	}
};


=== src\simulation\gravity\GravityPtr.h ===

#pragma once
#include <memory>

class Gravity;
struct GravityDeleter
{
	void operator ()(Gravity *ptr) const;
};
using GravityPtr = std::unique_ptr<Gravity, GravityDeleter>;


=== src\simulation\gravity\meson.build ===

if host_platform == 'emscripten'
	# FFTW_MEASURE fails on emscripten for some reason, probably a timing issue
	# FFTW_ESTIMATE is 20% slower
	conf_data.set('FFTW_PLAN_MEASURE', 'false')
else
	conf_data.set('FFTW_PLAN_MEASURE', 'true')
endif
powder_files += files('Fft.cpp')
render_files += files('Null.cpp')


=== src\simulation\gravity\Null.cpp ===

#include "Gravity.h"

void Gravity::Exchange(GravityOutput &gravOut, GravityInput &gravIn, bool forceRecalc)
{
}

GravityPtr Gravity::Create()
{
	return GravityPtr(new Gravity());
}

void GravityDeleter::operator ()(Gravity *ptr) const
{
	delete ptr;
}


=== src\simulation\simtools\AIR.cpp ===

#include "simulation/ToolCommon.h"
#include "simulation/Air.h"

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_AIR()
{
	Identifier = "DEFAULT_TOOL_AIR";
	Name = "AIR";
	Colour = 0xFFFFFF_rgb;
	Description = "Air, creates airflow and pressure.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength)
{
	sim->pv[y/CELL][x/CELL] += strength*0.05f;

	if (sim->pv[y/CELL][x/CELL] > MAX_PRESSURE)
		sim->pv[y/CELL][x/CELL] = MAX_PRESSURE;
	else if (sim->pv[y/CELL][x/CELL] < MIN_PRESSURE)
		sim->pv[y/CELL][x/CELL] = MIN_PRESSURE;
	return 1;
}


=== src\simulation\simtools\AMBM.cpp ===

#include "simulation/ToolCommon.h"

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_AMBM()
{
	Identifier = "DEFAULT_TOOL_AMBM";
	Name = "AMBM";
	Colour = 0x00DDFF_rgb;
	Description = "Decreases ambient air temperature.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation *sim, Particle *cpart, int x, int y, int brushX, int brushY, float strength)
{
	if (!sim->aheat_enable)
	{
		return 0;
	}

	sim->hv[y / CELL][x / CELL] -= strength * 2.0f;
	if (sim->hv[y / CELL][x / CELL] > MAX_TEMP) sim->hv[y / CELL][x / CELL] = MAX_TEMP;
	if (sim->hv[y / CELL][x / CELL] < MIN_TEMP) sim->hv[y / CELL][x / CELL] = MIN_TEMP;
	return 1;
}


=== src\simulation\simtools\AMBP.cpp ===

#include "simulation/ToolCommon.h"

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_AMBP()
{
	Identifier = "DEFAULT_TOOL_AMBP";
	Name = "AMBP";
	Colour = 0xFFDD00_rgb;
	Description = "Increases ambient air temperature.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation *sim, Particle *cpart, int x, int y, int brushX, int brushY, float strength)
{
	if (!sim->aheat_enable)
	{
		return 0;
	}

	sim->hv[y / CELL][x / CELL] += strength * 2.0f;
	if (sim->hv[y / CELL][x / CELL] > MAX_TEMP) sim->hv[y / CELL][x / CELL] = MAX_TEMP;
	if (sim->hv[y / CELL][x / CELL] < MIN_TEMP) sim->hv[y / CELL][x / CELL] = MIN_TEMP;
	return 1;
}


=== src\simulation\simtools\COOL.cpp ===

#include "simulation/ToolCommon.h"

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_COOL()
{
	Identifier = "DEFAULT_TOOL_COOL";
	Name = "COOL";
	Colour = 0x00DDFF_rgb;
	Description = "Cools the targeted element.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength)
{
	if(!cpart)
		return 0;
	if (cpart->type == PT_PUMP || cpart->type == PT_GPMP)
		cpart->temp -= strength*.1f;
	else
		cpart->temp -= strength*2.0f;

	if (cpart->temp > MAX_TEMP)
		cpart->temp = MAX_TEMP;
	else if (cpart->temp < 0)
		cpart->temp = 0;
	return 1;
}


=== src\simulation\simtools\CYCL.cpp ===

#include "simulation/ToolCommon.h"
#include "simulation/Air.h"

#include <cmath>

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_CYCL()
{
	Identifier = "DEFAULT_TOOL_CYCL";
	Name = "CYCL";
	Colour = 0x132f5b_rgb;
	Description = "Cyclone, produces swirling air currents";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength)
{
	/*
		Air velocity calculation.
		(x, y) -- turn 90 deg -> (-y, x)
	*/
	// only trigger once per cell (less laggy)
	if ((x%CELL) == 0 && (y%CELL) == 0)
	{
		if(brushX == x && brushY == y)
			return 1;

		float *vx = &sim->vx[y / CELL][x / CELL];
		float *vy = &sim->vy[y / CELL][x / CELL];

		auto dvx = float(brushX - x);
		auto dvy = float(brushY - y);
		float invsqr = 1/sqrtf(dvx*dvx + dvy*dvy);

		*vx -= (strength / 16) * (-dvy)*invsqr;
		*vy -= (strength / 16) * dvx*invsqr;

		// Clamp velocities
		if (*vx > MAX_PRESSURE)
			*vx = MAX_PRESSURE;
		else if (*vx < MIN_PRESSURE)
			*vx = MIN_PRESSURE;
		if (*vy > MAX_PRESSURE)
			*vy = MAX_PRESSURE;
		else if (*vy < MIN_PRESSURE)
			*vy = MIN_PRESSURE;

	}

	return 1;
}


=== src\simulation\simtools\HEAT.cpp ===

#include "simulation/ToolCommon.h"

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_HEAT()
{
	Identifier = "DEFAULT_TOOL_HEAT";
	Name = "HEAT";
	Colour = 0xFFDD00_rgb;
	Description = "Heats the targeted element.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength)
{
	if(!cpart)
		return 0;
	if (cpart->type == PT_PUMP || cpart->type == PT_GPMP)
		cpart->temp += strength*.1f;
	else
		cpart->temp += strength*2.0f;

	if (cpart->temp > MAX_TEMP)
		cpart->temp = MAX_TEMP;
	else if (cpart->temp < 0)
		cpart->temp = 0;
	return 1;
}


=== src\simulation\simtools\meson.build ===

simulation_tool_names = [
	'HEAT',
	'COOL',
	'AIR',
	'VAC',
	'PGRV',
	'NGRV',
	'MIX',
	'CYCL',
	'AMBM',
	'AMBP',
	'WIND',
]

simulation_tool_src = []
simulation_tool_ids = []
tool_id = 0
foreach tool_name : simulation_tool_names
	if not is_disabler(tool_name)
		simulation_tool_src += tool_name + '.cpp'
		simulation_tool_ids += [ [ tool_name, tool_id ] ]
	endif
	tool_id = tool_id + 1
endforeach
simulation_files += files(simulation_tool_src)


=== src\simulation\simtools\MIX.cpp ===

#include "simulation/ToolCommon.h"

#include "common/tpt-rand.h"
#include <cmath>

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_MIX()
{
	Identifier = "DEFAULT_TOOL_MIX";
	Name = "MIX";
	Colour = 0xFFD090_rgb;
	Description = "Mixes particles.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength)
{
	auto &sd = SimulationData::CRef();
	auto &elements = sd.elements;
	int thisPart = sim->pmap[y][x];
	if(!thisPart)
		return 0;

	if(sim->rng() % 100 != 0)
		return 0;

	int distance = (int)(std::pow(strength, .5f) * 10);

	if(!(elements[TYP(thisPart)].Properties & (TYPE_PART | TYPE_LIQUID | TYPE_GAS)))
		return 0;

	int newX = x + (sim->rng() % distance) - (distance/2);
	int newY = y + (sim->rng() % distance) - (distance/2);

	if(newX < 0 || newY < 0 || newX >= XRES || newY >= YRES)
		return 0;

	int thatPart = sim->pmap[newY][newX];
	if(!thatPart)
		return 0;

	if ((elements[TYP(thisPart)].Properties&STATE_FLAGS) != (elements[TYP(thatPart)].Properties&STATE_FLAGS))
		return 0;

	sim->pmap[y][x] = thatPart;
	sim->parts[ID(thatPart)].x = float(x);
	sim->parts[ID(thatPart)].y = float(y);

	sim->pmap[newY][newX] = thisPart;
	sim->parts[ID(thisPart)].x = float(newX);
	sim->parts[ID(thisPart)].y = float(newY);

	return 1;
}


=== src\simulation\simtools\NGRV.cpp ===

#include "simulation/ToolCommon.h"

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushYy, float strength);

void SimTool::Tool_NGRV()
{
	Identifier = "DEFAULT_TOOL_NGRV";
	Name = "NGRV";
	Colour = 0xAACCFF_rgb;
	Description = "Creates a short-lasting negative gravity well.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushYy, float strength)
{
	sim->gravIn.mass[Vec2{ x, y } / CELL] = strength * -5.0f;
	return 1;
}


=== src\simulation\simtools\PGRV.cpp ===

#include "simulation/ToolCommon.h"

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_PGRV()
{
	Identifier = "DEFAULT_TOOL_PGRV";
	Name = "PGRV";
	Colour = 0xCCCCFF_rgb;
	Description = "Creates a short-lasting gravity well.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength)
{
	sim->gravIn.mass[Vec2{ x, y } / CELL] = strength * 5.0f;
	return 1;
}


=== src\simulation\simtools\VAC.cpp ===

#include "simulation/ToolCommon.h"
#include "simulation/Air.h"

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength);

void SimTool::Tool_VAC()
{
	Identifier = "DEFAULT_TOOL_VAC";
	Name = "VAC";
	Colour = 0x303030_rgb;
	Description = "Vacuum, reduces air pressure.";
	Perform = &perform;
}

static int perform(SimTool *tool, Simulation * sim, Particle * cpart, int x, int y, int brushX, int brushY, float strength)
{
	sim->pv[y/CELL][x/CELL] -= strength*0.05f;

	if (sim->pv[y/CELL][x/CELL] > MAX_PRESSURE)
		sim->pv[y/CELL][x/CELL] = MAX_PRESSURE;
	else if (sim->pv[y/CELL][x/CELL] < MIN_PRESSURE)
		sim->pv[y/CELL][x/CELL] = MIN_PRESSURE;
	return 1;
}


=== src\simulation\simtools\WIND.cpp ===

#include "simulation/ToolCommon.h"
#include "simulation/Air.h"
#include "gui/game/Brush.h"

static void performDrawLine(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2, bool dragging);
static void performDrag(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2);

void SimTool::Tool_WIND()
{
	Identifier = "DEFAULT_TOOL_WIND";
	Name = "WIND";
	Colour = 0x404040_rgb;
	Description = "Creates air movement.";
	PerformDrawLine = &performDrawLine;
	PerformDrag = &performDrag;
}

static void performDrawLine(SimTool *tool, Simulation * sim, Brush const &brush, ui::Point position1, ui::Point position2, bool dragging)
{
	float strength = dragging?0.01f:0.002f;
	strength *= tool->Strength;

	for (ui::Point off : brush)
	{
		ui::Point coords = position1 + off;
		if (coords.X >= 0 && coords.Y >= 0 && coords.X < XRES && coords.Y < YRES)
		{
			sim->vx[coords.Y / CELL][coords.X / CELL] += (position2 - position1).X * strength;
			sim->vy[coords.Y / CELL][coords.X / CELL] += (position2 - position1).Y * strength;
		}
	}
}

static void performDrag(SimTool *tool, Simulation *sim, const Brush &brush, ui::Point position1, ui::Point position2)
{
	performDrawLine(tool, sim, brush, position1, position2, false);
}


=== src\tasks\AbandonableTask.cpp ===

#include "AbandonableTask.h"

void AbandonableTask::doWork_wrapper()
{
	Task::doWork_wrapper();
	done_cv.notify_one();

	bool abandoned;
	{
		std::lock_guard<std::mutex> g(taskMutex);
		abandoned = thAbandoned;
	}
	if (abandoned)
	{
		delete this;
	}
}

void AbandonableTask::Finish()
{
	{
		std::unique_lock<std::mutex> l(taskMutex);
		done_cv.wait(l, [this]() { return thDone; });
	}

	// Poll to make sure that the rest of the Task knows that it's
	// done, not just us. This has to be done because the thread that started
	// the AbandonableTask may or may not call Poll before calling Finish.
	// This may call callbacks.
	Poll();

	delete this;
}

void AbandonableTask::Abandon()
{
	bool delete_this = false;
	{
		std::lock_guard<std::mutex> g(taskMutex);
		if (thDone)
		{
			// If thDone is true, the thread has already finished. We're
			// not calling Poll because it may call callbacks, which
			// an abandoned task shouldn't do. Instead we just delete the
			// AbandonableTask after unlocking the mutex.
			delete_this = true;
		}
		else
		{
			// If at this point thDone is still false, the thread is still
			// running, meaning we can safely set thAbandoned and let
			// AbandonableTask::doWork_wrapper delete the AbandonableTask later.
			thAbandoned = true;
		}
	}

	if (delete_this)
	{
		delete this;
	}
}

AbandonableTask::AbandonableTask() :
	thAbandoned(false)
{
}

AbandonableTask::~AbandonableTask()
{
}



=== src\tasks\AbandonableTask.h ===

#pragma once
#include "Task.h"
#include <condition_variable>

class AbandonableTask : public Task
{
	std::condition_variable done_cv;
	
public:
	void Finish();
	void Abandon();
	AbandonableTask();
	virtual ~AbandonableTask();

protected:
	void doWork_wrapper() override;
	bool thAbandoned;
};


=== src\tasks\meson.build ===

powder_files += files(
	'AbandonableTask.cpp',
	'Task.cpp',
	'TaskWindow.cpp',
)


=== src\tasks\Task.cpp ===

#include "Task.h"

#include "TaskListener.h"

void Task::AddTaskListener(TaskListener * listener)
{
	this->listener = listener;
	notifyProgressMain();
	notifyStatusMain();
}

void Task::Start()
{
	before();
	std::thread([this]() { doWork_wrapper(); }).detach();
}

int Task::GetProgress()
{
	return progress;
}

String Task::GetStatus()
{
	return status;
}

String Task::GetError()
{
	return error;
}

bool Task::GetDone()
{
	return done;
}

bool Task::GetSuccess()
{
	return success;
}

void Task::Poll()
{
	if(!done)
	{
		int newProgress;
		bool newDone = false;
		bool newSuccess = false;
		String newStatus;
		String newError;
		{
			std::lock_guard<std::mutex> g(taskMutex);
			newProgress = thProgress;
			newDone = thDone;
			newSuccess = thSuccess;
			newStatus = thStatus;
			newError = thError;
		}

		success = newSuccess;

		if(newProgress!=progress) {
			progress = newProgress;
			notifyProgressMain();
		}

		if(newError!=error) {
			error = newError;
			notifyErrorMain();
		}

		if(newStatus!=status) {
			status = newStatus;
			notifyStatusMain();
		}

		if(newDone!=done)
		{
			done = newDone;
			after();
			notifyDoneMain();
		}
	}
}

Task::Task() :
	progress(0),
	done(false),
	thProgress(0),
	thDone(false),
	listener(nullptr)
{
}

Task::~Task()
{
}

void Task::before()
{

}

bool Task::doWork()
{
	notifyStatus("Fake progress");
	for(int i = 0; i < 100; i++)
	{
		notifyProgress(i);
	}
	return true;
}

void Task::after()
{

}

void Task::doWork_wrapper()
{
	bool newSuccess = doWork();
	{
		std::lock_guard<std::mutex> g(taskMutex);
		thSuccess = newSuccess;
		thDone = true;
	}
}

void Task::notifyProgress(int progress)
{
	std::lock_guard<std::mutex> g(taskMutex);
	thProgress = progress;
}

void Task::notifyStatus(String status)
{
	std::lock_guard<std::mutex> g(taskMutex);
	thStatus = status;
}

void Task::notifyError(String error)
{
	std::lock_guard<std::mutex> g(taskMutex);
	thError = error;
}

void Task::notifyProgressMain()
{
	if(listener)
		listener->NotifyProgress(this);
}

void Task::notifyStatusMain()
{
	if(listener)
		listener->NotifyStatus(this);
}

void Task::notifyDoneMain()
{
	if(listener)
		listener->NotifyDone(this);
}

void Task::notifyErrorMain()
{
	if(listener)
		listener->NotifyError(this);
}


=== src\tasks\Task.h ===

#pragma once
#include "common/String.h"
#include <thread>
#include <mutex>

class TaskListener;
class Task {
public:
	void AddTaskListener(TaskListener * listener);
	virtual void Start();
	int GetProgress();
	bool GetDone();
	bool GetSuccess();
	String GetError();
	String GetStatus();
	virtual void Poll();
	Task();
	virtual ~Task();

protected:
	int progress;
	bool done;
	bool success;
	String status;
	String error;

	int thProgress;
	bool thDone;
	bool thSuccess;
	String thStatus;
	String thError;

	TaskListener *listener;
	std::mutex taskMutex;

	virtual void before();
	virtual void after();
	virtual bool doWork();
	virtual void doWork_wrapper();

	virtual void notifyProgress(int progress);
	virtual void notifyError(String error);
	virtual void notifyStatus(String status);

	virtual void notifyProgressMain();
	virtual void notifyErrorMain();
	virtual void notifyStatusMain();
	virtual void notifyDoneMain();
};


=== src\tasks\TaskListener.h ===

#pragma once

class Task;
class TaskListener {
public:
	virtual void NotifyDone(Task * task) {}
	virtual void NotifyError(Task * task) {}
	virtual void NotifyProgress(Task * task) {}
	virtual void NotifyStatus(Task * task) {}
	virtual ~TaskListener() {}
};


=== src\tasks\TaskWindow.cpp ===

#include "TaskWindow.h"

#include "Task.h"

#include "gui/interface/Label.h"
#include "gui/interface/ProgressBar.h"
#include "gui/interface/Engine.h"
#include "gui/dialogues/ErrorMessage.h"
#include "gui/Style.h"

#include "graphics/Graphics.h"

#include <algorithm>

TaskWindow::TaskWindow(String title_, Task * task_, bool closeOnDone):
	ui::Window(ui::Point(-1, -1), ui::Point(240, 60)),
	task(task_),
	title(title_),
	progress(0),
	done(false),
	closeOnDone(closeOnDone),
	progressStatus("0%")
{

	ui::Label * tempLabel = new ui::Label(ui::Point(4, 5), ui::Point(Size.X-8, 15), title);
	tempLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	tempLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	tempLabel->SetTextColour(style::Colour::WarningTitle);
	AddComponent(tempLabel);

	statusLabel = new ui::Label(ui::Point(4, 23), ui::Point(Size.X-8, 15), "");
	statusLabel->Appearance.HorizontalAlign = ui::Appearance::AlignLeft;
	statusLabel->Appearance.VerticalAlign = ui::Appearance::AlignMiddle;
	AddComponent(statusLabel);

	progressBar = new ui::ProgressBar(Position + Vec2{ 1, Size.Y-16 }, Vec2{ Size.X, 17 });
	AddComponent(progressBar);

	MakeActiveWindow();

	task->AddTaskListener(this);
	task->Start();
}

void TaskWindow::NotifyStatus(Task * task)
{
	statusLabel->SetText(task->GetStatus());
}

void TaskWindow::NotifyError(Task * task)
{
	new ErrorMessage("Error", task->GetError());
	done = true;
}

void TaskWindow::NotifyDone(Task * task)
{
	if(closeOnDone)
		Exit();
	done = true;
}

void TaskWindow::Exit()
{
	CloseActiveWindow();
	SelfDestruct();
}

void TaskWindow::NotifyProgress(Task * task)
{
	progress = task->GetProgress();
	if(progress>-1)
		progressStatus = String::Build(progress, "%");
	else
		progressStatus = "Please wait...";
	progressBar->SetProgress(progress);
	progressBar->SetStatus(progressStatus);
}

void TaskWindow::OnTick()
{
	intermediatePos = float(std::fmod(ui::Engine::Ref().LastTick() * 0.06, 100.0));
	task->Poll();
	if (done)
		Exit();
}

void TaskWindow::OnDraw()
{
	Graphics * g = GetGraphics();
	g->DrawFilledRect(RectSized(Position - Vec2{ 1, 1 }, Size + Vec2{ 2, 2 }), 0x000000_rgb);
	g->DrawRect(RectSized(Position, Size), 0xFFFFFF_rgb);
}


=== src\tasks\TaskWindow.h ===

#pragma once
#include "gui/interface/Window.h"
#include "tasks/TaskListener.h"
#include <memory>

namespace ui
{
	class Label;
	class ProgressBar;
}

class Task;
class TaskWindow: public ui::Window, public TaskListener {
	std::unique_ptr<Task> task;
	String title;
	int progress;
	float intermediatePos;
	bool done;
	bool closeOnDone;
	ui::Label *statusLabel{};
	ui::ProgressBar *progressBar{};
	String progressStatus;
public:
	TaskWindow(String title_, Task * task_, bool closeOnDone = true);
	void NotifyStatus(Task * task) override;
	void NotifyDone(Task * task) override;
	void NotifyProgress(Task * task) override;
	void NotifyError(Task * task) override;
	void OnTick() override;
	void OnDraw() override;
	void Exit();
};


